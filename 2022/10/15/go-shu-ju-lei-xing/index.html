<!DOCTYPE html><html class="theme-next gemini use-motion" lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script><link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet"><script></script><meta name="theme-color" content="#222"><style>.pace .pace-progress{background:#1e92fb;height:3px}.pace .pace-progress-inner{box-shadow:0 0 10px #1e92fb,0 0 5px #1e92fb}.pace .pace-activity{border-top-color:#1e92fb;border-left-color:#1e92fb}</style><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="google-site-verification" content="HGM141IpbHrSmnAmR6W_zE4bo9Z3f-yXLeHYT3bg1fk"><meta name="baidu-site-verification" content="code-5Ai1DA8e6T"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4"><link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222"><meta name="keywords" content="Go,"><link rel="alternate" href="/atom.xml" title="凡间的精灵" type="application/atom+xml"><meta name="description" content="一、基础数据类型1.1 基础数据类型类型长度(字节)默认值说明bool1falsebyte10uint8，取值范围[0,255]rune40Unicode Code Point，int32int，uint4或8032或64位，取决于操作系统int8，uint810-128~127，0~255int16，uint1620-32768~32767，0-65535int32，uint3240-21亿~2"><meta name="keywords" content="Go"><meta property="og:type" content="article"><meta property="og:title" content="Go 数据类型"><meta property="og:url" content="http:&#x2F;&#x2F;chenzhonzhou.github.io&#x2F;2022&#x2F;10&#x2F;15&#x2F;go-shu-ju-lei-xing&#x2F;index.html"><meta property="og:site_name" content="凡间的精灵"><meta property="og:description" content="一、基础数据类型1.1 基础数据类型类型长度(字节)默认值说明bool1falsebyte10uint8，取值范围[0,255]rune40Unicode Code Point，int32int，uint4或8032或64位，取决于操作系统int8，uint810-128~127，0~255int16，uint1620-32768~32767，0-65535int32，uint3240-21亿~2"><meta property="og:locale" content="zh-Hans"><meta property="og:image" content="http:&#x2F;&#x2F;chenzhonzhou.github.io&#x2F;2022&#x2F;10&#x2F;15&#x2F;go-shu-ju-lei-xing&#x2F;%E5%9B%BE%E7%89%871.png"><meta property="og:updated_time" content="2022-12-24T07:40:24.330Z"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http:&#x2F;&#x2F;chenzhonzhou.github.io&#x2F;2022&#x2F;10&#x2F;15&#x2F;go-shu-ju-lei-xing&#x2F;%E5%9B%BE%E7%89%871.png"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Gemini",version:"5.1.4",sidebar:{position:"left",display:"always",offset:12,b2t:!0,scrollpercent:!0,onmobile:!0},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://chenzhonzhou.github.io/2022/10/15/go-shu-ju-lei-xing/"><title>Go 数据类型 | 凡间的精灵</title><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">凡间的精灵</span><span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">凡尘落素一精灵</p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-categories"><a href="/categories" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="menu-item-icon fa fa-fw fa-sitemap"></i><br>站点地图</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i></span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://chenzhonzhou.github.io/2022/10/15/go-shu-ju-lei-xing/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Zhongzhou Chen"><meta itemprop="description" content=""><meta itemprop="image" content="/images/chen.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="凡间的精灵"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Go 数据类型</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-10-15T22:05:14+08:00">2022-10-15</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Go/" itemprop="url" rel="index"><span itemprop="name">Go</span></a></span></span><div class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">5.7k</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span> <span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">23</span></div></div></header><div class="post-body" itemprop="articleBody"><h2 id="一、基础数据类型"><a href="#一、基础数据类型" class="headerlink" title="一、基础数据类型"></a>一、基础数据类型</h2><h3 id="1-1-基础数据类型"><a href="#1-1-基础数据类型" class="headerlink" title="1.1 基础数据类型"></a>1.1 基础数据类型</h3><table><thead><tr><th>类型</th><th>长度(字节)</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td>bool</td><td>1</td><td>false</td><td></td></tr><tr><td>byte</td><td>1</td><td>0</td><td>uint8，取值范围[0,255]</td></tr><tr><td>rune</td><td>4</td><td>0</td><td>Unicode Code Point，int32</td></tr><tr><td>int，uint</td><td>4或8</td><td>0</td><td>32或64位，取决于操作系统</td></tr><tr><td>int8，uint8</td><td>1</td><td>0</td><td>-128~127，0~255</td></tr><tr><td>int16，uint16</td><td>2</td><td>0</td><td>-32768~32767，0-65535</td></tr><tr><td>int32，uint32</td><td>4</td><td>0</td><td>-21亿~21亿，0~42亿，rune是int32的别名</td></tr><tr><td>int64，uint64</td><td>8</td><td>0</td><td></td></tr><tr><td>float32</td><td>4</td><td>0.0</td><td></td></tr><tr><td>float64</td><td>8</td><td>0.0</td><td></td></tr><tr><td>complex64</td><td>8</td><td></td><td></td></tr><tr><td>complex128</td><td>16</td><td></td><td></td></tr><tr><td>uintptr</td><td>4或8</td><td></td><td>以存储指针的uint32或uint64整数</td></tr></tbody></table><h3 id="1-2-复合数据类型"><a href="#1-2-复合数据类型" class="headerlink" title="1.2 复合数据类型"></a>1.2 复合数据类型</h3><table><thead><tr><th>类型</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td>array</td><td></td><td>值类型</td></tr><tr><td>struct</td><td></td><td>值类型</td></tr><tr><td>string</td><td>“”</td><td>UTF-8 字符串</td></tr><tr><td>slice</td><td>nil</td><td>引用类型</td></tr><tr><td>map</td><td>nil</td><td>引用类型</td></tr><tr><td>channel</td><td>nil</td><td>引用类型</td></tr><tr><td>interface</td><td>nil</td><td>接口</td></tr><tr><td>function</td><td>nil</td><td>函数</td></tr></tbody></table><h2 id="二、自定义类型"><a href="#二、自定义类型" class="headerlink" title="二、自定义类型"></a>二、自定义类型</h2><h3 id="2-1-自定义类型"><a href="#2-1-自定义类型" class="headerlink" title="2.1 自定义类型"></a>2.1 自定义类型</h3><p>在Go语言中有一些基本的数据类型，如string、整型、浮点型、布尔等数据类型，Go语言中可以使用 type 关键字来定义自定义类型。</p><p>自定义类型是 定义了一个全新的类型 。我们可以基于内置的基本类型定义，也可以通过 struct 定义。例如：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将MyInt定义为int类型</span></span><br><span class="line"><span class="keyword">type</span> MyInt <span class="keyword">int</span></span><br></pre></td></tr></tbody></table></figure><p>通过Type关键字的定义，MyInt就是一种新的类型，它具有 int 的特性。</p><p>思考：<br>实际上，Go语言中的结构体类型就是一种自定义类型。<br>看看结构体的定义格式就知道了：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> 结构体类型名 <span class="keyword">struct</span> {</span><br><span class="line">	字段名<span class="number">1</span> 字段类型<span class="number">1</span></span><br><span class="line">    字段名<span class="number">2</span> 字段类型<span class="number">2</span></span><br><span class="line">    …</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>是不是和上述自定义类型的格式一模一样呢？</p><h3 id="2-2-类型别名"><a href="#2-2-类型别名" class="headerlink" title="2.2 类型别名"></a>2.2 类型别名</h3><p>类型别名是Go1.9版本添加的新功能。</p><p>类型别名规定：TypeAlias只是Type的别名，本质上TypeAlias与Type是同一个类型。就像一个孩子小时候有小名、乳名，上学后用学名，英语老师又会给他起英文名，但这些名字都指的是他本人。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TypeAlias = Type</span><br></pre></td></tr></tbody></table></figure><p>我们之前见过的rune和byte就是类型别名，他们的定义如下：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="keyword">byte</span> = <span class="keyword">uint8</span></span><br><span class="line"><span class="keyword">type</span> <span class="keyword">rune</span> = <span class="keyword">int32</span></span><br></pre></td></tr></tbody></table></figure><h3 id="2-3-类型定义和类型别名的区别"><a href="#2-3-类型定义和类型别名的区别" class="headerlink" title="2.3 类型定义和类型别名的区别"></a>2.3 类型定义和类型别名的区别</h3><p>类型别名与类型定义表面上看只有一个等号的差异，我们通过下面的这段代码来理解它们之间的区别。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型定义</span></span><br><span class="line"><span class="keyword">type</span> NewInt <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型别名</span></span><br><span class="line"><span class="keyword">type</span> MyInt = <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="keyword">var</span> a NewInt</span><br><span class="line">	<span class="keyword">var</span> b MyInt</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">"type of a:%T\n"</span>, a) <span class="comment">//type of a:main.NewInt</span></span><br><span class="line">	fmt.Printf(<span class="string">"type of b:%T\n"</span>, b) <span class="comment">//type of b:int</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>输出结果：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> of a:main.NewInt</span><br><span class="line"><span class="keyword">type</span> of b:<span class="keyword">int</span></span><br></pre></td></tr></tbody></table></figure><p>结果显示a的类型是main.NewInt，表示main包下定义的NewInt类型。这是一个新的数据类型。</p><p>b的类型是int。MyInt类型别名只会在代码中存在，编译完成时并不会有MyInt类型。</p><h2 id="三、字符串"><a href="#三、字符串" class="headerlink" title="三、字符串"></a>三、字符串</h2><p>Go语言将字符串作为一种原生的基本数据类型。字符串是一个不可修改的数据类型。它的底层结构如下：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> stringStruct <span class="keyword">struct</span> {</span><br><span class="line">	str unsafe.Pointer <span class="comment">// 指向底层字节数组的指针</span></span><br><span class="line">	<span class="built_in">len</span> <span class="keyword">int</span>            <span class="comment">// 字节数组长度</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="3-1-字符串赋值"><a href="#3-1-字符串赋值" class="headerlink" title="3.1 字符串赋值"></a>3.1 字符串赋值</h3><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s1 :=<span class="string">"MY name is zhangsan \u4f17"</span> <span class="comment">//字符串里可以包含任意Unicode字符</span></span><br><span class="line">s2 := <span class="string">"He say:\"I'm file.\"\nThank\tyou."</span> <span class="comment">//包含转义字符</span></span><br><span class="line">s3 := <span class="string">`here is first \nline.`</span> <span class="comment">//反引号里的转文字符无效，原样输出包括空白符和换行符等</span></span><br></pre></td></tr></tbody></table></figure><h3 id="3-2-字符串常用操作"><a href="#3-2-字符串常用操作" class="headerlink" title="3.2 字符串常用操作"></a>3.2 字符串常用操作</h3><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>len(str)</td><td>求长度</td></tr><tr><td>strings.Split</td><td>分割</td></tr><tr><td>strings.Contains</td><td>判断是否包含</td></tr><tr><td>Strings.HasPrefix，strings.HasSuffix</td><td>前缀/后缀判断</td></tr><tr><td>Strings.Index()，Strings.LastIndex()</td><td>子串出现的位置</td></tr></tbody></table><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求长度</span></span><br><span class="line">s := <span class="string">"123 张三"</span></span><br><span class="line">fmt.Printf(<span class="string">"s len %d"</span>, <span class="built_in">len</span>(s))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分割</span></span><br><span class="line">s := <span class="string">"hello, how are you"</span></span><br><span class="line">fmt.Printf(<span class="string">"%t\n"</span>, strings.HasSuffix(s, <span class="string">"are"</span>))</span><br><span class="line">a := strings.Split(s, <span class="string">"l"</span>)</span><br><span class="line">fmt.Printf(<span class="string">"%s"</span>, a)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否包含</span></span><br><span class="line">s := <span class="string">"hello, how are you"</span></span><br><span class="line">fmt.Println(strings.Contains(s, <span class="string">"how"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前缀/后缀判断</span></span><br><span class="line">s := <span class="string">"hello, how are you"</span></span><br><span class="line">fmt.Println(strings.HasPrefix(s, <span class="string">"hello"</span>))</span><br><span class="line">fmt.Println(strings.HasSuffix(s, <span class="string">"hello"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子串出现的位置</span></span><br><span class="line">s := <span class="string">"hello, how are you"</span></span><br><span class="line">fmt.Println(strings.Index(s, <span class="string">"o"</span>))</span><br><span class="line">fmt.Println(strings.LastIndex(s, <span class="string">"o"</span>))</span><br></pre></td></tr></tbody></table></figure><h3 id="3-3-字符串拼接"><a href="#3-3-字符串拼接" class="headerlink" title="3.3 字符串拼接"></a>3.3 字符串拼接</h3><h4 id="3-3-1-加号拼接"><a href="#3-3-1-加号拼接" class="headerlink" title="3.3.1 加号拼接"></a>3.3.1 加号拼接</h4><p>最常用的方法肯定是 + 连接两个字符串。这与python类似，不过由于golang中的字符串是不可变的类型，因此用 + 连接会产生一个新的字符串对效率有影响。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s1 := <span class="string">"字符串"</span></span><br><span class="line">s2 := <span class="string">"拼接"</span></span><br><span class="line">s3 := s1 + s2</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印s3字符串</span></span><br><span class="line">fmt.Print(s3)</span><br></pre></td></tr></tbody></table></figure><h4 id="3-3-2-sprintf-函数"><a href="#3-3-2-sprintf-函数" class="headerlink" title="3.3.2 sprintf 函数"></a>3.3.2 sprintf 函数</h4><p>第二种方法使用sprintf函数，虽然不会像直接使用 + 那样产生临时字符串。但是效率也不高</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s1 := <span class="string">"字符串"</span></span><br><span class="line">s2 := <span class="string">"拼接"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印s3字符串</span></span><br><span class="line">s3 := fmt.Sprintf(<span class="string">"%s%s"</span>, s1, s2)</span><br></pre></td></tr></tbody></table></figure><h4 id="3-3-3-Join-函数"><a href="#3-3-3-Join-函数" class="headerlink" title="3.3.3 Join 函数"></a>3.3.3 Join 函数</h4><p>第三种方法是用Join函数，这里我们需要先引入strings包才能调用Join函数。Join函数会先根据字符串数组的内容，计算出一个拼接之后的长度，然后申请对应大小的内存，一个一个字符串填入，在已有一个数组的情况下，这种效率会很高，如果没有的话效率也不高。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要先导入strings包</span></span><br><span class="line">s1 := <span class="string">"字符串"</span></span><br><span class="line">s2 := <span class="string">"拼接"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个字符串数组包含上述的字符串</span></span><br><span class="line"><span class="keyword">var</span> str []<span class="keyword">string</span> = []<span class="keyword">string</span>{s1, s2}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用Join函数</span></span><br><span class="line">s3 := strings.Join(str, <span class="string">""</span>)</span><br><span class="line">fmt.Print(s3)</span><br></pre></td></tr></tbody></table></figure><h4 id="3-3-4-buffer-函数"><a href="#3-3-4-buffer-函数" class="headerlink" title="3.3.4 buffer 函数"></a>3.3.4 buffer 函数</h4><p>第四个方法是调用buffer.WriteString函数，这种方法的性能就要大大优于上面的了。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要先导入bytes包</span></span><br><span class="line">s1 := <span class="string">"字符串"</span></span><br><span class="line">s2 := <span class="string">"拼接"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义Buffer类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bt bytes.Buffer</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向bt中写入字符串</span></span><br><span class="line">bt.WriteString(s1)</span><br><span class="line">bt.WriteString(s2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得拼接后的字符串</span></span><br><span class="line">s3 := bt.String()</span><br><span class="line">fmt.Print(s3)</span><br></pre></td></tr></tbody></table></figure><h4 id="3-3-5-Builder-函数"><a href="#3-3-5-Builder-函数" class="headerlink" title="3.3.5 Builder 函数"></a>3.3.5 Builder 函数</h4><p>第5个方法是用buffer.Builder，这个方法和上面的差不多，不过官方建议用这个，使用方法和上面基本一样</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要先导入Strings包 </span></span><br><span class="line">s1 := <span class="string">"字符串"</span></span><br><span class="line">s2 := <span class="string">"拼接"</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> build strings.Builder </span><br><span class="line">build.WriteString(s1)</span><br><span class="line">build.WriteString(s2)</span><br><span class="line"></span><br><span class="line">s3 := build.String()</span><br><span class="line">fmt.Print(s3)</span><br></pre></td></tr></tbody></table></figure><h3 id="3-4-byte-和-rune"><a href="#3-4-byte-和-rune" class="headerlink" title="3.4 byte 和 rune"></a>3.4 byte 和 rune</h3><p>Go内置两种字符类型：一种是byte的字节类型（byte也是uint8的别名），另一种是表示Unicode编码的字符rune。</p><blockquote><p>string中每个元素叫”字符”，字符有两种：</p><ul><li>byte：1个字节，代表ASCII码的一个字符；</li><li>rune：4个字节，代码UTF-8字符，一个汉字可以用一个rune表示；</li></ul><p>string底层是byte数组，string的长度就是该byte数组的长度，UFT-8编码下一个汉字占3个byte，即一个汉字占3个长度；<br>string可以转换为[]byte或[]rune类型；<br>string是常量，不能修改其中的字符；</p></blockquote><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">"123 张三"</span></span><br><span class="line"><span class="comment">// arr := []byte(s) //byte类型</span></span><br><span class="line">arr := []<span class="keyword">rune</span>(s) <span class="comment">//rune类型</span></span><br><span class="line"><span class="keyword">for</span> _, ele := <span class="keyword">range</span> arr {</span><br><span class="line">fmt.Printf(<span class="string">"%c "</span>, ele)</span><br><span class="line">}</span><br><span class="line">fmt.Println()</span><br><span class="line">fmt.Printf(<span class="string">"arr len %d,s len %d"</span>, <span class="built_in">len</span>(arr), <span class="built_in">len</span>(s)) <span class="comment">//byte和rune中的中文字符长度不一样</span></span><br></pre></td></tr></tbody></table></figure><h2 id="四、强制类型转换"><a href="#四、强制类型转换" class="headerlink" title="四、强制类型转换"></a>四、强制类型转换</h2><p><strong>golang语言不支持类型自动转换（隐式转换），只支持强制类型转换（显示转换）</strong></p><p>即不同类型变量之间赋值需要用到强制类型转换语法</p><p>基本语法如下：</p><blockquote><p>表达式T(v)，表示将变量v的值转换为T类型，把转换后的值赋值给接收变量</p></blockquote><p>PS：存储范围更大的类型转换成存储范围更小的类型时，如果值超过了后者的取值范围，不会报错但是会直接截断字节，得到很奇怪的值（二进制数被从高位截断导致的）</p><ul><li>byte和int可以互相转换</li><li>float和int可以互相转换，小数位会丢失</li><li>bool和int不能相互转换</li><li>不同长度的int或float之间可以相互转换</li><li>string可以转换为[]byte或[]rune类型，byte或rune可以转换为string</li><li>低精度向高精度转换没问题，高精度向低精度转换会丢失位数</li><li>无符号向有符号转换，最高位是符号位</li></ul><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例子：</span></span><br><span class="line"><span class="keyword">var</span> i1 <span class="keyword">int64</span></span><br><span class="line"><span class="keyword">var</span> i2 <span class="keyword">int32</span></span><br><span class="line"><span class="keyword">var</span> i3 <span class="keyword">int8</span></span><br><span class="line">i1 = <span class="number">123</span></span><br><span class="line">i2 = <span class="keyword">int32</span>(i1)</span><br><span class="line">i3 = <span class="keyword">int8</span>(i1)</span><br><span class="line">fmt.Printf(<span class="string">"i1 类型为 %T ，值= %v\n"</span>, i1, i1) <span class="comment">// i1 类型为 int64 ，值= 123</span></span><br><span class="line">fmt.Printf(<span class="string">"i2 类型为 %T ，值= %v\n"</span>, i2, i2) <span class="comment">// i2 类型为 int32 ，值= 123</span></span><br><span class="line">fmt.Printf(<span class="string">"i3 类型为 %T ，值= %v\n"</span>, i3, i3) <span class="comment">// i3 类型为 int8 ，值= 123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储范围更大的类型转换成存储范围更小的类型时，如果值超过了后者的取值范围，不会报错但是会直接截断字节，得到很奇怪的值（二进制数被从高位截断导致的）</span></span><br><span class="line"><span class="comment">// 例子：</span></span><br><span class="line"><span class="keyword">var</span> i4 <span class="keyword">int</span> = <span class="number">1000</span></span><br><span class="line"><span class="keyword">var</span> i5 <span class="keyword">int8</span></span><br><span class="line">fmt.Println(i4) <span class="comment">// 1000</span></span><br><span class="line">i5 = <span class="keyword">int8</span>(i4)</span><br><span class="line">fmt.Println(i5) <span class="comment">// -24</span></span><br></pre></td></tr></tbody></table></figure><h2 id="五、数组"><a href="#五、数组" class="headerlink" title="五、数组"></a>五、数组</h2><p>数组是同一种数据类型元素的集合，是块连续的内存空间，在声明的时候必须指定长度，使用时可以修改数组成员，且长度不能改变。所以数组在声明的时候就可以把内存空间分配好，并赋上默认值，即完成了初始化。因为数组的长度是固定的，所以在Go语言中很少直接使用</p><p><img src="/2022/10/15/go-shu-ju-lei-xing/%E5%9B%BE%E7%89%871.png" alt="图片1"></p><h3 id="5-1-数组初始化"><a href="#5-1-数组初始化" class="headerlink" title="5.1 数组初始化"></a>5.1 数组初始化</h3><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 [<span class="number">5</span>]<span class="keyword">int</span> = [<span class="number">5</span>]<span class="keyword">int</span>{}         <span class="comment">//数组必须指定长度和类型，且长度和类型指定后不可改变</span></span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">5</span>]<span class="keyword">int</span>{}                <span class="comment">//推断长度是5的数组</span></span><br><span class="line"><span class="keyword">var</span> arr3 = [<span class="number">5</span>]<span class="keyword">int</span>{<span class="number">3</span>, <span class="number">2</span>}            <span class="comment">//给前2个元素赋值</span></span><br><span class="line"><span class="keyword">var</span> arr4 = [<span class="number">5</span>]<span class="keyword">int</span>{<span class="number">2</span>: <span class="number">15</span>, <span class="number">4</span>: <span class="number">22</span>}    <span class="comment">//给第2,4个元素赋值</span></span><br><span class="line"><span class="keyword">var</span> arr5 = [...]<span class="keyword">int</span>{<span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>} <span class="comment">//根据值的数量去推断数组长度</span></span><br><span class="line"><span class="keyword">var</span> arr6 = [...]<span class="keyword">struct</span> {           <span class="comment">//结构体赋值数组</span></span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age  <span class="keyword">int</span></span><br><span class="line">}{{<span class="string">"Tom"</span>, <span class="number">19</span>}, {<span class="string">"Jin"</span>, <span class="number">22</span>}}</span><br></pre></td></tr></tbody></table></figure><h3 id="5-2-二维数组初始化"><a href="#5-2-二维数组初始化" class="headerlink" title="5.2 二维数组初始化"></a>5.2 二维数组初始化</h3><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//5行3列，只给前2行赋值，且前2行的所有列还没有赋满</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">5</span>][<span class="number">3</span>]<span class="keyword">int</span>{{<span class="number">1</span>}, {<span class="number">2</span>, <span class="number">3</span>}}</span><br><span class="line"><span class="comment">//第1维可以用...推测，第2维不能用...</span></span><br><span class="line"><span class="keyword">var</span> arr2 = [...][<span class="number">3</span>]<span class="keyword">int</span>{{<span class="number">1</span>}, {<span class="number">2</span>, <span class="number">3</span>}}</span><br></pre></td></tr></tbody></table></figure><h3 id="5-3-访问数组元素"><a href="#5-3-访问数组元素" class="headerlink" title="5.3 访问数组元素"></a>5.3 访问数组元素</h3><p>通过index访问</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">访问首元素arr[0]</span><br><span class="line">访问末元素arr[len(arr)-1]</span><br></pre></td></tr></tbody></table></figure><p>访问二维数组元素</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">访问位于第三行第四列的元素arr[2][3]</span><br></pre></td></tr></tbody></table></figure><h3 id="5-4-遍历数组"><a href="#5-4-遍历数组" class="headerlink" title="5.4 遍历数组"></a>5.4 遍历数组</h3><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//for range 遍历数组</span></span><br><span class="line"><span class="keyword">for</span> i, ele := <span class="keyword">range</span> arr4 {</span><br><span class="line">    fmt.Printf(<span class="string">"index=%d,element=%d\n"</span>, i, ele)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//或 for 循环遍历数组</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= <span class="built_in">len</span>(arr4); i++ {</span><br><span class="line">    fmt.Printf(<span class="string">"index=%d,element=%d\n"</span>, i, arr4[i])</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>冒泡排序</strong></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    arr01 := [...]<span class="keyword">int</span>{<span class="number">54</span>,<span class="number">123</span>,<span class="number">11</span>,<span class="number">22</span>,<span class="number">875</span>,<span class="number">124</span>}</span><br><span class="line">    <span class="keyword">for</span> i :=<span class="number">1</span>;i&lt;<span class="built_in">len</span>(arr01);i++{</span><br><span class="line">        <span class="comment">//fmt.Println(arr01[i])</span></span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">0</span>;j&lt;<span class="built_in">len</span>(arr01)-i;j++{</span><br><span class="line">            <span class="keyword">if</span> arr01[j] &gt; arr01[j+<span class="number">1</span>]{</span><br><span class="line">                arr01[j],arr01[j+<span class="number">1</span>] = arr01[j+<span class="number">1</span>],arr01[j]</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        fmt.Println(arr01)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>遍历二维数组</strong></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历二维数组</span></span><br><span class="line"><span class="keyword">for</span> row, array := <span class="keyword">range</span> arr1 { <span class="comment">//再遍历行</span></span><br><span class="line">    <span class="keyword">for</span> col, ele := <span class="keyword">range</span> array { <span class="comment">//再遍历列</span></span><br><span class="line">        fmt.Printf(<span class="string">"arr[%d] [%d]=%d\n"</span>, row, col, ele)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="5-5-数组中的-cap-和-len"><a href="#5-5-数组中的-cap-和-len" class="headerlink" title="5.5 数组中的 cap 和 len"></a>5.5 数组中的 cap 和 len</h3><ul><li>cap代表capacity容量；</li><li>len代表length长度；</li><li>len代表目前数组里的几个元素，cap代表给数组分配的内存空间可以容纳多少个元素；</li><li>由于数组初始化之后长度不会改变，不需要给它预留内存空间所以<code>len(arr)==cap(arr)</code>；</li></ul><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr [<span class="number">5</span>]<span class="keyword">int</span> = [<span class="number">5</span>]<span class="keyword">int</span>{<span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">6</span>}</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(arr))</span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(arr))</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果：</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></tbody></table></figure><h3 id="5-6-数组传参"><a href="#5-6-数组传参" class="headerlink" title="5.6 数组传参"></a>5.6 数组传参</h3><ul><li>数组的长度和类型都是数组类型的一部分，函数传递数组类型时这两部分都必须吻合；</li><li>go语言没有按引用传参，全部是按值传参，即传递数组实际上传的是数组的拷贝，当数组的长度很大时，仅传参开销都很大；</li><li>如果想修改函数外部的数组，就把它的指针（数组在内存里的地址）传进来；</li></ul><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不使用指针传递数组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">arrPoint</span><span class="params">(arr [5]<span class="keyword">int</span>)</span></span> {</span><br><span class="line">	fmt.Printf(<span class="string">"%p\n"</span>, &amp;arr)</span><br><span class="line">    fmt.Printf(<span class="string">"%d\n"</span>, arr[<span class="number">0</span>])</span><br><span class="line">	arr[<span class="number">0</span>] += <span class="number">10</span></span><br><span class="line">    fmt.Printf(<span class="string">"%d\n"</span>, arr[<span class="number">0</span>])</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="keyword">var</span> crr [<span class="number">5</span>]<span class="keyword">int</span> = [<span class="number">5</span>]<span class="keyword">int</span>{<span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">6</span>}</span><br><span class="line">	fmt.Printf(<span class="string">"%p\n"</span>, &amp;crr)</span><br><span class="line">	arrPoint(crr)</span><br><span class="line">    fmt.Printf(<span class="string">"%d\n"</span>, crr[<span class="number">0</span>])</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果：</span></span><br><span class="line"><span class="number">0xc00000e330</span></span><br><span class="line"><span class="number">0xc00000e360</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="comment">//实际上是将外部的数组拷贝了一份，arrPoint函数修改的是拷贝后的数组</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 现在使用指针传递数组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">arrPoint</span><span class="params">(arr *[5]<span class="keyword">int</span>)</span></span> {</span><br><span class="line">	fmt.Printf(<span class="string">"%p\n"</span>, arr)</span><br><span class="line">	fmt.Printf(<span class="string">"%p\n"</span>, &amp;arr[<span class="number">0</span>])</span><br><span class="line">	fmt.Printf(<span class="string">"%d\n"</span>, arr[<span class="number">0</span>])</span><br><span class="line">	arr[<span class="number">0</span>] += <span class="number">10</span></span><br><span class="line">	fmt.Printf(<span class="string">"%d\n"</span>, arr[<span class="number">0</span>])</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="keyword">var</span> crr [<span class="number">5</span>]<span class="keyword">int</span> = [<span class="number">5</span>]<span class="keyword">int</span>{<span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">6</span>}</span><br><span class="line">	fmt.Printf(<span class="string">"%p\n"</span>, &amp;crr)</span><br><span class="line">	arrPoint(&amp;crr)</span><br><span class="line">	fmt.Printf(<span class="string">"%d\n"</span>, crr[<span class="number">0</span>])</span><br><span class="line">}</span><br><span class="line"><span class="comment">//输出结果：</span></span><br><span class="line"><span class="number">0xc00000e330</span></span><br><span class="line"><span class="number">0xc00000e330</span></span><br><span class="line"><span class="number">0xc00000e330</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">15</span></span><br></pre></td></tr></tbody></table></figure><h2 id="六、切片"><a href="#六、切片" class="headerlink" title="六、切片"></a>六、切片</h2><p>Go 语言切片是对数组的一种抽象。</p><p>Go 数组的长度不可改变，在特定场景中就不太适用，Go 中提供了一种灵活，功能强悍的内置类型：切片(“动态数组”)，与数组相比切片的长度是不固定的，可以追加元素，在追加时可能使切片的容量增大。</p><p>需要说明，slice 并不是数组或数组指针。它通过内部指针和相关属性 引用数组片段 ，以实现变长方案。</p><ul><li>切片：切片是数组的一个引用，因此切片是引用类型。但自身是结构体，值拷贝传递。</li><li>切片的长度可以改变，因此，切片相当于一个可变的数组。</li><li>切片遍历方式和数组一样，可以用 len() 求长度。表示可用元素数量，读写操作不能超过该限制。</li><li>cap 可以求出 slice 最大扩张容量，不能超出数组限制。<code>0 &lt;= len(slice) &lt;= len(array)</code>，其中array是slice引用的数组。</li><li>切片的定义：var 切片变量名 []类型，比如 <code>var str []string</code> 、 <code>var arr []int</code>。</li><li>如果 <code>slice == nil</code>，那么 len、cap 结果都等于 0。</li></ul><p>Go 语言中的切片类型是从数组类型基础上发展出来的新类型，当声明一个数组时，不指定该数组长度，则该类型为切片(“动态数组”)，切片有自己独立的内部结构字段(len, cap, array pointer)，并于其引用的底层数组共用存储空间。</p><h3 id="6-1-切片初始化"><a href="#6-1-切片初始化" class="headerlink" title="6.1 切片初始化"></a>6.1 切片初始化</h3><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常规声明</span></span><br><span class="line"><span class="keyword">var</span> s, e, f []<span class="keyword">int</span>           <span class="comment">//切片声明，len=cap=0</span></span><br><span class="line">s = []<span class="keyword">int</span>{}                 <span class="comment">//初始化，len=cap=0</span></span><br><span class="line">s = []<span class="keyword">int</span>{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>} <span class="comment">//初始化，len=cap=6</span></span><br><span class="line">e = s[<span class="number">0</span>:<span class="number">2</span>:<span class="built_in">cap</span>(s)]           <span class="comment">//有2个元素的切片, len为2, cap为6，2个元素是s中的前两位也就是1,2</span></span><br><span class="line">f = s[:<span class="number">0</span>]                   <span class="comment">//有0个元素的切片, len为0, cap为6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// make() 函数创建</span></span><br><span class="line"><span class="keyword">var</span> s []<span class="keyword">int</span></span><br><span class="line">s = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">3</span>)          <span class="comment">//初始化，len=cap=3</span></span><br><span class="line">s = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">3</span>, <span class="number">5</span>)       <span class="comment">//初始化，len=3,cap=5</span></span><br><span class="line">fmt.Printf(<span class="string">"%d\n"</span>, s)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值符 := 创建</span></span><br><span class="line">s2d := [][]<span class="keyword">int</span>{</span><br><span class="line">    {<span class="number">1</span>}, {<span class="number">2</span>, <span class="number">3</span>}, <span class="comment">//二维数组各行的列数相等，但二维切片各行的列数可以不相等</span></span><br><span class="line">}</span><br><span class="line">fmt.Printf(<span class="string">"%d\n"</span>, s2d)</span><br></pre></td></tr></tbody></table></figure><h3 id="6-2-append"><a href="#6-2-append" class="headerlink" title="6.2 append"></a>6.2 append</h3><ul><li>切片相对于数组最大的特点就是可以追加元素，可以自动扩容；</li><li>追加的元素放到预留的内存空间里，同时len加1；</li><li>如果预留空间已用完，则会重新申请一块更大的内存空间，capacity变成之前的2倍(cap&lt;1024)或1.25倍(cat&gt;1024)。把原内存空间的数据拷贝过来，在新内存空间上执行append操作；</li></ul><p><strong>末尾添加</strong> 预留空间不足时，append会重新分配内存</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a []<span class="keyword">int</span></span><br><span class="line">a = <span class="built_in">append</span>(a, <span class="number">1</span>)               <span class="comment">// 追加1个元素</span></span><br><span class="line">a = <span class="built_in">append</span>(a, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)         <span class="comment">// 追加多个元素, 手写解包方式</span></span><br><span class="line">a = <span class="built_in">append</span>(a, []<span class="keyword">int</span>{<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>}...) <span class="comment">// 追加一个切片, 切片需要解包</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 预留空间不足时，append会重新分配内存</span></span><br><span class="line">s1 := []<span class="keyword">int</span>{<span class="number">1</span>, <span class="number">2</span>}     <span class="comment">//初始化，len=2,cap=2</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s1), <span class="built_in">cap</span>(s1))</span><br><span class="line">s1 = <span class="built_in">append</span>(s1, <span class="number">10</span>)</span><br><span class="line">fmt.Println(s1)</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s1), <span class="built_in">cap</span>(s1)) <span class="comment">//预留空间已用完，申请了一个长度cap为4的内存空间</span></span><br><span class="line"><span class="comment">//输出结果：</span></span><br><span class="line"><span class="number">2</span> <span class="number">2</span></span><br><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">10</span>]</span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></tbody></table></figure><p><strong>开头添加</strong> 一般都会重新分配内存</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开头添加（一般都会重新分配内存）</span></span><br><span class="line"><span class="keyword">var</span> a = []<span class="keyword">int</span>{<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>}</span><br><span class="line">a = <span class="built_in">append</span>([]<span class="keyword">int</span>{<span class="number">0</span>}, a...)        <span class="comment">// 在开头添加1个元素</span></span><br><span class="line">a = <span class="built_in">append</span>([]<span class="keyword">int</span>{<span class="number">-3</span>, <span class="number">-2</span>, <span class="number">-1</span>}, a...) <span class="comment">// 在开头添加1个切片</span></span><br></pre></td></tr></tbody></table></figure><p><strong>中间添加</strong> (append和copy组合实现)</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// append实现，第二个append调用会创建一个临时的切片</span></span><br><span class="line"><span class="keyword">var</span> a []<span class="keyword">int</span></span><br><span class="line">a = <span class="built_in">append</span>(a[:i], <span class="built_in">append</span>([]<span class="keyword">int</span>{x}, a[i:]...)...)     <span class="comment">// 在第i个位置插入x</span></span><br><span class="line">a = <span class="built_in">append</span>(a[:i], <span class="built_in">append</span>([]<span class="keyword">int</span>{<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>}, a[i:]...)...) <span class="comment">// 在第i个位置插入切片</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// append和copy组合实现，避免创建中间的临时切片</span></span><br><span class="line">a = <span class="built_in">append</span>(a, <span class="number">0</span>) <span class="comment">// 先扩容</span></span><br><span class="line"><span class="built_in">copy</span>(a[i+<span class="number">1</span>:], a[i:]) <span class="comment">// a[i:]向后移动1个位置</span></span><br><span class="line">a[i] = x             <span class="comment">// 设置新添加的元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// append和copy组合，在指定位置插入切片（多个元素）</span></span><br><span class="line">a = <span class="built_in">append</span>(a, x...) <span class="comment">// 没有专门的函数来扩容，只有使用append</span></span><br><span class="line"><span class="built_in">copy</span>(a[i+<span class="built_in">len</span>(x):], a[i:])</span><br><span class="line"><span class="built_in">copy</span>(a[i:], x)</span><br></pre></td></tr></tbody></table></figure><h3 id="6-3-截取子切片"><a href="#6-3-截取子切片" class="headerlink" title="6.3 截取子切片"></a>6.3 截取子切片</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s := make([]int,4,5)  //len=4,cap=5</span><br><span class="line">sub_slice = s[1:3]    //len=2,cap=4</span><br></pre></td></tr></tbody></table></figure><p>刚开始，子切片和母切片共享底层的内存空间，修改子切片会反映到母切片上，在子切片上执行append会把新元素放到母切片预留的内存空间上；</p><p>当子切片不断执行append，耗完了母切片预留的内存空间，子切片跟母切片就会发生内存分享，此后两个切片相互独立没有任何关系。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">arr := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">crr := arr[<span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line">crr[<span class="number">0</span>] = <span class="number">8</span></span><br><span class="line">fmt.Println(crr, arr)</span><br><span class="line">crr = <span class="built_in">append</span>(crr, <span class="number">9</span>)</span><br><span class="line">crr = <span class="built_in">append</span>(crr, <span class="number">10</span>)</span><br><span class="line">fmt.Println(crr, arr)</span><br><span class="line">fmt.Printf(<span class="string">"%p %p\n"</span>, &amp;crr[<span class="number">0</span>], &amp;arr[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">//内存分离</span></span><br><span class="line">crr = <span class="built_in">append</span>(crr, <span class="number">12</span>)</span><br><span class="line">fmt.Println(crr, arr)</span><br><span class="line">fmt.Printf(<span class="string">"%p %p\n"</span>, &amp;crr[<span class="number">0</span>], &amp;arr[<span class="number">0</span>])</span><br><span class="line"><span class="comment">//输出结果：</span></span><br><span class="line">[<span class="number">8</span> <span class="number">0</span> <span class="number">0</span>] [<span class="number">8</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"><span class="number">0xc00000e330</span> <span class="number">0xc00000e330</span></span><br><span class="line">[<span class="number">8</span> <span class="number">0</span> <span class="number">0</span> <span class="number">9</span> <span class="number">10</span>] [<span class="number">8</span> <span class="number">0</span> <span class="number">0</span> <span class="number">9</span>]</span><br><span class="line">[<span class="number">8</span> <span class="number">0</span> <span class="number">0</span> <span class="number">9</span> <span class="number">10</span> <span class="number">12</span>] [<span class="number">8</span> <span class="number">0</span> <span class="number">0</span> <span class="number">9</span>]</span><br><span class="line"><span class="number">0xc000012320</span> <span class="number">0xc00000e330</span></span><br></pre></td></tr></tbody></table></figure><h2 id="七、map"><a href="#七、map" class="headerlink" title="七、map"></a>七、map</h2><p>Map 是高级语言中一种重要的数据结构，能够很方便的进行数据组织，主要都是&lt;k,v&gt;结构。<strong>除了slice,map,function的内建类型都可以作为key进行使用</strong>。因此，struct类型在不包含上述字段的时候，也可以作为key进行使用。</p><h3 id="7-1-Map的定义"><a href="#7-1-Map的定义" class="headerlink" title="7.1 Map的定义"></a>7.1 Map的定义</h3><p>Go语言中，可以通过自己手工使用基础语法进行map定义，也可以使用内置的<code>make</code>方法进行定义。</p><p><strong>基础定义方式</strong></p><p>Go语言中，定义map的基本语法格式是：<code>map[k类型] v类型 {k值，v值}</code>一个典型的Map定义实例如下：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span> {</span><br><span class="line">    <span class="string">"name"</span>:<span class="string">"ccmouse"</span>,</span><br><span class="line">    <span class="string">"course"</span>:<span class="string">"golang"</span>,</span><br><span class="line">    <span class="string">"site"</span>:<span class="string">"imooc"</span>,</span><br><span class="line">    <span class="string">"quality"</span>:<span class="string">"notbad"</span>,</span><br><span class="line">}</span><br><span class="line">fmt.Printf(<span class="string">"Map value is %v"</span>, m)</span><br></pre></td></tr></tbody></table></figure><p><strong>使用内置make方法</strong></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// k为string类型，v为int类型</span></span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基础声明方法</span></span><br><span class="line"><span class="keyword">var</span> m2 <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">m2 = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)    <span class="comment">//初始化，容量为0</span></span><br><span class="line">m2 = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>, <span class="number">5</span>) <span class="comment">//初始化 容量为5，如果能确定使用容量强烈建议在初始化时给一个合适的容量，减少扩容的概率</span></span><br><span class="line">m2 = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>{         <span class="comment">//初始化时直接赋值</span></span><br><span class="line">    <span class="string">"语文"</span>: <span class="number">10</span>,</span><br><span class="line">    <span class="string">"数学"</span>: <span class="number">15</span>,</span><br><span class="line">    <span class="string">"化学"</span>: <span class="number">20</span>,</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>map 在使用前一定要 make；<br>map 的 key 不能重复，如果重复了，则以最后这个 key-value 为准；<br>map 的 value 是可以相同的；<br>map 的 key-value 是无序；</p><h3 id="7-2-添加和删除key"><a href="#7-2-添加和删除key" class="headerlink" title="7.2 添加和删除key"></a>7.2 添加和删除key</h3><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加和删除key</span></span><br><span class="line">m2[<span class="string">"化学"</span>] = <span class="number">67</span></span><br><span class="line"><span class="built_in">delete</span>(m2, <span class="string">"化学"</span>)</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(m2), m2)</span><br></pre></td></tr></tbody></table></figure><h3 id="7-3-根据key查找value"><a href="#7-3-根据key查找value" class="headerlink" title="7.3 根据key查找value"></a>7.3 根据key查找value</h3><p>读取key对应的value，如果key不存在，则返回value类型的默认值</p><p>取key对应的value建议使用 if</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据key查找value</span></span><br><span class="line"><span class="keyword">if</span> value, exists := m2[<span class="string">"化学"</span>]; exists {</span><br><span class="line">fmt.Println(value)</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">fmt.Println(<span class="string">"map里不存在查找的value"</span>, exists)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="7-4-遍历map"><a href="#7-4-遍历map" class="headerlink" title="7.4 遍历map"></a>7.4 遍历map</h3><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历map</span></span><br><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> m2 {</span><br><span class="line">fmt.Printf(<span class="string">"%s=%d\n"</span>, key, value)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="八、channel"><a href="#八、channel" class="headerlink" title="八、channel"></a>八、channel</h2><p>Go语言中的通道（channel）是一种特殊的类型。<br>在任何时候，<strong>同时只能有一个</strong> goroutine 访问通道进行发送和获取数据。goroutine 间通过通道就可以通信。</p><p>通道像一个传送带或者队列，总是遵循先入先出（First In First Out）的规则，保证收发数据的顺序。</p><p>（1）channel本身是一个队列，先进先出<br>（2）线程安全，不需要加锁<br>（3）本身是有类型的，string, int 等，如果要存多种类型，则定义成 interface类型<br>（4）channel是引用类型，必须make之后才能使用，一旦 make，它的容量就确定了，不会动态增加！！它和map，slice不一样</p><p><strong>channel 的特点</strong>：<br>（1）一旦初始化容量，就不会改变了。<br>（2）当写满时，不可以写，取空时，不可以取。<br>（3）发送将持续阻塞直到数据被接收<br>把数据往通道中发送时，如果接收方一直都没有接收，那么发送操作将持续阻塞。Go 程序运行时能智能地发现一些永远无法发送成功的语句并做出提示<br>（4）接收将持续阻塞直到发送方发送数据。<br>如果接收方接收时，通道中没有发送方发送数据，接收方也会发生阻塞，直到发送方发送数据为止。<br>（5）每次接收一个元素。<br>通道一次只能接收一个数据元素。</p><h3 id="8-1-channel-的声明和使用"><a href="#8-1-channel-的声明和使用" class="headerlink" title="8.1 channel 的声明和使用"></a>8.1 channel 的声明和使用</h3><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 创建一个可以存放3个int类型的管道</span></span><br><span class="line"><span class="keyword">var</span> intChan <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">intChan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 看看intChan是什么</span></span><br><span class="line"><span class="comment">//channel其实和指针一样，本身存放在一个内存单元中，有它的地址</span></span><br><span class="line">fmt.Printf(<span class="string">"intChan 的值=%v intChan本身的地址=%p\n"</span>, intChan, &amp;intChan)</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 向管道写入数据</span></span><br><span class="line">intChan&lt;- <span class="number">10</span></span><br><span class="line">num := <span class="number">211</span></span><br><span class="line">intChan&lt;- num</span><br><span class="line">intChan&lt;- <span class="number">50</span></span><br><span class="line"><span class="comment">// //如果从channel取出数据后，可以继续放入</span></span><br><span class="line">&lt;-intChan</span><br><span class="line">intChan&lt;- <span class="number">98</span><span class="comment">//注意点, 当我们给管写入数据时，不能超过其容量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 看看管道的长度和cap(容量)</span></span><br><span class="line">fmt.Printf(<span class="string">"channel len= %v cap=%v \n"</span>, <span class="built_in">len</span>(intChan), <span class="built_in">cap</span>(intChan)) <span class="comment">// 3, 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//5. 从管道中读取数据</span></span><br><span class="line"><span class="keyword">var</span> num2 <span class="keyword">int</span></span><br><span class="line">num2 = &lt;-intChan </span><br><span class="line">fmt.Println(<span class="string">"num2="</span>, num2)</span><br><span class="line">fmt.Printf(<span class="string">"channel len= %v cap=%v \n"</span>, <span class="built_in">len</span>(intChan), <span class="built_in">cap</span>(intChan))  <span class="comment">// 2, 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//6. 在没有使用协程的情况下，如果我们的管道数据已经全部取出，再取就会报告 deadlock</span></span><br><span class="line">num3 := &lt;-intChan</span><br><span class="line">num4 := &lt;-intChan</span><br><span class="line"></span><br><span class="line"><span class="comment">//num5 := &lt;-intChan</span></span><br><span class="line">fmt.Println(<span class="string">"num3="</span>, num3, <span class="string">"num4="</span>, num4<span class="comment">/*, "num5=", num5*/</span>)</span><br></pre></td></tr></tbody></table></figure><h3 id="8-2-空接口类型的-channel"><a href="#8-2-空接口类型的-channel" class="headerlink" title="8.2 空接口类型的 channel"></a>8.2 空接口类型的 channel</h3><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> {</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Age <span class="keyword">int</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line"></span><br><span class="line">	<span class="comment">//定义一个存放任意数据类型的管道 3个数据</span></span><br><span class="line">	<span class="comment">//var allChan chan interface{}</span></span><br><span class="line">	allChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>{}, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">	allChan&lt;- <span class="number">10</span></span><br><span class="line">	allChan&lt;- <span class="string">"tom jack"</span></span><br><span class="line">	cat := Cat{<span class="string">"小花猫"</span>, <span class="number">4</span>}</span><br><span class="line">	allChan&lt;- cat</span><br><span class="line"></span><br><span class="line">	<span class="comment">//我们希望获得到管道中的第三个元素，则先将前2个推出</span></span><br><span class="line">	&lt;-allChan</span><br><span class="line">	&lt;-allChan</span><br><span class="line"></span><br><span class="line">	newCat := &lt;-allChan <span class="comment">//从管道中取出的Cat是什么?</span></span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">"newCat=%T , newCat=%v\n"</span>, newCat, newCat)</span><br><span class="line">	<span class="comment">//下面的写法是错误的!编译不通过</span></span><br><span class="line">	<span class="comment">//fmt.Printf("newCat.Name=%v", newCat.Name)</span></span><br><span class="line">	<span class="comment">//使用类型断言</span></span><br><span class="line">	a := newCat.(Cat) </span><br><span class="line">	fmt.Printf(<span class="string">"newCat.Name=%v"</span>, a.Name)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>定义 interface类型的空接口，可以接收任意类型的数据，但是在取出来的时候，必须断言！<br>a := newCat.(Cat)</p></blockquote><h3 id="8-3-channel-的遍历"><a href="#8-3-channel-的遍历" class="headerlink" title="8.3 channel 的遍历"></a>8.3 channel 的遍历</h3><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明chan类型，初始化可存放10个int</span></span><br><span class="line"><span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环写入</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ {</span><br><span class="line">    ch &lt;- i</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//for ++遍历不需要close</span></span><br><span class="line"><span class="comment">// for j := 0; j &lt; 10; j++ {</span></span><br><span class="line"><span class="comment">// 	v := &lt;-ch</span></span><br><span class="line"><span class="comment">// 	fmt.Println(v)</span></span><br><span class="line"><span class="comment">// }</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//for range 遍历需要close</span></span><br><span class="line"><span class="built_in">close</span>(ch)</span><br><span class="line"><span class="keyword">for</span> ele := <span class="keyword">range</span> ch {</span><br><span class="line">    fmt.Println(ele)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="九、引用类型"><a href="#九、引用类型" class="headerlink" title="九、引用类型"></a>九、引用类型</h2><ul><li>slice、map和channel是go语言里的3种引用类型，都可以通过make函数来进行初始化（申请内存分配）；</li><li>因为他们都包含一个指向底层数据结构的指针，所以称之后“引用”类型；</li><li>引用类型未初始化时都是nil，可以对它们执行len()函数，返回0；</li></ul><script>document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });</script></div><div><div><div style="text-align:center;color:#ccc;font-size:14px">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div></div></div><div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/Go/" rel="tag"><i class="fa fa-tag"></i> Go</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2022/10/11/go-yu-yan-ji-chu/" rel="next" title="Go 语言基础"><i class="fa fa-chevron-left"></i> Go 语言基础</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2022/11/08/go-jie-gou-ti-he-liu-cheng-kong-zhi/" rel="prev" title="Go 结构体和流程控制">Go 结构体和流程控制<i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"><div class="jiathis_style"><span class="jiathis_txt">分享到：</span> <a class="jiathis_button_fav">收藏夹</a> <a class="jiathis_button_copy">复制网址</a> <a class="jiathis_button_email">邮件</a> <a class="jiathis_button_weixin">微信</a> <a class="jiathis_button_qzone">QQ空间</a> <a class="jiathis_button_tqq">腾讯微博</a> <a class="jiathis_button_douban">豆瓣</a> <a class="jiathis_button_share">一键分享</a> <a href="http://www.jiathis.com/share?uid=2140465" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank">更多</a><a class="jiathis_counter_style"></a></div><script type="text/javascript">var jiathis_config={data_track_clickback:!0,summary:"",shortUrl:!1,hideMore:!1}</script><script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=" charset="utf-8"></script></div></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div id="sidebar-dimmer"></div><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/images/chen.png" alt="Zhongzhou Chen"><p class="site-author-name" itemprop="name">Zhongzhou Chen</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/%7C%7C%20archive"><span class="site-state-item-count">371</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">89</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">188</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#一、基础数据类型"><span class="nav-text">一、基础数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-基础数据类型"><span class="nav-text">1.1 基础数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-复合数据类型"><span class="nav-text">1.2 复合数据类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二、自定义类型"><span class="nav-text">二、自定义类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-自定义类型"><span class="nav-text">2.1 自定义类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-类型别名"><span class="nav-text">2.2 类型别名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-类型定义和类型别名的区别"><span class="nav-text">2.3 类型定义和类型别名的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三、字符串"><span class="nav-text">三、字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-字符串赋值"><span class="nav-text">3.1 字符串赋值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-字符串常用操作"><span class="nav-text">3.2 字符串常用操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-字符串拼接"><span class="nav-text">3.3 字符串拼接</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-1-加号拼接"><span class="nav-text">3.3.1 加号拼接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-2-sprintf-函数"><span class="nav-text">3.3.2 sprintf 函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-3-Join-函数"><span class="nav-text">3.3.3 Join 函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-4-buffer-函数"><span class="nav-text">3.3.4 buffer 函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-5-Builder-函数"><span class="nav-text">3.3.5 Builder 函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-byte-和-rune"><span class="nav-text">3.4 byte 和 rune</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四、强制类型转换"><span class="nav-text">四、强制类型转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#五、数组"><span class="nav-text">五、数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-数组初始化"><span class="nav-text">5.1 数组初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-二维数组初始化"><span class="nav-text">5.2 二维数组初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-访问数组元素"><span class="nav-text">5.3 访问数组元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-遍历数组"><span class="nav-text">5.4 遍历数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-5-数组中的-cap-和-len"><span class="nav-text">5.5 数组中的 cap 和 len</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-6-数组传参"><span class="nav-text">5.6 数组传参</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#六、切片"><span class="nav-text">六、切片</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-切片初始化"><span class="nav-text">6.1 切片初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-append"><span class="nav-text">6.2 append</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-截取子切片"><span class="nav-text">6.3 截取子切片</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#七、map"><span class="nav-text">七、map</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-Map的定义"><span class="nav-text">7.1 Map的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-添加和删除key"><span class="nav-text">7.2 添加和删除key</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-根据key查找value"><span class="nav-text">7.3 根据key查找value</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-4-遍历map"><span class="nav-text">7.4 遍历map</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#八、channel"><span class="nav-text">八、channel</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1-channel-的声明和使用"><span class="nav-text">8.1 channel 的声明和使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-空接口类型的-channel"><span class="nav-text">8.2 空接口类型的 channel</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-3-channel-的遍历"><span class="nav-text">8.3 channel 的遍历</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#九、引用类型"><span class="nav-text">九、引用类型</span></a></li></ol></div></div></section><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span id="scrollpercent"><span>0</span>%</span></div></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="copyright">&copy; <span itemprop="copyrightYear">2023</span><span class="with-love"><i class="fa fa-user"></i></span> <span class="author" itemprop="copyrightHolder">Zhongzhou Chen</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-area-chart"></i></span> <span class="post-meta-item-text">Site words total count&#58;</span> <span title="Site words total count">863.9k</span></div><span class="post-meta-divider"></span></div></footer></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><style>.copy-btn{display:inline-block;padding:6px 12px;font-size:13px;font-weight:700;line-height:20px;color:#333;white-space:nowrap;vertical-align:middle;cursor:pointer;background-color:#eee;background-image:linear-gradient(#fcfcfc,#eee);border:1px solid #d5d5d5;border-radius:3px;user-select:none;outline:0}.highlight-wrap .copy-btn{transition:opacity .3s ease-in-out;opacity:0;padding:2px 6px;position:absolute;right:4px;top:8px}.highlight-wrap .copy-btn:focus,.highlight-wrap:hover .copy-btn{opacity:1}.highlight-wrap{position:relative}</style><script>$(".highlight").each(function(t,e){var n=$("<div>").addClass("highlight-wrap");$(e).after(n),n.append($("<button>").addClass("copy-btn").append("复制").on("click",function(t){var e=$(this).parent().find(".code").find(".line").map(function(t,e){return $(e).text()}).toArray().join("\n"),n=document.createElement("textarea");document.body.appendChild(n),n.style.position="absolute",n.style.top="0px",n.style.left="0px",n.value=e,n.select(),n.focus();var o=document.execCommand("copy");document.body.removeChild(n),o?$(this).text("复制成功"):$(this).text("复制失败"),$(this).blur()})).on("mouseleave",function(t){var e=$(this).find(".copy-btn");setTimeout(function(){e.text("复制")},300)}).append(e)})</script><script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script><script type="text/javascript">function proceedsearch(){$("body").append('<div class="search-popup-overlay local-search-pop-overlay"></div>').css("overflow","hidden"),$(".search-popup-overlay").click(onPopupClose),$(".popup").toggle();var t=$("#local-search-input");t.attr("autocapitalize","none"),t.attr("autocorrect","off"),t.focus()}var isfetched=!1,isXml=!0,search_path="search.xml";0===search_path.length?search_path="search.xml":/json$/i.test(search_path)&&(isXml=!1);var path="/"+search_path,onPopupClose=function(t){$(".popup").hide(),$("#local-search-input").val(""),$(".search-result-list").remove(),$("#no-result").remove(),$(".local-search-pop-overlay").remove(),$("body").css("overflow","")},searchFunc=function(t,e,s){"use strict";$("body").append('<div class="search-popup-overlay local-search-pop-overlay"><div id="search-loading-icon"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div>').css("overflow","hidden"),$("#search-loading-icon").css("margin","20% auto 0 auto").css("text-align","center"),$.ajax({url:t,dataType:isXml?"xml":"json",async:!0,success:function(t){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var o=isXml?$("entry",t).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get():t,n=document.getElementById(e),r=document.getElementById(s);n.addEventListener("input",function(){var y=n.value.trim().toLowerCase(),T=y.split(/[\s\-]+/);1<T.length&&T.push(y);var b=[];if(0<y.length&&o.forEach(function(t){function e(t,e,o,n){for(var r=n[n.length-1],s=r.position,a=r.word,i=[],c=0;s+a.length<=o&&0!=n.length;){a===y&&c++,i.push({position:s,length:a.length});var l=s+a.length;for(n.pop();0!=n.length&&(s=(r=n[n.length-1]).position,a=r.word,s<l);)n.pop()}return h+=c,{hits:i,start:e,end:o,searchTextCount:c}}function o(o,t){var n="",r=t.start;return t.hits.forEach(function(t){n+=o.substring(r,t.position);var e=t.position+t.length;n+='<b class="search-keyword">'+o.substring(t.position,e)+"</b>",r=e}),n+=o.substring(r,t.end)}var n=!1,r=0,h=0,s=t.title.trim(),a=s.toLowerCase(),i=t.content.trim().replace(/<[^>]+>/g,""),c=i.toLowerCase(),l=decodeURIComponent(t.url),p=[],u=[];if(""!=s&&(T.forEach(function(t){function e(t,e,o){var n=t.length;if(0===n)return[];var r=0,s=[],a=[];for(o||(e=e.toLowerCase(),t=t.toLowerCase());-1<(s=e.indexOf(t,r));)a.push({position:s,word:t}),r=s+n;return a}p=p.concat(e(t,a,!1)),u=u.concat(e(t,c,!1))}),(0<p.length||0<u.length)&&(n=!0,r=p.length+u.length)),n){[p,u].forEach(function(t){t.sort(function(t,e){return e.position!==t.position?e.position-t.position:t.word.length-e.word.length})});var f=[];0!=p.length&&f.push(e(0,0,s.length,p));for(var d=[];0!=u.length;){var g=u[u.length-1],v=g.position,$=g.word,C=v-20,m=v+80;C<0&&(C=0),m<v+$.length&&(m=v+$.length),m>i.length&&(m=i.length),d.push(e(0,C,m,u))}d.sort(function(t,e){return t.searchTextCount!==e.searchTextCount?e.searchTextCount-t.searchTextCount:t.hits.length!==e.hits.length?e.hits.length-t.hits.length:t.start-e.start});var x=parseInt("1");0<=x&&(d=d.slice(0,x));var w="";w+=0!=f.length?"<li><a href='"+l+"' class='search-result-title'>"+o(s,f[0])+"</a>":"<li><a href='"+l+"' class='search-result-title'>"+s+"</a>",d.forEach(function(t){w+="<a href='"+l+'\'><p class="search-result">'+o(i,t)+"...</p></a>"}),w+="</li>",b.push({item:w,searchTextCount:h,hitCount:r,id:b.length})}}),1===T.length&&""===T[0])r.innerHTML='<div id="no-result"><i class="fa fa-search fa-5x" /></div>';else if(0===b.length)r.innerHTML='<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>';else{b.sort(function(t,e){return t.searchTextCount!==e.searchTextCount?e.searchTextCount-t.searchTextCount:t.hitCount!==e.hitCount?e.hitCount-t.hitCount:e.id-t.id});var e='<ul class="search-result-list">';b.forEach(function(t){e+=t.item}),e+="</ul>",r.innerHTML=e}}),$(".local-search-pop-overlay").remove(),$("body").css("overflow",""),proceedsearch()}})};$(".popup-trigger").click(function(t){t.stopPropagation(),!1===isfetched?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(onPopupClose),$(".popup").click(function(t){t.stopPropagation()}),$(document).on("keyup",function(t){27===t.which&&$(".search-popup").is(":visible")&&onPopupClose()})</script><script type="text/javascript" src="/js/src/love.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,log:!1,model:{jsonPath:"/live2dw/assets/shizuku.model.json"},display:{position:"right"},mobile:{show:!0,scale:.2},react:{opacityDefault:.7,opacityOnHover:.2,opacity:.4}})</script></body></html>