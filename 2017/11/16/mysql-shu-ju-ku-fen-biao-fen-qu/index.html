<!DOCTYPE html><html class="theme-next gemini use-motion" lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script><link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet"><script></script><meta name="theme-color" content="#222"><style>.pace .pace-progress{background:#1e92fb;height:3px}.pace .pace-progress-inner{box-shadow:0 0 10px #1e92fb,0 0 5px #1e92fb}.pace .pace-activity{border-top-color:#1e92fb;border-left-color:#1e92fb}</style><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="google-site-verification" content="HGM141IpbHrSmnAmR6W_zE4bo9Z3f-yXLeHYT3bg1fk"><meta name="baidu-site-verification" content="code-5Ai1DA8e6T"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4"><link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222"><meta name="keywords" content="数据库,MySQL,"><link rel="alternate" href="/atom.xml" title="凡间的精灵" type="application/atom+xml"><meta name="description" content="1、为什么要分表和分区？当我们的数据库中的数据越来越大时，随之而来的是单个表中数据太多。以至于查询速度变慢，而且由于表的锁机制导致应用操作也受到严重影响，出现了数据库性能瓶颈。mysql中有一种机制是表锁定和行锁定，是为了保证数据的完整性。表锁定表示你们都不能对这张表进行操作，必须等我对表操作完才行。行锁定也一样，别的sql必须等我对这条数据操作完了，才能对这条数据进行操作。当出现这种情况时，我们"><meta name="keywords" content="数据库,MySQL"><meta property="og:type" content="article"><meta property="og:title" content="MySQL 数据库分表分区"><meta property="og:url" content="http:&#x2F;&#x2F;chenzhonzhou.github.io&#x2F;2017&#x2F;11&#x2F;16&#x2F;mysql-shu-ju-ku-fen-biao-fen-qu&#x2F;index.html"><meta property="og:site_name" content="凡间的精灵"><meta property="og:description" content="1、为什么要分表和分区？当我们的数据库中的数据越来越大时，随之而来的是单个表中数据太多。以至于查询速度变慢，而且由于表的锁机制导致应用操作也受到严重影响，出现了数据库性能瓶颈。mysql中有一种机制是表锁定和行锁定，是为了保证数据的完整性。表锁定表示你们都不能对这张表进行操作，必须等我对表操作完才行。行锁定也一样，别的sql必须等我对这条数据操作完了，才能对这条数据进行操作。当出现这种情况时，我们"><meta property="og:locale" content="zh-Hans"><meta property="og:updated_time" content="2021-09-09T03:52:32.831Z"><meta name="twitter:card" content="summary"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Gemini",version:"5.1.4",sidebar:{position:"left",display:"always",offset:12,b2t:!0,scrollpercent:!0,onmobile:!0},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://chenzhonzhou.github.io/2017/11/16/mysql-shu-ju-ku-fen-biao-fen-qu/"><title>MySQL 数据库分表分区 | 凡间的精灵</title><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">凡间的精灵</span><span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">凡尘落素一精灵</p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-categories"><a href="/categories" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="menu-item-icon fa fa-fw fa-sitemap"></i><br>站点地图</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i></span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://chenzhonzhou.github.io/2017/11/16/mysql-shu-ju-ku-fen-biao-fen-qu/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Zhongzhou Chen"><meta itemprop="description" content=""><meta itemprop="image" content="/images/chen.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="凡间的精灵"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">MySQL 数据库分表分区</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-16T17:55:56+08:00">2017-11-16</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a></span> ， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a></span></span><div class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">6.9k</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span> <span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">30</span></div></div></header><div class="post-body" itemprop="articleBody"><h2 id="1、为什么要分表和分区？"><a href="#1、为什么要分表和分区？" class="headerlink" title="1、为什么要分表和分区？"></a>1、为什么要分表和分区？</h2><p>当我们的数据库中的数据越来越大时，随之而来的是单个表中数据太多。以至于查询速度变慢，而且由于表的锁机制导致应用操作也受到严重影响，出现了数据库性能瓶颈。</p><p>mysql中有一种机制是表锁定和行锁定，是为了保证数据的完整性。表锁定表示你们都不能对这张表进行操作，必须等我对表操作完才行。行锁定也一样，别的sql必须等我对这条数据操作完了，才能对这条数据进行操作。当出现这种情况时，我们可以考虑分表或分区。</p><h2 id="2、分表"><a href="#2、分表" class="headerlink" title="2、分表"></a>2、分表</h2><h3 id="2-1-什么是分表？"><a href="#2-1-什么是分表？" class="headerlink" title="2.1 什么是分表？"></a>2.1 什么是分表？</h3><p>分表是将一个大表按照一定的规则分解成多张具有独立存储空间的实体表，每个表都对应三个文件，MYD数据文件，.MYI索引文件，.frm表结构文件。这些表可以分布在同一块磁盘上，也可以在不同的机器上。app读写的时候根据事先定义好的规则得到对应的表名，然后去操作它。<br>将单个数据库表进行拆分，拆分成多个数据表，然后用户访问的时候，根据一定的算法（如用hash的方式，也可以用求余（取模）的方式），让用户访问不同的表，这样数据分散到多个数据表中，减少了单个数据表的访问压力。提升了数据库访问性能。分表的目的就在于此，减小数据库的负担，缩短查询时间。</p><h3 id="2-2-Mysql分表分为垂直切分和水平切分"><a href="#2-2-Mysql分表分为垂直切分和水平切分" class="headerlink" title="2.2 Mysql分表分为垂直切分和水平切分"></a>2.2 Mysql分表分为垂直切分和水平切分</h3><ol><li><p>垂直切分是指数据表列的拆分，把一张列比较多的表拆分为多张表<br>通常我们按以下原则进行垂直拆分:<br>把不常用的字段单独放在一张表;<br>把text，blob（binary large object，二进制大对象）等大字段拆分出来放在附表中;<br>经常组合查询的列放在一张表中;<br>垂直拆分更多时候就应该在数据表设计之初就执行的步骤，然后查询的时候用jion关键起来即可。</p></li><li><p>水平拆分是指数据表行的拆分，把一张的表的数据拆成多张表来存放。<br>水平拆分原则<br>通常情况下，我们使用hash、取模等方式来进行表的拆分<br>比如一张有400W的用户表users，为提高其查询效率我们把其分成4张表users1，users2，users3，users4<br>通过用ID取模的方法把数据分散到四张表内Id%4= [0,1,2,3]<br>然后查询,更新,删除也是通过取模的方法来查询<br>部分业务逻辑也可以通过地区，年份等字段来进行归档拆分;<br>进行拆分后的表，这时我们就要约束用户查询行为。比如我们是按年来进行拆分的,这个时候在页面设计上就约束用户必须要先选择年,然后才能进行查询。</p></li></ol><h3 id="2-3-分表的几种方式："><a href="#2-3-分表的几种方式：" class="headerlink" title="2.3 分表的几种方式："></a>2.3 分表的几种方式：</h3><h4 id="2-3-1-mysql集群"><a href="#2-3-1-mysql集群" class="headerlink" title="2.3.1 mysql集群"></a>2.3.1 mysql集群</h4><p>它并不是分表，但起到了和分表相同的作用。集群可分担数据库的操作次数，将任务分担到多台数据库上。集群可以读写分离，减少读写压力。从而提升数据库性能。</p><h4 id="2-3-2-预先估计会出现大数据量并且访问频繁的表，将其分为若干个表"><a href="#2-3-2-预先估计会出现大数据量并且访问频繁的表，将其分为若干个表" class="headerlink" title="2.3.2 预先估计会出现大数据量并且访问频繁的表，将其分为若干个表"></a>2.3.2 预先估计会出现大数据量并且访问频繁的表，将其分为若干个表</h4><p>根据一定的算法（如用hash的方式，也可以用求余（取模）的方式）让用户访问不同的表。<br>例如论坛里面发表帖子的表，时间长了这张表肯定很大，几十万，几百万都有可能。聊天室里面信息表，几十个人在一起一聊一个晚上，时间长了，这张表的数据肯定很大。像这样的情况很多。所以这种能预估出来的大数据量表，我们就事先分出个N个表，这个N是多少，根据实际情况而定。以聊天信息表为例：我们事先建100个这样的表， message_00,message_01,message_02……….message_98,message_99.然后根据用户的ID来判断这个用户的聊天信息放到哪张表里面，可以用hash的方式来获得，也可以用求余的方式来获得，方法很多。<br>或者可以设计每张表容纳的数据量是N条，那么如何判断某张表的数据是否容量已满呢？可以在程序段对于要新增数据的表，在插入前先做统计表记录数量的操作，当&lt;N条数据，就直接插入，当已经到达阀值，可以在程序段新创建数据库表（或者已经事先创建好），再执行插入操作）。</p><h4 id="2-3-3-利用merge存储引擎来实现分表"><a href="#2-3-3-利用merge存储引擎来实现分表" class="headerlink" title="2.3.3 利用merge存储引擎来实现分表"></a>2.3.3 利用merge存储引擎来实现分表</h4><p>如果要把已有的大数据量表分开比较痛苦，最痛苦的事就是改代码，因为程序里面的sql语句已经写好了，用merge存储引擎来实现分表, 这种方法比较适合。<br>merge分表，分为主表和子表，主表类似于一个壳子，逻辑上封装了子表，实际上数据都是存储在子表中的。<br>我们可以通过主表插入和查询数据，如果清楚分表规律，也可以直接操作子表。</p><p><strong><font size="5">下面我们来实现一个简单的利用merge存储引擎来实现分表的演示：</font></strong><br><strong>创建一个完整表存储着所有的成员信息（表名为member）</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; drop database IF EXISTS test;</span><br><span class="line">mysql&gt; create database test;</span><br><span class="line">mysql&gt; use test</span><br><span class="line">create table member(</span><br><span class="line">id bigint auto_increment primary key,</span><br><span class="line">name varchar(20),</span><br><span class="line">sex tinyint not null default &apos;0&apos;</span><br><span class="line">)engine=myisam default charset=utf8 auto_increment=1;</span><br></pre></td></tr></table></figure><p><strong>加入点数据</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into member(name,sex) values(&apos;tom1&apos;,1);</span><br><span class="line">mysql&gt; insert into member(name,sex) select name,sex from member;</span><br></pre></td></tr></table></figure><p><strong>第二条语句多执行几次就有了很多数据</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from member;</span><br><span class="line">+----+------+-----+</span><br><span class="line">| id | name | sex |</span><br><span class="line">+----+------+-----+</span><br><span class="line">|  1 | tom1 |   1 |</span><br><span class="line">|  2 | tom1 |   1 |</span><br><span class="line">|  3 | tom1 |   1 |</span><br><span class="line">|  4 | tom1 |   1 |</span><br><span class="line">|  5 | tom1 |   1 |</span><br><span class="line">|  6 | tom1 |   1 |</span><br><span class="line">|  7 | tom1 |   1 |</span><br><span class="line">|  8 | tom1 |   1 |</span><br><span class="line">|  9 | tom1 |   1 |</span><br><span class="line">| 10 | tom1 |   1 |</span><br><span class="line">| 11 | tom1 |   1 |</span><br><span class="line">| 12 | tom1 |   1 |</span><br><span class="line">| 13 | tom1 |   1 |</span><br><span class="line">| 14 | tom1 |   1 |</span><br><span class="line">| 15 | tom1 |   1 |</span><br><span class="line">| 16 | tom1 |   1 |</span><br><span class="line">+----+------+-----+</span><br></pre></td></tr></table></figure><p><strong>下面我们进行分表，这里我们把member分两个表tb_member1,tb_member2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use test;</span><br><span class="line">DROP table IF EXISTS tb_member1;</span><br><span class="line">create table tb_member1(</span><br><span class="line">id bigint primary key ,</span><br><span class="line">name varchar(20),</span><br><span class="line">sex tinyint not null default &apos;0&apos;</span><br><span class="line">)ENGINE=MyISAM DEFAULT CHARSET=utf8 ;</span><br><span class="line"></span><br><span class="line">DROP table IF EXISTS tb_member2;</span><br><span class="line">create table tb_member2(</span><br><span class="line">idbigint primary key,</span><br><span class="line">name varchar(20),</span><br><span class="line">sextinyint not null default &apos;0&apos;</span><br><span class="line">)ENGINE=MyISAM DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure><p>创建tb_member2也可以用下面的语句 create table tb_member2 like tb_member1;</p><p><strong>创建主表tb_member</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DROP table IF EXISTS tb_member;</span><br><span class="line">create table tb_member(</span><br><span class="line">id bigint primary key ,</span><br><span class="line">name varchar(20),</span><br><span class="line">sex tinyint not null default &apos;0&apos;</span><br><span class="line">) ENGINE=MERGE UNION=(tb_member1,tb_member2) INSERT_METHOD=LAST CHARSET=utf8 ;</span><br></pre></td></tr></table></figure><p><strong>注：</strong>INSERT_METHOD,此参数INSERT_METHOD = NO 表示该表不能做任何写入操作只作为查询使用,INSERT_METHOD = LAST表示插入到最后的一张表里面。INSERT_METHOD = first表示插入到第一张表里面。</p><p><strong>查看一下tb_member表的结构:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; desc tb_member;</span><br><span class="line">+-------+-------------+------+-----+---------+-----------------------------------------+</span><br><span class="line">| Field | Type        | Null | Key | Default | Extra          |</span><br><span class="line">+-------+-------------+------+-----+---------+-----------------------------------------+</span><br><span class="line">| id     | bigint(20)  | NO   | PRI | NULL    | auto_increment  |</span><br><span class="line">| name  | varchar(20) | YES  |     | NULL  |                |</span><br><span class="line">| sex    | tinyint(4)  | NO   |     | 0     |                |</span><br><span class="line">+-------+-------------+------+-----+---------+------------------------------------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>注：查看子表与主表的字段定义要一致</p><p><strong>接下来，我们把数据分到两个分表中去：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into tb_member1(id,name,sex) select id,name,sex from member where id%2=0;</span><br><span class="line">mysql&gt; insert into tb_member2(id,name,sex) select id,name,sex from member where id%2=1;</span><br></pre></td></tr></table></figure><p><strong>查看两个子表的数据：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from tb_member1;</span><br><span class="line">+----+------+-----+</span><br><span class="line">| id | name | sex |</span><br><span class="line">+----+------+-----+</span><br><span class="line">| 16 | tom1 |   1 |</span><br><span class="line">| 14 | tom1 |   1 |</span><br><span class="line">| 12 | tom1 |   1 |</span><br><span class="line">| 10 | tom1 |   1 |</span><br><span class="line">|  8 | tom1 |   1 |</span><br><span class="line">|  6 | tom1 |   1 |</span><br><span class="line">|  4 | tom1 |   1 |</span><br><span class="line">|  2 | tom1 |   1 |</span><br><span class="line">+----+------+-----+</span><br><span class="line">8 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from tb_member2;</span><br><span class="line">+----+------+-----+</span><br><span class="line">| id | name | sex |</span><br><span class="line">+----+------+-----+</span><br><span class="line">|  3 | tom1 |   1 |</span><br><span class="line">|  1 | tom1 |   1 |</span><br><span class="line">|  5 | tom1 |   1 |</span><br><span class="line">|  7 | tom1 |   1 |</span><br><span class="line">|  9 | tom1 |   1 |</span><br><span class="line">| 11 | tom1 |   1 |</span><br><span class="line">| 13 | tom1 |   1 |</span><br><span class="line">| 15 | tom1 |   1 |</span><br><span class="line">+----+------+-----+</span><br><span class="line">8 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p><strong>查看一下主表的数据：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from tb_member;</span><br><span class="line">+----+------+-----+</span><br><span class="line">| id | name | sex |</span><br><span class="line">+----+------+-----+</span><br><span class="line">| 16 | tom1 |   1 |</span><br><span class="line">| 14 | tom1 |   1 |</span><br><span class="line">| 12 | tom1 |   1 |</span><br><span class="line">| 10 | tom1 |   1 |</span><br><span class="line">|  8 | tom1 |   1 |</span><br><span class="line">|  6 | tom1 |   1 |</span><br><span class="line">|  4 | tom1 |   1 |</span><br><span class="line">|  2 | tom1 |   1 |</span><br><span class="line">| 15 | tom1 |   1 |</span><br><span class="line">| 13 | tom1 |   1 |</span><br><span class="line">| 11 | tom1 |   1 |</span><br><span class="line">|  9 | tom1 |   1 |</span><br><span class="line">|  7 | tom1 |   1 |</span><br><span class="line">|  5 | tom1 |   1 |</span><br><span class="line">|  3 | tom1 |   1 |</span><br><span class="line">|  1 | tom1 |   1 |</span><br><span class="line">+----+------+-----+</span><br><span class="line">16 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from tb_member where id=3;</span><br><span class="line">+----+------+-----+</span><br><span class="line">| id | name | sex |</span><br><span class="line">+----+------+-----+</span><br><span class="line">|  3 | tom1 |   1 |</span><br><span class="line">+----+------+-----+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>总表只是一个外壳，存取数据发生在一个一个的子表里面。<br><strong>注意：</strong>每个子表都有自已独立的相关表文件，而主表只是一个壳，并没有完整的相关表文件</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ls -l /usr/local/mysql/data/test/tb_member*</span><br></pre></td></tr></table></figure><p>-rw-r—–. 1 mysqlmysql 8614 Sep 15 21:49 /usr/local/mysql/data/test/tb_member1.frm<br>-rw-r—–. 1 mysqlmysql 320 Sep 16 00:02 /usr/local/mysql/data/test/tb_member1.MYD<br>-rw-r—–. 1 mysqlmysql 2048 Sep 16 00:43 /usr/local/mysql/data/test/tb_member1.MYI<br>-rw-r—–. 1 mysqlmysql 8614 Sep 15 21:50 /usr/local/mysql/data/test/tb_member2.frm<br>-rw-r—–. 1 mysqlmysql 180 Sep 16 00:02 /usr/local/mysql/data/test/tb_member2.MYD<br>-rw-r—–. 1 mysqlmysql 2048 Sep 16 00:43 /usr/local/mysql/data/test/tb_member2.MYI<br>-rw-r—–. 1 mysqlmysql 8614 Sep 16 21:12 /usr/local/mysql/data/test/tb_member3.frm<br>-rw-r—–. 1 mysqlmysql 0 Sep 16 21:12 /usr/local/mysql/data/test/tb_member3.MYD<br>-rw-r—–. 1 mysqlmysql 1024 Sep 16 21:12 /usr/local/mysql/data/test/tb_member3.MYI<br><font color="Blue">-rw-r—–. 1 mysqlmysql 8614 Sep 16 21:14 /usr/local/mysql/data/test/tb_member.frm</font><br><font color="Blue">-rw-r—–. 1 mysqlmysql 53 Sep 16 21:14 /usr/local/mysql/data/test/tb_member.MRG</font></p></blockquote><h2 id="2、分区"><a href="#2、分区" class="headerlink" title="2、分区"></a>2、分区</h2><h3 id="2-1-什么是分区？"><a href="#2-1-什么是分区？" class="headerlink" title="2.1 什么是分区？"></a>2.1 什么是分区？</h3><p>分区和分表相似，都是按照规则分解表。不同在于分表将大表分解为若干个独立的实体表，而分区是将数据分段划分在多个位置存放，分区后，表还是一张表，但数据散列到多个位置了。app读写的时候操作的还是表名字，db自动去组织分区的数据。</p><h3 id="2-2-分区主要有两种形式"><a href="#2-2-分区主要有两种形式" class="headerlink" title="2.2 分区主要有两种形式"></a>2.2 分区主要有两种形式</h3><p><strong>水平分区</strong>（<strong>Horizontal Partitioning</strong>）这种形式分区是对表的行进行分区，所有在表中定义的列在每个数据集中都能找到，所以表的特性依然得以保持。<br>举个简单例子：一个包含十年发票记录的表可以被分区为十个不同的分区，每个分区包含的是其中一年的记录。</p><p><strong>垂直分区</strong>（<strong>Vertical Partitioning</strong>）这种分区方式一般来说是通过对表的垂直划分来减少目标表的宽度，使某些特定的列被划分到特定的分区，每个分区都包含了其中的列所对应的行。<br>举个简单例子：一个包含了大text和BLOB列的表，这些text和BLOB列又不经常被访问，这时候就要把这些不经常使用的text和BLOB了划分到另一个分区，在保证它们数据相关性的同时还能提高访问速度。</p><p>分区技术支持<br>在5.6之前，使用这个参数查看当将配置是否支持分区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE &apos;%partition%&apos;;</span><br><span class="line">+-----------------------+---------------+</span><br><span class="line">|Variable_name          | Value |</span><br><span class="line">+-----------------------+---------------+</span><br><span class="line">| have_partition_engine | YES   |</span><br><span class="line">+-----------------------+------------------+</span><br></pre></td></tr></table></figure><p>如果是yes表示你当前的配置支持分区</p><p>在5.6及以采用后，则采用如下方式进行查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show plugins;</span><br></pre></td></tr></table></figure><p>在显示结果中，可以看到<strong>partition</strong>是<strong>ACTIVE</strong>的，表示支持分区</p><h3 id="2-3-按照范围-range-方式的表分区"><a href="#2-3-按照范围-range-方式的表分区" class="headerlink" title="2.3 按照范围(range)方式的表分区"></a>2.3 按照范围(range)方式的表分区</h3><p>下面我们先演示一个按照范围(range)方式的表分区</p><p><strong>创建range分区表</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use test2;</span><br><span class="line">mysql&gt; create table if not exists user (</span><br><span class="line">    -&gt;id int not null auto_increment,</span><br><span class="line">    -&gt;name varchar(30) not null default &apos;&apos;,</span><br><span class="line">    -&gt;sex int(1) not null default &apos;0&apos;,</span><br><span class="line">    -&gt;primary key(id)</span><br><span class="line">-&gt; )default charset=utf8 auto_increment=1</span><br><span class="line">    -&gt;partition by range(id) (</span><br><span class="line">    -&gt;partition p0 values less than (3),</span><br><span class="line">    -&gt;partition p1 values less than (6),</span><br><span class="line">    -&gt;partition p2 values less than (9),</span><br><span class="line">    -&gt;partition p3 values less than (12),</span><br><span class="line">    -&gt;partition p4 values less than maxvalue</span><br><span class="line">-&gt; );</span><br></pre></td></tr></table></figure><p><strong>插入些数据</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into test2.user(name,sex)values (&apos;tom1&apos;,&apos;0&apos;);</span><br><span class="line">mysql&gt; insert into test2.user(name,sex)values (&apos;tom2&apos;,&apos;1&apos;);</span><br><span class="line">mysql&gt; insert into test2.user(name,sex)values (&apos;tom3&apos;,&apos;1&apos;);</span><br><span class="line">mysql&gt; insert into test2.user(name,sex)values (&apos;tom4&apos;,&apos;0&apos;);</span><br><span class="line">mysql&gt; insert into test2.user(name,sex)values (&apos;tom5&apos;,&apos;0&apos;);</span><br><span class="line">mysql&gt; insert into test2.user(name,sex)values (&apos;tom6&apos;,&apos;1&apos;);</span><br><span class="line">mysql&gt; insert into test2.user(name,sex)values (&apos;tom7&apos;,&apos;1&apos;);</span><br><span class="line">mysql&gt; insert into test2.user(name,sex)values (&apos;tom8&apos;,&apos;1&apos;);</span><br><span class="line">mysql&gt; insert into test2.user(name,sex)values (&apos;tom9&apos;,&apos;1&apos;);</span><br><span class="line">mysql&gt; insert into test2.user(name,sex)values (&apos;tom10&apos;,&apos;1&apos;);</span><br><span class="line">mysql&gt; insert into test2.user(name,sex)values (&apos;tom11&apos;,&apos;1&apos;);</span><br><span class="line">mysql&gt; insert into test2.user(name,sex)values (&apos;tom12&apos;,&apos;1&apos;);</span><br><span class="line">mysql&gt; insert into test2.user(name,sex)values (&apos;tom13&apos;,&apos;1&apos;);</span><br><span class="line">mysql&gt; insert into test2.user(name,sex)values (&apos;tom14&apos;,&apos;1&apos;);</span><br></pre></td></tr></table></figure><p>到存放数据库表文件的地方看一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ls -l /usr/local/mysql/data/test2/user*</span><br><span class="line">-rw-r-----. 1 mysqlmysql  8614 Sep 16 21:46 /usr/local/mysql/data/test2/user.frm</span><br><span class="line">-rw-r-----. 1 mysqlmysql 98304 Sep 16 21:48 /usr/local/mysql/data/test2/user#P#p0.ibd</span><br><span class="line">-rw-r-----. 1 mysqlmysql 98304 Sep 16 21:48 /usr/local/mysql/data/test2/user#P#p1.ibd</span><br><span class="line">-rw-r-----. 1 mysqlmysql 98304 Sep 16 21:49 /usr/local/mysql/data/test2/user#P#p2.ibd</span><br><span class="line">-rw-r-----. 1 mysqlmysql 98304 Sep 16 21:49 /usr/local/mysql/data/test2/user#P#p3.ibd</span><br><span class="line">-rw-r-----. 1 mysqlmysql 98304 Sep 16 21:49 /usr/local/mysql/data/test2/user#P#p4.ibd</span><br><span class="line">mysql&gt; select count(id) as count from user;</span><br><span class="line">+-------+</span><br><span class="line">| count |</span><br><span class="line">+-------+</span><br><span class="line">|    14 |</span><br><span class="line">+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>从information_schema系统库中的partitions表中查看分区信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from information_schema.partitions where table_schema=&apos;test2&apos; and table_name=&apos;user&apos;\G;</span><br></pre></td></tr></table></figure><p>从某个分区中查询数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from test2.user partition(p0);</span><br></pre></td></tr></table></figure><p><strong>新增分区</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; alter table test2.user add partition (partition partionname values less than (n));</span><br></pre></td></tr></table></figure><p><strong>删除分区</strong><br>当删除了一个分区，也同时删除了该分区中所有的数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE test2.user DROP PARTITION p3;</span><br></pre></td></tr></table></figure><p><strong>分区的合并</strong><br>下面的SQL，将p1 – p3合并为2个分区p01– p02</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; alter table test2.user</span><br><span class="line">    -&gt; reorganize partition p1,p2,p3 into</span><br><span class="line">    -&gt; (partition p01 values less than (8),</span><br><span class="line">    -&gt;partition p02 values less than (12)</span><br><span class="line">    -&gt; );</span><br><span class="line">[root@localhost ~]# ls -l /usr/local/mysql/data/test2/user*</span><br><span class="line">-rw-r-----. 1 mysqlmysql  8614 Sep 16 22:06 /usr/local/mysql/data/test2/user.frm</span><br><span class="line">-rw-r-----. 1 mysqlmysql 98304 Sep 16 22:06 /usr/local/mysql/data/test2/user#P#p01.ibd</span><br><span class="line">-rw-r-----. 1 mysqlmysql 98304 Sep 16 22:06 /usr/local/mysql/data/test2/user#P#p02.ibd</span><br><span class="line">-rw-r-----. 1 mysqlmysql 98304 Sep 16 21:48 /usr/local/mysql/data/test2/user#P#p0.ibd</span><br><span class="line">-rw-r-----. 1 mysqlmysql 98304 Sep 16 21:49 /usr/local/mysql/data/test2/user#P#p4.ibd</span><br><span class="line">mysql&gt; select * from test2.user partition(p01);</span><br><span class="line">+----+------+-----+</span><br><span class="line">| id | name | sex |</span><br><span class="line">+----+------+-----+</span><br><span class="line">|  3 | tom3 |   1 |</span><br><span class="line">|  4 | tom4 |   0 |</span><br><span class="line">|  5 | tom5 |   0 |</span><br><span class="line">|  6 | tom6 |   1 |</span><br><span class="line">|  7 | tom7 |   1 |</span><br><span class="line">+----+------+-----+</span><br><span class="line">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>未分区表和分区表性能测试</p><p>创建一个未分区的表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table test2.tab1(c1 int,c2 varchar(30),c3 date);</span><br></pre></td></tr></table></figure><p>创建分区表,按日期的年份拆分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE test2.tab2 ( c1 int, c2 varchar(30) , c3 date )    </span><br><span class="line">PARTITION BY RANGE (year(c3)) (PARTITION p0 VALUES LESS THAN (1995),  </span><br><span class="line">PARTITION p1 VALUES LESS THAN (1996) , PARTITION p2 VALUES LESS THAN (1997) ,  </span><br><span class="line">PARTITION p3 VALUES LESS THAN (1998) , PARTITION p4 VALUES LESS THAN (1999) ,  </span><br><span class="line">PARTITION p5 VALUES LESS THAN (2000) , PARTITION p6 VALUES LESS THAN (2001) ,  </span><br><span class="line">PARTITION p7 VALUES LESS THAN (2002) , PARTITION p8 VALUES LESS THAN (2003) ,  </span><br><span class="line">PARTITION p9 VALUES LESS THAN (2004) , PARTITION p10 VALUES LESS THAN (2010),  </span><br><span class="line">PARTITION p11 VALUES LESS THAN MAXVALUE );</span><br></pre></td></tr></table></figure><p><strong>注意:</strong>最后一行，考虑到可能的最大值</p><p>通过存储过程插入100万条测试数据</p><p><strong>创建存储过程：</strong></p><blockquote><p>mysql&gt; delimiter $$//指定存储过程结束符</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">mysqmysql&gt; alter table test2.user</span><br><span class="line">    -&gt; reorganize partition p1,p2,p3 into</span><br><span class="line">    -&gt; (partition p01 values less than (8),</span><br><span class="line">    -&gt;partition p02 values less than (12)</span><br><span class="line">-&gt; );</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# ls -l /usr/local/mysql/data/test2/user*</span><br><span class="line">-rw-r-----. 1 mysqlmysql  8614 Sep 16 22:06 /usr/local/mysql/data/test2/user.frm</span><br><span class="line">-rw-r-----. 1 mysqlmysql 98304 Sep 16 22:06 /usr/local/mysql/data/test2/user#P#p01.ibd</span><br><span class="line">-rw-r-----. 1 mysqlmysql 98304 Sep 16 22:06 /usr/local/mysql/data/test2/user#P#p02.ibd</span><br><span class="line">-rw-r-----. 1 mysqlmysql 98304 Sep 16 21:48 /usr/local/mysql/data/test2/user#P#p0.ibd</span><br><span class="line">-rw-r-----. 1 mysqlmysql 98304 Sep 16 21:49 /usr/local/mysql/data/test2/user#P#p4.ibd</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from test2.user partition(p01);</span><br><span class="line">+----+------+-----+</span><br><span class="line">| id | name | sex |</span><br><span class="line">+----+------+-----+</span><br><span class="line">|  3 | tom3 |   1 |</span><br><span class="line">|  4 | tom4 |   0 |</span><br><span class="line">|  5 | tom5 |   0 |</span><br><span class="line">|  6 | tom6 |   1 |</span><br><span class="line">|  7 | tom7 |   1 |</span><br><span class="line">+----+------+-----+</span><br><span class="line">5 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; create table test2.tab1(c1 int,c2 varchar(30),c3 date);</span><br><span class="line">mysql&gt; CREATE TABLE test2.tab2 ( c1 int, c2 varchar(30) , c3 date )    </span><br><span class="line">PARTITION BY RANGE (year(c3)) (PARTITION p0 VALUES LESS THAN (1995),  </span><br><span class="line">PARTITION p1 VALUES LESS THAN (1996) , PARTITION p2 VALUES LESS THAN (1997) ,  </span><br><span class="line">PARTITION p3 VALUES LESS THAN (1998) , PARTITION p4 VALUES LESS THAN (1999) ,  </span><br><span class="line">PARTITION p5 VALUES LESS THAN (2000) , PARTITION p6 VALUES LESS THAN (2001) ,  </span><br><span class="line">PARTITION p7 VALUES LESS THAN (2002) , PARTITION p8 VALUES LESS THAN (2003) ,  </span><br><span class="line">PARTITION p9 VALUES LESS THAN (2004) , PARTITION p10 VALUES LESS THAN (2010),  </span><br><span class="line">PARTITION p11 VALUES LESS THAN MAXVALUE );</span><br></pre></td></tr></table></figure><p><strong>注意:</strong>最后一行，考虑到可能的最大值</p><p>通过存储过程插入100万条测试数据</p><p><strong>创建存储过程：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;delimiter $$</span><br><span class="line">mysql&gt;CREATE PROCEDURE load_part_tab()  </span><br><span class="line">       begin  </span><br><span class="line">    declare v int default 0;  </span><br><span class="line">    while v &lt; 1000000  </span><br><span class="line">    do  	</span><br><span class="line">        insert into test2.tab1  </span><br><span class="line">        values (v,&apos;testing partitions&apos;,adddate(&apos;1995-01-01&apos;,(rand(v)*36520) mod 3652));  </span><br><span class="line">         set v = v + 1;  </span><br><span class="line">    end while;  </span><br><span class="line">    end  </span><br><span class="line">   $$</span><br></pre></td></tr></table></figure><p><strong>注：</strong>RAND()函数在0和1之间产生一个随机数，如果一个整数参数N被指定，它被用作种子值。每个种子产生的随机数序列是不同的。</p><p><strong>执行存储过程load_part_tab向test2.tab1表插入数据</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; delimiter ;</span><br><span class="line">mysql&gt; call load_part_tab();</span><br></pre></td></tr></table></figure><p><strong>向test2.tab2表中插入数据</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into test2.tab2 select * from test2.tab1;</span><br></pre></td></tr></table></figure><p><strong>测试SQL性能</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select count(*) from test2.tab1 where c3 &gt; &apos;1995-01-01&apos; and c3 &lt; &apos;1995-12-31&apos;;</span><br><span class="line">+----------+</span><br><span class="line">| count(*) |</span><br><span class="line">+----------+</span><br><span class="line">|   219642 |</span><br><span class="line">+----------+</span><br><span class="line">1 row in set (0.84 sec)</span><br><span class="line">mysql&gt; select count(*) from test2.tab2 where c3 &gt; &apos;1995-01-01&apos; and c3 &lt; &apos;1995-12-31&apos;; </span><br><span class="line">+----------+</span><br><span class="line">| count(*) |</span><br><span class="line">+----------+</span><br><span class="line">|   219642 |</span><br><span class="line">+----------+</span><br><span class="line">1 row in set (0.09 sec)</span><br></pre></td></tr></table></figure><p>结果表明分区表比未分区表的执行时间少很多。</p><p><strong>通过explain语句来分析执行情况</strong></p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; flush tables;</span><br><span class="line">mysql&gt; explain select count(*) from test2.tab1 where c3 &gt; &apos;1995-01-01&apos; and c3 &lt; &apos;1995-12-31&apos;\G;</span><br></pre></td></tr></table></figure><p><strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong> 1. row <strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong></p><p>id: 1<br>select_type: SIMPLE<br>table: tab1<br>partitions: NULL<br>type: ALL<br>possible_keys: NULL<br>key: NULL<br>key_len: NULL<br>ref: NULL<br><font color="red">rows: 2001552</font><br>filtered: 11.11<br>Extra: Using where<br>1 row in set, 1 warning (0.00 sec)</p></blockquote><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select count(*) from test2.tab2 where c3 &gt; &apos;1995-01-01&apos; and c3 &lt; &apos;1995-12-31&apos;\G;</span><br></pre></td></tr></table></figure><p><strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong> 1. row <strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong><br>id: 1<br>select_type: SIMPLE<br>table: tab2<br>partitions: p1<br>type: ALL<br>possible_keys: NULL<br>key: NULL<br>key_len: NULL<br>ref: NULL<br><font color="red">rows: 220206</font><br>filtered: 11.11<br>Extra: Using where<br>1 row in set, 1 warning (0.00 sec)</p></blockquote><p>explain语句显示了SQL查询要处理的记录数目可以看出分区表比未分区表的明显扫描的记录要少很多。</p><p><strong>创建索引后情况测试</strong></p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create index idx_of_c3 on test2.tab1(c3);</span><br><span class="line">Query OK, 0 rows affected (5.07 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; create index idx_of_c3 on test2.tab2(c3);</span><br><span class="line">Query OK, 0 rows affected (4.87 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; flush tables;</span><br><span class="line">mysql&gt; select count(*) from test2.tab1 where c3 &gt; &apos;1996-01-01&apos; and c3 &lt; &apos;1996-12-31&apos;;</span><br></pre></td></tr></table></figure><p>+———-+<br>| count(*) |<br>+———-+<br>| 220264 |<br>+———-+<br>1 row in set <font color="red">(0.12 sec)</font></p></blockquote><p><strong>重启mysqld服务</strong></p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select count(*) from test2.tab2 where c3 &gt; &apos;1996-01-01&apos; and c3 &lt; &apos;1996-12-31&apos;;</span><br></pre></td></tr></table></figure><p>+———-+<br>| count(*) |<br>+———-+<br>| 220264 |<br>+———-+<br>1 row in set <font color="red">(0.11 sec)</font></p></blockquote><h3 id="2-3-mysql分区的类型"><a href="#2-3-mysql分区的类型" class="headerlink" title="2.3 mysql分区的类型"></a>2.3 mysql分区的类型</h3><h4 id="2-3-1-RANGE分区"><a href="#2-3-1-RANGE分区" class="headerlink" title="2.3.1 RANGE分区"></a>2.3.1 RANGE分区</h4><p>基于属于一个给定连续区间的列值，把多行分配给分区。这些区间要连续且不能相互重叠，使用VALUES LESS THAN操作符来进行定义。以下是示例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE employees (</span><br><span class="line">    id INT NOT NULL,</span><br><span class="line">    fname VARCHAR(30),</span><br><span class="line">    lname VARCHAR(30),</span><br><span class="line">    hired DATE NOT NULL DEFAULT &apos;1970-01-01&apos;,</span><br><span class="line">    separated DATE NOT NULL DEFAULT &apos;9999-12-31&apos;,</span><br><span class="line">    job_code INT NOT NULL,</span><br><span class="line">    store_id INT NOT NULL</span><br><span class="line">)  </span><br><span class="line"> partition BY RANGE (store_id) (</span><br><span class="line">    partition p0 VALUES LESS THAN (6),</span><br><span class="line">    partition p1 VALUES LESS THAN (11),</span><br><span class="line">    partition p2 VALUES LESS THAN (16),</span><br><span class="line">    partition p3 VALUES LESS THAN (21)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>按照这种分区方案，在商店1到5工作的雇员相对应的所有行被保存在分区P0中，商店6到10的雇员保存在P1中，依次类推。注意，每个分区都是按顺序进行定义，从最低到最高。<br>对于包含数据(72, ‘Michael’, ‘Widenius’, ‘1998-06-25’, NULL, 13)的一个新行，可以很容易地确定它将插入到p2分区中，但是如果增加了一个编号为第21的商店，将会发生什么呢？在这种方案下，由于没有规则把store_id大于20的商店包含在内，服务器将不知道把该行保存在何处，将会导致错误。要避免这种错误，可以创建maxvalue分区，所有不在指定范围内的记录都会被存储到maxvalue所在的分区中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; alter table test2.user add partition (partition p4 values less than maxvalue);</span><br></pre></td></tr></table></figure><h4 id="2-3-2-LIST分区"><a href="#2-3-2-LIST分区" class="headerlink" title="2.3.2 LIST分区"></a>2.3.2 LIST分区</h4><p>类似于按RANGE分区，区别在于LIST分区是基于列值匹配一个离散值集合中的某个值来进行选择。<br>LIST分区通过使用“PARTITION BY LIST(expr)”来实现，其中“expr” 是某列值或一个基于某个列值、并返回一个整数值的表达式，然后通过“VALUES IN (value_list)”的方式来定义每个分区，其中“value_list”是一个通过逗号分隔的整数列表。</p><p>要按照属于同一个地区商店的行保存在同一个分区中的方式来分割表，可以使用下面的“<strong>CREATE TABLE</strong>”语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE employees1 (</span><br><span class="line">    id INT NOT NULL,</span><br><span class="line">    fname VARCHAR(30),</span><br><span class="line">    lname VARCHAR(30),</span><br><span class="line">    hired DATE NOT NULL DEFAULT &apos;1970-01-01&apos;,</span><br><span class="line">    separated DATE NOT NULL DEFAULT &apos;9999-12-31&apos;,</span><br><span class="line">    job_code INT,</span><br><span class="line">    store_id INT</span><br><span class="line">)  </span><br><span class="line"> PARTITION BY LIST(store_id)</span><br><span class="line">(</span><br><span class="line">    PARTITION pNorth VALUES IN (3,5,6,9,17),</span><br><span class="line">    PARTITION pEast VALUES IN (1,2,10,11,19,20),</span><br><span class="line">    PARTITION pWest VALUES IN (4,12,13,14,18),</span><br><span class="line">    PARTITION pCentral VALUES IN (7,8,15,16)</span><br><span class="line">)；</span><br></pre></td></tr></table></figure><p>这使得在表中增加或删除指定地区的雇员记录变得容易起来。例如，假定西区的所有音像店都卖给了其他公司。那么与在西区音像店工作雇员相关的所有记录（行）可以使用查询“ALTER TABLE employees DROP PARTITION pWest；”来进行删除，它与具有同样作用的DELETE （删除）查询“DELETE query DELETE FROM employees WHERE store_id IN (4,12,13,14,18)；”比起来，要有效得多。</p><p>要点：如果试图插入列值不在分区值列表中的一行时，那么“INSERT”查询将失败并报错。例如，假定LIST分区的采用上面的方案，下面的插入将失败：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO employees VALUES(224, &apos;Linus&apos;, &apos;Torvalds&apos;, &apos;2002-05-01&apos;, &apos;2004-10-12&apos;, 42, 21);</span><br></pre></td></tr></table></figure><p>这是因为“store_id”列值21不能在用于定义分区pNorth, pEast, pWest,或pCentral的值列表中找到。要重点注意的是，LIST分区没有类似如“VALUES LESS THAN MAXVALUE”这样的包含其他值在内的定义。将要匹配的任何值都必须在值列表中找到。</p><h4 id="2-3-3-HASH分区"><a href="#2-3-3-HASH分区" class="headerlink" title="2.3.3 HASH分区"></a>2.3.3 HASH分区</h4><p>这种模式允许DBA通过对表的一个或多个列的Hash Key进行计算，最后通过这个Hash码不同数值对应的数据区域进行分区。</p><p>hash分区的目的是将数据均匀的分布到预先定义的各个分区中，保证各分区的数据量大致一致。在RANGE和LIST分区中，必须明确指定一个给定的列值或列值集合应该保存在哪个分区中；而在HASH分区中，MYSQL自动完成这些工作，用户所要定一个列值或者表达式，以及指定被分区的表将要被分割成的分区数量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table t_hash( a int(11), b datetime) partition by hash(year(b)) partitions 4;</span><br></pre></td></tr></table></figure><p>hash的分区函数页需要返回一个整数值。partitions子句中的值是一个非负整数，不加的partitions子句的话，默认为分区数为1。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into t_hash values(1,&apos;2010-04-01&apos;);</span><br></pre></td></tr></table></figure><p>该记录会被放入分区p2中。因为插入2010-04-01进入表t_hash,那么</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOD(YEAR(&apos;2010-04-01&apos;),4)=2</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from information_schema.partitions where table_schema=&apos;test2&apos; and table_name=&apos;t_hash&apos;\G;</span><br></pre></td></tr></table></figure><p><strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong> 1. row <strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong><br>TABLE_CATALOG: def<br>TABLE_SCHEMA: test2<br>TABLE_NAME: t_hash<br>PARTITION_NAME: p0<br>SUBPARTITION_NAME: NULL<br>PARTITION_ORDINAL_POSITION: 1<br>SUBPARTITION_ORDINAL_POSITION: NULL<br>PARTITION_METHOD: HASH<br>SUBPARTITION_METHOD: NULL<br>PARTITION_EXPRESSION: year(b)<br>SUBPARTITION_EXPRESSION: NULL<br>PARTITION_DESCRIPTION: NULL<br>TABLE_ROWS: 0<br>AVG_ROW_LENGTH: 0<br>DATA_LENGTH: 16384<br>MAX_DATA_LENGTH: NULL<br>INDEX_LENGTH: 0<br>DATA_FREE: 0<br>CREATE_TIME: 2016-09-16 22:48:59<br>UPDATE_TIME: 2016-09-17 23:36:22<br>CHECK_TIME: NULL<br>CHECKSUM: NULL<br>PARTITION_COMMENT:<br>NODEGROUP: default<br>TABLESPACE_NAME: NULL<br><strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong> 2. row <strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong><br>TABLE_CATALOG: def<br>TABLE_SCHEMA: test2<br>TABLE_NAME: t_hash<br>PARTITION_NAME: p1<br>SUBPARTITION_NAME: NULL<br>PARTITION_ORDINAL_POSITION: 2<br>SUBPARTITION_ORDINAL_POSITION: NULL<br>PARTITION_METHOD: HASH<br>SUBPARTITION_METHOD: NULL<br>PARTITION_EXPRESSION: year(b)<br>SUBPARTITION_EXPRESSION: NULL<br>PARTITION_DESCRIPTION: NULL<br>TABLE_ROWS: 0<br>AVG_ROW_LENGTH: 0<br>DATA_LENGTH: 16384<br>MAX_DATA_LENGTH: NULL<br>INDEX_LENGTH: 0<br>DATA_FREE: 0<br>CREATE_TIME: 2016-09-16 22:48:59<br>UPDATE_TIME: 2016-09-17 23:36:22<br>CHECK_TIME: NULL<br>CHECKSUM: NULL<br>PARTITION_COMMENT:<br>NODEGROUP: default<br>TABLESPACE_NAME: NULL<br><strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong> 3. row <strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong><br>TABLE_CATALOG: def<br>TABLE_SCHEMA: test2<br>TABLE_NAME: t_hash<br><font color="red">PARTITION_NAME: p2</font><br>SUBPARTITION_NAME: NULL<br>PARTITION_ORDINAL_POSITION: 3<br>SUBPARTITION_ORDINAL_POSITION: NULL<br>PARTITION_METHOD: HASH<br>SUBPARTITION_METHOD: NULL<br>PARTITION_EXPRESSION: year(b)<br>SUBPARTITION_EXPRESSION: NULL<br>PARTITION_DESCRIPTION: NULL<br><font color="red">TABLE_ROWS: 1</font><br>AVG_ROW_LENGTH: 16384<br>DATA_LENGTH: 16384<br>MAX_DATA_LENGTH: NULL<br>INDEX_LENGTH: 0<br>DATA_FREE: 0<br>CREATE_TIME: 2016-09-16 22:48:59<br>UPDATE_TIME: 2016-09-17 23:23:26<br>CHECK_TIME: NULL<br>CHECKSUM: NULL<br>PARTITION_COMMENT:<br>NODEGROUP: default<br>TABLESPACE_NAME: NULL<br><strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong> 4. row <strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong><br>TABLE_CATALOG: def<br>TABLE_SCHEMA: test2<br>TABLE_NAME: t_hash<br>PARTITION_NAME: p3<br>SUBPARTITION_NAME: NULL<br>PARTITION_ORDINAL_POSITION: 4<br>SUBPARTITION_ORDINAL_POSITION: NULL<br>PARTITION_METHOD: HASH<br>SUBPARTITION_METHOD: NULL<br>PARTITION_EXPRESSION: year(b)<br>SUBPARTITION_EXPRESSION: NULL<br>PARTITION_DESCRIPTION: NULL<br>TABLE_ROWS: 0<br>AVG_ROW_LENGTH: 0<br>DATA_LENGTH: 16384<br>MAX_DATA_LENGTH: NULL<br>INDEX_LENGTH: 0<br>DATA_FREE: 0<br>CREATE_TIME: 2016-09-16 22:48:59<br>UPDATE_TIME: 2016-09-17 23:23:26<br>CHECK_TIME: NULL<br>CHECKSUM: NULL<br>PARTITION_COMMENT:<br>NODEGROUP: default<br>TABLESPACE_NAME: NULL<br>4 rows in set (0.00 sec)</p></blockquote><p>可以看到P2分区有一条记录。当前这个例子并不能把数据均匀的分布到各个分区，因为按照YEAR函数进行的，该值本身是离散的。如果对连续的值进行HASH分区，如自增长的主键，则可以较好地将数据平均分布。</p><p>请思考：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into t_hash values(1,&apos;2012-04-01&apos;);</span><br></pre></td></tr></table></figure><p>记录会插入哪个分区？</p><h4 id="2-3-4-key分区"><a href="#2-3-4-key分区" class="headerlink" title="2.3.4 key分区"></a>2.3.4 key分区</h4><p>key分区和hash分区相似，不同在于hash分区是用户自定义函数进行分区，key分区使用mysql数据库提供的函数进行分区，NDB cluster使用MD5函数来分区，对于其他存储引擎mysql使用内部的hash函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table t_key( a int(11), b datetime) partition by key(b) partitions 4;</span><br></pre></td></tr></table></figure><p>上面的RANGE、LIST、HASH、KEY四种分区中，分区的条件必须是整形，如果不是整形需要通过函数将其转换为整形。</p><h4 id="2-3-5-columns分区"><a href="#2-3-5-columns分区" class="headerlink" title="2.3.5 columns分区"></a>2.3.5 columns分区</h4><p>mysql-5.5开始支持COLUMNS分区，可视为RANGE和LIST分区的进化，COLUMNS分区可以直接使用非整形数据进行分区。COLUMNS分区支持以下数据类型：</p><ol><li><strong>所有整形</strong>，如INT SMALLINT TINYINT BIGINT。FLOAT和DECIMAL则不支持。</li><li><strong>日期类型</strong>，如DATE和DATETIME。其余日期类型不支持。</li><li><strong>字符串类型</strong>，如CHAR、VARCHAR、BINARY和VARBINARY。BLOB和TEXT类型不支持。</li></ol><p>COLUMNS可以使用多个列进行分区。</p><h2 id="3、mysql分表和分区有什么区别呢？"><a href="#3、mysql分表和分区有什么区别呢？" class="headerlink" title="3、mysql分表和分区有什么区别呢？"></a>3、mysql分表和分区有什么区别呢？</h2><h3 id="3-1-实现方式上"><a href="#3-1-实现方式上" class="headerlink" title="3.1 实现方式上"></a>3.1 实现方式上</h3><ol><li>mysql的分表是真正的分表，一张表分成很多表后，每一个小表都是完整的一张表，都对应三个文件，一个.MYD数据文件，.MYI索引文件，.frm表结构文件。</li><li>分区不一样，一张大表进行分区后，他还是一张表，不会变成二张表，但是他存放数据的区块变多了</li></ol><h3 id="3-2-数据处理上"><a href="#3-2-数据处理上" class="headerlink" title="3.2 数据处理上"></a>3.2 数据处理上</h3><ol><li>分表后，数据都是存放在分表里，总表只是一个外壳，存取数据发生在一个一个的分表里面。</li><li>分区呢，不存在分表的概念，分区只不过把存放数据的文件分成了许多小块，分区后的表呢，还是一张表，数据处理还是由自己来完成。</li></ol><h3 id="3-3-提高性能上"><a href="#3-3-提高性能上" class="headerlink" title="3.3 提高性能上"></a>3.3 提高性能上</h3><ol><li><p>分表后，单表的并发能力提高了，磁盘I/O性能也提高了。并发能力为什么提高了呢，因为查寻一次所花的时间变短了，如果出现高并发的话，总表可以根据不同的查询，将并发压力分到不同的小表里面。</p></li><li><p>mysql提出了分区的概念，主要是想突破磁盘I/O瓶颈，想提高磁盘的读写能力，来增加mysql性能。<br>在这一点上，分区和分表的测重点不同，分表重点是存取数据时，如何提高mysql并发能力上；而分区呢，如何突破磁盘的读写能力，从而达到提高mysql性能的目的。</p></li></ol><h3 id="3-4-实现的难易度上"><a href="#3-4-实现的难易度上" class="headerlink" title="3.4 实现的难易度上"></a>3.4 实现的难易度上</h3><ol><li><p>分表的方法有很多，用merge来分表，是最简单的一种方式。这种方式跟分区难易度差不多，并且对程序代码来说可以做到透明的。如果是用其他分表方式就比分区麻烦了。</p></li><li><p>分区实现是比较简单的，建立分区表，根建平常的表没什么区别，并且对开代码端来说是透明的。</p></li></ol><h3 id="3-5-mysql分表和分区有什么联系？"><a href="#3-5-mysql分表和分区有什么联系？" class="headerlink" title="3.5 mysql分表和分区有什么联系？"></a>3.5 mysql分表和分区有什么联系？</h3><ol><li><p>都能提高mysql的性高，在高并发状态下都有一个良好的表现。</p></li><li><p>分表和分区不矛盾，可以相互配合的，对于那些大访问量，并且表数据比较多的表，我们可以采取分表和分区结合的方式，访问量不大，但是表数据很多的表，我们可以采取分区的方式等。</p></li><li><p>分表技术是比较麻烦的，需要手动去创建子表，app服务端读写时候需要计算子表名。采用merge好一些，但也要创建子表和配置子表间的union关系。</p></li><li><p>表分区相对于分表，操作方便，不需要创建子表。</p></li></ol></div><div><div><div style="text-align:center;color:#ccc;font-size:14px">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div></div></div><div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag"><i class="fa fa-tag"></i> 数据库</a><a href="/tags/MySQL/" rel="tag"><i class="fa fa-tag"></i> MySQL</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2017/11/05/memcache-huan-cun-fu-wu/" rel="next" title="MemCache 缓存服务"><i class="fa fa-chevron-left"></i> MemCache 缓存服务</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2017/11/19/linux-iptables-fang-huo-qiang/" rel="prev" title="Linux iptables防火墙">Linux iptables防火墙<i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"><div class="jiathis_style"><span class="jiathis_txt">分享到：</span> <a class="jiathis_button_fav">收藏夹</a> <a class="jiathis_button_copy">复制网址</a> <a class="jiathis_button_email">邮件</a> <a class="jiathis_button_weixin">微信</a> <a class="jiathis_button_qzone">QQ空间</a> <a class="jiathis_button_tqq">腾讯微博</a> <a class="jiathis_button_douban">豆瓣</a> <a class="jiathis_button_share">一键分享</a> <a href="http://www.jiathis.com/share?uid=2140465" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank">更多</a><a class="jiathis_counter_style"></a></div><script type="text/javascript">var jiathis_config={data_track_clickback:!0,summary:"",shortUrl:!1,hideMore:!1}</script><script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=" charset="utf-8"></script></div></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div id="sidebar-dimmer"></div><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/images/chen.png" alt="Zhongzhou Chen"><p class="site-author-name" itemprop="name">Zhongzhou Chen</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/%7C%7C%20archive"><span class="site-state-item-count">320</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">84</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">182</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1、为什么要分表和分区？"><span class="nav-text">1、为什么要分表和分区？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2、分表"><span class="nav-text">2、分表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-什么是分表？"><span class="nav-text">2.1 什么是分表？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-Mysql分表分为垂直切分和水平切分"><span class="nav-text">2.2 Mysql分表分为垂直切分和水平切分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-分表的几种方式："><span class="nav-text">2.3 分表的几种方式：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-1-mysql集群"><span class="nav-text">2.3.1 mysql集群</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-2-预先估计会出现大数据量并且访问频繁的表，将其分为若干个表"><span class="nav-text">2.3.2 预先估计会出现大数据量并且访问频繁的表，将其分为若干个表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-3-利用merge存储引擎来实现分表"><span class="nav-text">2.3.3 利用merge存储引擎来实现分表</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2、分区"><span class="nav-text">2、分区</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-什么是分区？"><span class="nav-text">2.1 什么是分区？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-分区主要有两种形式"><span class="nav-text">2.2 分区主要有两种形式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-按照范围-range-方式的表分区"><span class="nav-text">2.3 按照范围(range)方式的表分区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-mysql分区的类型"><span class="nav-text">2.3 mysql分区的类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-1-RANGE分区"><span class="nav-text">2.3.1 RANGE分区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-2-LIST分区"><span class="nav-text">2.3.2 LIST分区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-3-HASH分区"><span class="nav-text">2.3.3 HASH分区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-4-key分区"><span class="nav-text">2.3.4 key分区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-5-columns分区"><span class="nav-text">2.3.5 columns分区</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3、mysql分表和分区有什么区别呢？"><span class="nav-text">3、mysql分表和分区有什么区别呢？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-实现方式上"><span class="nav-text">3.1 实现方式上</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-数据处理上"><span class="nav-text">3.2 数据处理上</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-提高性能上"><span class="nav-text">3.3 提高性能上</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-实现的难易度上"><span class="nav-text">3.4 实现的难易度上</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-mysql分表和分区有什么联系？"><span class="nav-text">3.5 mysql分表和分区有什么联系？</span></a></li></ol></li></ol></div></div></section><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span id="scrollpercent"><span>0</span>%</span></div></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="copyright">&copy; <span itemprop="copyrightYear">2022</span><span class="with-love"><i class="fa fa-user"></i></span> <span class="author" itemprop="copyrightHolder">Zhongzhou Chen</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-area-chart"></i></span> <span class="post-meta-item-text">Site words total count&#58;</span> <span title="Site words total count">758.4k</span></div><span class="post-meta-divider"></span></div></footer></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><style>.copy-btn{display:inline-block;padding:6px 12px;font-size:13px;font-weight:700;line-height:20px;color:#333;white-space:nowrap;vertical-align:middle;cursor:pointer;background-color:#eee;background-image:linear-gradient(#fcfcfc,#eee);border:1px solid #d5d5d5;border-radius:3px;user-select:none;outline:0}.highlight-wrap .copy-btn{transition:opacity .3s ease-in-out;opacity:0;padding:2px 6px;position:absolute;right:4px;top:8px}.highlight-wrap .copy-btn:focus,.highlight-wrap:hover .copy-btn{opacity:1}.highlight-wrap{position:relative}</style><script>$(".highlight").each(function(t,e){var n=$("<div>").addClass("highlight-wrap");$(e).after(n),n.append($("<button>").addClass("copy-btn").append("复制").on("click",function(t){var e=$(this).parent().find(".code").find(".line").map(function(t,e){return $(e).text()}).toArray().join("\n"),n=document.createElement("textarea");document.body.appendChild(n),n.style.position="absolute",n.style.top="0px",n.style.left="0px",n.value=e,n.select(),n.focus();var o=document.execCommand("copy");document.body.removeChild(n),o?$(this).text("复制成功"):$(this).text("复制失败"),$(this).blur()})).on("mouseleave",function(t){var e=$(this).find(".copy-btn");setTimeout(function(){e.text("复制")},300)}).append(e)})</script><script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script><script type="text/javascript">function proceedsearch(){$("body").append('<div class="search-popup-overlay local-search-pop-overlay"></div>').css("overflow","hidden"),$(".search-popup-overlay").click(onPopupClose),$(".popup").toggle();var t=$("#local-search-input");t.attr("autocapitalize","none"),t.attr("autocorrect","off"),t.focus()}var isfetched=!1,isXml=!0,search_path="search.xml";0===search_path.length?search_path="search.xml":/json$/i.test(search_path)&&(isXml=!1);var path="/"+search_path,onPopupClose=function(t){$(".popup").hide(),$("#local-search-input").val(""),$(".search-result-list").remove(),$("#no-result").remove(),$(".local-search-pop-overlay").remove(),$("body").css("overflow","")},searchFunc=function(t,e,s){"use strict";$("body").append('<div class="search-popup-overlay local-search-pop-overlay"><div id="search-loading-icon"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div>').css("overflow","hidden"),$("#search-loading-icon").css("margin","20% auto 0 auto").css("text-align","center"),$.ajax({url:t,dataType:isXml?"xml":"json",async:!0,success:function(t){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var o=isXml?$("entry",t).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get():t,n=document.getElementById(e),r=document.getElementById(s);n.addEventListener("input",function(){var y=n.value.trim().toLowerCase(),T=y.split(/[\s\-]+/);1<T.length&&T.push(y);var b=[];if(0<y.length&&o.forEach(function(t){function e(t,e,o,n){for(var r=n[n.length-1],s=r.position,a=r.word,i=[],c=0;s+a.length<=o&&0!=n.length;){a===y&&c++,i.push({position:s,length:a.length});var l=s+a.length;for(n.pop();0!=n.length&&(s=(r=n[n.length-1]).position,a=r.word,s<l);)n.pop()}return h+=c,{hits:i,start:e,end:o,searchTextCount:c}}function o(o,t){var n="",r=t.start;return t.hits.forEach(function(t){n+=o.substring(r,t.position);var e=t.position+t.length;n+='<b class="search-keyword">'+o.substring(t.position,e)+"</b>",r=e}),n+=o.substring(r,t.end)}var n=!1,r=0,h=0,s=t.title.trim(),a=s.toLowerCase(),i=t.content.trim().replace(/<[^>]+>/g,""),c=i.toLowerCase(),l=decodeURIComponent(t.url),p=[],u=[];if(""!=s&&(T.forEach(function(t){function e(t,e,o){var n=t.length;if(0===n)return[];var r=0,s=[],a=[];for(o||(e=e.toLowerCase(),t=t.toLowerCase());-1<(s=e.indexOf(t,r));)a.push({position:s,word:t}),r=s+n;return a}p=p.concat(e(t,a,!1)),u=u.concat(e(t,c,!1))}),(0<p.length||0<u.length)&&(n=!0,r=p.length+u.length)),n){[p,u].forEach(function(t){t.sort(function(t,e){return e.position!==t.position?e.position-t.position:t.word.length-e.word.length})});var f=[];0!=p.length&&f.push(e(0,0,s.length,p));for(var d=[];0!=u.length;){var g=u[u.length-1],v=g.position,$=g.word,C=v-20,m=v+80;C<0&&(C=0),m<v+$.length&&(m=v+$.length),m>i.length&&(m=i.length),d.push(e(0,C,m,u))}d.sort(function(t,e){return t.searchTextCount!==e.searchTextCount?e.searchTextCount-t.searchTextCount:t.hits.length!==e.hits.length?e.hits.length-t.hits.length:t.start-e.start});var x=parseInt("1");0<=x&&(d=d.slice(0,x));var w="";w+=0!=f.length?"<li><a href='"+l+"' class='search-result-title'>"+o(s,f[0])+"</a>":"<li><a href='"+l+"' class='search-result-title'>"+s+"</a>",d.forEach(function(t){w+="<a href='"+l+'\'><p class="search-result">'+o(i,t)+"...</p></a>"}),w+="</li>",b.push({item:w,searchTextCount:h,hitCount:r,id:b.length})}}),1===T.length&&""===T[0])r.innerHTML='<div id="no-result"><i class="fa fa-search fa-5x" /></div>';else if(0===b.length)r.innerHTML='<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>';else{b.sort(function(t,e){return t.searchTextCount!==e.searchTextCount?e.searchTextCount-t.searchTextCount:t.hitCount!==e.hitCount?e.hitCount-t.hitCount:e.id-t.id});var e='<ul class="search-result-list">';b.forEach(function(t){e+=t.item}),e+="</ul>",r.innerHTML=e}}),$(".local-search-pop-overlay").remove(),$("body").css("overflow",""),proceedsearch()}})};$(".popup-trigger").click(function(t){t.stopPropagation(),!1===isfetched?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(onPopupClose),$(".popup").click(function(t){t.stopPropagation()}),$(document).on("keyup",function(t){27===t.which&&$(".search-popup").is(":visible")&&onPopupClose()})</script><script type="text/javascript" src="/js/src/love.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,log:!1,model:{jsonPath:"/live2dw/assets/shizuku.model.json"},display:{position:"right"},mobile:{show:!0,scale:.2},react:{opacityDefault:.7,opacityOnHover:.2,opacity:.4}})</script></body></html>