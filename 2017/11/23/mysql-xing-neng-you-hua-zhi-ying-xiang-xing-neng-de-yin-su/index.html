<!DOCTYPE html><html class="theme-next gemini use-motion" lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script><link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet"><script></script><meta name="theme-color" content="#222"><style>.pace .pace-progress{background:#1e92fb;height:3px}.pace .pace-progress-inner{box-shadow:0 0 10px #1e92fb,0 0 5px #1e92fb}.pace .pace-activity{border-top-color:#1e92fb;border-left-color:#1e92fb}</style><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4"><link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222"><meta name="keywords" content="数据库,MySQL,"><link rel="alternate" href="/atom.xml" title="凡间的精灵" type="application/atom+xml"><meta name="description" content="1、MySQL 性能优化之影响性能的因素1.1 商业需求的影响不合理需求造成资源投入产出比过低，这里我们就用一个看上去很简单的功能来分析一下。需求：一个论坛帖子总量的统计，附加要求：实时更新从功能上来看非常容易实现，执行一条SELECT COUNT(*) from 表名 的Query 就可以得到结果。但是，如果我们采用不是MyISAM 存储引擎，而是使用的Innodb 的存储引擎，那么大家可以试想"><meta name="keywords" content="数据库,MySQL"><meta property="og:type" content="article"><meta property="og:title" content="MySQL 性能优化之影响性能的因素"><meta property="og:url" content="http:&#x2F;&#x2F;chenzhonzhou.github.io&#x2F;2017&#x2F;11&#x2F;23&#x2F;mysql-xing-neng-you-hua-zhi-ying-xiang-xing-neng-de-yin-su&#x2F;index.html"><meta property="og:site_name" content="凡间的精灵"><meta property="og:description" content="1、MySQL 性能优化之影响性能的因素1.1 商业需求的影响不合理需求造成资源投入产出比过低，这里我们就用一个看上去很简单的功能来分析一下。需求：一个论坛帖子总量的统计，附加要求：实时更新从功能上来看非常容易实现，执行一条SELECT COUNT(*) from 表名 的Query 就可以得到结果。但是，如果我们采用不是MyISAM 存储引擎，而是使用的Innodb 的存储引擎，那么大家可以试想"><meta property="og:locale" content="zh-Hans"><meta property="og:image" content="http:&#x2F;&#x2F;chenzhonzhou.github.io&#x2F;2017&#x2F;11&#x2F;23&#x2F;mysql-xing-neng-you-hua-zhi-ying-xiang-xing-neng-de-yin-su&#x2F;%E5%9B%BE%E7%89%871.png"><meta property="og:image" content="http:&#x2F;&#x2F;chenzhonzhou.github.io&#x2F;2017&#x2F;11&#x2F;23&#x2F;mysql-xing-neng-you-hua-zhi-ying-xiang-xing-neng-de-yin-su&#x2F;%E5%9B%BE%E7%89%872.png"><meta property="og:image" content="http:&#x2F;&#x2F;chenzhonzhou.github.io&#x2F;2017&#x2F;11&#x2F;23&#x2F;mysql-xing-neng-you-hua-zhi-ying-xiang-xing-neng-de-yin-su&#x2F;%E5%9B%BE%E7%89%873.png"><meta property="og:image" content="http:&#x2F;&#x2F;chenzhonzhou.github.io&#x2F;2017&#x2F;11&#x2F;23&#x2F;mysql-xing-neng-you-hua-zhi-ying-xiang-xing-neng-de-yin-su&#x2F;%E5%9B%BE%E7%89%874.png"><meta property="og:image" content="http:&#x2F;&#x2F;chenzhonzhou.github.io&#x2F;2017&#x2F;11&#x2F;23&#x2F;mysql-xing-neng-you-hua-zhi-ying-xiang-xing-neng-de-yin-su&#x2F;%E5%9B%BE%E7%89%875.png"><meta property="og:image" content="http:&#x2F;&#x2F;chenzhonzhou.github.io&#x2F;2017&#x2F;11&#x2F;23&#x2F;mysql-xing-neng-you-hua-zhi-ying-xiang-xing-neng-de-yin-su&#x2F;%E5%9B%BE%E7%89%876.png"><meta property="og:image" content="http:&#x2F;&#x2F;chenzhonzhou.github.io&#x2F;2017&#x2F;11&#x2F;23&#x2F;mysql-xing-neng-you-hua-zhi-ying-xiang-xing-neng-de-yin-su&#x2F;%E5%9B%BE%E7%89%877.png"><meta property="og:image" content="http:&#x2F;&#x2F;chenzhonzhou.github.io&#x2F;2017&#x2F;11&#x2F;23&#x2F;mysql-xing-neng-you-hua-zhi-ying-xiang-xing-neng-de-yin-su&#x2F;%E5%9B%BE%E7%89%878.png"><meta property="og:image" content="http:&#x2F;&#x2F;chenzhonzhou.github.io&#x2F;2017&#x2F;11&#x2F;23&#x2F;mysql-xing-neng-you-hua-zhi-ying-xiang-xing-neng-de-yin-su&#x2F;%E5%9B%BE%E7%89%879.png"><meta property="og:image" content="http:&#x2F;&#x2F;chenzhonzhou.github.io&#x2F;2017&#x2F;11&#x2F;23&#x2F;mysql-xing-neng-you-hua-zhi-ying-xiang-xing-neng-de-yin-su&#x2F;%E5%9B%BE%E7%89%8710.png"><meta property="og:image" content="http:&#x2F;&#x2F;chenzhonzhou.github.io&#x2F;2017&#x2F;11&#x2F;23&#x2F;mysql-xing-neng-you-hua-zhi-ying-xiang-xing-neng-de-yin-su&#x2F;%E5%9B%BE%E7%89%8711.png"><meta property="og:image" content="http:&#x2F;&#x2F;chenzhonzhou.github.io&#x2F;2017&#x2F;11&#x2F;23&#x2F;mysql-xing-neng-you-hua-zhi-ying-xiang-xing-neng-de-yin-su&#x2F;%E5%9B%BE%E7%89%8712.png"><meta property="og:image" content="http:&#x2F;&#x2F;chenzhonzhou.github.io&#x2F;2017&#x2F;11&#x2F;23&#x2F;mysql-xing-neng-you-hua-zhi-ying-xiang-xing-neng-de-yin-su&#x2F;%E5%9B%BE%E7%89%8713.png"><meta property="og:updated_time" content="2021-09-08T10:25:13.068Z"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http:&#x2F;&#x2F;chenzhonzhou.github.io&#x2F;2017&#x2F;11&#x2F;23&#x2F;mysql-xing-neng-you-hua-zhi-ying-xiang-xing-neng-de-yin-su&#x2F;%E5%9B%BE%E7%89%871.png"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Gemini",version:"5.1.4",sidebar:{position:"left",display:"always",offset:12,b2t:!0,scrollpercent:!0,onmobile:!0},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://chenzhonzhou.github.io/2017/11/23/mysql-xing-neng-you-hua-zhi-ying-xiang-xing-neng-de-yin-su/"><title>MySQL 性能优化之影响性能的因素 | 凡间的精灵</title><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">凡间的精灵</span><span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">凡尘落素一精灵</p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives" rel="section"><i class="menu-item-icon fa fa-fw fa-question-circle"></i><br>归档</a></li><li class="menu-item menu-item-categories"><a href="/categories" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-about"><a href="/about" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i></span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://chenzhonzhou.github.io/2017/11/23/mysql-xing-neng-you-hua-zhi-ying-xiang-xing-neng-de-yin-su/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Zhongzhou Chen"><meta itemprop="description" content=""><meta itemprop="image" content="/images/chen.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="凡间的精灵"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">MySQL 性能优化之影响性能的因素</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-23T17:55:56+08:00">2017-11-23</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a></span> ， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a></span></span><div class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">11.9k</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span> <span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">45</span></div></div></header><div class="post-body" itemprop="articleBody"><h2 id="1、MySQL-性能优化之影响性能的因素"><a href="#1、MySQL-性能优化之影响性能的因素" class="headerlink" title="1、MySQL 性能优化之影响性能的因素"></a>1、MySQL 性能优化之影响性能的因素</h2><h3 id="1-1-商业需求的影响"><a href="#1-1-商业需求的影响" class="headerlink" title="1.1 商业需求的影响"></a>1.1 商业需求的影响</h3><p>不合理需求造成资源投入产出比过低，这里我们就用一个看上去很简单的功能来分析一下。<br>需求：一个论坛帖子总量的统计，附加要求：实时更新</p><p><code>从功能上来看非常容易实现，执行一条SELECT COUNT(*) from 表名 的Query 就可以得到结果。但是，如果我们采用不是MyISAM 存储引擎，而是使用的Innodb 的存储引擎，那么大家可以试想一下，如果存放帖子的表中已经有上千万的帖子的时候，执行这条Query 语句需要多少成本？恐怕再好的硬件设备，恐怕都不可能在10秒之内完成一次查询吧 注：没有where的count(*)使用MyISAM要比InnoDB快得多。因为MyISAM内置了一个计数器，count(*)时它直接从计数器中读，而InnoDB必须扫描全表。所以在InnoDB上执行count(*)时一般要伴随where，且where中要包含主键以外的索引列。</code></p><p>既然这样查询不行，那我们是不是该专门为这个功能建一个表，就只有一个字段，一条记录，就存放这个统计量，每次有新的帖子产生的时候，都将这个值增加1，这样我们每次都只需要查询这个表就可以得到结果了，这个效率肯定能够满足要求了。确实，查询效率肯定能够满足要求，可是如果帖子产生很快，在高峰时期可能每秒就有几十甚至上百个帖子新增操作的时候，恐怕这个统计表又要成为大家的噩梦了。要么因为并发的问题造成统计结果的不准确，要么因为锁资源争用严重造成整体性能的大幅度下降。</p><p>其实这里问题的焦点不应该是实现这个功能的技术细节，而是在于这个功能的附加要求“实时更新”上面。当一个论坛的帖子数量很大了之后，到底有多少人会关注这个统计数据是否是实时变化的？有多少人在乎这个数据在短时间内的不精确性？恐怕不会有人会盯着这个统计数字并追究当自己发了一个帖子然后回头刷新页面发现这个统计数字没有加1 吧？所以只要去掉了这个“实时更新”的附加条件，就可以非常容易的实现这个功能了。就像之前所提到的那样，通过创建一个统计表，然后通过一个定时任务每隔一定时间段去更新一次里面的统计值，这样既可以解决统计值查询的效率问题，又可以保证不影响新发贴的效率，一举两得。</p><h3 id="1-2-系统架构及实现的影响"><a href="#1-2-系统架构及实现的影响" class="headerlink" title="1.2 系统架构及实现的影响"></a>1.2 系统架构及实现的影响</h3><p>所有数据都是适合在数据库中存放的吗？数据库为我们提供了太多的功能，反而让很多并不是太了解数据库的人错误的使用了数据库的很多并不是太擅长或者对性能影响很大的功能，最后却全部怪罪到数据库身上。</p><p><strong>实际上，以下几类数据都是不适合在数据库中存放的：</strong></p><ul><li><p>二进制多媒体数据</p><p>这种数据主要包括图片，音频、视频和其他一些相关的二进制文件。将二进制多媒体数据存放在数据库中，一个问题是数据库空间资源耗用非常严重，另一个问题是这些数据的存储很消耗数据库主机的CPU 资源。这些数据的处理本不是数据库的优势，如果我们硬要将他们塞入数据库，肯定会造成数据库的处理资源消耗严重。</p></li><li><p>超大文本数据</p><p>对于5.0.3 之前的MySQL 版本，VARCHAR 类型的数据最长只能存放255 个字节，如果需要存储更长的文本数据到一个字段，我们就必须使用TEXT 类型（最大可存放64KB）的字段，甚至是更大的LONGTEXT 类型（最大4GB）。而TEXT类型数据的处理性能要远比VARCHAR 类型数据的处理性能低下很多。从5.0.3 版本开始，VARCHAR 类型的最大长度被调整到64KB 了，所以，超大文本数据存放在数据库中不仅会带来性能低下的问题，还会带来空间占用的浪费问题。<br>是否合理的利用了应用层Cache 机制？<br>对于Web 应用，活跃数据的数据量总是不会特别的大，有些活跃数据更是很少变化。对于这类数据，我们是否有必要每次需要的时候都到数据库中去查询呢？如果我们能够将变化相对较少的部分活跃数据通过应用层的Cache 机制Cache 到内存中，对性能的提升肯定是成数量级的，而且由于是活跃数据，对系统整体的性能影响也会很大。</p></li></ul><h3 id="1-3-查询语句对性能的影响"><a href="#1-3-查询语句对性能的影响" class="headerlink" title="1.3 查询语句对性能的影响"></a>1.3 查询语句对性能的影响</h3><p>SQL语句的优劣是对性能有影响的，每个SQL 语句在优化之前和优化之后的性能差异也是各不相同。</p><p>在数据库管理软件中，最大的性能瓶颈就是在于磁盘IO，也就是数据的存取操作上面。而对于同一份数据，当我们以不同方式去寻找其中的某一点内容的时候，所需要读取的数据量可能会有天壤之别，所消耗的资源也自然是区别很大。</p><p>功能完全相同的两条SQL 的在性能方面的差异。</p><p><strong>我们在执行sql语句时可以用explain来查看执行计划：</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="keyword">explain</span> </span><br><span class="line">    -&gt; <span class="keyword">select</span> stuid,stuname,cardid <span class="keyword">from</span> tb1 <span class="keyword">where</span> stuid <span class="keyword">between</span> <span class="number">3000</span> <span class="keyword">and</span> <span class="number">5000</span></span><br><span class="line">    -&gt; <span class="keyword">order</span> <span class="keyword">by</span> stuid <span class="keyword">desc</span></span><br><span class="line">    -&gt; <span class="keyword">limit</span> <span class="number">20</span> \G</span><br><span class="line">*************************** <span class="number">1.</span> <span class="keyword">row</span> ***************************</span><br><span class="line">           id: <span class="number">1</span></span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        <span class="keyword">table</span>: tb1</span><br><span class="line">   partitions: <span class="keyword">NULL</span></span><br><span class="line">         <span class="keyword">type</span>: range</span><br><span class="line">possible_keys: <span class="keyword">PRIMARY</span></span><br><span class="line">          key: <span class="keyword">PRIMARY</span></span><br><span class="line">      key_len: <span class="number">4</span></span><br><span class="line">          <span class="keyword">ref</span>: <span class="keyword">NULL</span></span><br><span class="line">         <span class="keyword">rows</span>: <span class="number">3678</span></span><br><span class="line">     filtered: <span class="number">100.00</span></span><br><span class="line">        Extra: <span class="keyword">Using</span> <span class="keyword">where</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> <span class="built_in">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p><strong>还可以打开mysql的profiling 功能，来查看sql的实际执行计划</strong></p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set profiling=1;</span><br><span class="line">mysql&gt; <span class="keyword">select</span> stuid,stuname,cardid <span class="keyword">from</span> tb1 <span class="keyword">where</span> stuid <span class="keyword">between</span> <span class="number">3000</span> <span class="keyword">and</span> <span class="number">5000</span> <span class="keyword">order</span> <span class="keyword">by</span> stuid <span class="keyword">desc</span> <span class="keyword">limit</span> <span class="number">5</span>\G</span><br><span class="line">mysql&gt; <span class="keyword">show</span>  profile;</span><br></pre></td></tr></table></figure><p>通过执行“SHOW PROFILE” 命令获取当前系统中保存的多个Query 的profile 的概要信息。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show<span class="built_in"> profile </span>CPU,BLOCK IO <span class="keyword">for</span> query 1;</span><br></pre></td></tr></table></figure><h3 id="1-4-数据库Schema设计对性能的影响"><a href="#1-4-数据库Schema设计对性能的影响" class="headerlink" title="1.4 数据库Schema设计对性能的影响"></a>1.4 数据库Schema设计对性能的影响</h3><h3 id="1-5-硬件选择对性能的影响"><a href="#1-5-硬件选择对性能的影响" class="headerlink" title="1.5 硬件选择对性能的影响"></a>1.5 硬件选择对性能的影响</h3><p>首先，数据库主机是存取数据的地方，所以数据库主机的IO 性能肯定是需要最优先考虑的一个因素，这一点不管是什么类型的数据库应用都是适用的。在主机中决定IO 性能部件主要由磁盘和内存所决定，当然也包括各种与IO 相关的板卡。</p><p>其次，由于数据库主机和普通的应用程序服务器相比，资源要相对集中很多，单台主机上所需要进行的计算量自然也就比较多，所以数据库主机的CPU处理能力也不能忽视。<br>最后，由于数据库负责数据的存储，与各应用程序的交互中传递的数据量比其他各类服务器都要多，所以数据库主机的网络设备的性能也可能会成为系统的瓶颈。</p><p>所以，数据库应用系统的优化，实际上是一个需要多方面配合，多方面优化的才能产生根本性改善的事情。简单来说，可以通过下面三句话来简单的概括数据库应用系统的性能优化：商业需求合理化，系统架构最优化，逻辑实现精简化，硬件设施理性化。</p><h2 id="2、MySQL性能优化之-索引"><a href="#2、MySQL性能优化之-索引" class="headerlink" title="2、MySQL性能优化之-索引"></a>2、MySQL性能优化之-索引</h2><p>关于MySQL索引的好处，如果正确合理设计并且使用索引的MySQL是一辆兰博基尼的话，那么没有设计和使用索引的MySQL就是一个人力三轮车。对于没有索引的表，单表查询可能几十万数据就是瓶颈，而通常大型网站单日就可能会产生几十万甚至几百万的数据，没有索引查询会变的非常缓慢。</p><h3 id="2-1-做一个简单测试"><a href="#2-1-做一个简单测试" class="headerlink" title="2.1 做一个简单测试"></a>2.1 做一个简单测试</h3><p>假如我们创建了一个tb1表，向表中插入20000行数据，表的创建和数据插入用如下脚本实现</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cat mysql3.sh </span></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">HOSTNAME=<span class="string">"localhost"</span></span><br><span class="line">PORT=<span class="string">"3306"</span></span><br><span class="line">USERNAME=<span class="string">"root"</span></span><br><span class="line">PASSWORD=<span class="string">"123.abc"</span></span><br><span class="line"></span><br><span class="line">DBNAME=<span class="string">"test1"</span></span><br><span class="line">TABLENAME=<span class="string">"tb1"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#create database</span></span><br><span class="line">mysql -h <span class="variable">$&#123;HOSTNAME&#125;</span> -P <span class="variable">$&#123;PORT&#125;</span> -u <span class="variable">$&#123;USERNAME&#125;</span> -p<span class="variable">$&#123;PASSWORD&#125;</span> -e <span class="string">"drop database if exists <span class="variable">$&#123;DBNAME&#125;</span>"</span></span><br><span class="line">create_db_sql=<span class="string">"create database if not exists <span class="variable">$&#123;DBNAME&#125;</span>"</span></span><br><span class="line">mysql -h <span class="variable">$&#123;HOSTNAME&#125;</span> -P <span class="variable">$&#123;PORT&#125;</span> -u <span class="variable">$&#123;USERNAME&#125;</span> -p<span class="variable">$&#123;PASSWORD&#125;</span> -e <span class="string">"<span class="variable">$&#123;create_db_sql&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#create table</span></span><br><span class="line">create_table_sql=<span class="string">"create table if not exists <span class="variable">$&#123;TABLENAME&#125;</span>(stuid int not null primary key,stuname varchar(20) not null,stusex char(1) not null,cardid varchar(20) not null,birthday datetime,entertime datetime,address varchar(100) default null)"</span></span><br><span class="line">mysql -h <span class="variable">$&#123;HOSTNAME&#125;</span> -P <span class="variable">$&#123;PORT&#125;</span> -u <span class="variable">$&#123;USERNAME&#125;</span> -p<span class="variable">$&#123;PASSWORD&#125;</span> <span class="variable">$&#123;DBNAME&#125;</span> -e <span class="string">"<span class="variable">$&#123;create_table_sql&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#insert data to table</span></span><br><span class="line">i=1</span><br><span class="line"><span class="keyword">while</span> [ <span class="variable">$i</span> -le 20000 ]</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">insert_sql=<span class="string">"insert into <span class="variable">$&#123;TABLENAME&#125;</span> values (<span class="variable">$i</span>,'zhangsan','1','1234567890123456','1999-10-10','2016-9-3','zhongguo beijingshi changpinqu')"</span></span><br><span class="line">mysql -h <span class="variable">$&#123;HOSTNAME&#125;</span> -P <span class="variable">$&#123;PORT&#125;</span> -u <span class="variable">$&#123;USERNAME&#125;</span> -p<span class="variable">$&#123;PASSWORD&#125;</span> <span class="variable">$&#123;DBNAME&#125;</span> -e <span class="string">"<span class="variable">$&#123;insert_sql&#125;</span>"</span></span><br><span class="line"><span class="built_in">let</span> i++</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment">#select data</span></span><br><span class="line">select_sql=<span class="string">"select count(*) from <span class="variable">$&#123;TABLENAME&#125;</span>"</span></span><br><span class="line">mysql -h <span class="variable">$&#123;HOSTNAME&#125;</span> -P <span class="variable">$&#123;PORT&#125;</span> -u <span class="variable">$&#123;USERNAME&#125;</span> -p<span class="variable">$&#123;PASSWORD&#125;</span> <span class="variable">$&#123;DBNAME&#125;</span> -e <span class="string">"<span class="variable">$&#123;select_sql&#125;</span>"</span></span><br></pre></td></tr></table></figure><p><strong>再手动插入一行数据，如</strong></p><p>下面开始测试，查询stuname=’admin’的记录</p><p><strong>情况1：</strong>stuname列上没有创建索引的情况</p><blockquote><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="keyword">explain</span> <span class="keyword">select</span> stuid,stuname,stusex,cardid,entertime <span class="keyword">from</span> tb1 <span class="keyword">where</span> stuname=<span class="string">'admin'</span>\G;</span><br></pre></td></tr></table></figure><p><strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong> 1. row <strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong><br>id: 1<br>select_type: SIMPLE<br>table: tb1<br>partitions: NULL<br>type: ALL<br>possible_keys: NULL<br>key: NULL<br>key_len: NULL<br>ref: NULL<br><font color="red">rows: 18910</font><br>filtered: 10.00<br>Extra: Using where<br><font color="red">1 row in set, 1 warning (0.01 sec)</font></p></blockquote><p><strong>情况2：</strong>stuname列上创建索引的情况再查询</p><blockquote><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="keyword">create</span> <span class="keyword">index</span> index_stuname <span class="keyword">on</span> tb1(stuname);</span><br><span class="line">mysql&gt; <span class="keyword">explain</span> <span class="keyword">select</span> stuid,stuname,stusex,cardid,entertime <span class="keyword">from</span> tb1 <span class="keyword">where</span> stuname=<span class="string">'admin'</span>\G;</span><br></pre></td></tr></table></figure><p><strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong> 1. row <strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong><br>id: 1<br>select_type: SIMPLE<br>table: tb1<br>partitions: NULL<br>type: ref<br>possible_keys: index_stuname<br>key: index_stuname<br>key_len: 62<br>ref: const<br><font color="red">rows: 1</font><br>filtered: 100.00<br>Extra: NULL<br><font color="red">1 row in set, 1 warning (0.00 sec)</font></p></blockquote><p>在查找stuname=”admin”的记录时，如果在stuname上已经建立了索引，MySQL无须任何扫描全表，即准确可找到该记录。相反，MySQL会扫描所有记录。<br>所以在数据库表中，对字段建立索引可以大大提高查询速度。<br>索引是在存储引擎中实现的，而不是在服务器层中实现的。所以，每种存储引擎的索引都不一定完全相同，并不是所有的存储引擎都支持所有的索引类型。</p><h3 id="2-2-索引概述"><a href="#2-2-索引概述" class="headerlink" title="2.2 索引概述"></a>2.2 索引概述</h3><h4 id="2-2-1-什么是索引？"><a href="#2-2-1-什么是索引？" class="headerlink" title="2.2.1 什么是索引？"></a>2.2.1 <strong>什么是索引？</strong></h4><p>索引（Index）是帮助MySQL高效获取数据的数据结构，这是一种比较官方的说法。它的存在形式是文件。索引能够帮助我们快速定位数据。 更通俗的说，数据库索引好比是一本书前面的目录，能加快数据库的查询速度。<br>索引的数据结构<br>这里主介绍B-tree索引的结构</p><p><img src="/2017/11/23/mysql-xing-neng-you-hua-zhi-ying-xiang-xing-neng-de-yin-su/%E5%9B%BE%E7%89%871.png" alt="image-20191116150701420"></p><p>如上图，是一颗b+树，这里只说一些重点，浅蓝色的块我们称之为一个磁盘块，可以看到每个磁盘块包含几个数据项（深蓝色所示）和指针（黄色所示），如磁盘块1包含数据项17和35，包含指针P1、P2、P3，P1表示小于17的磁盘块，P2表示在17和35之间的磁盘块，P3表示大于35的磁盘块。真实的数据存在于叶子节点即3、5、9、10、13、15、28、29、36、60、75、79、90、99。非叶子节点只不存储真实的数据，只存储指引搜索方向的数据项和指针，如17、35并不真实存在于数据表中。<br>b+树的查找过程<br><strong>如图所示</strong>，如果要查找数据项29，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO，在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短（相比磁盘的IO）可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第二次IO，29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计三次IO。真实的情况是，3层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。</p><p><strong>为什么使用索引？</strong><br>索引可以让mysql高效运行，可以大大提高mysql的查询（包括排序，分组）效率；数据约束（唯一索引的建立）。</p><p><strong>索引给我带来什么好处？</strong><br>提高查询效率，快速定位数据</p><p><strong>使用索引产生的代价？</strong></p><ol><li>索引本身是以文件的形式存放在硬盘，需要的时候才加载至内存，所以添加索引会增加磁盘的开销；</li><li>写数据：需要更新索引，对数据库是个很大的开销，降低表更新、添加和删除的速度</li></ol><p><strong>不建议使用索引的情况：</strong></p><ol><li>表记录较少</li><li>索引的选择性较低，所谓索引的选择性，是指不重复的索引值与表记录数的比值，取值范围（0-1）。选择性越高，索引的价值越大。</li></ol><h4 id="2-2-2-索引的类型？"><a href="#2-2-2-索引的类型？" class="headerlink" title="2.2.2 索引的类型？"></a>2.2.2 <strong>索引的类型？</strong></h4><p>索引包括<strong>单列索引</strong>和<strong>组合索引</strong><br><strong>单列索引</strong>，即一个索引只包含单个列，一个表可以有多个单列索引，但这不是组合索引。组合索引，即一个索包含多个列。</p><ol><li><strong>普通索引</strong><br>这是最基本的索引，它没有任何限制</li></ol><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> indexName <span class="keyword">ON</span> tablename(column1[,column2,……])</span><br></pre></td></tr></table></figure><ol start="2"><li><p><strong>唯一索引</strong><br>它与前面的普通索引类似，不同的就是索引列的值必须唯一，但允许空值，空值是指null。如果是组合索引，组合列的值必须唯一</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> <span class="keyword">INDEX</span> indexName <span class="keyword">ON</span> tablename(column1[,column2,……])</span><br></pre></td></tr></table></figure><p><strong>主键索引：</strong>一种特殊的唯一索引，不允许有空值，一般在建表的时候同时建立主键索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tablename(<span class="keyword">ID</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,  username <span class="built_in">VARCHAR</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  PRIMARY <span class="keyword">KEY</span>(<span class="keyword">ID</span>) );</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p><strong>组合索引</strong><br>为了进一步提升MySQL的效率，就要考虑建立组合索引<br>例如：创建一个表，包含如下字段</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> mytable(<span class="keyword">ID</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>, username <span class="built_in">VARCHAR</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>, city <span class="built_in">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>, age <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>  );</span><br></pre></td></tr></table></figure><p>将 username, city, age建到一个索引里</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> username_city_age <span class="keyword">ON</span> mytable(username,city,age);</span><br></pre></td></tr></table></figure><p>如果分别在 usernname，city，age上建立单列索引，让该表有3个单列索引，查询时和上述的组合索引效率也会大不一样，远远低于组合索引。虽然此时有了三个索引，但MySQL只能用到其中那个它认为似乎是最有效率的单列索引。<br>建立这样的组合索引，其实是相当于分别建立了下面三组组合索引：<br>usernname,city,age usernname,city usernname 为什么没有 city，age这样的组合索引呢？这是因为MySQL组合索引“最左前缀”的结果。简单的理解就是只从最左面的开始组合。并不是只要包含这三列的查询都会用到该组合索引，下面的几个SQL就会用到这个组合索引：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * <span class="keyword">FROM</span> mytable WHREE <span class="attribute">username</span>=<span class="string">"admin"</span> <span class="keyword">AND</span> <span class="attribute">city</span>=<span class="string">"郑州"</span>  </span><br><span class="line">SELECT * <span class="keyword">FROM</span> mytable WHREE <span class="attribute">username</span>=<span class="string">"admin"</span></span><br></pre></td></tr></table></figure><p>而下面几个则不会用到：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * <span class="keyword">FROM</span> mytable WHREE <span class="attribute">age</span>=20 <span class="keyword">AND</span> <span class="attribute">city</span>=<span class="string">"郑州"</span>  </span><br><span class="line">SELECT * <span class="keyword">FROM</span> mytable WHREE <span class="attribute">city</span>=<span class="string">"郑州"</span></span><br></pre></td></tr></table></figure></li></ol><p>如果对多列进行索引(组合索引)，列的顺序非常重要，MySQL仅能对索引最左边的前缀进行有效的查找。<br>例如：<br>假设存在组合索引index1(c1,c2)，查询语句select * from t1 where c1=1 and c2=2能够使用该索引。查询语句select * from t1 where c1=1也能够使用该索引。但是，查询语句select * from t1 where c2=2不能够使用该索引，因为没有组合索引的引导列，即要想使用c2列进行查找，必需出现c1等于某值。因此我们在创建组合索引时应该将最常用作限制条件的列放在最左边，依次递减。</p><ol start="4"><li><p><strong>全文索引</strong><br>只用于MyISAM 表 对文本域进行索引。字段类型包括char、varchar、text<br>不过切记对于大容量的数据表，生成全文索引是一个非常消耗时间非常消耗硬盘空间的做法。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> FULLTEXT <span class="keyword">INDEX</span> indexname <span class="keyword">ON</span> tablename(<span class="keyword">column</span>)</span><br></pre></td></tr></table></figure></li></ol><p><strong>查看索引</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="keyword">show</span> <span class="keyword">index</span> <span class="keyword">from</span> tablename;</span><br><span class="line">mysql&gt; <span class="keyword">show</span> keys <span class="keyword">from</span> tablename;</span><br></pre></td></tr></table></figure><h3 id="2-3-建立索引的时机"><a href="#2-3-建立索引的时机" class="headerlink" title="2.3 建立索引的时机"></a>2.3 建立索引的时机</h3><p>到这里我们已经学会了建立索引，那么我们需要在什么情况下建立索引呢？<br>一般来说，在WHERE和JOIN子句中出现的列需要建立索引，</p><p>例如：<br>代码如下:<strong>在username上创建索引</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * <span class="keyword">FROM</span> mytable WHREE <span class="attribute">username</span>=<span class="string">"admin"</span> <span class="keyword">AND</span> <span class="attribute">city</span>=<span class="string">"郑州"</span></span><br></pre></td></tr></table></figure><p>代码如下:</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> t.Name  <span class="keyword">FROM</span> mytable1 t <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> mytable2 m   <span class="keyword">ON</span> t.username=m.username;</span><br></pre></td></tr></table></figure><p>此时就需要对两个表的userame上建立索引。<br>使用索引的注意事项<br>刚才提到只有某些时候的LIKE才需建立索引。因为在以通配符%和_开头作查询时，MySQL不会使用索引。</p><p><strong>例如下句会使用索引：</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> mytable <span class="keyword">WHERE</span> username lik<span class="string">e'admin%'</span></span><br></pre></td></tr></table></figure><p><strong>而下句就不会使用：</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> mytable <span class="keyword">WHERE</span> <span class="type">Name</span> lik<span class="string">e'%admin'</span></span><br></pre></td></tr></table></figure><p><strong>不要在列上进行运算,例如</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * <span class="keyword">from</span><span class="built_in"> users </span>where YEAR(adddate)&lt;2007;</span><br></pre></td></tr></table></figure><p>这将导致索引失效而进行全表扫描，因此我们可以改成</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">where</span> adddate&lt;<span class="string">'2007-01-01'</span>;</span><br></pre></td></tr></table></figure><h3 id="2-4-总结"><a href="#2-4-总结" class="headerlink" title="2.4 总结"></a>2.4 总结</h3><p><strong>选择索引列：</strong></p><ol><li>性能优化过程中，选择在哪个列上创建索引是最重要的步骤之一。可以考虑使用索引 的主要有 两种类型的列：在where子句中出现的列，在join子句中出现的列。</li><li>考虑列中值的分布，索引的列的基数越大，索引的效果越好。</li><li>使用短索引，如果对字符串列进行索引，应该指定一个前缀长度，可节省大量索引空间，提升查询速度。<br>例如：CREATE INDEX username_city_age ON mytable(username（10）,city,age);<br>建表时，usernname长度为 16，这里用 10。这是因为一般情况下名字的长度不会超过10，这样会加速索引查询速度，还会减少索引文件的大小，提高INSERT的更新速度。</li><li>利用最左前缀</li><li>不要过度索引，只保持所需的索引。每个额外的索引都要占用额外的磁盘空间，并降低写操作的性能。 在修改表的内容时，索引必须进行更新，有时可能需要重构，因此，索引越多，所花的时间越长。</li></ol><p>MySQL只对一下操作符才使用索引：<strong>&lt;,&lt;=,=,&gt;,&gt;=,between,in,</strong><br>以及某些时候的<strong>like</strong>(不以通配符%或_开头的情形)。<br>以上就是有关Mysql索引的相关理论介绍，下面我们来学习如何慢查询分析、优化索引和配置</p><h2 id="3、mysql性能优化-慢查询分析、优化索引和配置"><a href="#3、mysql性能优化-慢查询分析、优化索引和配置" class="headerlink" title="3、mysql性能优化-慢查询分析、优化索引和配置"></a>3、mysql性能优化-慢查询分析、优化索引和配置</h2><h3 id="3-1-基本思路"><a href="#3-1-基本思路" class="headerlink" title="3.1 基本思路"></a><strong>3.1 基本思路</strong></h3><ol><li>性能瓶颈定位<br>Show命令<br>慢查询日志<br>explain分析查询<br>profiling分析查询</li><li>索引及查询优化</li><li>配置优化</li></ol><p>MySQL数据库是常见的两个瓶颈是CPU和I/O的瓶颈，CPU在饱和的时候一般发生在数据装入内存或从磁盘上读取数据时候。磁盘I/O瓶颈发生在装入数据远大于内存容量的时候，如果应用分布在网络上，那么查询量相当大的时候那么平瓶颈就会出现在网络上，我们可以用mpstat, iostat, sar和vmstat来查看系统的性能状态。<br>除了服务器硬件的性能瓶颈，对于MySQL系统本身，我们可以使用工具来优化数据库的性能，通常有三种：<strong>使用索引</strong>，<strong>使用EXPLAIN</strong>分析查询以及<strong>调整MySQL</strong>的内部配置。</p><h3 id="3-2-查询与索引优化分析"><a href="#3-2-查询与索引优化分析" class="headerlink" title="3.2 查询与索引优化分析"></a>3.2 查询与索引优化分析</h3><p>在优化MySQL时，通常需要对数据库进行分析，常见的分析手段有慢查询日志，EXPLAIN 分析查询，profiling分析以及show命令查询系统状态及系统变量，通过定位分析性能的瓶颈，才能更好的优化数据库系统的性能。<br>性能瓶颈定位<br>show命令<br>可以通过show命令查看MySQL状态及变量，找到系统的瓶颈：<br>查看MySQL服务器配置信息</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show <span class="keyword">variables</span>;</span><br></pre></td></tr></table></figure><p>查看MySQL服务器运行的各种状态值</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="built_in">show</span> global <span class="built_in">status</span>;</span><br></pre></td></tr></table></figure><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># mysqladmin <span class="keyword">variables</span> -u <span class="comment">username -ppassword</span>    //显示系统变量</span><br><span class="line"># mysqladmin <span class="comment">extended-status -u username -ppassword</span>   //显示状态信息</span><br></pre></td></tr></table></figure><p>比较全的show命令的使用可参考：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> <span class="built_in">help</span> show</span></span><br></pre></td></tr></table></figure><p>或 <a href="http://dev.mysql.com/doc/refman/5.7/en/show.html" target="_blank" rel="noopener">http://dev.mysql.com/doc/refman/5.7/en/show.html</a></p><h4 id="3-2-1-慢查询日志"><a href="#3-2-1-慢查询日志" class="headerlink" title="3.2.1 慢查询日志"></a>3.2.1 慢查询日志</h4><p><strong>慢查询日志开启：</strong><br>在配置文件my.cnf中在[mysqld]一行下面加入3个配置参数，并重启mysql服务</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">slow_query_log</span> = <span class="number">1</span>    //<span class="number">0</span>关闭  <span class="number">1</span>开启</span><br><span class="line"><span class="attr">slow_query_log_file</span> = /usr/local/mysql/data/slow-query.log    //慢查询日志存放地点</span><br><span class="line"><span class="attr">long_query_time</span> = <span class="number">1</span>                               //表示查询超过<span class="number">1</span>秒才记录</span><br></pre></td></tr></table></figure><p>在<code>my.cnf</code>中添加<code>log-queries-not-using-indexes</code>参数，表示向慢查询日志中记录没有使用索引的查询。</p><p><strong>慢查询日志开启方法二：</strong><br>我们也可以通过命令行设置变量来即时启动慢日志查询</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="keyword">set</span> global <span class="comment">slow_query_log = on</span>;</span><br><span class="line">mysql&gt; <span class="keyword">set</span> long_query_time <span class="comment">= 0.01</span>;</span><br><span class="line">mysql&gt; <span class="keyword">set</span> global <span class="comment">slow_query_log_file =</span> <span class="comment">"/usr/local/mysql/data/slow-query.log"</span>;</span><br><span class="line"></span><br><span class="line">查看慢查询的设置信息</span><br><span class="line">mysql&gt; show <span class="keyword">variables</span> like <span class="comment">'%slow_query_log%'</span>;</span><br><span class="line">mysql&gt; show <span class="keyword">variables</span> like <span class="comment">'%long_query_time%'</span>;</span><br></pre></td></tr></table></figure><p>我们可以通过打开log文件查看得知哪些SQL执行效率低下</p><blockquote><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost data]# <span class="keyword">cat</span> slow-<span class="keyword">query</span>.<span class="keyword">log</span> </span><br></pre></td></tr></table></figure><p>Time: 2016-09-06T14:17:12.582189Z<br>User@Host: root[root] @ localhost [] Id: 3<br>Query_time: <font color="red">0.008316</font> Lock_time: 0.000304 Rows_sent: 1 Rows_examined: 20002<br>SET timestamp=1473171432;<br>select * from test1.tb1 where stusex=’0’; <font color="red">//没有使用索引的query</font><br>Time: 2016-09-06T15:54:42.648291Z<br>User@Host: root[root] @ localhost [] Id: 14<br>Query_time: <font color="red">0.017319</font> Lock_time: 0.000612 Rows_sent: 1 Rows_examined: 20001<br>SET timestamp=1473177282;<br>select * from test1.tb1 where entertime &lt;&gt; ‘2016-9-3’; <font color="red">//慢查询query</font></p></blockquote><p>从日志中，可以发现查询时间超过0.01 秒的SQL，而小于0.01秒的没有出现在此日志中。</p><p>如果慢查询日志中记录内容很多，可以使用mysqldumpslow工具（MySQL客户端安装自带）来对慢查询日志进行分类汇总。mysqldumpslow对日志文件进行了分类汇总，显示汇总后摘要结果。</p><p>有关<code>mysqldumpslow</code>命令的用法可以参考其帮助：<code>mysqldumpslow --help</code></p><blockquote><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost data]<span class="comment"># mysqldumpslow -a -s at -r slow-query.log </span></span><br></pre></td></tr></table></figure><p>Reading mysql slow query log from slow-query.log<br>Count: 1 Time=0.00s (0s) Lock=0.00s (0s) Rows=0.0 (0), 0users@0hosts<br>Time: 2016-09-06T15:54:42.648291Z<br>#User@Host: root[root] @ localhost [] Id: 14<br>#Query_time: <font color="red">0.017319</font> Lock_time: 0.000612 Rows_sent: 1 Rows_examined: 20001<br>SET timestamp=1473177282;<br>select * from test1.tb1 where entertime &lt;&gt; ‘2016-9-3’</p></blockquote><p><strong>上面显示结果中就是一条慢查询，如何优化呢？</strong></p><p>一是在entertime列上创建索引优化查询</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="keyword">create</span> <span class="keyword">index</span> index_entertime <span class="keyword">on</span> test1.tb1(entertime);</span><br></pre></td></tr></table></figure><p>二是优化这个sql查询语句</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from test1.tb1 where entertime &lt; '<span class="number">2016</span><span class="number">-9</span><span class="number">-3</span>' or entertime &gt; '<span class="number">2016</span><span class="number">-9</span><span class="number">-3</span>';</span><br></pre></td></tr></table></figure><p>从下图可以看查询0.00秒</p><p><img src="/2017/11/23/mysql-xing-neng-you-hua-zhi-ying-xiang-xing-neng-de-yin-su/%E5%9B%BE%E7%89%872.png" alt="image-20191116152914565"></p><p>使用mysqldumpslow命令可以非常明确的得到各种我们需要的查询语句，对MySQL查询语句的监控、分析、优化是MySQL优化非常重要的一步。开启慢查询日志后，由于日志记录操作，在一定程度上会占用CPU资源影响mysql的性能，但是可以阶段性开启来定位性能瓶颈。</p><h4 id="3-2-2-explain分析查询"><a href="#3-2-2-explain分析查询" class="headerlink" title="3.2.2 explain分析查询"></a>3.2.2 explain分析查询</h4><p>使用 EXPLAIN 关键字可以模拟优化器执行SQL查询语句，从而知道MySQL是如何处理你的SQL语句的。这可以帮你分析你的查询语句或是表结构的性能瓶颈。通过explain命令可以得到:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> test1.tb1 <span class="keyword">where</span> stuname=<span class="string">'admin'</span>\G;</span><br><span class="line">*************************** <span class="number">1.</span> <span class="keyword">row</span> ***************************</span><br><span class="line">           id: <span class="number">1</span></span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        <span class="keyword">table</span>: tb1</span><br><span class="line">   partitions: <span class="keyword">NULL</span></span><br><span class="line">         <span class="keyword">type</span>: <span class="keyword">ALL</span>      //全表扫描</span><br><span class="line">possible_keys: <span class="keyword">NULL</span></span><br><span class="line">          key: <span class="keyword">NULL</span></span><br><span class="line">      key_len: <span class="keyword">NULL</span></span><br><span class="line">          <span class="keyword">ref</span>: <span class="keyword">NULL</span></span><br><span class="line">         <span class="keyword">rows</span>: <span class="number">19986</span></span><br><span class="line">     filtered: <span class="number">10.00</span></span><br><span class="line">        Extra: <span class="keyword">Using</span> <span class="keyword">where</span>    //使用<span class="keyword">where</span>过滤数据</span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> <span class="built_in">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>EXPLAIN字段含义：</p><table><thead><tr><th>字段</th><th>描述</th></tr></thead><tbody><tr><td>Table</td><td>显示这一行的数据是关于哪张表的</td></tr><tr><td>type</td><td>这是最重要的字段之一，显示查询使用了何种类型。从最好到最差的连接类型为system、const、eq_reg、ref、range、index和ALL</td></tr><tr><td>possible_keys</td><td>显示可能应用在这张表中的索引。如果为空，没有可能的索引</td></tr><tr><td>key</td><td>实际使用的索引。如果为NULL，则没有使用索引</td></tr><tr><td>key_len</td><td>使用的索引的长度。在不损失精确性的情况下，长度越短越好</td></tr><tr><td>ref</td><td>显示索引的哪一列被使用了，如果可能的话，是一个常数</td></tr><tr><td>rows</td><td>MySQL认为必须检索的用来返回请求数据的行数</td></tr><tr><td>Extra</td><td>关于MYSQL如何解析查询的额外信息</td></tr></tbody></table><p>从上面的explain模拟优化器执行sql语句来看是没有使用索引查询的，而是全表扫描</p><p><strong>优化方法：在stuname列上创建索引</strong></p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="keyword">create</span> <span class="keyword">index</span> index_stuname <span class="keyword">on</span> test1.tb1(stuname);</span><br></pre></td></tr></table></figure><p>再次执行explain</p><blockquote><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> test1.tb1 <span class="keyword">where</span> stuname=<span class="string">'admin'</span>\G;</span><br></pre></td></tr></table></figure><p><strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong> 1. row <strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong><br>id: 1<br>select_type: SIMPLE<br>table: tb1<br>partitions: NULL<br>type: ref<br><font color="red">possible_keys: index_stuname</font><br><font color="red">key: index_stuname</font><br>key_len: 62<br>ref: const<br><font color="red">rows: 1</font><br>filtered: 100.00<br>Extra: NULL<br>1 row in set, 1 warning (0.00 sec)</p></blockquote><p>显示结果说明该查询语句使用了index_stuname索引查询数据而非全表扫描。</p><h4 id="3-2-3-profiling分析查询"><a href="#3-2-3-profiling分析查询" class="headerlink" title="3.2.3 profiling分析查询"></a>3.2.3 profiling分析查询</h4><p>通过慢日志查询可以知道哪些SQL语句执行效率低下，通过explain我们可以得知SQL语句的具体执行情况，索引使用等，还可以结合show命令查看执行状态。如果觉得explain的信息不够详细，可以同通过profiling命令得到更准确的SQL执行消耗系统资源的信息。</p><p>profiling默认是关闭的。可以通过以下语句查看</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show <span class="keyword">variables</span> like <span class="comment">'%profiling%'</span>;    <span class="comment">//off表示未开启</span></span><br></pre></td></tr></table></figure><p><img src="/2017/11/23/mysql-xing-neng-you-hua-zhi-ying-xiang-xing-neng-de-yin-su/%E5%9B%BE%E7%89%873.png" alt="image-20191116153727442"></p><p>或</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="built_in">select</span> <span class="comment">@@</span>profiling;     <span class="comment">//0表示未开启</span></span><br></pre></td></tr></table></figure><p><img src="/2017/11/23/mysql-xing-neng-you-hua-zhi-ying-xiang-xing-neng-de-yin-su/%E5%9B%BE%E7%89%874.png" alt="image-20191116153812831"></p><p><strong>打开profiling功能：</strong></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set profiling=1;</span><br><span class="line">Query OK, 0 rows affected, 1 warning (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select @@profiling;</span><br><span class="line"><span class="code">+---------------------+</span></span><br><span class="line">| @@profiling  |</span><br><span class="line"><span class="code">+---------------------+</span></span><br><span class="line">|           1 |</span><br><span class="line"><span class="code">+----------------------+</span></span><br></pre></td></tr></table></figure><p><strong>执行要测试的sql语句</strong></p><blockquote><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="keyword">select</span> * <span class="keyword">from</span> test1.tb1 <span class="keyword">where</span> stuname=<span class="string">'admin'</span> <span class="keyword">and</span> entertime=<span class="string">'2016-9-1'</span>;</span><br><span class="line">mysql&gt; <span class="keyword">show</span> profiles\G;   //可以得到被执行的<span class="keyword">SQL</span>语句的时间和ID</span><br></pre></td></tr></table></figure><p><strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong> 1. row <strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong><br>Query_ID: 1<br>Duration: 0.00012650<br>Query: select @@profiling<br><strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong> 2. row <strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong><br><font color="red">Query_ID: 2</font><br><font color="red">Duration: 0.00121725</font><br>Query: select * from test1.tb1 where stuname=’admin’ and entertime=’2016-9-1’</p></blockquote><blockquote><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show profile <span class="keyword">for</span> query <span class="number">2</span>;  <span class="comment">//得到对应SQL语句执行的详细信息</span></span><br></pre></td></tr></table></figure><p>+———————-+————————-+<br>| Status | Duration |<br>+———————-+————————-+<br>| starting | 0.000230 |<br>| checking permissions | 0.000013 |<br>| Opening tables | 0.000030 |<br>| init | 0.000087 |<br>| <font color="red">System lock</font> | 0.000018 |<br>| optimizing | 0.000128 |<br>| statistics | 0.000378 |<br>| preparing | 0.000026 |<br>| executing | 0.000005 |<br>| <font color="red">Sending data</font> | 0.000187 |<br>| end | 0.000013 |<br>| query end | 0.000011 |<br>| closing tables | 0.000010 |<br>| freeing items | 0.000061 |<br>| cleaning up | 0.000021 |<br>+———————-+————————-+</p></blockquote><p><strong>status:</strong>是profile里的状态，<strong>duration：</strong>是status状态下的耗时。因此我们关注的就是那个状态最耗时，这些状态中那些可以优化。</p><p>当然也可以查看更多的信息如CPU等等</p><blockquote><p>SHOW PROFILE [type [, type] … ] [FOR QUERY n]<br>type:<br>ALL：显示所有的开销信息<br>BLOCK IO：显示块IO相关开销<br>CPU：显示用户CPU时间、系统CPU时间<br>IPC：显示发送和接收相关开销信息<br>PAGE FAULTS：显示页面错误相关开销信息<br>SWAPS：显示交换次数相关开销的信息</p></blockquote><p><strong>测试完成之以后，记得要关闭调试功能，以免影响数据库的正常使用：</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="builtin-name">set</span> <span class="attribute">profiling</span>=0;</span><br></pre></td></tr></table></figure><h3 id="3-3-配置优化"><a href="#3-3-配置优化" class="headerlink" title="3.3 配置优化"></a>3.3 配置优化</h3><p>Mysql参数优化对于不同的网站，及其在线量，访问量，帖子数量，网络情况，以及机器硬件配置都有关系，优化不可能一次性完成，需要不断的观察以及调试，才有可能得到最佳效果。<br>下面列出了对性能优化影响较大的主要变量，主要分为连接请求的变量和缓冲区变量</p><h4 id="3-3-1-连接请求的变量"><a href="#3-3-1-连接请求的变量" class="headerlink" title="3.3.1 连接请求的变量"></a>3.3.1 连接请求的变量</h4><h5 id="3-3-1-1-max-connections"><a href="#3-3-1-1-max-connections" class="headerlink" title="3.3.1.1 max_connections"></a>3.3.1.1 max_connections</h5><p>MySQL的最大连接数，如果服务器的并发连接请求量比较大，建议调高此值，以增加并行连接数量，当然这建立在机器能支撑的情况下，因为如果连接数越多， MySQL会为每个连接提供连接缓冲区，就会开销越多的内存，所以要适当调整该值，不能盲目提高设值。<br>数值过小会经常出现ERROR 1040: Too many connections错误，可以过mysql&gt; show status like ‘connections’;通配符查看当前状态的连接数量(试图连接到MySQL(不管是否连接成功)的连接数)，以定夺该值的大小。</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show <span class="keyword">variables</span> like <span class="comment">'max_connections'</span>;   <span class="comment">//最大连接数</span></span><br><span class="line">mysql&gt; show global status like <span class="string">'max_used_connections'</span>;   <span class="comment">//响应的连接数</span></span><br><span class="line">max_used_connections / max_connections * <span class="number">100</span>% （理想值≈ <span class="number">85</span>%）</span><br></pre></td></tr></table></figure><p>如果max_used_connections跟max_connections相同那么就是max_connections设置过低或者超过服务器负载上限了，低于10%则设置过大。</p><p><strong>如何设置max_connections?</strong></p><p>修改<code>/etc/my.cnf</code>文件，在<code>[mysqld]</code>下面添加如下内容，如设置最大连接数为1024</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">max_connections</span> = <span class="number">1024</span></span><br></pre></td></tr></table></figure><p>重启mysql服务</p><h5 id="3-3-1-2-back-log"><a href="#3-3-1-2-back-log" class="headerlink" title="3.3.1.2 back_log"></a>3.3.1.2 back_log</h5><p>MySQL能暂存的连接数量。当主要MySQL线程在一个很短时间内得到非常多的连接请求，它就会起作用。如果MySQL的连接数据达到max_connections时，新来的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈的数量即back_log，如果等待连接的数量超过back_log，将不被授予连接资源。<br>back_log值指出在MySQL暂时停止回答新请求之前的短时间内有多少个请求可以被存在堆栈中。只有如果期望在一个短时间内有很多连接，你需要增加它。<br>当观察你主机进程列表（mysql&gt; show full processlist;），发现大量<br>xxxxx | unauthenticated user | xxx.xxx.xxx.xxx | NULL | Connect | NULL | login | NULL 的待连接进程时，就要加大back_log 的值了或加大max_connections的值。<br>通过</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show <span class="keyword">variables</span> like <span class="comment">'back_log'</span>;</span><br></pre></td></tr></table></figure><p>查看back_log的设置<br><strong>如何设置back_log?</strong><br>修改<code>/etc/my.cnf</code>文件，在<code>[mysqld]</code>下面添加如下内容，如设置最大连接数为1024</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">back_log</span> = <span class="number">1024</span></span><br></pre></td></tr></table></figure><p>重启mysql服务</p><h5 id="3-3-1-3-wait-timeout-和-interactive-timeout"><a href="#3-3-1-3-wait-timeout-和-interactive-timeout" class="headerlink" title="3.3.1.3 wait_timeout 和 interactive_timeout"></a>3.3.1.3 wait_timeout 和 interactive_timeout</h5><p><strong>wait_timeout</strong> – 指的是MySQL在关闭一个非交互的连接之前所要等待的秒数<br><strong>interactive_time</strong> – 指的是mysql在关闭一个交互的连接之前所要等待的秒数，比如我们在终端上进入mysql管理，使用的即使交互的连接，这时候，如果没有操作的时间超过了interactive_time设置的时间就会自动断开。默认数值是28800，可调优为7200。</p><p><strong>对性能的影响：</strong><br>wait_timeout：</p><ol><li>如果设置大小，那么连接关闭的很快，从而使一些持久的连接不起作用</li><li>如果设置太大，容易造成连接打开时间过长，在<code>show processlist</code>时，能看到太多的sleep状态的连接，从而造成too many connections错误</li><li>一般希望wait_timeout尽可能地低</li></ol><p>interactive_timeout 的设置将要对你的web application没有多大的影响<br>查看wait_timeout和interactive_timeout</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show <span class="keyword">variables</span> like <span class="comment">'%wait_timeout%'</span>;</span><br><span class="line">mysql&gt; show <span class="keyword">variables</span> like <span class="comment">'%interactive_timeout%'</span>;</span><br></pre></td></tr></table></figure><p><strong>如何设置wait_timeout和interactive_timeout?</strong><br>修改<code>/etc/my.cnf</code>文件，在<code>[mysqld]</code>下面添加如下内容</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">wait_timeout</span>=<span class="number">7200</span></span><br><span class="line"><span class="attr">interactive_timeout</span>=<span class="number">7200</span></span><br></pre></td></tr></table></figure><p>重启MySQL Server进入后，查看设置已经生效。</p><h4 id="3-3-2-绶冲区变量"><a href="#3-3-2-绶冲区变量" class="headerlink" title="3.3.2 绶冲区变量"></a>3.3.2 绶冲区变量</h4><p><strong>全局缓冲：</strong></p><h5 id="3-3-2-1-key-buffer-size"><a href="#3-3-2-1-key-buffer-size" class="headerlink" title="3.3.2.1 key_buffer_size"></a>3.3.2.1 key_buffer_size</h5><p>key_buffer_size指定索引缓冲区的大小，它决定索引处理的速度，尤其是索引读的速度。通过检查状态值Key_read_requests和Key_reads，可以知道key_buffer_size设置是否合理。比例key_reads / key_read_requests应该尽可能的低，至少是1:100，1:1000更好（上述状态值可以使用<code>SHOW STATUS LIKE &#39;key_read%&#39;;</code>获得）。</p><p><img src="/2017/11/23/mysql-xing-neng-you-hua-zhi-ying-xiang-xing-neng-de-yin-su/%E5%9B%BE%E7%89%875.png" alt="img"></p><p>一共有6个索引读取请求，有3个请求在内存中没有找到直接从硬盘读取索引，计算索引</p><p><strong>未命中缓存的概率：</strong></p><blockquote><p>key_cache_miss_rate ＝ Key_reads / Key_read_requests * 100% =50%</p></blockquote><p><strong>key_buffer_size只对MyISAM表起作用</strong>。即使你不使用MyISAM表，但是内部的临时磁盘表是MyISAM表，也要使用该值。可以使用检查状态值created_tmp_disk_tables得知详情。</p><p><img src="/2017/11/23/mysql-xing-neng-you-hua-zhi-ying-xiang-xing-neng-de-yin-su/%E5%9B%BE%E7%89%876.png" alt="image-20191116155703606"></p><p><strong>如何调整key_buffer_size</strong><br>默认配置数值是8388608(8M)，主机有4GB内存，可以调优值为268435456(256MB)<br>修改<code>/etc/my.cnf</code>文件，在<code>[mysqld]</code>下面添加如下内容</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">key_buffer_size=268435456</span><br><span class="line">或 </span><br><span class="line">key_buffer_size=256M</span><br></pre></td></tr></table></figure><p>重启MySQL Server进入后，查看设置已经生效。</p><h5 id="3-3-2-2-query-cache-size-查询缓存简称QC"><a href="#3-3-2-2-query-cache-size-查询缓存简称QC" class="headerlink" title="3.3.2.2 query_cache_size(查询缓存简称QC)"></a>3.3.2.2 query_cache_size(查询缓存简称QC)</h5><p>使用查询缓冲，MySQL将查询结果存放在缓冲区中，今后对于同样的SELECT语句（区分大小写），将直接从缓冲区中读取结果。<br>一个SQL查询如果以select开头，那么MySQL服务器将尝试对其使用查询缓存。<br><strong>注：</strong>两个SQL语句，只要相差哪怕是一个字符（例如大小写不一样；多一个空格等），那么这两个SQL将使用不同的一个CACHE。</p><p>通过检查状态值<code>&#39;Qcache%&#39;</code>，可以知道query_cache_size设置是否合理（上述状态值可以使用<code>SHOW STATUS LIKE &#39;Qcache%&#39;;</code>获得）。</p><p><img src="/2017/11/23/mysql-xing-neng-you-hua-zhi-ying-xiang-xing-neng-de-yin-su/%E5%9B%BE%E7%89%877.png" alt="img"></p><p><strong>Qcache_free_blocks：</strong>缓存中相邻内存块的个数。如果该值显示较大，则说明Query Cache 中的内存碎片较多了，FLUSH QUERY CACHE会对缓存中的碎片进行整理，从而得到一个空闲块。</p><p><strong>注：</strong>当一个表被更新之后，和它相关的cache blocks将被free。但是这个block依然可能存在队列中，除非是在队列的尾部。可以用FLUSH QUERY CACHE语句来清空free blocks<br><strong>Qcache_free_memory：</strong>Query Cache 中目前剩余的内存大小。通过这个参数我们可以较为准确的观察出当前系统中的Query Cache 内存大小是否足够，是需要增加还是过多了。<br><strong>Qcache_hits：</strong>表示有多少次命中缓存。我们主要可以通过该值来验证我们的查询缓存的效果。数字越大，缓存效果越理想。<br><strong>Qcache_inserts：</strong>表示多少次未命中然后插入，意思是新来的SQL请求在缓存中未找到，不得不执行查询处理，执行查询处理后把结果insert到查询缓存中。这样的情况的次数越多，表示查询缓存应用到的比较少，效果也就不理想。当然系统刚启动后，查询缓存是空的，这很正常。<br><strong>Qcache_lowmem_prunes：</strong>多少条Query 因为内存不足而被清除出Query Cache。通过“Qcache_lowmem_prunes”和“Qcache_free_memory”相互结合，能够更清楚的了解到我们系统中Query Cache 的内存大小是否真的足够，是否非常频繁的出现因为内存不足而有Query 被换出。这个数字最好长时间来看；如果这个数字在不断增长，就表示可能碎片非常严重，或者内存很少。（上面的free_blocks和free_memory可以告诉您属于哪种情况）<br><strong>Qcache_not_cached：</strong>不适合进行缓存的查询的数量，通常是由于这些查询不是 SELECT 语句或者用了now()之类的函数。<br><strong>Qcache_queries_in_cache：</strong>当前Query Cache 中cache 的Query 数量；<br><strong>Qcache_total_blocks：</strong>当前Query Cache 中的block 数量；。</p><p>我们再查询一下服务器关于query_cache的配置：</p><p><img src="/2017/11/23/mysql-xing-neng-you-hua-zhi-ying-xiang-xing-neng-de-yin-su/%E5%9B%BE%E7%89%878.png" alt="img"></p><p>上图可以看出query_cache_type为off表示不缓存任何查询</p><p><strong>各字段的解释：</strong><br>query_cache_limit：超过此大小的查询将不缓存<br>query_cache_min_res_unit：缓存块的最小大小 ，query_cache_min_res_unit的配置是一柄<strong><code>双刃剑</code></strong>，默认是4KB，设置值大对大数据查询有好处，但如果你的查询都是小数据查询，就容易造成内存碎片和浪费。<br>query_cache_size：查询缓存大小 (注：QC存储的最小单位是1024 byte，所以如果你设定了一个不是1024的倍数的值，这个值会被四舍五入到最接近当前值的等于1024的倍数的值。)<br>query_cache_type：缓存类型，决定缓存什么样的查询，注意这个值不能随便设置，必须设置为数字，可选项目以及说明如下：</p><p><img src="/2017/11/23/mysql-xing-neng-you-hua-zhi-ying-xiang-xing-neng-de-yin-su/%E5%9B%BE%E7%89%879.png" alt="img"></p><p>如果设置为0，那么可以说，你的缓存根本就没有用，相当于禁用了。<br>如果设置为1，将会缓存所有的结果，除非你的select语句使用SQL_NO_CACHE禁用了查询缓存。<br>如果设置为2，则只缓存在select语句中通过SQL_CACHE指定需要缓存的查询。<br>修改/etc/my.cnf,配置完后的部分文件如下：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">query_cache_size</span>=<span class="number">256</span>M</span><br><span class="line"><span class="attr">query_cache_type</span>=<span class="number">1</span></span><br></pre></td></tr></table></figure><p>保存文件，重新启动MYSQL服务，然后通过如下查询来验证是否真正开启了：</p><p><img src="/2017/11/23/mysql-xing-neng-you-hua-zhi-ying-xiang-xing-neng-de-yin-su/%E5%9B%BE%E7%89%8710.png" alt="img"></p><p><img src="/2017/11/23/mysql-xing-neng-you-hua-zhi-ying-xiang-xing-neng-de-yin-su/%E5%9B%BE%E7%89%8711.png" alt="img"></p><p>query_cache_wlock_invalidate：当有其他客户端正在对MyISAM表进行写操作时，如果查询在query cache中，是否返回cache结果还是等写操作完成再读表获取结果。</p><p>查询缓存碎片率 = Qcache_free_blocks / Qcache_total_blocks * 100%<br>如果查询缓存碎片率超过20%，可以用FLUSH QUERY CACHE整理缓存碎片，或者试试减小query_cache_min_res_unit，如果你的查询都是小数据量的话。<br>查询缓存利用率 = (query_cache_size – Qcache_free_memory) / query_cache_size * 100%<br>查询缓存利用率在25%以下的话说明query_cache_size设置的过大，可适当减小；查询缓存利用率在80％以上而且Qcache_lowmem_prunes &gt; 50的话说明query_cache_size可能有点小，要不就是碎片太多。<br>查询缓存命中率 = Qcache_hits/(Qcache_hits +Qcache_inserts) * 100%</p><p><strong>Query Cache 的限制</strong></p><ol><li>所有子查询中的外部查询SQL 不能被Cache；</li><li>在Procedure，Function 以及Trigger 中的Query 不能被Cache；</li><li>包含其他很多每次执行可能得到不一样结果的函数的Query不能被Cache。<br>鉴于上面的这些限制，在使用Query Cache 的过程中，建议通过精确设置的方式来使用，仅仅让合适的表的数据可以进入Query Cache，仅仅让某些Query的查询结果被Cache。</li></ol><p><strong>如何设置query_cache_size？</strong></p><p>修改<code>/etc/my.cnf</code>文件，在<code>[mysqld]</code>下面添加如下内容</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">query_cache_size</span>=<span class="number">256</span>M</span><br><span class="line"><span class="attr">query_cache_type</span>=<span class="number">1</span></span><br></pre></td></tr></table></figure><p>重启MySQL Server进入后，查看设置已经生效。</p><h5 id="3-3-2-3-max-connect-errors"><a href="#3-3-2-3-max-connect-errors" class="headerlink" title="3.3.2.3 max_connect_errors"></a>3.3.2.3 max_connect_errors</h5><p>max_connect_errors是一个MySQL中与安全有关的计数器值，它负责阻止过多尝试失败的客户端以防止暴力破解密码的情况, 当超过指定次数，MYSQL服务器将禁止host的连接请求，直到mysql服务器重启或通过flush hosts命令清空此host的相关信息。max_connect_errors的值与性能并无太大关系。<br>修改<code>/etc/my.cnf</code>文件，在<code>[mysqld]</code>下面添加如下内容</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">max_connect_errors</span>=<span class="number">20</span></span><br></pre></td></tr></table></figure><p>重启MySQL Server进入后，查看设置已经生效。</p><h5 id="3-3-2-4-sort-buffer-size"><a href="#3-3-2-4-sort-buffer-size" class="headerlink" title="3.3.2.4 sort_buffer_size"></a>3.3.2.4 sort_buffer_size</h5><p>每个需要进行排序的线程分配该大小的一个缓冲区。增加这值加速ORDER BY或GROUP BY操作。<br>Sort_Buffer_Size 是一个connection级参数，在每个connection（session）第一次需要使用这个buffer的时候，一次性分配设置的内存。<br>Sort_Buffer_Size 并不是越大越好，由于是connection级的参数，过大的设置+高并发可能会耗尽系统内存资源。例如：500个连接将会消耗 500*sort_buffer_size(2M)=1G内存<br>例如设置sort_buffer_size<br>修改/etc/my.cnf文件，在[mysqld]下面添加如下内容</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sort_buffer_size</span> = <span class="number">2</span>M</span><br></pre></td></tr></table></figure><p>重启MySQL Server进入后，查看设置已经生效。</p><h5 id="3-3-2-5-max-allowed-packet-32M"><a href="#3-3-2-5-max-allowed-packet-32M" class="headerlink" title="3.3.2.5 max_allowed_packet = 32M"></a>3.3.2.5 max_allowed_packet = 32M</h5><p>MySQL根据配置文件会限制Server接受的数据包大小。有时候大的插入和更新会受 max_allowed_packet 参数限制，导致写入或者更新失败。最大值是1GB，必须设置1024的倍数。</p><h5 id="3-3-2-6-join-buffer-size-2M"><a href="#3-3-2-6-join-buffer-size-2M" class="headerlink" title="3.3.2.6 join_buffer_size = 2M"></a>3.3.2.6 join_buffer_size = 2M</h5><p>用于表间关联缓存的大小，和sort_buffer_size一样，该参数对应的分配内存也是每个连接独享。</p><h5 id="3-3-2-7-thread-cache-size-300"><a href="#3-3-2-7-thread-cache-size-300" class="headerlink" title="3.3.2.7 thread_cache_size = 300"></a>3.3.2.7 thread_cache_size = 300</h5><p>服务器线程缓存，这个值表示可以重新利用保存在缓存中线程的数量,当断开连接时,那么客户端的线程将被放到缓存中以响应下一个客户而不是销毁(前提是缓存数未达上限),如果线程重新被请求，那么请求将从缓存中读取,如果缓存中是空的或者是新的请求，那么这个线程将被重新创建,如果有很多新的线程，增加这个值可以改善系统性能.通过比 较 Connections 和 Threads_created 状态的变量，可以看到这个变量的作用。设置规则如下：1GB 内存配置为8，2GB配 置为16，3GB配置为32，4GB或更高内存，可配置更大。服务器处理此客户的线程将会缓存起来以响应下一个客户而不是销毁(前提是缓存数未达上限)</p><p><img src="/2017/11/23/mysql-xing-neng-you-hua-zhi-ying-xiang-xing-neng-de-yin-su/%E5%9B%BE%E7%89%8712.png" alt="image-20191116160759133"></p><p>试图连接到MySQL(不管是否连接成功)的连接数</p><p><img src="/2017/11/23/mysql-xing-neng-you-hua-zhi-ying-xiang-xing-neng-de-yin-su/%E5%9B%BE%E7%89%8713.png" alt="image-20191116160810843"></p><p><strong>Threads_cached: *<em>代表当前此时此刻线程缓存中有多少空闲线程。<br>*</em>Threads_connected:</strong> 代表当前已建立连接的数量，因为一个连接就需要一个线程，所以也可以看成当前被使用的线程数。<br><strong>Threads_created:</strong> 代表从最近一次服务启动，已创建线程的数量，如果发现Threads_created值过大的话，表明MySQL服务器一直在创建线程，这也是比较耗资源，可以适当增加配置文件中thread_cache_size值。<br><strong>Threads_running:</strong> 代表当前激活的（非睡眠状态）线程数。并不是代表正在使用的线程数，有时候连接已建立，但是连接处于sleep状态。</p><h4 id="3-3-3-配置InnoDB的几个变量"><a href="#3-3-3-配置InnoDB的几个变量" class="headerlink" title="3.3.3 配置InnoDB的几个变量"></a>3.3.3 配置InnoDB的几个变量</h4><h5 id="3-3-3-1-innodb-buffer-pool-size"><a href="#3-3-3-1-innodb-buffer-pool-size" class="headerlink" title="3.3.3.1  innodb_buffer_pool_size"></a>3.3.3.1 innodb_buffer_pool_size</h5><p>对于InnoDB表来说，innodb_buffer_pool_size的作用就相当于key_buffer_size对于MyISAM表的作用一样。InnoDB使用该参数指定大小的内存来缓冲数据和索引。对于单独的MySQL数据库服务器，最大可以把该值设置成物理内存的80%。根据MySQL手册，对于2G内存的机器，推荐值是1G（50%）。 如果你的数据量不大，并且不会暴增，那么无需把 innodb_buffer_pool_size 设置的太大了。</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show <span class="keyword">variables</span> like <span class="comment">'innodb_buffer_pool_size'</span>;</span><br></pre></td></tr></table></figure><p><strong>设置innodb_buffer_pool_size</strong><br>修改<code>/etc/my.cnf</code>文件，在<code>[mysqld]</code>下面添加如下内容</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">nnodb_buffer_pool_size</span> = <span class="number">2048</span>M</span><br></pre></td></tr></table></figure><p>重启MySQL Server进入后，查看设置已经生效。</p><h5 id="3-3-3-2-innodb-flush-log-at-trx-commit"><a href="#3-3-3-2-innodb-flush-log-at-trx-commit" class="headerlink" title="3.3.3.2 innodb_flush_log_at_trx_commit"></a>3.3.3.2 innodb_flush_log_at_trx_commit</h5><p>主要控制了innodb将log buffer中的数据写入日志文件并flush磁盘的时间点，取值分别为0、1、2三个。0，表示当事务提交时，不做日志写入操作，而是每秒钟将log buffer中的数据写入日志文件并flush磁盘一次；1，则在每秒钟或是每次事物的提交都会引起日志文件写入、flush磁盘的操作，确保了事务的ACID；设置为2，每次事务提交引起写入日志文件的动作，但每秒钟完成一次flush磁盘操作。<br>实际测试发现，该值对插入数据的速度影响非常大，设置为2时插入10000条记录只需要2秒，设置为0时只需要1秒，而设置为1时则需要229秒。因此，MySQL手册也建议尽量将插入操作合并成一个事务，这样可以大幅提高速度。<br>根据MySQL手册，在允许丢失最近部分事务的危险的前提下，可以把该值设为0或2。</p><h5 id="3-3-3-3-innodb-thread-concurrency-0"><a href="#3-3-3-3-innodb-thread-concurrency-0" class="headerlink" title="3.3.3.3 innodb_thread_concurrency = 0"></a>3.3.3.3 innodb_thread_concurrency = 0</h5><p>此参数用来设置innodb线程的并发数量，默认值为0表示不限制，若要设置则与服务器的CPU核数相同或是cpu的核数的2倍，建议用默认设置，一般为8.</p><h5 id="3-3-3-4-innodb-log-buffer-size"><a href="#3-3-3-4-innodb-log-buffer-size" class="headerlink" title="3.3.3.4 innodb_log_buffer_size"></a>3.3.3.4 innodb_log_buffer_size</h5><p>此参数确定些日志文件所用的内存大小，以M为单位。缓冲区更大能提高性能，对于较大的事务，可以增大缓存大小。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">innodb_log_buffer_size</span>=<span class="number">32</span>M</span><br></pre></td></tr></table></figure><h5 id="3-3-3-5-innodb-log-file-size-50M"><a href="#3-3-3-5-innodb-log-file-size-50M" class="headerlink" title="3.3.3.5 innodb_log_file_size = 50M"></a>3.3.3.5 innodb_log_file_size = 50M</h5><p>此参数确定数据日志文件的大小，以M为单位，更大的设置可以提高性能.</p><h5 id="3-3-3-6-innodb-log-files-in-group-3"><a href="#3-3-3-6-innodb-log-files-in-group-3" class="headerlink" title="3.3.3.6 innodb_log_files_in_group = 3"></a>3.3.3.6 innodb_log_files_in_group = 3</h5><p>为提高性能，MySQL可以以循环方式将日志文件写到多个文件。推荐设置为3</p><h5 id="3-3-3-7-read-buffer-size-1M"><a href="#3-3-3-7-read-buffer-size-1M" class="headerlink" title="3.3.3.7 read_buffer_size = 1M"></a>3.3.3.7 read_buffer_size = 1M</h5><p>MySql 读入缓冲区大小。对表进行顺序扫描的请求将分配一个读入缓冲区，MySql会为它分配一段内存缓冲区。如果对表的顺序扫描请求非常频繁，并且你认为频繁扫描进行得太慢，可以通过增加该变量值以及内存缓冲区大小提高其性能。和 sort_buffer_size一样，该参数对应的分配内存也是每个连接独享。</p><h5 id="3-3-3-8-read-rnd-buffer-size-16M"><a href="#3-3-3-8-read-rnd-buffer-size-16M" class="headerlink" title="3.3.3.8 read_rnd_buffer_size = 16M"></a>3.3.3.8 read_rnd_buffer_size = 16M</h5><p>MySql 的随机读（查询操作）缓冲区大小。当按任意顺序读取行时(例如，按照排序顺序)，将分配一个随机读缓存区。进行排序查询时，MySql会首先扫描一遍该缓冲，以避免磁盘搜索，提高查询速度，如果需要排序大量数据，可适当调高该值。但MySql会为每个客户连接发放该缓冲空间，所以应尽量适当设置该值，以避免内存开销过大。</p><p><strong>注：</strong>顺序读是指根据索引的叶节点数据就能顺序地读取所需要的行数据。随机读是指一般需要根据辅助索引叶节点中的主键寻找实际行数据，而辅助索引和主键所在的数据段不同，因此访问方式是随机的。</p><h5 id="3-3-3-9-bulk-insert-buffer-size-64M"><a href="#3-3-3-9-bulk-insert-buffer-size-64M" class="headerlink" title="3.3.3.9 bulk_insert_buffer_size = 64M"></a>3.3.3.9 bulk_insert_buffer_size = 64M</h5><p>批量插入数据缓存大小，可以有效提高插入效率，默认为8M</p><h5 id="3-3-3-10-binary-log"><a href="#3-3-3-10-binary-log" class="headerlink" title="3.3.3.10 binary log"></a>3.3.3.10 binary log</h5><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">log</span><span class="params">-bin</span>=/usr/<span class="built_in">local</span>/mysql/<span class="built_in">data</span>/mysql<span class="params">-bin</span></span><br></pre></td></tr></table></figure><p>binlog_cache_size = 2M //为每个session 分配的内存，在事务过程中用来存储二进制日志的缓存, 提高记录bin-log的效率。没有什么大事务，dml也不是很频繁的情况下可以设置小一点，如果事务大而且多，dml操作也频繁，则可以适当的调大一点。前者建议是–1M，后者建议是：即 2–4M<br>max_binlog_cache_size = 8M //表示的是binlog 能够使用的最大cache 内存大小<br>max_binlog_size = 512M //指定binlog日志文件的大小，如果当前的日志大小达到max_binlog_size，还会自动创建新的二进制日志。你不能将该变量设置为大于1GB或小于4096字节。 默认值是1GB。在导入大容量的sql文件时，建议关闭sql_log_bin，否则硬盘扛不住，而且建议定期做删除。<br>expire_logs_days = 7 //定义了mysql清除过期日志的时间。<br>二进制日志自动删除的天数。默认值为0,表示“没有自动删除”。<br>mysqladmin flush-logs 也可以重新开始新的binary log</p><p><strong>在优化之前执行mysqlslap工具进行测试</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mysqlslap <span class="attribute">--defaults-file</span>=/etc/my.cnf <span class="attribute">--concurrency</span>=10 <span class="attribute">--iterations</span>=1 <span class="attribute">--create-schema</span>=<span class="string">'test1'</span> <span class="attribute">--query</span>=<span class="string">'select * from test1.tb1'</span> <span class="attribute">--engine</span>=innodb <span class="attribute">--number-of-queries</span>=2000 -uroot -p123456 –verbose</span><br></pre></td></tr></table></figure><p>显示结果：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Benchmark</span><br><span class="line">	Running <span class="keyword">for</span> engine innodb</span><br><span class="line">	Average <span class="built_in">number</span> <span class="keyword">of</span> <span class="built_in">seconds</span> <span class="built_in">to</span> run all queries: <span class="number">13.837</span> <span class="built_in">seconds</span></span><br><span class="line">	Minimum <span class="built_in">number</span> <span class="keyword">of</span> <span class="built_in">seconds</span> <span class="built_in">to</span> run all queries: <span class="number">13.837</span> <span class="built_in">seconds</span></span><br><span class="line">	Maximum <span class="built_in">number</span> <span class="keyword">of</span> <span class="built_in">seconds</span> <span class="built_in">to</span> run all queries: <span class="number">13.837</span> <span class="built_in">seconds</span></span><br><span class="line">	Number <span class="keyword">of</span> clients running queries: <span class="number">10</span></span><br><span class="line">	Average <span class="built_in">number</span> <span class="keyword">of</span> queries per client: <span class="number">200</span></span><br></pre></td></tr></table></figure><p><strong>优化之后执行mysqlslap工具进行测试</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#mysqlslap <span class="attribute">--defaults-file</span>=/etc/my.cnf <span class="attribute">--concurrency</span>=10 <span class="attribute">--iterations</span>=1 <span class="attribute">--create-schema</span>=<span class="string">'test1'</span> <span class="attribute">--query</span>=<span class="string">'select * from test1.tb1'</span> <span class="attribute">--engine</span>=innodb <span class="attribute">--number-of-queries</span>=2000 -uroot -p123456 –verbose</span><br></pre></td></tr></table></figure><p>显示结果：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Benchmark</span><br><span class="line">	Running <span class="keyword">for</span> engine innodb</span><br><span class="line">	Average <span class="built_in">number</span> <span class="keyword">of</span> <span class="built_in">seconds</span> <span class="built_in">to</span> run all queries: <span class="number">4.199</span> <span class="built_in">seconds</span></span><br><span class="line">	Minimum <span class="built_in">number</span> <span class="keyword">of</span> <span class="built_in">seconds</span> <span class="built_in">to</span> run all queries: <span class="number">4.199</span> <span class="built_in">seconds</span></span><br><span class="line">	Maximum <span class="built_in">number</span> <span class="keyword">of</span> <span class="built_in">seconds</span> <span class="built_in">to</span> run all queries: <span class="number">4.199</span> <span class="built_in">seconds</span></span><br><span class="line">	Number <span class="keyword">of</span> clients running queries: <span class="number">10</span></span><br><span class="line">	Average <span class="built_in">number</span> <span class="keyword">of</span> queries per client: <span class="number">200</span></span><br></pre></td></tr></table></figure><p><strong>相关优化参数总结：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">slow_query_log = 1</span><br><span class="line">slow_query_log_file = /usr/local/mysql/data/slow-query.log</span><br><span class="line">long_query_time = 1</span><br><span class="line">log-queries-not-using-indexes</span><br><span class="line">max_connections = 1024</span><br><span class="line">back_log = 128</span><br><span class="line">wait_timeout = 60</span><br><span class="line">interactive_timeout = 7200</span><br><span class="line">key_buffer_size=256M</span><br><span class="line">query_cache_size = 256M</span><br><span class="line">query_cache_type=1</span><br><span class="line">query_cache_limit=50M</span><br><span class="line">max_connect_errors=20</span><br><span class="line">sort_buffer_size = 2M</span><br><span class="line">max_allowed_packet=32M</span><br><span class="line">join_buffer_size=2M</span><br><span class="line">thread_cache_size=200</span><br><span class="line">innodb_buffer_pool_size = 2048M</span><br><span class="line">innodb_flush_log_at_trx_commit = 1</span><br><span class="line">innodb_log_buffer_size=32M</span><br><span class="line">innodb_log_file_size=128M</span><br><span class="line">innodb_log_files_in_group=3</span><br><span class="line">log-bin=mysql-bin</span><br><span class="line">binlog_cache_size=2M</span><br><span class="line">max_binlog_cache_size=8M</span><br><span class="line">max_binlog_size=512M</span><br><span class="line">expire_logs_days=7</span><br><span class="line">read_buffer_size=1M</span><br><span class="line">read_rnd_buffer_size=16M</span><br><span class="line">bulk_insert_buffer_size=64M</span><br><span class="line">log-error = /usr/local/mysql/data/mysqld.err</span><br></pre></td></tr></table></figure></div><div><div><div style="text-align:center;color:#ccc;font-size:14px">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div></div></div><div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag"><i class="fa fa-tag"></i> 数据库</a><a href="/tags/MySQL/" rel="tag"><i class="fa fa-tag"></i> MySQL</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2017/11/19/linux-iptables-fang-huo-qiang/" rel="next" title="Linux iptables防火墙"><i class="fa fa-chevron-left"></i> Linux iptables防火墙</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2017/11/23/mysql-shi-wu-de-cao-zuo/" rel="prev" title="MySQL 事务的操作">MySQL 事务的操作<i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"><div class="jiathis_style"><span class="jiathis_txt">分享到：</span> <a class="jiathis_button_fav">收藏夹</a> <a class="jiathis_button_copy">复制网址</a> <a class="jiathis_button_email">邮件</a> <a class="jiathis_button_weixin">微信</a> <a class="jiathis_button_qzone">QQ空间</a> <a class="jiathis_button_tqq">腾讯微博</a> <a class="jiathis_button_douban">豆瓣</a> <a class="jiathis_button_share">一键分享</a> <a href="http://www.jiathis.com/share?uid=2140465" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank">更多</a><a class="jiathis_counter_style"></a></div><script type="text/javascript">var jiathis_config={data_track_clickback:!0,summary:"",shortUrl:!1,hideMore:!1}</script><script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=" charset="utf-8"></script></div></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div id="sidebar-dimmer"></div><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/images/chen.png" alt="Zhongzhou Chen"><p class="site-author-name" itemprop="name">Zhongzhou Chen</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives"><span class="site-state-item-count">282</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">84</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">164</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1、MySQL-性能优化之影响性能的因素"><span class="nav-text">1、MySQL 性能优化之影响性能的因素</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-商业需求的影响"><span class="nav-text">1.1 商业需求的影响</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-系统架构及实现的影响"><span class="nav-text">1.2 系统架构及实现的影响</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-查询语句对性能的影响"><span class="nav-text">1.3 查询语句对性能的影响</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-数据库Schema设计对性能的影响"><span class="nav-text">1.4 数据库Schema设计对性能的影响</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-硬件选择对性能的影响"><span class="nav-text">1.5 硬件选择对性能的影响</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2、MySQL性能优化之-索引"><span class="nav-text">2、MySQL性能优化之-索引</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-做一个简单测试"><span class="nav-text">2.1 做一个简单测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-索引概述"><span class="nav-text">2.2 索引概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-1-什么是索引？"><span class="nav-text">2.2.1 什么是索引？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-2-索引的类型？"><span class="nav-text">2.2.2 索引的类型？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-建立索引的时机"><span class="nav-text">2.3 建立索引的时机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-总结"><span class="nav-text">2.4 总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3、mysql性能优化-慢查询分析、优化索引和配置"><span class="nav-text">3、mysql性能优化-慢查询分析、优化索引和配置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-基本思路"><span class="nav-text">3.1 基本思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-查询与索引优化分析"><span class="nav-text">3.2 查询与索引优化分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-1-慢查询日志"><span class="nav-text">3.2.1 慢查询日志</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-2-explain分析查询"><span class="nav-text">3.2.2 explain分析查询</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-3-profiling分析查询"><span class="nav-text">3.2.3 profiling分析查询</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-配置优化"><span class="nav-text">3.3 配置优化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-1-连接请求的变量"><span class="nav-text">3.3.1 连接请求的变量</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-1-1-max-connections"><span class="nav-text">3.3.1.1 max_connections</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-1-2-back-log"><span class="nav-text">3.3.1.2 back_log</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-1-3-wait-timeout-和-interactive-timeout"><span class="nav-text">3.3.1.3 wait_timeout 和 interactive_timeout</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-2-绶冲区变量"><span class="nav-text">3.3.2 绶冲区变量</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-2-1-key-buffer-size"><span class="nav-text">3.3.2.1 key_buffer_size</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-2-2-query-cache-size-查询缓存简称QC"><span class="nav-text">3.3.2.2 query_cache_size(查询缓存简称QC)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-2-3-max-connect-errors"><span class="nav-text">3.3.2.3 max_connect_errors</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-2-4-sort-buffer-size"><span class="nav-text">3.3.2.4 sort_buffer_size</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-2-5-max-allowed-packet-32M"><span class="nav-text">3.3.2.5 max_allowed_packet = 32M</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-2-6-join-buffer-size-2M"><span class="nav-text">3.3.2.6 join_buffer_size = 2M</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-2-7-thread-cache-size-300"><span class="nav-text">3.3.2.7 thread_cache_size = 300</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-3-配置InnoDB的几个变量"><span class="nav-text">3.3.3 配置InnoDB的几个变量</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-3-1-innodb-buffer-pool-size"><span class="nav-text">3.3.3.1 innodb_buffer_pool_size</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-3-2-innodb-flush-log-at-trx-commit"><span class="nav-text">3.3.3.2 innodb_flush_log_at_trx_commit</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-3-3-innodb-thread-concurrency-0"><span class="nav-text">3.3.3.3 innodb_thread_concurrency = 0</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-3-4-innodb-log-buffer-size"><span class="nav-text">3.3.3.4 innodb_log_buffer_size</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-3-5-innodb-log-file-size-50M"><span class="nav-text">3.3.3.5 innodb_log_file_size = 50M</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-3-6-innodb-log-files-in-group-3"><span class="nav-text">3.3.3.6 innodb_log_files_in_group = 3</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-3-7-read-buffer-size-1M"><span class="nav-text">3.3.3.7 read_buffer_size = 1M</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-3-8-read-rnd-buffer-size-16M"><span class="nav-text">3.3.3.8 read_rnd_buffer_size = 16M</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-3-9-bulk-insert-buffer-size-64M"><span class="nav-text">3.3.3.9 bulk_insert_buffer_size = 64M</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-3-10-binary-log"><span class="nav-text">3.3.3.10 binary log</span></a></li></ol></li></ol></li></ol></li></ol></div></div></section><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span id="scrollpercent"><span>0</span>%</span></div></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="copyright">&copy; <span itemprop="copyrightYear">2021</span><span class="with-love"><i class="fa fa-user"></i></span> <span class="author" itemprop="copyrightHolder">Zhongzhou Chen</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-area-chart"></i></span> <span class="post-meta-item-text">Site words total count&#58;</span> <span title="Site words total count">597k</span></div><span class="post-meta-divider"></span></div></footer></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script><script type="text/javascript">function proceedsearch(){$("body").append('<div class="search-popup-overlay local-search-pop-overlay"></div>').css("overflow","hidden"),$(".search-popup-overlay").click(onPopupClose),$(".popup").toggle();var t=$("#local-search-input");t.attr("autocapitalize","none"),t.attr("autocorrect","off"),t.focus()}var isfetched=!1,isXml=!0,search_path="search.xml";0===search_path.length?search_path="search.xml":/json$/i.test(search_path)&&(isXml=!1);var path="/"+search_path,onPopupClose=function(t){$(".popup").hide(),$("#local-search-input").val(""),$(".search-result-list").remove(),$("#no-result").remove(),$(".local-search-pop-overlay").remove(),$("body").css("overflow","")},searchFunc=function(t,e,s){"use strict";$("body").append('<div class="search-popup-overlay local-search-pop-overlay"><div id="search-loading-icon"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div>').css("overflow","hidden"),$("#search-loading-icon").css("margin","20% auto 0 auto").css("text-align","center"),$.ajax({url:t,dataType:isXml?"xml":"json",async:!0,success:function(t){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var o=isXml?$("entry",t).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get():t,n=document.getElementById(e),r=document.getElementById(s);n.addEventListener("input",function(){var y=n.value.trim().toLowerCase(),T=y.split(/[\s\-]+/);1<T.length&&T.push(y);var b=[];if(0<y.length&&o.forEach(function(t){function e(t,e,o,n){for(var r=n[n.length-1],s=r.position,a=r.word,i=[],c=0;s+a.length<=o&&0!=n.length;){a===y&&c++,i.push({position:s,length:a.length});var l=s+a.length;for(n.pop();0!=n.length&&(s=(r=n[n.length-1]).position,a=r.word,s<l);)n.pop()}return h+=c,{hits:i,start:e,end:o,searchTextCount:c}}function o(o,t){var n="",r=t.start;return t.hits.forEach(function(t){n+=o.substring(r,t.position);var e=t.position+t.length;n+='<b class="search-keyword">'+o.substring(t.position,e)+"</b>",r=e}),n+=o.substring(r,t.end)}var n=!1,r=0,h=0,s=t.title.trim(),a=s.toLowerCase(),i=t.content.trim().replace(/<[^>]+>/g,""),c=i.toLowerCase(),l=decodeURIComponent(t.url),p=[],u=[];if(""!=s&&(T.forEach(function(t){function e(t,e,o){var n=t.length;if(0===n)return[];var r=0,s=[],a=[];for(o||(e=e.toLowerCase(),t=t.toLowerCase());-1<(s=e.indexOf(t,r));)a.push({position:s,word:t}),r=s+n;return a}p=p.concat(e(t,a,!1)),u=u.concat(e(t,c,!1))}),(0<p.length||0<u.length)&&(n=!0,r=p.length+u.length)),n){[p,u].forEach(function(t){t.sort(function(t,e){return e.position!==t.position?e.position-t.position:t.word.length-e.word.length})});var f=[];0!=p.length&&f.push(e(0,0,s.length,p));for(var d=[];0!=u.length;){var g=u[u.length-1],v=g.position,$=g.word,C=v-20,m=v+80;C<0&&(C=0),m<v+$.length&&(m=v+$.length),m>i.length&&(m=i.length),d.push(e(0,C,m,u))}d.sort(function(t,e){return t.searchTextCount!==e.searchTextCount?e.searchTextCount-t.searchTextCount:t.hits.length!==e.hits.length?e.hits.length-t.hits.length:t.start-e.start});var x=parseInt("1");0<=x&&(d=d.slice(0,x));var w="";w+=0!=f.length?"<li><a href='"+l+"' class='search-result-title'>"+o(s,f[0])+"</a>":"<li><a href='"+l+"' class='search-result-title'>"+s+"</a>",d.forEach(function(t){w+="<a href='"+l+'\'><p class="search-result">'+o(i,t)+"...</p></a>"}),w+="</li>",b.push({item:w,searchTextCount:h,hitCount:r,id:b.length})}}),1===T.length&&""===T[0])r.innerHTML='<div id="no-result"><i class="fa fa-search fa-5x" /></div>';else if(0===b.length)r.innerHTML='<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>';else{b.sort(function(t,e){return t.searchTextCount!==e.searchTextCount?e.searchTextCount-t.searchTextCount:t.hitCount!==e.hitCount?e.hitCount-t.hitCount:e.id-t.id});var e='<ul class="search-result-list">';b.forEach(function(t){e+=t.item}),e+="</ul>",r.innerHTML=e}}),$(".local-search-pop-overlay").remove(),$("body").css("overflow",""),proceedsearch()}})};$(".popup-trigger").click(function(t){t.stopPropagation(),!1===isfetched?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(onPopupClose),$(".popup").click(function(t){t.stopPropagation()}),$(document).on("keyup",function(t){27===t.which&&$(".search-popup").is(":visible")&&onPopupClose()})</script><script type="text/javascript" src="/js/src/clipboard.min.js"></script><script type="text/javascript" src="/js/src/clipboard-use.js"></script><script type="text/javascript" src="/js/src/love.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,log:!1,model:{jsonPath:"/live2dw/assets/shizuku.model.json"},display:{position:"right"},mobile:{show:!0,scale:.5},react:{opacityDefault:.7,opacityOnHover:.2}})</script></body></html>