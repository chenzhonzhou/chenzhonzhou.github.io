<!-- build time:Sun Dec 03 2023 14:38:56 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html class="theme-next gemini use-motion" lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script><link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet"><script></script><meta name="theme-color" content="#222"><style>.pace .pace-progress{background:#1E92FB;height:3px}.pace .pace-progress-inner{box-shadow:0 0 10px #1E92FB,0 0 5px #1E92FB}.pace .pace-activity{border-top-color:#1E92FB;border-left-color:#1E92FB}</style><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="google-site-verification" content="HGM141IpbHrSmnAmR6W_zE4bo9Z3f-yXLeHYT3bg1fk"><meta name="baidu-site-verification" content="code-5Ai1DA8e6T"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4"><link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222"><meta name="keywords" content="Go,"><link rel="alternate" href="/atom.xml" title="凡间的精灵" type="application/atom+xml"><meta name="description" content="Go 反射Go语言提供了一种机制在运行时更新和检查变量的值、调用变量的方法和变量支持的内在操作，但是在编译时并不知道这些变量的具体类型，这种机制被称为反射。反射也可以让我们将类型本身作为第一类的值类型处理。反射是指在程序运行期对程序本身进行访问和修改的能力，程序在编译时变量被转换为内存地址，变量名不会被编译器写入到可执行部分，在运行程序时程序无法获取自身的信息。支持反射的语言可以在程序编译期将变量"><meta name="keywords" content="Go"><meta property="og:type" content="article"><meta property="og:title" content="Go 反射"><meta property="og:url" content="http:&#x2F;&#x2F;chenzhonzhou.github.io&#x2F;2023&#x2F;04&#x2F;11&#x2F;go-fan-she&#x2F;index.html"><meta property="og:site_name" content="凡间的精灵"><meta property="og:description" content="Go 反射Go语言提供了一种机制在运行时更新和检查变量的值、调用变量的方法和变量支持的内在操作，但是在编译时并不知道这些变量的具体类型，这种机制被称为反射。反射也可以让我们将类型本身作为第一类的值类型处理。反射是指在程序运行期对程序本身进行访问和修改的能力，程序在编译时变量被转换为内存地址，变量名不会被编译器写入到可执行部分，在运行程序时程序无法获取自身的信息。支持反射的语言可以在程序编译期将变量"><meta property="og:locale" content="zh-Hans"><meta property="og:updated_time" content="2023-12-02T03:13:57.607Z"><meta name="twitter:card" content="summary"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Gemini",version:"5.1.4",sidebar:{position:"left",display:"always",offset:12,b2t:!0,scrollpercent:!0,onmobile:!0},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://chenzhonzhou.github.io/2023/04/11/go-fan-she/"><title>Go 反射 | 凡间的精灵</title><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">凡间的精灵</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">凡尘落素一精灵</p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-categories"><a href="/categories" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="menu-item-icon fa fa-fw fa-sitemap"></i><br>站点地图</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i> </span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://chenzhonzhou.github.io/2023/04/11/go-fan-she/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Zhongzhou Chen"><meta itemprop="description" content=""><meta itemprop="image" content="/images/chen.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="凡间的精灵"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Go 反射</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2023-04-11T11:12:01+08:00">2023-04-11 </time></span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Go/" itemprop="url" rel="index"><span itemprop="name">Go</span></a></span></span><div class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">3.6k </span><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">15</span></div></div></header><div class="post-body" itemprop="articleBody"><h2 id="Go-反射"><a href="#Go-反射" class="headerlink" title="Go 反射"></a>Go 反射</h2><p>Go语言提供了一种机制在运行时更新和检查变量的值、调用变量的方法和变量支持的内在操作，但是在编译时并不知道这些变量的具体类型，这种机制被称为反射。反射也可以让我们将类型本身作为第一类的值类型处理。</p><p>反射是指在程序运行期对程序本身进行访问和修改的能力，程序在编译时变量被转换为内存地址，变量名不会被编译器写入到可执行部分，在运行程序时程序无法获取自身的信息。</p><p>支持反射的语言可以在程序编译期将变量的反射信息，如字段名称、类型信息、结构体信息等整合到可执行文件中，并给程序提供接口访问反射信息，这样就可以在程序运行期获取类型的反射信息，并且有能力修改它们。</p><p>C/<a href="http://c.biancheng.net/cplus/" target="_blank" rel="noopener">C++</a>语言没有支持反射功能，只能通过 typeid 提供非常弱化的程序运行时类型信息；Java、<a href="http://c.biancheng.net/csharp/" target="_blank" rel="noopener">C#</a> 等语言都支持完整的反射功能；Lua、<a href="http://c.biancheng.net/js/" target="_blank" rel="noopener">JavaScript</a> 类动态语言，由于其本身的语法特性就可以让代码在运行期访问程序自身的值和类型信息，因此不需要反射系统。</p><p>Go语言程序的反射系统无法获取到一个可执行文件空间中或者是一个包中的所有类型信息，需要配合使用标准库中对应的词法、语法解析器和抽象语法树（AST）对源码进行扫描后获得这些信息。</p><p>Go语言提供了 reflect 包来访问程序的反射信息。</p><h2 id="Type和Value方法"><a href="#Type和Value方法" class="headerlink" title="Type和Value方法"></a>Type和Value方法</h2><h3 id="Type和Value拥有的同名方法"><a href="#Type和Value拥有的同名方法" class="headerlink" title="Type和Value拥有的同名方法"></a>Type和Value拥有的同名方法</h3><table><thead><tr><th align="left">Method</th><th align="left">Type返回类型</th><th align="left">Value返回类型</th><th align="left">备注</th></tr></thead><tbody><tr><td align="left">Kind</td><td align="left">Kind</td><td align="left">Kind</td><td align="left">返回指定对象的Kind类型</td></tr><tr><td align="left">NumMethod</td><td align="left">int</td><td align="left">int</td><td align="left">返回struct拥有的方法总数，包括unexported方法</td></tr><tr><td align="left">MethodByName</td><td align="left">Method</td><td align="left">Value</td><td align="left">根据方法名找方法</td></tr><tr><td align="left">Method</td><td align="left">Method</td><td align="left">Value</td><td align="left">返回第i个方法</td></tr><tr><td align="left">NumField</td><td align="left">int</td><td align="left">int</td><td align="left">返回struct所包含的field数量</td></tr><tr><td align="left">Field</td><td align="left">StructField</td><td align="left">Value</td><td align="left">取struct结构的第n个field</td></tr><tr><td align="left">FieldByIndex</td><td align="left">StructField</td><td align="left">Value</td><td align="left">嵌套的方式取struct的field，比如v.FieldByIndex([]int{1,2})等价于 v.field(1).field(2)</td></tr><tr><td align="left">FieldByName</td><td align="left">StructFiel,bool</td><td align="left">Value</td><td align="left">返回名称匹配match函数的field</td></tr><tr><td align="left">FieldByNameFunc</td><td align="left">StructField,bool</td><td align="left">Value</td><td align="left">返回名称匹配match函数的field</td></tr></tbody></table><h3 id="Type独有的方法"><a href="#Type独有的方法" class="headerlink" title="Type独有的方法"></a>Type独有的方法</h3><table><thead><tr><th align="left">Method</th><th align="left">备注</th></tr></thead><tbody><tr><td align="left">Align</td><td align="left">分配内存时的内存对齐字节数</td></tr><tr><td align="left">FieldAlign</td><td align="left">作为struct的field时内存对齐字节数</td></tr><tr><td align="left">Name</td><td align="left">type名 string类型</td></tr><tr><td align="left">PkgPath</td><td align="left">包路径， “encoding/base64”， 内置类型返回empty string</td></tr><tr><td align="left">Size</td><td align="left">该类型变量占用字节数</td></tr><tr><td align="left">String</td><td align="left">type的string表示方式</td></tr><tr><td align="left">Implements</td><td align="left">判断该类型是否实现了某个接口</td></tr><tr><td align="left">AssignableTo</td><td align="left">判断该类型能否赋值给某个类型</td></tr><tr><td align="left">ConvertibleTo</td><td align="left">判断该类型能否转换为另外一种类型</td></tr><tr><td align="left">Comparable</td><td align="left">判断该类型变量是否可以比较</td></tr><tr><td align="left">ChanDir</td><td align="left">返回channel的方向 recv/send/double</td></tr><tr><td align="left">IsVariadic</td><td align="left">判断函数是否接受可变参数</td></tr><tr><td align="left">Elem</td><td align="left">取该类型的元素</td></tr><tr><td align="left">In</td><td align="left">函数第n个入参</td></tr><tr><td align="left">Out</td><td align="left">函数第n个出参</td></tr><tr><td align="left">NumIn</td><td align="left">函数的入参数个数</td></tr><tr><td align="left">NumOut</td><td align="left">函数的出参个数</td></tr><tr><td align="left">Key</td><td align="left">返回map结构的key类型Type</td></tr><tr><td align="left">Len</td><td align="left">返回array的长度</td></tr></tbody></table><h3 id="Value独有的方法"><a href="#Value独有的方法" class="headerlink" title="Value独有的方法"></a>Value独有的方法</h3><table><thead><tr><th align="left">Method</th><th align="left">备注</th></tr></thead><tbody><tr><td align="left">Addr</td><td align="left">v的指针，前提时CanAddr()返回true</td></tr><tr><td align="left">Bool</td><td align="left">取值，布尔类型</td></tr><tr><td align="left">Bytes</td><td align="left">取值，字节流</td></tr><tr><td align="left">Call</td><td align="left">调用函数</td></tr><tr><td align="left">CallSlice</td><td align="left">调用具有可变参的函数</td></tr><tr><td align="left">CanAddr</td><td align="left">判断能否取址</td></tr><tr><td align="left">CanInterface</td><td align="left">判断Interface方法能否使用</td></tr><tr><td align="left">CanSet</td><td align="left">判断v的值能否改变</td></tr><tr><td align="left">Cap</td><td align="left">判断容量 Array/Chan/Slice</td></tr><tr><td align="left">Close</td><td align="left">关闭Chan</td></tr><tr><td align="left">Complex</td><td align="left">取值，复数</td></tr><tr><td align="left">Convert</td><td align="left">返回将v转换位type t的结果</td></tr><tr><td align="left">Elem</td><td align="left">返回interface包含或者Ptr指针的实际值</td></tr><tr><td align="left">Float</td><td align="left">取值，浮点型</td></tr><tr><td align="left">Index 索引操作</td><td align="left">Array/Slice/String</td></tr><tr><td align="left">Int</td><td align="left">取值，整型</td></tr><tr><td align="left">Interface</td><td align="left">将当前value以interface{}形式返回</td></tr><tr><td align="left">IsNil</td><td align="left">判断是否为nil，chan, func, interface, map, pointer, or slice value</td></tr><tr><td align="left">IsValid</td><td align="left">是否是可操作的Value，返回false表示为zero Value</td></tr><tr><td align="left">Len</td><td align="left">适用于Array, Chan, Map, Slice, or String</td></tr><tr><td align="left">MapIndex</td><td align="left">对map类型按key取值</td></tr><tr><td align="left">MapKeys</td><td align="left">map类型的所有key的列表</td></tr><tr><td align="left">OverflowComplex</td><td align="left">溢出判断</td></tr><tr><td align="left">OverflowFloat</td><td align="left">溢出判断</td></tr><tr><td align="left">OverflowInt</td><td align="left">溢出判断</td></tr><tr><td align="left">OverflowUint</td><td align="left">溢出判断</td></tr><tr><td align="left">Pointer</td><td align="left">返回uintptr 适用于slice</td></tr><tr><td align="left">Recv</td><td align="left">chan接收</td></tr><tr><td align="left">Send</td><td align="left">chan发送</td></tr><tr><td align="left">Set</td><td align="left">将x赋值给v，类型要匹配</td></tr><tr><td align="left">SetBool</td><td align="left">Bool赋值，需要先判断CanSet()为true</td></tr><tr><td align="left">SetBytes</td><td align="left">Bytes赋值</td></tr><tr><td align="left">SetCap</td><td align="left">slice调整切片容量</td></tr><tr><td align="left">SetMapIndex</td><td align="left">map索引赋值</td></tr><tr><td align="left">SetUint</td><td align="left">Unit赋值</td></tr><tr><td align="left">SetPointer</td><td align="left">unsafe.Pointer赋值</td></tr><tr><td align="left">SetString</td><td align="left">String赋值</td></tr><tr><td align="left">Slice</td><td align="left">return v[i:j] 适用于Array/Slict/String</td></tr><tr><td align="left">String</td><td align="left">return value的string表示方法</td></tr><tr><td align="left">TryRecv</td><td align="left">chan非阻塞接收</td></tr><tr><td align="left">TrySend</td><td align="left">chan非阻塞发送</td></tr><tr><td align="left">Type</td><td align="left">返回value的Type</td></tr><tr><td align="left">UnsafeAddr</td><td align="left">返回指向value的data的指针</td></tr></tbody></table><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="结构体Type"><a href="#结构体Type" class="headerlink" title="结构体Type"></a>结构体Type</h3><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> {</span><br><span class="line">	Name <span class="keyword">string</span> <span class="string">`json:"name"`</span></span><br><span class="line">	age  <span class="keyword">int</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">GetName</span><span class="params">()</span> <span class="title">string</span></span> {</span><br><span class="line">	<span class="keyword">return</span> p.Name</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">getAge</span><span class="params">()</span> <span class="title">int</span></span> {</span><br><span class="line">	<span class="keyword">return</span> p.age</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="comment">// 结构体</span></span><br><span class="line">	tom := Person{Name: <span class="string">"tom"</span>, age: <span class="number">20</span>}</span><br><span class="line">	t := reflect.TypeOf(tom)</span><br><span class="line">	fmt.Println(t, t.Kind(), t.Size()) <span class="comment">// 类型是Person，种类是struct，占据内存字节数</span></span><br><span class="line">	fmt.Println(<span class="string">"~~~~~~~~~~~~~~~~~~~~~~~~~~~"</span>)</span><br><span class="line">	<span class="comment">// 字段</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; t.NumField(); i++ {</span><br><span class="line">		f := t.Field(i)</span><br><span class="line">		fmt.Println(i, f)</span><br><span class="line">		fmt.Println(</span><br><span class="line">			f.Name,            <span class="comment">// 字段名</span></span><br><span class="line">			f.Index,           <span class="comment">// 字段索引</span></span><br><span class="line">			f.Type,            <span class="comment">// 字段类型</span></span><br><span class="line">			f.Type.Kind(),     <span class="comment">// 字段类型的种类</span></span><br><span class="line">			f.Offset,          <span class="comment">// 相当于结构体首地址该字段值的偏移，string占16字节</span></span><br><span class="line">			f.Anonymous,       <span class="comment">// 是否匿名成员，就是没有名字。注意不要和可见性混淆</span></span><br><span class="line">			f.IsExported(),    <span class="comment">// 是否导出，包外可见否</span></span><br><span class="line">			f.Tag,             <span class="comment">// 本质上就是string类型</span></span><br><span class="line">			f.Tag.Get(<span class="string">"json"</span>), <span class="comment">// 获取结构体字段定义后面反引号部分的tag</span></span><br><span class="line">		)</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">// 方法，只包括导出的方法，也不包括receiver是该结构体指针的方法</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; t.NumMethod(); i++ {</span><br><span class="line">		m := t.Method(i)</span><br><span class="line">		fmt.Println(i, m)</span><br><span class="line">		fmt.Println(</span><br><span class="line">			m.Name,         <span class="comment">// 方法名</span></span><br><span class="line">			m.Index,        <span class="comment">// 方法索引</span></span><br><span class="line">			m.Type,         <span class="comment">// 方法类型，函数签名</span></span><br><span class="line">			m.Type.Kind(),  <span class="comment">// 方法类型的种类</span></span><br><span class="line">			m.IsExported(), <span class="comment">// 是否导出。当然未导出的看不到</span></span><br><span class="line">			m.Func,         <span class="comment">// reflect.Value</span></span><br><span class="line">		)</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="指针类型"><a href="#指针类型" class="headerlink" title="指针类型"></a>指针类型</h3><p>指针类型不能调用NumField()方法，这是结构体才能调用的，这时候就要使用Elem()方法来解析指针，相当于对指针类型变量做了*操作获取元素。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> {</span><br><span class="line">	Name <span class="keyword">string</span> <span class="string">`json:"name"`</span></span><br><span class="line">	age  <span class="keyword">int</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">GetName</span><span class="params">()</span> <span class="title">string</span></span> {</span><br><span class="line">	<span class="keyword">return</span> p.Name</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">getAge</span><span class="params">()</span> <span class="title">int</span></span> {</span><br><span class="line">	<span class="keyword">return</span> p.age</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="comment">// 结构体</span></span><br><span class="line">	tom := &amp;Person{Name: <span class="string">"tom"</span>, age: <span class="number">20</span>}</span><br><span class="line">	t := reflect.TypeOf(tom)</span><br><span class="line">	fmt.Println(t, t.Kind()) <span class="comment">// 类型是Person，种类是struct</span></span><br><span class="line">	fmt.Println(<span class="string">"~~~~~~~~~~~~~~~~~~~~~~~~~~~"</span>)</span><br><span class="line">	<span class="comment">// 字段</span></span><br><span class="line">	<span class="comment">// fmt.Println(t.NumField()) //reflect: NumField of non-struct type	*main.Person</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; t.Elem().NumField(); i++ {</span><br><span class="line">		f := t.Elem().Field(i)</span><br><span class="line">		fmt.Println(i, f)</span><br><span class="line">		fmt.Println(</span><br><span class="line">			f.Name,            <span class="comment">// 字段名</span></span><br><span class="line">			f.Index,           <span class="comment">// 字段索引</span></span><br><span class="line">			f.Type,            <span class="comment">// 字段类型</span></span><br><span class="line">			f.Type.Kind(),     <span class="comment">// 字段类型的种类</span></span><br><span class="line">			f.Offset,          <span class="comment">// 相当于结构体首地址该字段值的偏移，string占16字节</span></span><br><span class="line">			f.Anonymous,       <span class="comment">// 是否匿名成员，就是没有名字。注意不要和可见性混淆</span></span><br><span class="line">			f.IsExported(),    <span class="comment">// 是否导出，包外可见否</span></span><br><span class="line">			f.Tag,             <span class="comment">// 本质上就是string类型</span></span><br><span class="line">			f.Tag.Get(<span class="string">"json"</span>), <span class="comment">// 获取结构体字段定义后面反引号部分的tag</span></span><br><span class="line">		)</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 方法，只包括导出的方法，也不包括receiver是该结构体指针的方法</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; t.Elem().NumMethod(); i++ {</span><br><span class="line">		m := t.Method(i)</span><br><span class="line">		fmt.Println(i, m)</span><br><span class="line">		fmt.Println(</span><br><span class="line">			m.Name,         <span class="comment">// 方法名</span></span><br><span class="line">			m.Index,        <span class="comment">// 方法索引</span></span><br><span class="line">			m.Type,         <span class="comment">// 方法类型，函数签名</span></span><br><span class="line">			m.Type.Kind(),  <span class="comment">// 方法类型的种类</span></span><br><span class="line">			m.IsExported(), <span class="comment">// 是否导出。当然未导出的看不到</span></span><br><span class="line">			m.Func,         <span class="comment">// reflect.Value</span></span><br><span class="line">		)</span><br><span class="line">	}</span><br><span class="line">	fmt.Println(<span class="string">"~~~~~~~~~~~~~~~~~~~~~~~~~~~"</span>)</span><br><span class="line">	<span class="comment">// 方法，使用指针访问，可以访问所有receiver的导出的方法</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; t.NumMethod(); i++ {</span><br><span class="line">		m := t.Method(i)</span><br><span class="line">		fmt.Println(i, m)</span><br><span class="line">		fmt.Println(</span><br><span class="line">			m.Name,         <span class="comment">// 方法名</span></span><br><span class="line">			m.Index,        <span class="comment">// 方法索引</span></span><br><span class="line">			m.Type,         <span class="comment">// 方法类型，函数签名</span></span><br><span class="line">			m.Type.Kind(),  <span class="comment">// 方法类型的种类</span></span><br><span class="line">			m.IsExported(), <span class="comment">// 是否导出。当然未导出的看不到</span></span><br><span class="line">			m.Func,         <span class="comment">// reflect.Value</span></span><br><span class="line">		)</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="接口类型"><a href="#接口类型" class="headerlink" title="接口类型"></a>接口类型</h3><p>对于接口类型可以判断是否实现了某个接口。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Runner <span class="keyword">interface</span> {</span><br><span class="line">	run()</span><br><span class="line">}</span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> {</span><br><span class="line">	Name <span class="keyword">string</span> <span class="string">`json:"name"`</span></span><br><span class="line">	Age  <span class="keyword">int</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">// func (Person) run() {</span></span><br><span class="line"><span class="comment">// }</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	tom := Person{<span class="string">"Tom"</span>, <span class="number">20</span>}</span><br><span class="line">	t1 := reflect.TypeOf(tom)</span><br><span class="line">	t2 := reflect.TypeOf((*Runner)(<span class="literal">nil</span>)) <span class="comment">// *Runner的类型</span></span><br><span class="line">	fmt.Println(t2, t2.Kind())</span><br><span class="line">	t3 := t2.Elem() <span class="comment">// 解析指针获得实例的类型</span></span><br><span class="line">	fmt.Println(t3, t3.Kind())</span><br><span class="line">	<span class="keyword">if</span> t1.Implements(t3) {</span><br><span class="line">		fmt.Println(<span class="string">"实现了"</span>)</span><br><span class="line">	} <span class="keyword">else</span> {</span><br><span class="line">		fmt.Println(<span class="string">"未实现"</span>)</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>(*Runner)(nil) 说明：</p><blockquote><p>nil是指针的零值，也就是空指针<br><em>Runner把空指针强制类型转换为</em>Runner类型空指针</p></blockquote><h3 id="Value和原始值"><a href="#Value和原始值" class="headerlink" title="Value和原始值"></a>Value和原始值</h3><p>reflect.Value 与原始值之间可以通过 值包装 和 值获取 相互转化。</p><table><thead><tr><th>方法签名</th><th>说明</th></tr></thead><tbody><tr><td>Interface() interface {}</td><td>将值以 interface{} 类型返回，可以通过<strong>类型断言</strong>转换为指定类型</td></tr><tr><td>Int() int64</td><td>将值以 int64 类型返回，所有有符号整型均可以此方式返回，如果需要的是int类型，则需要强制类型转换</td></tr><tr><td>Uint() uint64</td><td>将值以 uint64 类型返回，所有无符号整型均可以此方式返回</td></tr><tr><td>Float() float64</td><td>将值以双精度（float64）类型返回，所有浮点数（float32、float64）均可以此方式返回</td></tr><tr><td>Bool() bool</td><td>将值以 bool 类型返回</td></tr><tr><td>Bytes() []bytes</td><td>将值以字节数组 []bytes 类型返回</td></tr><tr><td>String() string</td><td>将值以字符串类型返回</td></tr></tbody></table><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">100</span></span><br><span class="line">v := reflect.ValueOf(a) <span class="comment">// 原始值 =&gt; Value，原始值包装</span></span><br><span class="line">i := v.Interface() <span class="comment">// 等价于 var i interface{} = (v's underlying value)，Value =&gt; 原始值，值获取</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">100</span></span><br><span class="line">	v := reflect.ValueOf(a)</span><br><span class="line">	i := v.Interface() <span class="comment">// 等价于 var i interface{} = (v's underlying value)</span></span><br><span class="line">	<span class="comment">// 1 接口类型断言</span></span><br><span class="line">	j := i.(<span class="keyword">int</span>) <span class="comment">// 获得int类型原始值，断言失败panic</span></span><br><span class="line">	fmt.Printf(<span class="string">"%T %[1]d\n"</span>, j)</span><br><span class="line">	j1, isStr := i.(<span class="keyword">string</span>) <span class="comment">// 断言失败与否看isStr，失败不panic</span></span><br><span class="line">	fmt.Println(j1, isStr)</span><br><span class="line">	<span class="comment">// 2 值获取</span></span><br><span class="line">	k := v.Int() <span class="comment">// 返回的是int64</span></span><br><span class="line">	fmt.Printf(<span class="string">"%T %[1]d\n"</span>, k)</span><br><span class="line">	fmt.Println(<span class="keyword">int</span>(k)) <span class="comment">// 强制类型转换为int获得原始值</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="空值和有效性判断"><a href="#空值和有效性判断" class="headerlink" title="空值和有效性判断"></a>空值和有效性判断</h3><table><thead><tr><th>方法签名</th><th>说明</th></tr></thead><tbody><tr><td>IsValid() bool</td><td>判断值是否有效。当值本身非法时，返回 false，例如 reflect.ValueOf(nil).IsValid()就是false常用来判断返回值是否有效</td></tr><tr><td>IsZero() bool</td><td>值是否是零值。如果值无效则panic</td></tr><tr><td>IsNil() bool</td><td>值是否为 nil。必须是chan、func、interface、map、pointer、slice，否则panic。类似于语言层的 v== nil 操作常用来判断指针是否为空</td></tr></tbody></table><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">100</span></span><br><span class="line">	v := reflect.ValueOf(a)</span><br><span class="line">	fmt.Println(</span><br><span class="line">		v.IsValid(), <span class="comment">// true</span></span><br><span class="line">		<span class="comment">// v.IsNil(), // 必须是chan、func、interface、map、pointer、slice，否则panic</span></span><br><span class="line">		v.IsZero(), <span class="comment">// false</span></span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">var</span> b *<span class="keyword">int</span></span><br><span class="line">	v = reflect.ValueOf(b)</span><br><span class="line">	fmt.Println(</span><br><span class="line">		v.IsValid(), <span class="comment">// true</span></span><br><span class="line">		v.IsNil(),   <span class="comment">// true</span></span><br><span class="line">		v.IsZero(),  <span class="comment">// true</span></span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	v = reflect.ValueOf(<span class="literal">nil</span>)</span><br><span class="line">	fmt.Println(</span><br><span class="line">		v.IsValid(), <span class="comment">// false，因为nil是用来给某种类型做零值，直接用nil不知道其类型，所以无效</span></span><br><span class="line">	)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>注意，上例中reflect.ValueOf(nil).IsValid()为false，而reflect.ValueOf(b).IsValid()为true，因为b是有类型的，它是*int不过是空指针罢了，所以有效，而nil不是。</p><h3 id="反射和结构体"><a href="#反射和结构体" class="headerlink" title="反射和结构体"></a>反射和结构体</h3><table><thead><tr><th>方法签名</th><th>说明</th></tr></thead><tbody><tr><td>Field(i int) Value</td><td>根据索引，返回索引对应的结构体成员字段的反射值对象。当值不是结构体或索引超界时panic</td></tr><tr><td>NumField() int</td><td>返回结构体成员字段数量。当值不是结构体或索引超界时发生宕机</td></tr><tr><td>FieldByName(name string) Value</td><td>根据给定字符串返回字符串对应的结构体字段。没有找到时返回零值，当值不是结构体panic</td></tr><tr><td>FieldByIndex(index []int) Value</td><td>多层成员访问时，根据 []int 提供的每个结构体的字段索引，返回字段的值。 没有找到时返回零值，当值不是结构体panic</td></tr><tr><td>Method(i int) Value</td><td>根据索引，返回索引对应的结构体成员方法的反射值对象。当值不是结构体或索引超界时panic</td></tr><tr><td>MethodByName(name string) Value</td><td>根据给定字符串返回字符串对应的结构体方法。没有找到时返回零值，当值不是结构体panic</td></tr></tbody></table><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> {</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	age  <span class="keyword">int</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p person)</span> <span class="title">GetName</span><span class="params">()</span> <span class="title">string</span></span> {</span><br><span class="line">	<span class="keyword">return</span> p.name</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="keyword">var</span> a = person{}</span><br><span class="line">	a.name = <span class="string">"tom"</span></span><br><span class="line">	<span class="comment">// a.age = 100</span></span><br><span class="line">	v := reflect.ValueOf(a)</span><br><span class="line">	t := v.Type()</span><br><span class="line">	fmt.Println(v, t, t.Kind())</span><br><span class="line">	fmt.Println(<span class="string">"~~~~~~~~~~~~~~~~~~~~~~~~~~~"</span>)</span><br><span class="line">	<span class="comment">// 下面使用Type和Value遍历字段的区别</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; t.NumField(); i++ {</span><br><span class="line">		f := t.Field(i)</span><br><span class="line">		fmt.Println(</span><br><span class="line">			f.Name, f.Index, f.Offset,</span><br><span class="line">			f.Anonymous, f.IsExported(), <span class="comment">// Type字段类型信息</span></span><br><span class="line">		)</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; v.NumField(); i++ {</span><br><span class="line">		f := v.Field(i)</span><br><span class="line">		fmt.Println(i, f.IsValid(), f.IsZero()) <span class="comment">// Value关注字段的值</span></span><br><span class="line">	}</span><br><span class="line">	fmt.Println(<span class="string">"~~~~~~~~~~~~~~~~~~~~~~~~~~~"</span>)</span><br><span class="line">	fmt.Println(</span><br><span class="line">		v.FieldByName(<span class="string">"name"</span>).IsZero(),            <span class="comment">// 通过v找底层结构体的name字段</span></span><br><span class="line">		v.Field(<span class="number">1</span>).IsValid(), v.Field(<span class="number">1</span>).IsZero(), <span class="comment">// 字段age</span></span><br><span class="line">		v.FieldByIndex([]<span class="keyword">int</span>{<span class="number">1</span>}).IsValid(),  <span class="comment">// 字段age</span></span><br><span class="line">		v.FieldByName(<span class="string">"score"</span>).IsValid(),    <span class="comment">// score字段不存在，无效</span></span><br><span class="line">		v.MethodByName(<span class="string">"GetName"</span>).IsValid(), <span class="comment">// GetName方法不存在，无效</span></span><br><span class="line">	)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>反射调用函数</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> {</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	age  <span class="keyword">int</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p person)</span> <span class="title">GetName</span><span class="params">(prefix, suffix <span class="keyword">string</span>)</span> <span class="title">string</span></span> {</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">"%s %s %s"</span>, prefix, p.name, suffix)</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="keyword">var</span> a = person{}</span><br><span class="line">	a.name = <span class="string">"tom"</span></span><br><span class="line">	<span class="comment">// a.age = 100</span></span><br><span class="line">	v := reflect.ValueOf(a)         <span class="comment">// 结构体的Value</span></span><br><span class="line">	vf := v.MethodByName(<span class="string">"GetName"</span>) <span class="comment">// 函数的Value</span></span><br><span class="line">	fmt.Println(v, vf)</span><br><span class="line">	<span class="comment">// 构建参数列表，需要2个入参</span></span><br><span class="line">	p1 := reflect.ValueOf(<span class="string">"!!"</span>)</span><br><span class="line">	p2 := reflect.ValueOf(<span class="string">"##"</span>)</span><br><span class="line">	inParams := []reflect.Value{p1, p2}</span><br><span class="line">	outParams := vf.Call(inParams) <span class="comment">// Call调用需要[]reflect.Value的参数列表</span></span><br><span class="line">	fmt.Println(outParams)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="反射修改值"><a href="#反射修改值" class="headerlink" title="反射修改值"></a>反射修改值</h3><table><thead><tr><th>方法签名</th><th>说明</th></tr></thead><tbody><tr><td>Elem() Value</td><td>取值指向的元素值，类似于语言层 * 操作。当值类型不是指针或接口时panic，空指针时返回 nil 的 Value</td></tr><tr><td>Addr() Value</td><td>对可寻址的值返回其地址，类似于语言层 &amp; 操作。当值不可寻址时panic</td></tr><tr><td>CanAddr() bool</td><td>表示值是否可寻址</td></tr><tr><td>CanSet() bool</td><td>返回值能否被修改。要求值可寻址且是导出的字段</td></tr><tr><td>Set(x Value)</td><td>将值设置为传入的反射值对象的值</td></tr><tr><td>Setlnt(x int64)</td><td>使用 int64 设置值。当值的类型不是 int、int8、int16、 int32、int64 时会发生宕机</td></tr><tr><td>SetUint(x uint64)</td><td>使用 uint64 设置值。当值的类型不是 uint、uint8、uint16、uint32、uint64时分发生宕机</td></tr><tr><td>SetFloat(x float64)</td><td>使用 float64 设置值。当值的类型不是 float32、float64 时会发生宕机</td></tr><tr><td>SetBool(x bool)</td><td>使用 bool 设置值。当值的类型不是 bod 时会发生宕机</td></tr><tr><td>SetBytes(x []byte)</td><td>设置字节数组 []bytes值。当值的类型不是 []byte 时会发生宕机</td></tr><tr><td>SetString(x string)</td><td>设置字符串值。当值的类型不是 string 时会发生宕机</td></tr></tbody></table><p>如果CanSet() 返回false，调用以上Set*方法都会panic</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可被寻址</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">100</span></span><br><span class="line">	v := reflect.ValueOf(&amp;a).Elem()      <span class="comment">// a指针指向的元素的Value</span></span><br><span class="line">	fmt.Println(v.CanAddr(), v.CanSet()) <span class="comment">// true true</span></span><br><span class="line">	v.SetInt(<span class="number">200</span>)</span><br><span class="line">	fmt.Println(v, <span class="keyword">int</span>(v.Int()))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可被导出</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> {</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	age  <span class="keyword">int</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	v := reflect.ValueOf(&amp;person{Name: <span class="string">"Tom"</span>, age: <span class="number">20</span>})</span><br><span class="line">	vf1 := v.Elem().FieldByName(<span class="string">"Name"</span>)           <span class="comment">// 导出字段</span></span><br><span class="line">	fmt.Println(vf1, vf1.CanAddr(), vf1.CanSet()) <span class="comment">// true true</span></span><br><span class="line">	vf1.SetString(<span class="string">"Jerry"</span>)                        <span class="comment">// 成功修改</span></span><br><span class="line">	vf2 := v.Elem().FieldByName(<span class="string">"age"</span>)            <span class="comment">// 未导出字段</span></span><br><span class="line">	fmt.Println(vf2, vf2.CanAddr(), vf2.CanSet()) <span class="comment">// true false</span></span><br><span class="line">	<span class="comment">// vf2.SetInt(30) // reflect.Value.SetInt using value obtained using unexported</span></span><br><span class="line">	fmt.Println(v) <span class="comment">// 名字已经变成了Jerry了</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="反射创建实例"><a href="#反射创建实例" class="headerlink" title="反射创建实例"></a>反射创建实例</h3><p>需要用到 <code>reflect.New(typ reflect.Type) reflect.Value</code> ，简单讲就是将<code>Type New</code>成<code>Value</code>。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">100</span></span><br><span class="line">	t := reflect.TypeOf(a)                       <span class="comment">// 提取类型信息</span></span><br><span class="line">	v := reflect.New(t)                          <span class="comment">// 创建一个该类型的新的零值返回指针的Value，相当于new(int)</span></span><br><span class="line">	fmt.Println(v, v.Elem(), v.Type(), v.Kind()) <span class="comment">// 内存地址 0 *int ptr</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><script>document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });</script></div><div><div><div style="text-align:center;color:#ccc;font-size:14px">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div></div></div><div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/Go/" rel="tag"><i class="fa fa-tag"></i> Go</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2023/04/05/go-biao-zhun-ku-shi-jian-chu-li/" rel="next" title="Go 标准库时间处理"><i class="fa fa-chevron-left"></i> Go 标准库时间处理</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2023/04/11/go-jia-jie-mi/" rel="prev" title="Go 加解密">Go 加解密 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"><div class="jiathis_style"><span class="jiathis_txt">分享到：</span> <a class="jiathis_button_fav">收藏夹</a> <a class="jiathis_button_copy">复制网址</a> <a class="jiathis_button_email">邮件</a> <a class="jiathis_button_weixin">微信</a> <a class="jiathis_button_qzone">QQ空间</a> <a class="jiathis_button_tqq">腾讯微博</a> <a class="jiathis_button_douban">豆瓣</a> <a class="jiathis_button_share">一键分享</a> <a href="http://www.jiathis.com/share?uid=2140465" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank">更多</a> <a class="jiathis_counter_style"></a></div><script type="text/javascript">var jiathis_config={data_track_clickback:!0,summary:"",shortUrl:!1,hideMore:!1}</script><script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=" charset="utf-8"></script></div></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div id="sidebar-dimmer"></div><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/images/chen.png" alt="Zhongzhou Chen"><p class="site-author-name" itemprop="name">Zhongzhou Chen</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/%7C%7C%20archive"><span class="site-state-item-count">371</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">89</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">188</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Go-反射"><span class="nav-text">Go 反射</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Type和Value方法"><span class="nav-text">Type和Value方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Type和Value拥有的同名方法"><span class="nav-text">Type和Value拥有的同名方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Type独有的方法"><span class="nav-text">Type独有的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Value独有的方法"><span class="nav-text">Value独有的方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实例"><span class="nav-text">实例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#结构体Type"><span class="nav-text">结构体Type</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#指针类型"><span class="nav-text">指针类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#接口类型"><span class="nav-text">接口类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Value和原始值"><span class="nav-text">Value和原始值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#空值和有效性判断"><span class="nav-text">空值和有效性判断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#反射和结构体"><span class="nav-text">反射和结构体</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#反射修改值"><span class="nav-text">反射修改值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#反射创建实例"><span class="nav-text">反射创建实例</span></a></li></ol></li></ol></div></div></section><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span id="scrollpercent"><span>0</span>%</span></div></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="copyright">&copy; <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">Zhongzhou Chen</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-area-chart"></i> </span><span class="post-meta-item-text">Site words total count&#58;</span> <span title="Site words total count">863.9k</span></div><span class="post-meta-divider"></span></div></footer></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><style>.copy-btn{display:inline-block;padding:6px 12px;font-size:13px;font-weight:700;line-height:20px;color:#333;white-space:nowrap;vertical-align:middle;cursor:pointer;background-color:#eee;background-image:linear-gradient(#fcfcfc,#eee);border:1px solid #d5d5d5;border-radius:3px;user-select:none;outline:0}.highlight-wrap .copy-btn{transition:opacity .3s ease-in-out;opacity:0;padding:2px 6px;position:absolute;right:4px;top:8px}.highlight-wrap .copy-btn:focus,.highlight-wrap:hover .copy-btn{opacity:1}.highlight-wrap{position:relative}</style><script>$(".highlight").each(function(t,e){var n=$("<div>").addClass("highlight-wrap");$(e).after(n),n.append($("<button>").addClass("copy-btn").append("复制").on("click",function(t){var e=$(this).parent().find(".code").find(".line").map(function(t,e){return $(e).text()}).toArray().join("\n"),n=document.createElement("textarea");document.body.appendChild(n),n.style.position="absolute",n.style.top="0px",n.style.left="0px",n.value=e,n.select(),n.focus();var o=document.execCommand("copy");document.body.removeChild(n),o?$(this).text("复制成功"):$(this).text("复制失败"),$(this).blur()})).on("mouseleave",function(t){var e=$(this).find(".copy-btn");setTimeout(function(){e.text("复制")},300)}).append(e)})</script><script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script><script type="text/javascript">function proceedsearch(){$("body").append('<div class="search-popup-overlay local-search-pop-overlay"></div>').css("overflow","hidden"),$(".search-popup-overlay").click(onPopupClose),$(".popup").toggle();var t=$("#local-search-input");t.attr("autocapitalize","none"),t.attr("autocorrect","off"),t.focus()}var isfetched=!1,isXml=!0,search_path="search.xml";0===search_path.length?search_path="search.xml":/json$/i.test(search_path)&&(isXml=!1);var path="/"+search_path,onPopupClose=function(t){$(".popup").hide(),$("#local-search-input").val(""),$(".search-result-list").remove(),$("#no-result").remove(),$(".local-search-pop-overlay").remove(),$("body").css("overflow","")},searchFunc=function(t,e,o){"use strict";$("body").append('<div class="search-popup-overlay local-search-pop-overlay"><div id="search-loading-icon"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div>').css("overflow","hidden"),$("#search-loading-icon").css("margin","20% auto 0 auto").css("text-align","center"),$.ajax({url:t,dataType:isXml?"xml":"json",async:!0,success:function(t){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var n=isXml?$("entry",t).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get():t,r=document.getElementById(e),s=document.getElementById(o),a=function(){var t=r.value.trim().toLowerCase(),e=t.split(/[\s\-]+/);e.length>1&&e.push(t);var o=[];if(t.length>0&&n.forEach(function(n){function r(e,o,n,r){for(var s=r[r.length-1],a=s.position,i=s.word,l=[],h=0;a+i.length<=n&&0!=r.length;){i===t&&h++,l.push({position:a,length:i.length});var p=a+i.length;for(r.pop();0!=r.length&&(s=r[r.length-1],a=s.position,i=s.word,p>a);)r.pop()}return c+=h,{hits:l,start:o,end:n,searchTextCount:h}}function s(t,e){var o="",n=e.start;return e.hits.forEach(function(e){o+=t.substring(n,e.position);var r=e.position+e.length;o+='<b class="search-keyword">'+t.substring(e.position,r)+"</b>",n=r}),o+=t.substring(n,e.end)}var a=!1,i=0,c=0,l=n.title.trim(),h=l.toLowerCase(),p=n.content.trim().replace(/<[^>]+>/g,""),u=p.toLowerCase(),f=decodeURIComponent(n.url),d=[],g=[];if(""!=l&&(e.forEach(function(t){function e(t,e,o){var n=t.length;if(0===n)return[];var r=0,s=[],a=[];for(o||(e=e.toLowerCase(),t=t.toLowerCase());(s=e.indexOf(t,r))>-1;)a.push({position:s,word:t}),r=s+n;return a}d=d.concat(e(t,h,!1)),g=g.concat(e(t,u,!1))}),(d.length>0||g.length>0)&&(a=!0,i=d.length+g.length)),a){[d,g].forEach(function(t){t.sort(function(t,e){return e.position!==t.position?e.position-t.position:t.word.length-e.word.length})});var v=[];0!=d.length&&v.push(r(l,0,l.length,d));for(var $=[];0!=g.length;){var C=g[g.length-1],m=C.position,x=C.word,w=m-20,y=m+80;0>w&&(w=0),y<m+x.length&&(y=m+x.length),y>p.length&&(y=p.length),$.push(r(p,w,y,g))}$.sort(function(t,e){return t.searchTextCount!==e.searchTextCount?e.searchTextCount-t.searchTextCount:t.hits.length!==e.hits.length?e.hits.length-t.hits.length:t.start-e.start});var T=parseInt("1");T>=0&&($=$.slice(0,T));var b="";b+=0!=v.length?"<li><a href='"+f+"' class='search-result-title'>"+s(l,v[0])+"</a>":"<li><a href='"+f+"' class='search-result-title'>"+l+"</a>",$.forEach(function(t){b+="<a href='"+f+'\'><p class="search-result">'+s(p,t)+"...</p></a>"}),b+="</li>",o.push({item:b,searchTextCount:c,hitCount:i,id:o.length})}}),1===e.length&&""===e[0])s.innerHTML='<div id="no-result"><i class="fa fa-search fa-5x" /></div>';else if(0===o.length)s.innerHTML='<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>';else{o.sort(function(t,e){return t.searchTextCount!==e.searchTextCount?e.searchTextCount-t.searchTextCount:t.hitCount!==e.hitCount?e.hitCount-t.hitCount:e.id-t.id});var a='<ul class="search-result-list">';o.forEach(function(t){a+=t.item}),a+="</ul>",s.innerHTML=a}};r.addEventListener("input",a),$(".local-search-pop-overlay").remove(),$("body").css("overflow",""),proceedsearch()}})};$(".popup-trigger").click(function(t){t.stopPropagation(),isfetched===!1?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(onPopupClose),$(".popup").click(function(t){t.stopPropagation()}),$(document).on("keyup",function(t){var e=27===t.which&&$(".search-popup").is(":visible");e&&onPopupClose()})</script><script type="text/javascript" src="/js/src/love.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,log:!1,model:{jsonPath:"/live2dw/assets/shizuku.model.json"},display:{position:"right"},mobile:{show:!0,scale:.2},react:{opacityDefault:.7,opacityOnHover:.2,opacity:.4}})</script></body></html><!-- rebuild by neat -->