<!-- build time:Wed Oct 30 2019 10:39:08 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html class="theme-next gemini use-motion" lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script><link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet"><script></script><meta name="theme-color" content="#222"><style>.pace .pace-progress{background:#1E92FB;height:3px}.pace .pace-progress-inner{box-shadow:0 0 10px #1E92FB,0 0 5px #1E92FB}.pace .pace-activity{border-top-color:#1E92FB;border-left-color:#1E92FB}</style><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4"><link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222"><meta name="keywords" content="docker,"><link rel="alternate" href="/atom.xml" title="凡间的精灵" type="application/atom+xml"><meta name="description" content="一、Docker简介Docker是什么?Docker的英文本意是“搬运工”，在程序员的世界里，Docker搬运的是集装箱（Container），集装箱里装的是任意类型的App，开发者通过Docker可以将App变成一种标准化的、可移植的、自管理的组件，可以在任何主流系统中开发、调试和运行。说白了,docker是一种用了新颖方式实现的轻量级虚拟机,类似于VM,但是在原理和应用上和VM的差别还是很大的"><meta name="keywords" content="docker"><meta property="og:type" content="article"><meta property="og:title" content="docker镜像、容器管理"><meta property="og:url" content="http:&#x2F;&#x2F;chenzhonzhou.github.io&#x2F;2018&#x2F;09&#x2F;05&#x2F;docker-jing-xiang-rong-qi-guan-li&#x2F;index.html"><meta property="og:site_name" content="凡间的精灵"><meta property="og:description" content="一、Docker简介Docker是什么?Docker的英文本意是“搬运工”，在程序员的世界里，Docker搬运的是集装箱（Container），集装箱里装的是任意类型的App，开发者通过Docker可以将App变成一种标准化的、可移植的、自管理的组件，可以在任何主流系统中开发、调试和运行。说白了,docker是一种用了新颖方式实现的轻量级虚拟机,类似于VM,但是在原理和应用上和VM的差别还是很大的"><meta property="og:locale" content="zh-Hans"><meta property="og:image" content="https:&#x2F;&#x2F;img2018.cnblogs.com&#x2F;blog&#x2F;1829796&#x2F;201910&#x2F;1829796-20191022105823671-1553838987.png"><meta property="og:image" content="https:&#x2F;&#x2F;img2018.cnblogs.com&#x2F;blog&#x2F;1829796&#x2F;201910&#x2F;1829796-20191022110500682-916327167.png"><meta property="og:image" content="https:&#x2F;&#x2F;img2018.cnblogs.com&#x2F;blog&#x2F;1829796&#x2F;201910&#x2F;1829796-20191022110512127-968965811.png"><meta property="og:image" content="https:&#x2F;&#x2F;img2018.cnblogs.com&#x2F;blog&#x2F;1829796&#x2F;201910&#x2F;1829796-20191022110524969-1070377586.png"><meta property="og:image" content="https:&#x2F;&#x2F;img2018.cnblogs.com&#x2F;blog&#x2F;1829796&#x2F;201910&#x2F;1829796-20191022110535409-1799935510.png"><meta property="og:image" content="https:&#x2F;&#x2F;img2018.cnblogs.com&#x2F;blog&#x2F;1829796&#x2F;201910&#x2F;1829796-20191022110543385-1355070567.png"><meta property="og:image" content="https:&#x2F;&#x2F;img2018.cnblogs.com&#x2F;blog&#x2F;1829796&#x2F;201910&#x2F;1829796-20191022110637478-664814624.png"><meta property="og:image" content="https:&#x2F;&#x2F;img2018.cnblogs.com&#x2F;blog&#x2F;1829796&#x2F;201910&#x2F;1829796-20191022110650983-1343036792.png"><meta property="og:image" content="https:&#x2F;&#x2F;img2018.cnblogs.com&#x2F;blog&#x2F;1829796&#x2F;201910&#x2F;1829796-20191022110738858-1203258864.png"><meta property="og:image" content="https:&#x2F;&#x2F;img2018.cnblogs.com&#x2F;blog&#x2F;1829796&#x2F;201910&#x2F;1829796-20191022110749689-485534913.png"><meta property="og:image" content="https:&#x2F;&#x2F;img2018.cnblogs.com&#x2F;blog&#x2F;1829796&#x2F;201910&#x2F;1829796-20191022110800024-2009126343.png"><meta property="og:image" content="https:&#x2F;&#x2F;img2018.cnblogs.com&#x2F;blog&#x2F;1829796&#x2F;201910&#x2F;1829796-20191022110908741-1979087383.png"><meta property="og:updated_time" content="2019-10-23T02:18:04.501Z"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https:&#x2F;&#x2F;img2018.cnblogs.com&#x2F;blog&#x2F;1829796&#x2F;201910&#x2F;1829796-20191022105823671-1553838987.png"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Gemini",version:"5.1.4",sidebar:{position:"left",display:"always",offset:12,b2t:!0,scrollpercent:!0,onmobile:!0},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://chenzhonzhou.github.io/2018/09/05/docker-jing-xiang-rong-qi-guan-li/"><title>docker镜像、容器管理 | 凡间的精灵</title><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">凡间的精灵</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">凡尘落素一精灵</p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives" rel="section"><i class="menu-item-icon fa fa-fw fa-question-circle"></i><br>归档</a></li><li class="menu-item menu-item-categories"><a href="/categories" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-about"><a href="/about" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i> </span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://chenzhonzhou.github.io/2018/09/05/docker-jing-xiang-rong-qi-guan-li/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Zhongzhou Chen"><meta itemprop="description" content=""><meta itemprop="image" content="/images/chen.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="凡间的精灵"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">docker镜像、容器管理</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-05T12:07:11+08:00">2018-09-05 </time></span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/docker/" itemprop="url" rel="index"><span itemprop="name">docker</span></a></span></span><div class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">11.8k </span><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">46</span></div></div></header><div class="post-body" itemprop="articleBody"><h3 id="一、Docker简介"><a href="#一、Docker简介" class="headerlink" title="一、Docker简介"></a>一、Docker简介</h3><h5 id="Docker是什么"><a href="#Docker是什么" class="headerlink" title="Docker是什么?"></a>Docker是什么?</h5><p>Docker的英文本意是“搬运工”，在程序员的世界里，Docker搬运的是集装箱（Container），集装箱里装的是任意类型的App，开发者通过Docker可以将App变成一种标准化的、可移植的、自管理的组件，可以在任何主流系统中开发、调试和运行。</p><p>说白了,docker是一种用了新颖方式实现的轻量级虚拟机,类似于VM,但是在原理和应用上和VM的差别还是很大的.并且docker的专业叫法是应用容器(Application Container)。</p><p>为啥要用容器?<br>应用容器是个啥样子呢,一个做好的应用容器长得就像一个装好了一组特定应用的虚拟机一样,比如我现在想用mysql,那我就找个装好了mysql的容器就可以了,然后运行起来,我就能使用mysql了。</p><p>为啥不能直接安装一个mysql?安装一个SQL Server也可以啊,可是有的时候根据每个人电脑的不同,在安装的时候可能会报出各种各样的错误,万一你的机器中毒了,你的电脑挂了,你所有的服务都需要重新安装.但是有了docker,或者说有了容器就不同了,你就相当于有了一个可以运行起来的虚拟机,只要你能运行容器,mysql的配置就省了.而且如果你想换个电脑,直接把容器”端过来”就可以使用容器里面的服务.</p><p>Docker 基于 Go 语言开发，代码托管在Github上，并遵循Apache 2.0 开源协议。Docker 容器可以封装任何有效负载，几乎可以在任何服务器之间进行一致性运行。换句话说，开发者构建的应用只需一次构建即可多平台运行。运营人员只需配置他们的服务，即可运行所有的应用。</p><p>若是利用容器的话,那么开发直接在容器里开发,测试的时候把整个容器给测试,测好了把测试后容器再上线就好了.通过容器,整个开发,测试和生产环境可以保持高度一致。</p><p>此外容器也VM一样具有一定得隔离性,各个容器之间的数据和内存空间相互隔离,可以保证一定的安全性。</p><p>Hyper-V、KVM和Xen等虚拟机管理程序都“基于虚拟化硬件仿真机制。这意味着，它们对系统要求很高.然而，容器却使用共享的操作系统。这意味着它们在使用系统资源方面比虚拟机管理程序要高效得多。容器不是对硬件进行虚拟化处理，而是驻留在一个Linux实例上。<br>Docker可以解决虚拟机能够解决的问题，同时也能够解决虚拟机由于资源要求过高而无法解决的问题。</p><h5 id="为什么要使用docker？"><a href="#为什么要使用docker？" class="headerlink" title="为什么要使用docker？"></a>为什么要使用docker？</h5><h6 id="1-、快速交付应用程序"><a href="#1-、快速交付应用程序" class="headerlink" title="1 、快速交付应用程序"></a>1 、快速交付应用程序</h6><p>•开发者使用一个标准的 image 来构建开发容器，开发完成之后，系统管理员就可以使用这个容器来部署代码<br>•docker可以快速创建容器，快速迭代应用程序，并让整个过程可见，使团队中的其他成员更容易理解应用程序是如何创建和工作的。<br>•docker容器很轻！很快！容器的启动时间是次秒级的，节约开发、测试、部署的时间</p><h6 id="2-、更容易部署和扩展"><a href="#2-、更容易部署和扩展" class="headerlink" title="2 、更容易部署和扩展"></a>2 、更容易部署和扩展</h6><p>•docker容器可以在几乎所有的环境中运行，物理机、虚拟机、公有云、私有云、个人电脑、服务器等等。<br>•docker容器兼容很多平台，这样就可以把一个应用程序从一个平台迁移到另外一个。</p><h6 id="3-、效率更高"><a href="#3-、效率更高" class="headerlink" title="3 、效率更高"></a>3 、效率更高</h6><p>•docker容器不需要 hypervisor ，他是内核级的虚拟化。</p><h6 id="4-、快速部署也意味着更简单的管理"><a href="#4-、快速部署也意味着更简单的管理" class="headerlink" title="4 、快速部署也意味着更简单的管理"></a>4 、快速部署也意味着更简单的管理</h6><p>•通常只需要小小的改变就可以替代以往巨型和大量的更新工作。</p><ul><li>Docker 的常用案例包括：<br> 自动打包和部署应用<br> 创建轻量、私有的 PaaS 环境<br> 自动化测试和持续集成/部署<br> 部署并扩展 Web 应用、数据库和后端服务器</li></ul><h5 id="那么为啥不用VM"><a href="#那么为啥不用VM" class="headerlink" title="那么为啥不用VM?"></a>那么为啥不用VM?</h5><p>那么既然容器和VM这么类似为啥不用VM?docker容器相对于VM还是有很多优点的:<br>1.启动速度快,容器通常在一秒内可以启动.而VM要很久.<br>2.资源利用率高,一台普通服务器可以跑上千个容器，而跑VM就。。。。。。<br>3.性能开销小,VM需要额外的CPU和内存来完成OS的功能,这一部分占据了额外的资源.</p><p>为啥相似的功能在性能上会有如此巨大的差距呢?看一下他们的设计图,先看VM的:</p><p>下面的图片比较了 Docker 和传统虚拟化方式的不同之处，<br><img src="https://img2018.cnblogs.com/blog/1829796/201910/1829796-20191022105823671-1553838987.png" alt></p><p>可见容器是在操作系统层面上实现虚拟化，直接复用本地主机的操作系统，而传统方式则是在硬件层面实现。</p><p>Docker优势和劣势<br>作为一种新兴的虚拟化方式，Docker 跟传统的虚拟化方式相比具有众多的优势。<br>首先，Docker 容器的启动可以在秒级实现，这相比传统的虚拟机方式要快得多。<br>其次，Docker 对系统资源的利用率很高，一台主机上可以同时运行数千个 Docker 容器。<br>容器除了运行其中应用外，基本不消耗额外的系统资源，使得应用的性能很高，同时系统的开销尽量小。传统虚拟机方式运行 10 个不同的应用就要起 10 个虚拟机，而 Docker 只需要启动 10 个隔离的应用即可。</p><p>具体说来，Docker 在如下几个方面具有较大的优势。<br>更快速的交付和部署<br>对开发和运维（devop）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。开发者可以使用一个标准的镜像来构建一套开发容器，开发完成之后，运维人员可以直接使用这个容器来部署代码。 Docker 可以快速创建容器，快速迭代应用程序，并让整个过程全程可见，使团队中的其他成员更容易理解应用程序是如何创建和工作的。 Docker 容器很轻很快！容器的启动时间是秒级的，大量地节约开发、测试、部署的时间。<br>更高效的虚拟化<br>Docker 容器的运行不需要额外的 hypervisor 支持，它是内核级的虚拟化，因此可以实现更高的性能和效率。<br>更轻松的迁移和扩展<br>Docker 容器几乎可以在任意的平台上运行，包括物理机、虚拟机、公有云、私有云、个人电脑、服务器等。这种兼容性可以让用户把一个应用程序从一个平台直接迁移到另外一个。<br>更简单的管理<br>使用 Docker，只需要小小的修改，就可以替代以往大量的更新工作。所有的修改都以增量的方式被分发和更新，从而实现自动化并且高效的管理。</p><p>对比传统虚拟机总结<br>| 特性 | 容器 | 虚拟机 |<br>| ———- | —————— | ————– |<br>| 启动 | 秒级 | 分钟级 |<br>| 硬盘使用 | 一般为MB | 一般为GB |<br>| 性能 | 接近原生 | 弱于 |<br>| 系统支持量 | 单机支持上千个容器 | 单机最多几十个 |</p><h3 id="二、Docker-的体系结构"><a href="#二、Docker-的体系结构" class="headerlink" title="二、Docker 的体系结构"></a>二、Docker 的体系结构</h3><p>docker使用C/S 架构，docker daemon 作为 server 端接受 client 的请求，并处理（创建、运行、分发容器），他们可以运行在一个机器上，也通过 socket或者 RESTful API 通信<br><img src="https://img2018.cnblogs.com/blog/1829796/201910/1829796-20191022110500682-916327167.png" alt></p><p>Docker daemon 一般在宿主主机后台运行。<br>Docker client以系统命令的形式存在，用户用docker命令来跟docker daemon 交互。</p><p>Docker 守护进程（Docker daemon）<br>如上图所示，Docker 守护进程运行在一台主机上。用户并不直接和守护进程进行交互，而是通过 Docker 客户端间接和其通信。<br>Docker 客户端（Docker client）<br>Docker 客户端，实际上是docker的二进制程序，是用户与 Docker 交互方式。它接收用户指令并且与背后的 Docker 守护进程通信。<br><img src="https://img2018.cnblogs.com/blog/1829796/201910/1829796-20191022110512127-968965811.png" alt></p><h5 id="Docker-内部："><a href="#Docker-内部：" class="headerlink" title="Docker 内部："></a>Docker 内部：</h5><p>要理解 Docker 内部构建，需要理解以下三种部件：<br>1)Docker 镜像 - Docker images<br>2)Docker 仓库 - Docker registeries<br>3)Docker 容器 - Docker containers</p><h5 id="1、Docker-镜像-："><a href="#1、Docker-镜像-：" class="headerlink" title="1、Docker 镜像 ："></a>1、Docker 镜像 ：</h5><p>Docker 镜像是 Docker 容器运行时的只读模板，镜像可以用来创建 Docker 容器。每一个镜像由一系列的层 (layers) 组成。Docker 使用UnionFS（联合文件系统）来将这些层联合到单独的镜像中。UnionFS允许独立文件系统中的文件和文件夹(称之为分支)被透明覆盖，形成一个单独连贯的文件系统。正因为有了这些层的存在，Docker 是如此的轻量。当你改变了一个 Docker 镜像，比如升级到某个程序到新的版本，一个新的层会被创建。因此，不用替换整个原先的镜像或者重新建立(在使用虚拟机的时候你可能会这么做)，只是一个新的层被添加或升级了。现在你不用重新发布整个镜像，只需要升级，层使得分发 Docker 镜像变得简单和快速。<br>每个docker都有很多层次构成，docker使用 union file systems 将这些不同的层结合到一个image 中去。<br>例如：centos镜像中安装nginx，就成了nginx镜像”，其实在此时Docker镜像的层级概念就体现出来了。底层一个centos操作系统镜像，上面叠加一个ngnx层，就完成了一个nginx镜像的构建。层级概念就不难理解，此时我们一般centos操作系统镜像称为nginx镜像层的父镜像。<br><img src="https://img2018.cnblogs.com/blog/1829796/201910/1829796-20191022110524969-1070377586.png" alt></p><h5 id="2、Docker-仓库-："><a href="#2、Docker-仓库-：" class="headerlink" title="2、Docker 仓库 ："></a>2、Docker 仓库 ：</h5><p>Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。同样的，Docker 仓库也有公有和私有的概念。公有的 Docker 仓库名字是 Docker Hub。Docker Hub 提供了庞大的镜像集合供使用。这些镜像可以是自己创建，或者在别人的镜像基础上创建。<br>仓库是集中存放镜像文件的场所。有时候会把仓库和仓库注册服务器（Registry）混为一谈，并不严格区分。实际上，仓库注册服务器上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签（tag）。</p><p>仓库分为公开仓库（Public）和私有仓库（Private）两种形式，最大的公开仓库是 Docker Hub，存放了数量庞大的镜像供用户下载。国内的公开仓库包括 Docker Pool等，可以提供大陆用户更稳定快速的访问。</p><p>当然，用户也可以在本地网络内创建一个私有仓库。当用户创建了自己的镜像之后就可以使用push命令将它上传到公有或者私有仓库，这样下次在另外一台机器上使用这个镜像时候，只需要从仓库上pull下来就可以了。<br>*注：Docker 仓库的概念跟Git类似，注册服务器可以理解为 GitHub 这样的托管服务。</p><h5 id="3、Docker-容器-："><a href="#3、Docker-容器-：" class="headerlink" title="3、Docker 容器 ："></a>3、Docker 容器 ：</h5><p>Docker 容器用来运行应用，一个Docker容器包含了所有的某个应用运行所需要的环境。每一个 Docker 容器都是从 Docker 镜像创建的。Docker 容器可以运行、开始、停止、移动和删除。每一个 Docker 容器都是独立和安全的应用平台。<br>容器是从镜像创建的运行实例。它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。<br>可以把容器看做是一个简易版的 Linux 环境（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。<br>*注：镜像是只读的，容器在启动的时候创建一层可写层作为最上层。<br><img src="https://img2018.cnblogs.com/blog/1829796/201910/1829796-20191022110535409-1799935510.png" alt></p><p>与虚拟机相比，容器有一个很大的差异，它们被设计用来运行”单进程”，无法很好地模拟一个完整的环境。Docker设计者极力推崇“一个容器一个进程的方式”，如果你要选择在一个容器中运行多个进程，那唯一情况是：出于调试目的。<br>容器是设计来运行一个应用的，而非一台机器。你可能会把容器当虚拟机用，但你将失去很多的灵活性，因为Docker提供了用于分离应用与数据的工具，使得你可以快捷地更新运行中的代码/系统，而不影响数据。<br>Docker 从 0.9 版本开始使用 libcontainer 替代 lxc，libcontainer 和 Linux 系统的交互图如下：<br><img src="https://img2018.cnblogs.com/blog/1829796/201910/1829796-20191022110543385-1355070567.png" alt></p><p>Docker 底层技术<br>docker底层的 2 个核心技术分别是 Namespaces 和 Control groups<br>Namespaces用来隔离各个容器</p><h6 id="1-pid-namespace"><a href="#1-pid-namespace" class="headerlink" title="1)pid namespace"></a>1)pid namespace</h6><p>不同用户的进程就是通过pid namespace 隔离开的，且不同 namespace 中可以有相同pid。所有的LXC进程在docker中的父进程为docker进程，每个lxc进程具有不同的 namespace 。</p><h6 id="2-net-namespace"><a href="#2-net-namespace" class="headerlink" title="2) net namespace"></a>2) net namespace</h6><p>有了pid namespace, 每个 namespace 中的pid能够相互隔离，但是网络端口还是共享 host 的端口。网络隔离是通过 net namespace 实现的，每个 net namespace 有独立的 network devices, IP addresses, IP routing tables, /proc/net 目录。这样每个 container 的网络就能隔离开来。docker默认采用veth的方式将 container 中的虚拟网卡同 host 上的一个docker bridge: docker0 连接在一起。</p><h6 id="3-ipc-namespace"><a href="#3-ipc-namespace" class="headerlink" title="3) ipc namespace"></a>3) ipc namespace</h6><p>container 中进程交互还是采用linux常见的进程间交互方法 (interprocess communication - IPC),包括常见的信号量、消息队列和共享内存。container 的进程间交互实际上还是host 上具有相同pid namespace 中的进程间交互。</p><h6 id="4-mnt-namespace"><a href="#4-mnt-namespace" class="headerlink" title="4) mnt namespace"></a>4) mnt namespace</h6><p>类似chroot，将一个进程放到一个特定的目录执行。mnt namespace 允许不同 namespace 的进程看到的文件结构不同，这样每个 namespace 中的进程所看到的文件目录就被隔离开了。在container里头，看到的文件系统，就是一个完整的linux系统，有/etc、/lib 等，通过chroot实现。</p><h6 id="5-uts-namespace"><a href="#5-uts-namespace" class="headerlink" title="5) uts namespace"></a>5) uts namespace</h6><p>UTS(“UNIX Time-sharing System”) namespace 允许每个 container 拥有独立的 hostname 和 domain name, 使其在网络上可以被视作一个独立的节点而非 Host 上的一个进程。</p><h6 id="6-user-namespace"><a href="#6-user-namespace" class="headerlink" title="6) user namespace"></a>6) user namespace</h6><p>每个 container 可以有不同的 user 和 group id, 也就是说可以在 container 内部用 container 内部的用户执行程序而非 Host 上的用户。</p><p>有了以上 6 种 namespace 从进程、网络、IPC、文件系统、UTS和用户角度的隔离，一个 container 就可以对外展现出一个独立计算机的能力，并且不同 container 从 OS 层面实现了隔离。然而不同 namespace 之间资源还是相互竞争的，仍然需要类似ulimit来管理每个 container 所能使用的资源 - -cgroup。</p><p>资源配额「cgroups」<br>cgroups 实现了对资源的配额和度量。 cgroups 的使用非常简单，提供类似文件的接口，在 /cgroup 目录下新建一个文件夹即可新建一个 group，在此文件夹中新建 task 文件，并将 pid 写入该文件，即可实现对该进程的资源控制。具体的资源配置选项可以在该文件夹中新建子 subsystem ，{子系统前缀}.{资源项} 是典型的配置方法， 如 memory.usageinbytes 就定义了该 group 在 subsystem memory 中的一个内存限制选项。 另外，cgroups 中的 subsystem 可以随意组合，一个 subsystem 可以在不同的 group 中，也可以一个 group 包含多个 subsystem - 也就是说一个 subsystem。<br>memory<br>内存相关的限制<br>cpu<br>在 cgroup 中，并不能像硬件虚拟化方案一样能够定义 CPU 能力，但是能够定义 CPU 轮转的优先级，因此具有较高 CPU 优先级的进程会更可能得到 CPU 运算。 通过将参数写入 cpu.shares ,即可定义改 cgroup 的 CPU 优先级 - 这里是一个相对权重，而非绝对值<br>blkio<br>block IO 相关的统计和限制，byte/operation 统计和限制 (IOPS 等)，读写速度限制等，但是这里主要统计的都是同步 IO<br>devices<br>设备权限限制</p><h3 id="三、Docker-安装"><a href="#三、Docker-安装" class="headerlink" title="三、Docker 安装"></a>三、Docker 安装</h3><p>docker官网：<a href="https://docs.docker.com" target="_blank" rel="noopener">https://docs.docker.com</a><br>Docker值得关注的特性：<br>o文件系统隔离：每个进程容器运行在一个完全独立的根文件系统里。<br>o资源隔离：系统资源，像CPU和内存等可以分配到不同的容器中，使用cgroup。<br>o网络隔离：每个进程容器运行在自己的网络空间，虚拟接口和IP地址。<br>o日志记录：Docker将会收集和记录每个进程容器的标准流（stdout/stderr/stdin），用于实时检索或批量检索。<br>o变更管理：容器文件系统的变更可以提交到新的映像中，并可重复使用以创建更多的容器。无需使用模板或手动配置。<br>o交互式shell：Docker可以分配一个虚拟终端并关联到任何容器的标准输入上，</p><p>CentOS 系列安装 Docker，Docker 支持 CentOS6 及以后的版本。<br>CentOS6：<br>在RedHat/CentOS环境下安装Docker。官方文档要求Linux kernel至少3.8以上，且docker只能运行在64位的系统中。由于RHEL6和CentOS6的内核版本为2.6，因此必须要先升级内核。</p><p>升级内核（记住一定要升级，要不然会出现很多莫名奇怪的问题，建议用yum安装）</p><h5 id="1、Centos6系统安装docker"><a href="#1、Centos6系统安装docker" class="headerlink" title="1、Centos6系统安装docker:"></a>1、Centos6系统安装docker:</h5><p>1-1)yum安装带aufs模块的3.10内核</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@server4</span> ~]<span class="meta"># cd /etc/yum.repos.d/</span></span><br><span class="line">[root<span class="symbol">@server4</span> yum.repos.d]<span class="meta"># wget http://www.hop5.in/yum/el6/hop5.repo</span></span><br><span class="line">[root<span class="symbol">@server4</span> yum.repos.d]<span class="meta"># ls</span></span><br><span class="line">hop5.repo</span><br><span class="line">[root<span class="symbol">@server4</span> yum.repos.d]<span class="meta"># yum -y install kernel-ml-aufs kernel-ml-aufs-devel</span></span><br></pre></td></tr></table></figure><p>1-2)修改grub的主配置文件/etc/grub.conf，设置default=0，表示第一个title下的内容为默认启动的kernel（一般新安装的内核在第一个位置），</p><p>1-3)重启系统，这时候你的内核就成功升级了。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@server4 ~]</span># <span class="selector-tag">uname</span> <span class="selector-tag">-r</span></span><br><span class="line">3<span class="selector-class">.10</span><span class="selector-class">.0-327</span><span class="selector-class">.el7</span><span class="selector-class">.x86_64</span></span><br></pre></td></tr></table></figure><p>1-4)可以使用EPEL库安装 Docker，命令如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#yum</span> install http:<span class="comment">//mirrors.yun-idc.com/epel/6/i386/epel-release-6-8.noarch.rpm</span></span><br><span class="line"><span class="selector-id">#yum</span> install docker-io</span><br></pre></td></tr></table></figure><p>1-5)启动docker服务</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#service</span> docker start</span><br></pre></td></tr></table></figure><h5 id="2、CentOS7安装docker："><a href="#2、CentOS7安装docker：" class="headerlink" title="2、CentOS7安装docker："></a>2、CentOS7安装docker：</h5><p>2-1）Prerequisites（先决条件）<br>Docker requires a 64-bit installation regardless of your CentOS version. Also, your kernel must be 3.10 at minimum, which CentOS 7 runs.<br>To check your current kernel version, open a terminal and use uname -r to display your kernel version:<br>[root@server4 yum.repos.d]# uname -r<br>3.10.0-327.el7.x86_64</p><p>2-2）Docker 软件包已经包括在默认的 CentOS-Extras 软件源里。因此想要安装docker，只需要运行下面的 yum 命令：<br>[root@server4 yum.repos.d]# yum -y install docker<br>注：如出现以下报错<br>[root@server4 yum.repos.d]# yum -y install docker<br>Loaded plugins: plugins: fastestmirror, langpacks<br>Existing lock /var/run/yum.pid: another copy is running as pid 13120.<br>Another app is currently holding the yum lock; waiting for it to exit…<br>The other application is: PackageKit<br>Memory : 26 M RSS (429 MB VSZ)<br>Started: Fri Nov 11 10:27:44 2016 - 00:12 ago<br>State : Sleeping, pid: 13120<br>解决方法：<br>[root@server4 yum.repos.d]# rm -rf /var/run/yum.pid</p><p>2-3）启动 Docker 服务：<br>安装完成后，使用下面的命令来启动docker服务，并将其设置为开机启动：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@server4</span> ~]<span class="meta"># systemctl enable docker </span></span><br><span class="line">[root<span class="symbol">@server4</span> ~]<span class="meta"># systemctl start docker</span></span><br></pre></td></tr></table></figure><p>2-4)查看docker版本</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[<span class="symbol">root@</span>server4 ~]# docker version</span><br><span class="line">Client:</span><br><span class="line"> Version:         <span class="number">1.10</span><span class="number">.3</span></span><br><span class="line"> API version:     <span class="number">1.22</span></span><br><span class="line"> Package version: docker-common<span class="number">-1.10</span><span class="number">.3</span><span class="number">-46.</span>el7.centos<span class="number">.14</span>.x86_64</span><br><span class="line"> Go version:      go1<span class="number">.6</span><span class="number">.3</span></span><br><span class="line"> Git commit:      cb079f6-unsupported</span><br><span class="line"> Built:           Fri Sep <span class="number">16</span> <span class="number">13</span>:<span class="number">24</span>:<span class="number">25</span> <span class="number">2016</span></span><br><span class="line"> OS/Arch:         linux/amd64</span><br><span class="line"></span><br><span class="line">Server:</span><br><span class="line"> Version:         <span class="number">1.10</span><span class="number">.3</span></span><br><span class="line"> API version:     <span class="number">1.22</span></span><br><span class="line"> Package version: docker-common<span class="number">-1.10</span><span class="number">.3</span><span class="number">-46.</span>el7.centos<span class="number">.14</span>.x86_64</span><br><span class="line"> Go version:      go1<span class="number">.6</span><span class="number">.3</span></span><br><span class="line"> Git commit:      cb079f6-unsupported</span><br><span class="line"> Built:           Fri Sep <span class="number">16</span> <span class="number">13</span>:<span class="number">24</span>:<span class="number">25</span> <span class="number">2016</span></span><br><span class="line"> OS/Arch:         linux/amd64</span><br></pre></td></tr></table></figure><p>2-5)查看docker版本：docker info</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[root@server4 ~]# docker info</span><br><span class="line">Containers: 0</span><br><span class="line"> Running: 0</span><br><span class="line"> Paused: 0</span><br><span class="line"> Stopped: 0</span><br><span class="line">Images: 0</span><br><span class="line">Server Version: 1.10.3</span><br><span class="line">Storage Driver: devicemapper</span><br><span class="line"><span class="built_in"> Pool </span>Name: docker-253:0-1785801-pool</span><br><span class="line"><span class="built_in"> Pool </span>Blocksize: 65.54 kB</span><br><span class="line"> Base Device Size: 10.74 GB</span><br><span class="line"> Backing Filesystem: xfs</span><br><span class="line"> Data file: /dev/loop0</span><br><span class="line"> Metadata file: /dev/loop1</span><br><span class="line"> Data Space Used: 11.8 MB</span><br><span class="line"> Data Space Total: 107.4 GB</span><br><span class="line"> Data Space Available: 40.74 GB</span><br><span class="line"> Metadata Space Used: 581.6 kB</span><br><span class="line"> Metadata Space Total: 2.147 GB</span><br><span class="line"> Metadata Space Available: 2.147 GB</span><br><span class="line"> Udev Sync Supported: <span class="literal">true</span></span><br><span class="line"> Deferred Removal Enabled: <span class="literal">false</span></span><br><span class="line"> Deferred Deletion Enabled: <span class="literal">false</span></span><br><span class="line"> Deferred Deleted Device Count: 0</span><br><span class="line"> Data loop file: /var/lib/docker/devicemapper/devicemapper/data</span><br></pre></td></tr></table></figure><p>以上是使用centos7软件源提供的docker安装程序<br>附：也可以按照官方文档安装<br>1.Log into your machine as a user with sudo or root privileges.<br>2.Make sure your existing yum packages are up-to-date.<br>3．Add the yum repo<br>$ sudo tee /etc/yum.repos.d/docker.repo&lt;&lt;-‘EOF’<br>[dockerrepo]<br>name=DockerRepositorybaseurl=<a href="https://yum.dockerproject.org/repo/main/centos/7/" target="_blank" rel="noopener">https://yum.dockerproject.org/repo/main/centos/7/</a><br>enabled=1<br>gpgcheck=1<br>gpgkey=<a href="https://yum.dockerproject.org/gpg" target="_blank" rel="noopener">https://yum.dockerproject.org/gpg</a><br>EOF<br>注：如果我们既想把输出保存到文件中，又想在屏幕上看到输出内容，就可以使用tee命令了。tee命令读取标准输入，把这些内容同时输出到标准输出和（多个）文件中<br>4．Install the Docker package<br>$ sudo yum install docker-engine<br>5．Start the Docker daemon.<br>$ sudo service dockerstart<br>6．Verify docker is installed correctly by running a test image in a container.<br>验证docker安装正确</p><p>以上是使用centos7软件源提供的docker安装程序<br>附：也可以按照官方文档安装<br>1.Log into your machine as a user with sudo or root privileges.<br>2.Make sure your existing yum packages are up-to-date.<br>3．Add the yum repo<br>$ sudo tee /etc/yum.repos.d/docker.repo&lt;&lt;-‘EOF’<br>[dockerrepo]<br>name=DockerRepositorybaseurl=<a href="https://yum.dockerproject.org/repo/main/centos/7/" target="_blank" rel="noopener">https://yum.dockerproject.org/repo/main/centos/7/</a><br>enabled=1<br>gpgcheck=1<br>gpgkey=<a href="https://yum.dockerproject.org/gpg" target="_blank" rel="noopener">https://yum.dockerproject.org/gpg</a><br>EOF<br>注：如果我们既想把输出保存到文件中，又想在屏幕上看到输出内容，就可以使用tee命令了。tee命令读取标准输入，把这些内容同时输出到标准输出和（多个）文件中<br>4．Install the Docker package<br>$ sudo yum install docker-engine<br>5．Start the Docker daemon.<br>$ sudo service dockerstart<br>6．Verify docker is installed correctly by running a test image in a container.<br>验证docker安装正确</p><p>$ sudo docker run hello-world</p><p>7.docker默认使用的是unix socket</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="symbol">root@</span>server4 ~]# ss -ax | grep docker</span><br><span class="line">u_str  LISTEN     <span class="number">0</span>      <span class="number">128</span>    /var/lib/docker/network/files/<span class="number">8269</span>c2bdc34721cabf2d2fa89b52bafd7fd1cd3f7d0c7456518c74b5cb704bdf.sock <span class="number">53403</span>                 * <span class="number">0</span>                    </span><br><span class="line">u_str  LISTEN     <span class="number">0</span>      <span class="number">128</span>    /var/run/docker.sock <span class="number">53301</span>                 * <span class="number">0</span>                    </span><br><span class="line">u_str  ESTAB      <span class="number">0</span>      <span class="number">0</span>      /var/run/docker.sock <span class="number">55511</span>                 * <span class="number">48920</span></span><br></pre></td></tr></table></figure><p>​<br>附：直接输入docker命令来查看所有的Options和Commands，查看某一个command的详细使用方法：dockerCOMMAND–help</p><h3 id="四、Docker-image详细介绍"><a href="#四、Docker-image详细介绍" class="headerlink" title="四、Docker image详细介绍"></a>四、Docker image详细介绍</h3><p>在之前的介绍中，我们知道docker images 是docker的三大组件之一。<br>docker把下载的 images 存储到docker主机上，如果一个 image 不在主机上，docker会从一个镜像仓库下载，默认的仓库是 DOCKER HUB 公共仓库。<br>接下来将介绍更多关于docker images 的内容，包括：<br>•使用和管理本地主机上的 images<br>•创建一个基础的 images<br>•上传 images 到docker hub （公共 images 仓库）<br>•列出本地主机上已经存在的 images</p><h5 id="1）使用docker-images-显示本机上的-images"><a href="#1）使用docker-images-显示本机上的-images" class="headerlink" title="1）使用docker images  显示本机上的 images"></a>1）使用docker images 显示本机上的 images</h5><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="symbol">root@</span>localhost ~]# docker images </span><br><span class="line">REPOSITORY     TAG          IMAGE ID         CREATED         SIZE</span><br><span class="line">docker.io/centos  latest        <span class="number">50</span>dae1ee8677     <span class="number">3</span> months ago     <span class="number">196.7</span> MB</span><br></pre></td></tr></table></figure><p>在列出信息中，<br>•REPOSITORY:来自于哪个仓库，比如 docker.io/centos<br>•TAG的标记，比如 latest<br>•IMAGE ID:镜像它的 ID 号<br>•CREATED:创建时间<br>•SIZE:镜像的 SIZE<br>一个仓库可能有一个 images 的都个发行版，比如ubuntu，他们有 10.04 12.04 12.10 13.04 14.04,每个发行版的标记都不同，可以使用 tag 命令来指定 images<br>注：如果你不指定具体的发行版，比如仅使用ubuntu，那么docker会使用最新的发行版ubuntu:latest<br>提示：建议最好指定发行版，只有这样你才可以保证你真正使用的 image 是那个</p><h5 id="2）获取-images-网络"><a href="#2）获取-images-网络" class="headerlink" title="2）获取 images (网络)"></a>2）获取 images (网络)</h5><p>我们如何获取新的 images 呢？当我们启动容器使用的 image 不再本地主机上时，docker会自动下载他们。这很耗时，我们可以使用docker pull 命令来预先下载我们需要的 image 。下面的例子下载一个centos 镜像。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker pull docker.io/centos</span><br><span class="line">Using<span class="built_in"> default </span>tag: latest</span><br><span class="line">Trying <span class="keyword">to</span> pull repository docker.io/library/centos <span class="built_in">..</span>. </span><br><span class="line">latest: Pulling <span class="keyword">from</span> docker.io/library/centos</span><br><span class="line">08d48e6f1cff: Downloading [&gt;                                   ] 1.081 MB/70.48 MB</span><br></pre></td></tr></table></figure><p>这样当我们使用这个 image 来启动容器的时候，它就可以马上启动了。</p><p>这样当我们使用这个 image 来启动容器的时候，它就可以马上启动了。</p><h5 id="3）查找-images-网络"><a href="#3）查找-images-网络" class="headerlink" title="3）查找 images (网络)"></a>3）查找 images (网络)</h5><p>docker的一个特点是很多人因为各种不同的用途创建了各种不同的 images 。它们都被上传到了docker hub 共有仓库上，我们可以在docker hub 的网站上来查找它们。使用docker search 命令。比如，当我们需要 ruby 和sinatra作为 web 应用程序的开发时，我们使用docker search 来搜索合适的image ，使用关键字sinatra</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@localhost</span> ~]<span class="meta"># docker search sinatra</span></span><br></pre></td></tr></table></figure><p>我们看到返回了很多包含sinatra的 images 。其中包括 image 名字、描述、星级（表示该 image 的受欢迎程度）、是否官方创建、是否自动创建。官方的 images 是stackbrew项目组创建和维护的，automated 资源允许你验证 image 的来源和内容。</p><p>到目前为止，我们看到了 2种 images 资源。比如ubuntu，被称为基础或则根镜像。这些基础镜像是docker公司创建、验证、支持、提供。他们往往使用一个单词作为他们的名字。还有一种类型，比如我们选择的 training/sinatra镜像。它是由docker的用户创建并维护的，你可以通过指定 image 名字的前缀来指定他们，比如 training 。</p><h5 id="4）下载-images"><a href="#4）下载-images" class="headerlink" title="4）下载 images"></a>4）下载 images</h5><p>现在我们指定了一个 image ， training/sinatra，我们可以使用docker pull 命令来下载它</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@localhost</span> ~]<span class="meta"># docker pull  docker.io/jdeathe/centos-ssh</span></span><br></pre></td></tr></table></figure><p>下载过程中，会输出获取镜像的每一层信息。<br>该命令实际上相当于#docker pull registry.hub.docker.com/ubuntu:12.04 命令，即从注册服<br>务器 registry.hub.docker.com 中的ubuntu仓库来下载标记为 12.04 的镜像。<br>有时候官方仓库注册服务器下载较慢，可以从其他仓库下载。从其它仓库下载时需要指定完整的仓库注册服务器地址。例如</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#docker</span> pull <span class="selector-tag">dl</span><span class="selector-class">.dockerpool</span><span class="selector-class">.com</span>:<span class="number">5000</span>/ubuntu:<span class="number">12.04</span></span><br></pre></td></tr></table></figure><h5 id="5-查看镜像文件docker-images"><a href="#5-查看镜像文件docker-images" class="headerlink" title="5) 查看镜像文件docker images"></a>5) 查看镜像文件docker images</h5><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="symbol">root@</span>localhost ~]# docker images </span><br><span class="line">REPOSITORY      TAG             IMAGE ID          CREATED          SIZE</span><br><span class="line">docker.io/centos   latest           <span class="number">50</span>dae1ee8677      <span class="number">3</span> months ago      <span class="number">196.7</span> MB</span><br><span class="line">docker.io/centos   centos6         cf2c3ece5e41       <span class="number">4</span> months ago      <span class="number">194.6</span> MB</span><br></pre></td></tr></table></figure><h5 id="6-查看完整信息"><a href="#6-查看完整信息" class="headerlink" title="6) 查看完整信息"></a>6) 查看完整信息</h5><p>当镜像下载成功后，你可以看到 12 位的 hash 值像 05188b417f30，这是下载完整的镜像的精简 ID，这些短的镜像 ID 是完整镜像 ID 的前 12 个字符–可以使用docker inspect 或者docker images –no-trunc来获得完整的镜像 ID</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@localhost</span> ~]<span class="meta"># docker inspect docker.io/centos</span></span><br></pre></td></tr></table></figure><p>或: –no-trunc来获得完整的镜像 ID</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@localhost</span> ~]<span class="meta"># docker images --no-trunc</span></span><br></pre></td></tr></table></figure><h5 id="7）创建我们自己的-images"><a href="#7）创建我们自己的-images" class="headerlink" title="7）创建我们自己的 images"></a>7）创建我们自己的 images</h5><p>别人的镜像虽然好，但不一定适合我们。我们可以对他们做一些改变，有 2 个方法：<br>1.第一个方法：使用docker commit 来扩展一个 image<br>1-1先使用 image 启动容器，更新后提交结果到新的 image 。</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@localhost</span> ~]<span class="meta"># docker run -it docker.io/centos /bin/bash</span></span><br><span class="line">[root<span class="symbol">@cfd9c030875b</span> /]<span class="meta">#</span></span><br></pre></td></tr></table></figure><p>注意：记住容器的 ID ，稍后我们还会用到</p><p>注意：记住容器的 ID ，稍后我们还会用到</p><p>1-2在容器中添加mariadb-server应用。</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@cfd9c030875b</span> /]<span class="meta"># yum -y install httpd</span></span><br><span class="line">[root<span class="symbol">@cfd9c030875b</span> /]<span class="meta"># exit</span></span><br></pre></td></tr></table></figure><p>exit<br>当结束后，我们使用 exit 来退出，现在我们的容器已经被我们改变了</p><p>exit<br>当结束后，我们使用 exit 来退出，现在我们的容器已经被我们改变了</p><p>1-3使用docker commint命令来提交相应的副本。</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@localhost</span> ~]<span class="meta"># docker commit -m <span class="string">"added httpd app"</span> -a <span class="string">"docker chen"</span> cfd9c030875b centos:httpd</span></span><br><span class="line">sha256:<span class="number">05653</span>ceb4e74275edfbc16edaa1976410e0fd6a35b910d4d04d83f8e92353669</span><br></pre></td></tr></table></figure><p>其中:<br>-m 来指定提交的说明信息，跟我们使用的版本控制工具一样；<br>-a 可以指定更新的用户信息；之后是用来创建镜像的容器的 ID；<br>最后指定目标镜像的仓库名和 tag 信息。创建成功后会返回这个镜像的 ID信息。</p><p>其中:<br>-m 来指定提交的说明信息，跟我们使用的版本控制工具一样；<br>-a 可以指定更新的用户信息；之后是用来创建镜像的容器的 ID；<br>最后指定目标镜像的仓库名和 tag 信息。创建成功后会返回这个镜像的 ID信息。</p><p>1-4)使用docker images 来查看新创建的镜像。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="symbol">root@</span>localhost ~]# docker images </span><br><span class="line">REPOSITORY       TAG             IMAGE ID         CREATED            SIZE</span><br><span class="line">centos           httpd            <span class="number">05653</span>ceb4e74     About a minute ago   <span class="number">295.3</span> MB</span><br><span class="line">docker.io/centos   latest            <span class="number">50</span>dae1ee8677     <span class="number">3</span> months ago        <span class="number">196.7</span> MB</span><br><span class="line">docker.io/centos  centos6          cf2c3ece5e41       <span class="number">4</span> months ago         <span class="number">194.6</span> MB</span><br></pre></td></tr></table></figure><p>之后，可以使用新的镜像来启动容器</p><p>之后，可以使用新的镜像来启动容器</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="symbol">root@</span>localhost ~]# docker run  -it centos:httpd /bin/bash</span><br><span class="line">[<span class="symbol">root@</span><span class="number">392e3f</span>a371b7 /]# uname -r</span><br><span class="line"><span class="number">3.10</span><span class="number">.0</span><span class="number">-327.</span>el7.x86_64</span><br></pre></td></tr></table></figure><p>2.第二个办法：从dockerfile来创建 image<br>使用docker commit 来扩展一个 image 比较简单，但它不容易在一个团队中分享它。我们使用docker build 来创建一个新的 image 。为此，我们需要创建一个dockerfile，包含一些如何创建我们的image 的指令。<br>2-1）创建一个目录和一个dockerfile</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@localhost</span> ~]<span class="meta"># mkdir -p /docker/httpd</span></span><br><span class="line">[root<span class="symbol">@localhost</span> ~]<span class="meta"># cd /docker/httpd</span></span><br><span class="line">[root<span class="symbol">@localhost</span> httpd]<span class="meta"># vim dockerfile</span></span><br><span class="line"><span class="meta">#This is a comment</span></span><br><span class="line">FROM docker.io/centos</span><br><span class="line">MAINTAINER chen &lt;chen<span class="symbol">@mail</span>.com&gt;</span><br><span class="line"><span class="built_in">RUN</span> yum -y -q install httpd</span><br></pre></td></tr></table></figure><p>Dockerfile基本的语法是<br>使用#来注释<br>FROM指令告诉 Docker 使用哪个镜像作为基础（docker使用哪个 image 源）<br>MAINTAINER是维护者的信息<br>RUN开头的指令会在创建中运行，比如安装一个软件包，在这里使用 yum来安装了一些软件</p><p>Dockerfile基本的语法是<br>使用#来注释<br>FROM指令告诉 Docker 使用哪个镜像作为基础（docker使用哪个 image 源）<br>MAINTAINER是维护者的信息<br>RUN开头的指令会在创建中运行，比如安装一个软件包，在这里使用 yum来安装了一些软件</p><p>2-2）编写完成Dockerfile后可以使用docker build 来生成镜像。</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@localhost</span> httpd]<span class="meta"># docker build -t=<span class="string">"centos:httpd-1"</span> .</span></span><br></pre></td></tr></table></figure><p>其中:<br>-t 标记来添加 tag，指定新的镜像的用户信息。<br>“.”是Dockerfile所在的路径（当前目录），也可以替换为一个具体的Dockerfile的路径。<br>可以看到 build 进程在执行操作。它要做的第一件事情就是上传这个Dockerfile内容，因为所有的操作都要依据Dockerfile来进行。然后，Dockfile中的指令被一条一条的执行。每一步都创建了一个新的容器，在容器中执行指令并提交修改（就跟之前介绍过的docker commit 一样）。当所有的指令都执行完毕之后，返回了最终的镜像 id。所有的中间步骤所产生的容器都被删除和清理了。<br>*注意一个镜像不能超过 127 层</p><p>2-3）查看生成的镜像</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="symbol">root@</span>localhost httpd]# docker images </span><br><span class="line">REPOSITORY        TAG              IMAGE ID          CREATED           SIZE</span><br><span class="line">centos            httpd<span class="number">-1</span>           a7e5b7ebdc89      <span class="number">8</span> minutes ago      <span class="number">338.5</span> MB</span><br><span class="line">centos            httpd            f8cadf4f19b7       <span class="number">13</span> minutes ago      <span class="number">338.5</span> MB</span><br><span class="line">docker.io/centos    latest            <span class="number">50</span>dae1ee8677      <span class="number">3</span> months ago       <span class="number">196.7</span> MB</span><br><span class="line">docker.io/centos   centos6           cf2c3ece5e41       <span class="number">4</span> months ago       <span class="number">194.6</span> MB</span><br></pre></td></tr></table></figure><p>2-4）从我们新建的 images 开启容器</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@localhost</span> httpd]<span class="meta"># docker run -it centos:httod-1 /bin/bash</span></span><br><span class="line">[root<span class="symbol">@dafdc2b34c56</span> /]<span class="meta">#</span></span><br></pre></td></tr></table></figure><p>2-5）还可以用docker tag 命令来修改镜像的标签。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="symbol">root@</span>localhost httpd]# docker tag centos:httpd<span class="number">-1</span> centos:httod<span class="number">-1</span></span><br><span class="line">[<span class="symbol">root@</span>localhost httpd]# docker images </span><br><span class="line">REPOSITORY        TAG             IMAGE ID         CREATED            SIZE</span><br><span class="line">centos            httod<span class="number">-1</span>           a7e5b7ebdc89      <span class="number">12</span> minutes ago     <span class="number">338.5</span> MB</span><br><span class="line">centos            httpd<span class="number">-1</span>           a7e5b7ebdc89      <span class="number">12</span> minutes ago     <span class="number">338.5</span> MB</span><br><span class="line">centos            httpd            f8cadf4f19b7       <span class="number">17</span> minutes ago      <span class="number">338.5</span> MB</span><br><span class="line">docker.io/centos   latest             <span class="number">50</span>dae1ee8677      <span class="number">3</span> months ago       <span class="number">196.7</span> MB</span><br><span class="line">docker.io/centos   centos6           cf2c3ece5e41       <span class="number">4</span> months ago       <span class="number">194.6</span> MB</span><br></pre></td></tr></table></figure><p>3.从本地文件系统导入<br>要从本地文件系统导入一个镜像，可以使用openvz（容器虚拟化的先锋技术）的模板来创建：openvz的模板下载地址为<a href="http://openvz.org/Download/template/precreated。" target="_blank" rel="noopener">http://openvz.org/Download/template/precreated。</a><br>先下载了一个centos-6-x86_64.tar.gz的镜像，之后使用以下命令导入：<br><img src="https://img2018.cnblogs.com/blog/1829796/201910/1829796-20191022110637478-664814624.png" alt></p><h5 id="8）上传镜像"><a href="#8）上传镜像" class="headerlink" title="8）上传镜像"></a>8）上传镜像</h5><p>用户可以通过docker push 命令，把自己创建的镜像上传到仓库中来共享。例如，用户在 Docker Hub 上，完成注册后，可以推送自己的镜像到仓库中。<br>这里有两种访问可以创建和注册一个 Docker Hub 账户：<br>1.通过网站，（<a href="https://hub.docker.com）" target="_blank" rel="noopener">https://hub.docker.com）</a><br>2.通过命令行<br>你可以通过使用命令行输入 docker login 命令来创建一个 Docker Hub 账号</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#docker</span> login</span><br></pre></td></tr></table></figure><p>邮箱确认<br>一旦你填写完毕表格，请查看你的电子邮件，通过点击欢迎信息中的链接来激活您的账户。</p><p>邮箱确认<br>一旦你填写完毕表格，请查看你的电子邮件，通过点击欢迎信息中的链接来激活您的账户。</p><p>基本思路：<br>首先注册docker的账户，然后使用docker login登录。<br>使用docker push可以将自己的镜像上传上去了<br><img src="https://img2018.cnblogs.com/blog/1829796/201910/1829796-20191022110650983-1343036792.png" alt></p><p>如果有其他的仓库,例如:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push docker<span class="selector-class">.sina</span><span class="selector-class">.com</span><span class="selector-class">.cn</span>:<span class="number">5000</span>/commit</span><br></pre></td></tr></table></figure><h5 id="9）用dcokerrmi移除本地-images"><a href="#9）用dcokerrmi移除本地-images" class="headerlink" title="9）用dcokerrmi移除本地 images"></a>9）用dcokerrmi移除本地 images</h5><p>dockerrmi镜像名或镜像id</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="symbol">root@</span>localhost httpd]# docker rmi centos:httod<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>注意：在删除 images 之前要先用dockerrm删掉依赖于这个 images 的容器</p><p>注意：在删除 images 之前要先用dockerrm删掉依赖于这个 images 的容器</p><h5 id="10）存出和载入镜像"><a href="#10）存出和载入镜像" class="headerlink" title="10）存出和载入镜像"></a>10）存出和载入镜像</h5><p>当需要把一台机器上的镜像迁移到另一台机器的时候，需要存出镜像与载入镜像。<br>10-1）存出镜像<br>如果要导出镜像到本地文件，可以使用docker save 命令。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="symbol">root@</span>localhost ~]# docker save -o centos<span class="number">-6</span>-httpd.tar centos:httpd<span class="number">-1</span></span><br><span class="line">[<span class="symbol">root@</span>localhost ~]# ls centos<span class="number">-6</span>-httpd.tar </span><br><span class="line">centos<span class="number">-6</span>-httpd.tar</span><br></pre></td></tr></table></figure><p>10-2）载入镜像<br>可以使用docker load 从导出的本地文件中再导入到本地镜像库，例如</p><p>这将导入镜像以及其相关的元数据信息（包括标签等）</p><h3 id="五、Docker-容器"><a href="#五、Docker-容器" class="headerlink" title="五、Docker 容器"></a>五、Docker 容器</h3><p>容器是 Docker 又一核心概念,简单的说，容器是独立运行的一个或一组应用，以及它们的运行态环境。对应的，虚拟机可以理解为模拟运行的一整套操作系统（提供了运行态环境和其他系统环境）和跑在上面的应用。<br>本章将具体介绍如何来管理一个容器，包括创建、启动和停止等。<br>启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（stopped）的容器重新启动。</p><h5 id="1、新建并启动"><a href="#1、新建并启动" class="headerlink" title="1、新建并启动"></a>1、新建并启动</h5><p>所需要的命令主要为docker run<br>下面的命令则启动一个 bash 终端，允许用户进行交互。</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@localhost</span> ~]<span class="meta"># docker run -it docker.io/centos:centos6</span></span><br><span class="line">[root<span class="symbol">@c88f4fefd1ff</span> /]<span class="meta">#</span></span><br></pre></td></tr></table></figure><p>-t 选项让 Docker 分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上，<br>-i则让容器的标准输入保持打开(即交互式)，可以使用—name给容器起个形象的名称。<br>在交互模式下，用户可以通过所创建的终端来输入命令，例如</p><p>-t 选项让 Docker 分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上，<br>-i则让容器的标准输入保持打开(即交互式)，可以使用—name给容器起个形象的名称。<br>在交互模式下，用户可以通过所创建的终端来输入命令，例如</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="symbol">root@</span>c88f4fefd1ff /]# pwd</span><br><span class="line">/</span><br><span class="line">[<span class="symbol">root@</span>c88f4fefd1ff /]# ps -ef</span><br><span class="line">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class="line">root         <span class="number">1</span>     <span class="number">0</span>  <span class="number">0</span> <span class="number">08</span>:<span class="number">18</span> ?        <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> /bin/bash</span><br><span class="line">root        <span class="number">12</span>     <span class="number">1</span>  <span class="number">0</span> <span class="number">08</span>:<span class="number">20</span> ?        <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> ps -ef</span><br></pre></td></tr></table></figure><p>容器的核心为所执行的应用程序，所需要的资源都是应用程序运行所必需的。除此之外，并没有其它的资源。可以在伪终端中利用ps或 top 来查看进程信息。</p><p>容器的核心为所执行的应用程序，所需要的资源都是应用程序运行所必需的。除此之外，并没有其它的资源。可以在伪终端中利用ps或 top 来查看进程信息。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="symbol">root@</span>c88f4fefd1ff /]# ps</span><br><span class="line">  PID TTY          TIME CMD</span><br><span class="line">    <span class="number">1</span> ?        <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> bash</span><br><span class="line">   <span class="number">13</span> ?        <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> ps</span><br></pre></td></tr></table></figure><p>可见，容器中仅运行了指定的 bash 应用。这种特点使得 Docker 对资源的利用率极高，是货真价实的轻量级虚拟化。</p><p>可见，容器中仅运行了指定的 bash 应用。这种特点使得 Docker 对资源的利用率极高，是货真价实的轻量级虚拟化。</p><p>如果这个时候我们正常退出，logout 或者 exit 或者Ctrl+d或者Ctrl+c，dockerps–a 查看容器处于 Exit 状态如果需要正常退出可以使用 CTRL –p + CTRL -q —-就像先按 CTRL -p 然后 CTRL –q 退出伪终端<br>下面的命令输出一个“Hello World”，之后终止容器。</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@localhost</span> ~]<span class="meta"># docker run docker.io/centos:latest /bin/echo <span class="string">'hello world'</span></span></span><br><span class="line">htool world</span><br></pre></td></tr></table></figure><p>这跟在本地直接执行 /bin/echo ‘hello world’ 几乎感觉不出任何区别。</p><p>这跟在本地直接执行 /bin/echo ‘hello world’ 几乎感觉不出任何区别。</p><p>当利用docker run 来创建容器时，Docker 在后台运行的标准操作包括：<br>1.检查本地是否存在指定的镜像，不存在就从公有仓库下载<br>2.利用镜像创建并启动一个容器<br>3.分配一个文件系统，并在只读的镜像层外面挂载一层可读写层<br>4.从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去<br>5.从地址池配置一个ip地址给容器<br>6.执行用户指定的应用程序<br>7.执行完毕后容器被终止</p><h5 id="2、查看容器dockerps"><a href="#2、查看容器dockerps" class="headerlink" title="2、查看容器dockerps"></a>2、查看容器dockerps</h5><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker ps -a</span></span><br><span class="line">![](https:<span class="regexp">//img</span>2018.cnblogs.com<span class="regexp">/blog/</span><span class="number">1829796</span><span class="regexp">/201910/</span><span class="number">1829796</span>-<span class="number">20191022110725324</span>-<span class="number">901966730</span>.png)</span><br></pre></td></tr></table></figure><p>附：养成查看帮助的习惯</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker ps -h</span><br><span class="line"></span><br><span class="line"><span class="keyword">Usage</span>:	docker ps [<span class="keyword">OPTIONS</span>]</span><br><span class="line"></span><br><span class="line">List containers</span><br><span class="line"></span><br><span class="line">  -a, <span class="comment">--all          Show all containers (default shows just running)</span></span><br><span class="line">  -f, <span class="comment">--filter=[]    Filter output based on conditions provided</span></span><br><span class="line">  <span class="comment">--format           Pretty-print containers using a Go template</span></span><br><span class="line">  <span class="comment">--help             Print usage</span></span><br><span class="line">  -l, <span class="comment">--latest       Show the latest created container (includes all states)</span></span><br><span class="line">  -n=<span class="number">-1</span>              <span class="keyword">Show</span> n last created containers (includes <span class="keyword">all</span> states)</span><br><span class="line">  <span class="comment">--no-trunc         Don't truncate output</span></span><br><span class="line">  -q, <span class="comment">--quiet        Only display numeric IDs</span></span><br><span class="line">  -s, <span class="comment">--size         Display total file sizes</span></span><br></pre></td></tr></table></figure><h5 id="3、可以利用docker-start-命令，直接将一个已经终止的容器启动运行。"><a href="#3、可以利用docker-start-命令，直接将一个已经终止的容器启动运行。" class="headerlink" title="3、可以利用docker start  命令，直接将一个已经终止的容器启动运行。"></a>3、可以利用docker start 命令，直接将一个已经终止的容器启动运行。</h5><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start <span class="string">[contraiID]</span></span><br></pre></td></tr></table></figure><p>容器处于 Exited 状态，可以直接启动<br><img src="https://img2018.cnblogs.com/blog/1829796/201910/1829796-20191022110738858-1203258864.png" alt></p><h5 id="4、终止容器"><a href="#4、终止容器" class="headerlink" title="4、终止容器"></a>4、终止容器</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">stop</span> [容器 <span class="keyword">ID</span>]</span><br><span class="line"></span><br><span class="line">docker <span class="keyword">kill</span> [容器 <span class="keyword">ID</span>]</span><br></pre></td></tr></table></figure><p>可以使用docker stop 来终止一个运行中的容器。此外，当Docker容器中指定的应用终结时，容器也自动终止。例如对于前面所讲中启动了一个终端的容器，用户通过 exit 命令或Ctrl+d来退出终端时，所创建的容器立刻终止<br>终止状态的容器可以用docker ps -a 命令看到。例如<br><img src="https://img2018.cnblogs.com/blog/1829796/201910/1829796-20191022110749689-485534913.png" alt></p><p>状态由 Up -&gt; Exit<br>处于终止状态的容器，可以通过docker start 命令来重新启动。</p><h5 id="5、重启容器"><a href="#5、重启容器" class="headerlink" title="5、重启容器"></a>5、重启容器</h5><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">restart</span>  命令会将一个运行态的容器终止，然后再重新启动它。</span><br><span class="line"></span><br><span class="line">docker <span class="built_in">restart</span> [容器 ID]</span><br></pre></td></tr></table></figure><p><img src="https://img2018.cnblogs.com/blog/1829796/201910/1829796-20191022110800024-2009126343.png" alt></p><h5 id="6、守护状态运行"><a href="#6、守护状态运行" class="headerlink" title="6、守护状态运行"></a>6、守护状态运行</h5><p>更多的时候，需要让 Docker 容器在后台以守护状态（Daemonized）形式运行。此时，可以通过添加 -d 参数来实现。例如下面的命令会在后台运行容器。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker run -d docker.io/centos /bin/bash -c "while true ; do echo hello world ; sleep 1 ; done"</span></span><br><span class="line">![](https:<span class="regexp">//img</span>2018.cnblogs.com<span class="regexp">/blog/</span><span class="number">1829796</span><span class="regexp">/201910/</span><span class="number">1829796</span>-<span class="number">20191022110819599</span>-<span class="number">2000970667</span>.png)</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@localhost</span> ~]<span class="meta"># docker run -dt docker.io/centos /bin/bash</span></span><br><span class="line"><span class="number">56</span>c3adf740ba870818af856ab76fe43fa7f44d7a0f2fc26fc4b4558788585e3a</span><br><span class="line">[root<span class="symbol">@localhost</span> ~]<span class="meta">#</span></span><br></pre></td></tr></table></figure><p>容器启动后会返回一个唯一的 id，也可以通过docker ps命令来查看容器信息。<br>1．docker run -d 运行提个新的容器，我们通过-d 命令让他作为一个后台运行<br>2．centos:centos6 是一个我们想要在内部运行命令的镜像<br>3．/bin/sh -c 是我们想要在容器内部运行的命令<br>4．while true; do echo hello weibo; sleep 1; done 这是一个简单的脚本，我们仅仅只是每秒打印一次 hello word 一直到我们结束它</p><p>容器启动后会返回一个唯一的 id，也可以通过docker ps命令来查看容器信息。<br>1．docker run -d 运行提个新的容器，我们通过-d 命令让他作为一个后台运行<br>2．centos:centos6 是一个我们想要在内部运行命令的镜像<br>3．/bin/sh -c 是我们想要在容器内部运行的命令<br>4．while true; do echo hello weibo; sleep 1; done 这是一个简单的脚本，我们仅仅只是每秒打印一次 hello word 一直到我们结束它</p><h5 id="7、用docker-inspect查看容器的信息"><a href="#7、用docker-inspect查看容器的信息" class="headerlink" title="7、用docker  inspect查看容器的信息"></a>7、用docker inspect查看容器的信息</h5><p>命令格式：docker inspect 容器ID或容器名</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">root@localhost ~</span>]<span class="meta"># docker inspect 56c3adf740ba</span></span><br><span class="line"> [<span class="meta"></span></span><br><span class="line"><span class="meta">    &#123;</span></span><br><span class="line"><span class="meta">        <span class="meta-string">"Id"</span>: <span class="meta-string">"56c3adf740ba870818af856ab76fe43fa7f44d7a0f2fc26fc4b4558788585e3a"</span>,</span></span><br><span class="line"><span class="meta">        <span class="meta-string">"Created"</span>: <span class="meta-string">"2016-11-15T10:50:58.658378757Z"</span>,</span></span><br><span class="line"><span class="meta">        <span class="meta-string">"Path"</span>: <span class="meta-string">"/bin/bash"</span>,</span></span><br><span class="line"><span class="meta">        <span class="meta-string">"Args"</span>: [</span>],</span><br><span class="line">        <span class="string">"State"</span>: &#123;</span><br><span class="line">            <span class="string">"Status"</span>: <span class="string">"running"</span>,</span><br><span class="line">            <span class="string">"Running"</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="string">"Paused"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"Restarting"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"OOMKilled"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"Dead"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"Pid"</span>: <span class="number">42710</span>,</span><br><span class="line">            <span class="string">"ExitCode"</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="string">"Error"</span>: <span class="string">""</span>,</span><br><span class="line">            <span class="string">"StartedAt"</span>: <span class="string">"2016-11-15T10:50:59.092432423Z"</span>,</span><br><span class="line">            <span class="string">"FinishedAt"</span>: <span class="string">"0001-01-01T00:00:00Z"</span></span><br><span class="line">        &#125;,</span><br></pre></td></tr></table></figure><p>用docker inspect查看容器的ip地址</p><p>用docker inspect查看容器的ip地址</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="symbol">root@</span>localhost ~]# docker inspect -f <span class="string">'&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;'</span> <span class="number">56</span>c3adf740ba</span><br><span class="line"><span class="number">172.17</span><span class="number">.0</span><span class="number">.4</span></span><br></pre></td></tr></table></figure><p>用docker inspect查看容器执行的程序</p><p>用docker inspect查看容器执行的程序</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@localhost</span> ~]<span class="meta"># docker inspect  -f <span class="string">'&#123;&#123;.Config.Cmd&#125;&#125;'</span> 56c3adf740ba </span></span><br><span class="line">&#123;[/bin/bash]&#125;</span><br></pre></td></tr></table></figure><h5 id="8、进入容器"><a href="#8、进入容器" class="headerlink" title="8、进入容器"></a>8、进入容器</h5><p>在使用 -d 参数时，容器启动后会进入后台。某些时候需要进入容器进行操作，有很多种方法，包括使用docker attach 命令或nsenter命令。<br>使用docker attach进入容器<br>docker attach 是Docker自带的命令。下面示例如何使用该命令。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="symbol">root@</span>localhost ~]# docker attach <span class="number">56</span>c3adf740ba </span><br><span class="line">[<span class="symbol">root@</span><span class="number">56</span>c3adf740ba /]#</span><br></pre></td></tr></table></figure><p>或：</p><p>或：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="symbol">root@</span>localhost ~]# docker attach --sig-proxy=<span class="literal">false</span> <span class="number">56</span>c3adf740ba </span><br><span class="line">[<span class="symbol">root@</span><span class="number">56</span>c3adf740ba /]#</span><br></pre></td></tr></table></figure><p>1．docker attach 允许我们进入后台进程.<br>2．–sig-proxy=false 不使用容器转发信号，允许我们使用 ctrl -c 来退出，执行dockerps查看在后台运行<br>但是使用 attach命令有时候并不方便。当多个窗口同时 attach 到同一个容器的时候，所有窗口都会同步显示。当某个窗口因命令阻塞时,其他窗口也无法执行操作了。</p><p>1．docker attach 允许我们进入后台进程.<br>2．–sig-proxy=false 不使用容器转发信号，允许我们使用 ctrl -c 来退出，执行dockerps查看在后台运行<br>但是使用 attach命令有时候并不方便。当多个窗口同时 attach 到同一个容器的时候，所有窗口都会同步显示。当某个窗口因命令阻塞时,其他窗口也无法执行操作了。</p><p>也可以执行docker exec进入运行的容器</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker  exec  -<span class="keyword">it</span>  容器ID/名称 /bin/bash</span><br></pre></td></tr></table></figure><p>以上命令返回一个命令界面，exec代表直接在容器中运行命令</p><p>以上命令返回一个命令界面，exec代表直接在容器中运行命令</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="symbol">root@</span>localhost ~]# docker exec -it <span class="number">56</span>c3adf740ba</span><br><span class="line">[<span class="symbol">root@</span><span class="number">56</span>c3adf740ba /]#</span><br></pre></td></tr></table></figure><h5 id="9、使用nsenter进入容器"><a href="#9、使用nsenter进入容器" class="headerlink" title="9、使用nsenter进入容器"></a>9、使用nsenter进入容器</h5><p>安装<br>nsenter工具在util-linux包2.23版本后包含。如果系统中util-linux包没有该命令，可以按照下面的方法从源码安装</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#wgethttps</span>:<span class="comment">//www.kernel.org/pub/linux/utils/util-linux/v2.24/util-linux-2.24.tar.gz</span></span><br><span class="line"><span class="selector-id">#tar</span> util-linux-<span class="number">2.24</span><span class="selector-class">.tar</span><span class="selector-class">.gz</span></span><br><span class="line"><span class="selector-id">#cd</span> util-linux-<span class="number">2.24</span></span><br><span class="line"></span><br><span class="line">./configure --without-ncurses&amp;&amp; make nsenter</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#cpnsenter</span> /usr/local/bin</span><br></pre></td></tr></table></figure><p>nsenter可以访问另一个进程的名字空间。nsenter要正常工作需要有 root 权限<br>庆幸的是centos7使用的是util-linux-2.23，所以就直接使用系统提供的util-linux包了。</p><p>nsenter可以访问另一个进程的名字空间。nsenter要正常工作需要有 root 权限<br>庆幸的是centos7使用的是util-linux-2.23，所以就直接使用系统提供的util-linux包了。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># <span class="selector-tag">rpm</span> <span class="selector-tag">-q</span> <span class="selector-tag">util-linux</span></span><br><span class="line"><span class="selector-tag">util-linux-2</span><span class="selector-class">.23</span><span class="selector-class">.2-26</span><span class="selector-class">.el7</span><span class="selector-class">.x86_64</span></span><br></pre></td></tr></table></figure><p>为了连接到容器，你还需要找到容器的第一个进程的PID，可以通过下面的命令获取。</p><p>为了连接到容器，你还需要找到容器的第一个进程的PID，可以通过下面的命令获取。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PID=<span class="constructor">$(<span class="params">docker</span> <span class="params">inspect</span> --<span class="params">format</span> <span class="string">"&#123;&#123; .State.Pid &#125;&#125;"</span> &lt;<span class="params">container</span>&gt;)</span></span><br></pre></td></tr></table></figure><p>通过这个PID，就可以连接到这个容器：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">nsenter</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">target</span> <span class="comment">$PID</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">mount</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">uts</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">ipc</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">net</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">pid</span></span><br></pre></td></tr></table></figure><p>下面给出一个完整的例子。<br><img src="https://img2018.cnblogs.com/blog/1829796/201910/1829796-20191022110908741-1979087383.png" alt></p><p>下面给出一个完整的例子。</p><p>通过这个PID，就可以连接到这个容器：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">nsenter</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">target</span> <span class="comment">$PID</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">mount</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">uts</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">ipc</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">net</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">pid</span></span><br></pre></td></tr></table></figure><p>下面给出一个完整的例子。</p><p>下面给出一个完整的例子。</p><p>附：更简单的，建议大家下载 .bashrc_docker，并将内容放到 .bashrc中。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#wget</span>  ~ https:<span class="comment">//github.com/yeasy/docker_practice/raw/master/_local/.bashrc_docker</span></span><br><span class="line"><span class="selector-id">#echo</span> <span class="string">"[ -f ~/.bashrc_docker ] &amp;&amp;. ~/.bashrc_docker"</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="selector-id">#source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><p>这个文件中定义了很多方便使用 Docker 的命令，例如docker-pid可以获取某个容器的PID；而docker-enter 可以进入容器或直接在容器内执行命令。</p><p>这个文件中定义了很多方便使用 Docker 的命令，例如docker-pid可以获取某个容器的PID；而docker-enter 可以进入容器或直接在容器内执行命令。</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo $(docker-pid&lt;<span class="keyword">container</span>&gt;)</span><br><span class="line">docker-enter &lt;<span class="keyword">container</span>&gt; <span class="keyword">ls</span></span><br></pre></td></tr></table></figure><p>容器导入和导出<br>导出容器：<br>docker export [容器 id] &gt; [导出文件]<br>如果要导出本地某个容器，可以使用docker export 命令。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># <span class="selector-tag">docker</span> <span class="selector-tag">export</span> 56<span class="selector-tag">c3adf740ba</span> &gt; <span class="selector-tag">centos_web</span><span class="selector-class">.tar</span></span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># <span class="selector-tag">ls</span></span><br><span class="line"><span class="selector-tag">anaconda-ks</span><span class="selector-class">.cfg</span></span><br><span class="line"><span class="selector-tag">centos6</span><span class="selector-class">.tar</span></span><br><span class="line"><span class="selector-tag">centos7</span><span class="selector-class">.tar</span></span><br><span class="line"><span class="selector-tag">centos_web</span><span class="selector-class">.tar</span></span><br></pre></td></tr></table></figure><p>这样将导出容器快照到本地文件</p><p>这样将导出容器快照到本地文件</p><p>导入容器：<br>可以使用docker import 从容器快照文件中再导入为镜像</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">cat</span> centos6.tar | docker <span class="keyword">import</span> – centos6:test</span><br></pre></td></tr></table></figure><p>docker images</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="symbol">root@</span>localhost ~]# cat centos_web.tar | docker <span class="keyword">import</span> - centos:web</span><br><span class="line">sha256:<span class="number">4429751684</span>b5529cb70ddd080ada1462b3dfe2f48651c02a42c8ebd794a11c7d</span><br><span class="line">[<span class="symbol">root@</span>localhost ~]# docker images </span><br><span class="line">REPOSITORY       TAG               IMAGE ID          CREATED           SIZE</span><br><span class="line">centos            web              <span class="number">4429751684</span>b5      <span class="number">4</span> seconds ago     <span class="number">196.7</span> MB</span><br></pre></td></tr></table></figure><p>此外，也可以通过指定 URL 或者某个目录来导入，例如<br>docker import <a href="http://example.com/exampleimage.tgzexample/imagerepo" target="_blank" rel="noopener">http://example.com/exampleimage.tgzexample/imagerepo</a><br>*注：用户既可以使用docker load 来导入镜像存储文件到本地镜像库，也可以使用docker import 来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</p><p>此外，也可以通过指定 URL 或者某个目录来导入，例如<br>docker import <a href="http://example.com/exampleimage.tgzexample/imagerepo" target="_blank" rel="noopener">http://example.com/exampleimage.tgzexample/imagerepo</a><br>*注：用户既可以使用docker load 来导入镜像存储文件到本地镜像库，也可以使用docker import 来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</p><p>删除容器<br>可以使用dockerrm来删除一个处于终止状态的容器。<br>如果要删除一个运行中的容器，可以添加 -f 参数。Docker 会发送SIGKILL信号给容器。</p><p>docker rm [容器 id/容器 name]</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="symbol">root@</span>localhost ~]# docker rm -f <span class="number">3</span>db07fa904c9</span><br><span class="line"><span class="number">3</span>db07fa904c9</span><br></pre></td></tr></table></figure><p>批量删除多个容器<br>docker rm $(docker ps –a –q)</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">[<span class="identifier">root</span>@<span class="identifier">localhost</span> ~]</span># docker rm -f <span class="constructor">$(<span class="params">docker</span> <span class="params">ps</span> -<span class="params">a</span>)</span></span><br><span class="line"><span class="number">56</span>c3adf740ba</span><br><span class="line">e674da52f432</span><br><span class="line">acb16411ba25</span><br><span class="line">eea3221f0dac</span><br></pre></td></tr></table></figure></div><div><div><div style="text-align:center;color:#ccc;font-size:14px">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div></div></div><div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/docker/" rel="tag"><i class="fa fa-tag"></i> docker</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2018/09/01/yum-an-zhuang-docker/" rel="next" title="yum 安装docker"><i class="fa fa-chevron-left"></i> yum 安装docker</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2019/03/01/prometheus-bu-shu-you-xiang-gao-jing-qi-ye-wei-xin-gao-jing-ding-ding-gao-jing/" rel="prev" title="Prometheus部署+邮箱告警+企业微信告警+钉钉告警">Prometheus部署+邮箱告警+企业微信告警+钉钉告警 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"><div class="jiathis_style"><span class="jiathis_txt">分享到：</span> <a class="jiathis_button_fav">收藏夹</a> <a class="jiathis_button_copy">复制网址</a> <a class="jiathis_button_email">邮件</a> <a class="jiathis_button_weixin">微信</a> <a class="jiathis_button_qzone">QQ空间</a> <a class="jiathis_button_tqq">腾讯微博</a> <a class="jiathis_button_douban">豆瓣</a> <a class="jiathis_button_share">一键分享</a> <a href="http://www.jiathis.com/share?uid=2140465" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank">更多</a> <a class="jiathis_counter_style"></a></div><script type="text/javascript">var jiathis_config={data_track_clickback:!0,summary:"",shortUrl:!1,hideMore:!1}</script><script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=" charset="utf-8"></script></div></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div id="sidebar-dimmer"></div><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/images/chen.png" alt="Zhongzhou Chen"><p class="site-author-name" itemprop="name">Zhongzhou Chen</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives"><span class="site-state-item-count">12</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">8</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">8</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#一、Docker简介"><span class="nav-text">一、Docker简介</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Docker是什么"><span class="nav-text">Docker是什么?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#为什么要使用docker？"><span class="nav-text">为什么要使用docker？</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-、快速交付应用程序"><span class="nav-text">1 、快速交付应用程序</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-、更容易部署和扩展"><span class="nav-text">2 、更容易部署和扩展</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-、效率更高"><span class="nav-text">3 、效率更高</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4-、快速部署也意味着更简单的管理"><span class="nav-text">4 、快速部署也意味着更简单的管理</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#那么为啥不用VM"><span class="nav-text">那么为啥不用VM?</span></a></li></ol></li></ol><li class="nav-item nav-level-3"><a class="nav-link" href="#二、Docker-的体系结构"><span class="nav-text">二、Docker 的体系结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Docker-内部："><span class="nav-text">Docker 内部：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1、Docker-镜像-："><span class="nav-text">1、Docker 镜像 ：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、Docker-仓库-："><span class="nav-text">2、Docker 仓库 ：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3、Docker-容器-："><span class="nav-text">3、Docker 容器 ：</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-pid-namespace"><span class="nav-text">1)pid namespace</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-net-namespace"><span class="nav-text">2) net namespace</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-ipc-namespace"><span class="nav-text">3) ipc namespace</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4-mnt-namespace"><span class="nav-text">4) mnt namespace</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#5-uts-namespace"><span class="nav-text">5) uts namespace</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#6-user-namespace"><span class="nav-text">6) user namespace</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三、Docker-安装"><span class="nav-text">三、Docker 安装</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、Centos6系统安装docker"><span class="nav-text">1、Centos6系统安装docker:</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、CentOS7安装docker："><span class="nav-text">2、CentOS7安装docker：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#四、Docker-image详细介绍"><span class="nav-text">四、Docker image详细介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1）使用docker-images-显示本机上的-images"><span class="nav-text">1）使用docker images 显示本机上的 images</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2）获取-images-网络"><span class="nav-text">2）获取 images (网络)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3）查找-images-网络"><span class="nav-text">3）查找 images (网络)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4）下载-images"><span class="nav-text">4）下载 images</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-查看镜像文件docker-images"><span class="nav-text">5) 查看镜像文件docker images</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-查看完整信息"><span class="nav-text">6) 查看完整信息</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7）创建我们自己的-images"><span class="nav-text">7）创建我们自己的 images</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8）上传镜像"><span class="nav-text">8）上传镜像</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#9）用dcokerrmi移除本地-images"><span class="nav-text">9）用dcokerrmi移除本地 images</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#10）存出和载入镜像"><span class="nav-text">10）存出和载入镜像</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#五、Docker-容器"><span class="nav-text">五、Docker 容器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、新建并启动"><span class="nav-text">1、新建并启动</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、查看容器dockerps"><span class="nav-text">2、查看容器dockerps</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3、可以利用docker-start-命令，直接将一个已经终止的容器启动运行。"><span class="nav-text">3、可以利用docker start 命令，直接将一个已经终止的容器启动运行。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4、终止容器"><span class="nav-text">4、终止容器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5、重启容器"><span class="nav-text">5、重启容器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6、守护状态运行"><span class="nav-text">6、守护状态运行</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7、用docker-inspect查看容器的信息"><span class="nav-text">7、用docker inspect查看容器的信息</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8、进入容器"><span class="nav-text">8、进入容器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#9、使用nsenter进入容器"><span class="nav-text">9、使用nsenter进入容器</span></a></li></ol></li></div></div></section><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span id="scrollpercent"><span>0</span>%</span></div></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="copyright">&copy; <span itemprop="copyrightYear">2019</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">Zhongzhou Chen</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-area-chart"></i> </span><span class="post-meta-item-text">Site words total count&#58;</span> <span title="Site words total count">17.4k</span></div><span class="post-meta-divider"></span></div></footer></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script><script type="text/javascript">function proceedsearch(){$("body").append('<div class="search-popup-overlay local-search-pop-overlay"></div>').css("overflow","hidden"),$(".search-popup-overlay").click(onPopupClose),$(".popup").toggle();var t=$("#local-search-input");t.attr("autocapitalize","none"),t.attr("autocorrect","off"),t.focus()}var isfetched=!1,isXml=!0,search_path="search.xml";0===search_path.length?search_path="search.xml":/json$/i.test(search_path)&&(isXml=!1);var path="/"+search_path,onPopupClose=function(t){$(".popup").hide(),$("#local-search-input").val(""),$(".search-result-list").remove(),$("#no-result").remove(),$(".local-search-pop-overlay").remove(),$("body").css("overflow","")},searchFunc=function(t,e,o){"use strict";$("body").append('<div class="search-popup-overlay local-search-pop-overlay"><div id="search-loading-icon"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div>').css("overflow","hidden"),$("#search-loading-icon").css("margin","20% auto 0 auto").css("text-align","center"),$.ajax({url:t,dataType:isXml?"xml":"json",async:!0,success:function(t){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var n=isXml?$("entry",t).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get():t,r=document.getElementById(e),s=document.getElementById(o),a=function(){var t=r.value.trim().toLowerCase(),e=t.split(/[\s\-]+/);e.length>1&&e.push(t);var o=[];if(t.length>0&&n.forEach(function(n){function r(e,o,n,r){for(var s=r[r.length-1],a=s.position,i=s.word,l=[],h=0;a+i.length<=n&&0!=r.length;){i===t&&h++,l.push({position:a,length:i.length});var p=a+i.length;for(r.pop();0!=r.length&&(s=r[r.length-1],a=s.position,i=s.word,p>a);)r.pop()}return c+=h,{hits:l,start:o,end:n,searchTextCount:h}}function s(t,e){var o="",n=e.start;return e.hits.forEach(function(e){o+=t.substring(n,e.position);var r=e.position+e.length;o+='<b class="search-keyword">'+t.substring(e.position,r)+"</b>",n=r}),o+=t.substring(n,e.end)}var a=!1,i=0,c=0,l=n.title.trim(),h=l.toLowerCase(),p=n.content.trim().replace(/<[^>]+>/g,""),u=p.toLowerCase(),f=decodeURIComponent(n.url),d=[],g=[];if(""!=l&&(e.forEach(function(t){function e(t,e,o){var n=t.length;if(0===n)return[];var r=0,s=[],a=[];for(o||(e=e.toLowerCase(),t=t.toLowerCase());(s=e.indexOf(t,r))>-1;)a.push({position:s,word:t}),r=s+n;return a}d=d.concat(e(t,h,!1)),g=g.concat(e(t,u,!1))}),(d.length>0||g.length>0)&&(a=!0,i=d.length+g.length)),a){[d,g].forEach(function(t){t.sort(function(t,e){return e.position!==t.position?e.position-t.position:t.word.length-e.word.length})});var v=[];0!=d.length&&v.push(r(l,0,l.length,d));for(var $=[];0!=g.length;){var C=g[g.length-1],m=C.position,x=C.word,w=m-20,y=m+80;0>w&&(w=0),y<m+x.length&&(y=m+x.length),y>p.length&&(y=p.length),$.push(r(p,w,y,g))}$.sort(function(t,e){return t.searchTextCount!==e.searchTextCount?e.searchTextCount-t.searchTextCount:t.hits.length!==e.hits.length?e.hits.length-t.hits.length:t.start-e.start});var T=parseInt("1");T>=0&&($=$.slice(0,T));var b="";b+=0!=v.length?"<li><a href='"+f+"' class='search-result-title'>"+s(l,v[0])+"</a>":"<li><a href='"+f+"' class='search-result-title'>"+l+"</a>",$.forEach(function(t){b+="<a href='"+f+'\'><p class="search-result">'+s(p,t)+"...</p></a>"}),b+="</li>",o.push({item:b,searchTextCount:c,hitCount:i,id:o.length})}}),1===e.length&&""===e[0])s.innerHTML='<div id="no-result"><i class="fa fa-search fa-5x" /></div>';else if(0===o.length)s.innerHTML='<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>';else{o.sort(function(t,e){return t.searchTextCount!==e.searchTextCount?e.searchTextCount-t.searchTextCount:t.hitCount!==e.hitCount?e.hitCount-t.hitCount:e.id-t.id});var a='<ul class="search-result-list">';o.forEach(function(t){a+=t.item}),a+="</ul>",s.innerHTML=a}};r.addEventListener("input",a),$(".local-search-pop-overlay").remove(),$("body").css("overflow",""),proceedsearch()}})};$(".popup-trigger").click(function(t){t.stopPropagation(),isfetched===!1?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(onPopupClose),$(".popup").click(function(t){t.stopPropagation()}),$(document).on("keyup",function(t){var e=27===t.which&&$(".search-popup").is(":visible");e&&onPopupClose()})</script><script type="text/javascript" src="/js/src/clipboard.min.js"></script><script type="text/javascript" src="/js/src/clipboard-use.js"></script><script type="text/javascript" src="/js/src/love.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,log:!1,model:{jsonPath:"/live2dw/assets/shizuku.model.json"},display:{position:"right"},mobile:{show:!0,scale:.5},react:{opacityDefault:.7,opacityOnHover:.2}})</script></body></html><!-- rebuild by neat -->