<!DOCTYPE html><html class="theme-next gemini use-motion" lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script><link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet"><script></script><meta name="theme-color" content="#222"><style>.pace .pace-progress{background:#1e92fb;height:3px}.pace .pace-progress-inner{box-shadow:0 0 10px #1e92fb,0 0 5px #1e92fb}.pace .pace-activity{border-top-color:#1e92fb;border-left-color:#1e92fb}</style><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="google-site-verification" content="HGM141IpbHrSmnAmR6W_zE4bo9Z3f-yXLeHYT3bg1fk"><meta name="baidu-site-verification" content="code-5Ai1DA8e6T"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4"><link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222"><meta name="keywords" content="消息队列,Kafka,"><link rel="alternate" href="/atom.xml" title="凡间的精灵" type="application/atom+xml"><meta name="description" content="一 、Kafka 简介Apache kafka 是一个分布式的基于push-subscribe的消息系统，它具备快速、可扩展、可持久化的特点。作为hadoop生态系统的一部分，被各种商业公司广泛应用。它的最大的特性就是可以实时的处理大量数据以满足各种需求场景：比如基于hadoop的批处理系统、低延迟的实时系统、storm&#x2F;spark流式处理引擎、海量日志系统等。二、Kafka 技术概览2.1 Ka"><meta name="keywords" content="消息队列,Kafka"><meta property="og:type" content="article"><meta property="og:title" content="Kafka 原理"><meta property="og:url" content="http:&#x2F;&#x2F;chenzhonzhou.github.io&#x2F;2019&#x2F;06&#x2F;15&#x2F;kafka-yuan-li&#x2F;index.html"><meta property="og:site_name" content="凡间的精灵"><meta property="og:description" content="一 、Kafka 简介Apache kafka 是一个分布式的基于push-subscribe的消息系统，它具备快速、可扩展、可持久化的特点。作为hadoop生态系统的一部分，被各种商业公司广泛应用。它的最大的特性就是可以实时的处理大量数据以满足各种需求场景：比如基于hadoop的批处理系统、低延迟的实时系统、storm&#x2F;spark流式处理引擎、海量日志系统等。二、Kafka 技术概览2.1 Ka"><meta property="og:locale" content="zh-Hans"><meta property="og:image" content="http:&#x2F;&#x2F;chenzhonzhou.github.io&#x2F;2019&#x2F;06&#x2F;15&#x2F;kafka-yuan-li&#x2F;%E5%9B%BE%E7%89%871.png"><meta property="og:image" content="http:&#x2F;&#x2F;chenzhonzhou.github.io&#x2F;2019&#x2F;06&#x2F;15&#x2F;kafka-yuan-li&#x2F;%E5%9B%BE%E7%89%872.png"><meta property="og:image" content="http:&#x2F;&#x2F;chenzhonzhou.github.io&#x2F;2019&#x2F;06&#x2F;15&#x2F;kafka-yuan-li&#x2F;%E5%9B%BE%E7%89%8711.png"><meta property="og:image" content="http:&#x2F;&#x2F;chenzhonzhou.github.io&#x2F;2019&#x2F;06&#x2F;15&#x2F;kafka-yuan-li&#x2F;%E5%9B%BE%E7%89%873.png"><meta property="og:image" content="http:&#x2F;&#x2F;chenzhonzhou.github.io&#x2F;2019&#x2F;06&#x2F;15&#x2F;kafka-yuan-li&#x2F;%E5%9B%BE%E7%89%879.png"><meta property="og:image" content="http:&#x2F;&#x2F;chenzhonzhou.github.io&#x2F;2019&#x2F;06&#x2F;15&#x2F;kafka-yuan-li&#x2F;%E5%9B%BE%E7%89%8710.png"><meta property="og:image" content="http:&#x2F;&#x2F;chenzhonzhou.github.io&#x2F;2019&#x2F;06&#x2F;15&#x2F;kafka-yuan-li&#x2F;%E5%9B%BE%E7%89%874.png"><meta property="og:image" content="http:&#x2F;&#x2F;chenzhonzhou.github.io&#x2F;2019&#x2F;06&#x2F;15&#x2F;kafka-yuan-li&#x2F;%E5%9B%BE%E7%89%875.png"><meta property="og:image" content="http:&#x2F;&#x2F;chenzhonzhou.github.io&#x2F;2019&#x2F;06&#x2F;15&#x2F;kafka-yuan-li&#x2F;%E5%9B%BE%E7%89%876.png"><meta property="og:image" content="http:&#x2F;&#x2F;chenzhonzhou.github.io&#x2F;2019&#x2F;06&#x2F;15&#x2F;kafka-yuan-li&#x2F;%E5%9B%BE%E7%89%877.png"><meta property="og:image" content="http:&#x2F;&#x2F;chenzhonzhou.github.io&#x2F;2019&#x2F;06&#x2F;15&#x2F;kafka-yuan-li&#x2F;%E5%9B%BE%E7%89%878.png"><meta property="og:updated_time" content="2021-12-23T09:57:45.662Z"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http:&#x2F;&#x2F;chenzhonzhou.github.io&#x2F;2019&#x2F;06&#x2F;15&#x2F;kafka-yuan-li&#x2F;%E5%9B%BE%E7%89%871.png"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Gemini",version:"5.1.4",sidebar:{position:"left",display:"always",offset:12,b2t:!0,scrollpercent:!0,onmobile:!0},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://chenzhonzhou.github.io/2019/06/15/kafka-yuan-li/"><title>Kafka 原理 | 凡间的精灵</title><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">凡间的精灵</span><span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">凡尘落素一精灵</p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-categories"><a href="/categories" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="menu-item-icon fa fa-fw fa-sitemap"></i><br>站点地图</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i></span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://chenzhonzhou.github.io/2019/06/15/kafka-yuan-li/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Zhongzhou Chen"><meta itemprop="description" content=""><meta itemprop="image" content="/images/chen.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="凡间的精灵"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Kafka 原理</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-15T10:26:30+08:00">2019-06-15</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">消息队列</span></a></span> ， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Kafka/" itemprop="url" rel="index"><span itemprop="name">Kafka</span></a></span></span><div class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">7.7k</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span> <span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">27</span></div></div></header><div class="post-body" itemprop="articleBody"><h2 id="一-、Kafka-简介"><a href="#一-、Kafka-简介" class="headerlink" title="一 、Kafka 简介"></a>一 、Kafka 简介</h2><p>Apache kafka 是一个分布式的基于push-subscribe的消息系统，它具备快速、可扩展、可持久化的特点。作为hadoop生态系统的一部分，被各种商业公司广泛应用。它的最大的特性就是可以实时的处理大量数据以满足各种需求场景：比如基于hadoop的批处理系统、低延迟的实时系统、storm/spark流式处理引擎、海量日志系统等。</p><h2 id="二、Kafka-技术概览"><a href="#二、Kafka-技术概览" class="headerlink" title="二、Kafka 技术概览"></a>二、Kafka 技术概览</h2><h3 id="2-1-Kafka-的特性"><a href="#2-1-Kafka-的特性" class="headerlink" title="2.1 Kafka 的特性"></a>2.1 Kafka 的特性</h3><blockquote><p><strong>高吞吐量、低延迟：</strong>kafka每秒可以处理几十万条消息，它的延迟最低只有几毫秒；<br><strong>可扩展性：</strong>kafka集群支持热扩展；<br><strong>持久性、可靠性：</strong>消息被持久化到本地磁盘，并且支持数据备份防止数据丢失；<br><strong>容错性：</strong>允许集群中节点失败（若副本数量为n,则允许n-1个节点失败）；<br><strong>高并发：</strong>支持数千个客户端同时读写。</p></blockquote><h3 id="2-2-Kafka-设计思想"><a href="#2-2-Kafka-设计思想" class="headerlink" title="2.2 Kafka 设计思想"></a>2.2 Kafka 设计思想</h3><blockquote><p><strong>Consumergroup：</strong>各个consumer可以组成一个组，每个消息只能被组中的一个consumer消费，如果一个消息可以被多个consumer消费的话，那么这些consumer必须在不同的组。<br><strong>消息状态：</strong>在Kafka中，消息的状态被保存在consumer中，broker不会关心哪个消息被消费了被谁消费了，只记录一个offset值（指向partition中下一个要被消费的消息位置），这就意味着如果consumer处理不好的话，broker上的一个消息可能会被消费多次。<br><strong>消息持久化：</strong>Kafka中会把消息持久化到本地文件系统中，并且保持极高的效率。<br><strong>消息有效期：</strong>Kafka会长久保留其中的消息，以便consumer可以多次消费，当然其中很多细节是可配置的。<br><strong>批量发送：</strong>Kafka支持以消息集合为单位进行批量发送，以提高push效率。<br><strong>push-and-pull :</strong> Kafka中的Producer和consumer采用的是push-and-pull模式，即Producer只管向broker push消息，consumer只管从broker pull消息，两者对消息的生产和消费是异步的。<br><strong>Kafka集群中broker之间的关系：</strong>不是主从关系，各个broker在集群中地位一样，我们可以随意的增加或删除任何一个broker节点。<br><strong>负载均衡方面：</strong> Kafka提供了一个 metadata API来管理broker之间的负载（对Kafka0.8.x而言，对于0.7.x主要靠zookeeper来实现负载均衡）。<br><strong>同步异步：</strong>Producer采用异步push方式，极大提高Kafka系统的吞吐率（可以通过参数控制是采用同步还是异步方式）。<br><strong>分区机制partition：</strong>Kafka的broker端支持消息分区，Producer可以决定把消息发到哪个分区，在一个分区中消息的顺序就是Producer发送消息的顺序，一个主题中可以有多个分区，具体分区的数量是可配置的。分区的意义很重大，后面的内容会逐渐体现。<br><strong>离线数据装载：</strong>Kafka由于对可拓展的数据持久化的支持，它也非常适合向Hadoop或者数据仓库中进行数据装载。<br><strong>插件支持：</strong>现在不少活跃的社区已经开发出不少插件来拓展Kafka的功能，如用来配合Storm、Hadoop、flume相关的插件。</p></blockquote><h3 id="2-3-kafka-应用场景"><a href="#2-3-kafka-应用场景" class="headerlink" title="2.3 kafka 应用场景"></a>2.3 kafka 应用场景</h3><p><strong>日志收集：</strong>一个公司可以用Kafka可以收集各种服务的log，通过kafka以统一接口服务的方式开放给各种consumer，例如hadoop、Hbase、Solr等。<br><strong>消息系统：</strong>解耦和生产者和消费者、缓存消息等。<br><strong>用户活动跟踪</strong>：Kafka经常被用来记录web用户或者app用户的各种活动，如浏览网页、搜索、点击等活动，这些活动信息被各个服务器发布到kafka的topic中，然后订阅者通过订阅这些topic来做实时的监控分析，或者装载到hadoop、数据仓库中做离线分析和挖掘。<br><strong>运营指标：</strong>Kafka也经常用来记录运营监控数据。包括收集各种分布式应用的数据，生产各种操作的集中反馈，比如报警和报告。<br><strong>流式处理：</strong>比如spark streaming和storm事件源</p><h3 id="2-4-Kafka-架构组件"><a href="#2-4-Kafka-架构组件" class="headerlink" title="2.4 Kafka 架构组件"></a>2.4 Kafka 架构组件</h3><p>Kafka中发布订阅的对象是topic。我们可以为每类数据创建一个topic，把向topic发布消息的客户端称作producer，从topic订阅消息的客户端称作consumer。Producers和consumers可以同时从多个topic读写数据。一个kafka集群由一个或多个broker服务器组成，它负责持久化和备份具体的kafka消息。</p><p><img src="/2019/06/15/kafka-yuan-li/%E5%9B%BE%E7%89%871.png" alt="图片1"></p><blockquote><p><strong>topic：</strong>消息存放的目录即主题<br><strong>Producer：</strong>生产消息到topic的一方<br><strong>Consumer：</strong>订阅topic消费消息的一方<br><strong>Broker：</strong>Kafka的服务实例就是一个broker</p></blockquote><h3 id="2-5-Kafka-Topic-amp-Partition"><a href="#2-5-Kafka-Topic-amp-Partition" class="headerlink" title="2.5 Kafka Topic&amp;Partition"></a>2.5 Kafka Topic&amp;Partition</h3><p>消息发送时都被发送到一个topic，其本质就是一个目录，而topic由是由一些Partition Logs(分区日志)组成，其组织结构如下图所示：</p><p><img src="/2019/06/15/kafka-yuan-li/%E5%9B%BE%E7%89%872.png" alt="图片2"></p><p>可以看到，每个Partition中的消息都是有序的，生产的消息被不断追加到Partition log上，其中的每一个消息都被赋予了一个唯一的offset值。<br>Kafka集群会保存所有的消息，不管消息有没有被消费；我们可以设定消息的过期时间，只有过期的数据才会被自动清除以释放磁盘空间。比如我们设置消息过期时间为2天，那么这2天内的所有消息都会被保存到集群中，数据只有超过了两天才会被清除。<br>Kafka需要维持的元数据只有一个–消费消息在Partition中的offset值，Consumer每消费一个消息，offset就会加1。其实消息的状态完全是由Consumer控制的，Consumer可以跟踪和重设这个offset值，这样的话Consumer就可以读取任意位置的消息。<br>把消息日志以Partition的形式存放有多重考虑，第一，方便在集群中扩展，每个Partition可以通过调整以适应它所在的机器，而一个topic又可以有多个Partition组成，因此整个集群就可以适应任意大小的数据了；第二就是可以提高并发，因为可以以Partition为单位读写了。</p><h2 id="三、Kafka-核心组件"><a href="#三、Kafka-核心组件" class="headerlink" title="三、Kafka 核心组件"></a>三、Kafka 核心组件</h2><p><img src="/2019/06/15/kafka-yuan-li/%E5%9B%BE%E7%89%8711.png" alt="图片11"></p><blockquote><ul><li><strong>Producer：</strong>Producer 即生产者，消息的产生者，是消息的入口。</li><li><strong>Kafka Cluster：</strong> Broker：Broker 是 Kafka 实例，每个服务器上有一个或多个 Kafka 的实例，我们姑且认为每个 Broker 对应一台服务器。 每个 Kafka 集群内的 Broker 都有一个不重复的编号，如图中的 Broker-0、Broker-1 等……</li><li><strong>Topic：</strong>消息的主题，可以理解为消息的分类，Kafka 的数据就保存在 Topic。在每个 Broker 上都可以创建多个 Topic。</li><li><strong>Partition：</strong>Topic 的分区，每个 Topic 可以有多个分区，分区的作用是做负载，提高 Kafka 的吞吐量。 同一个 Topic 在不同的分区的数据是不重复的，Partition 的表现形式就是一个一个的文件夹。</li><li><strong>Replication：</strong>每一个分区都有多个副本，副本的作用是做备胎。当主分区（Leader）故障的时候会选择一个备胎（Follower）上位，成为 Leader。 在 Kafka 中默认副本的最大数量是 10 个，且副本的数量不能大于 Broker 的数量，Follower 和 Leader 绝对是在不同的机器，同一机器对同一个分区也只可能存放一个副本（包括自己）。</li><li><strong>Message：</strong>每一条发送的消息主体。</li><li><strong>Consumer：</strong>消费者，即消息的消费方，是消息的出口。</li><li><strong>Consumer Group：</strong>我们可以将多个消费者组成一个消费者组，在 Kafka 的设计中同一个分区的数据只能被消费者组中的某一个消费者消费。 同一个消费者组的消费者可以消费同一个 Topic 的不同分区的数据，这也是为了提高 Kafka 的吞吐量。</li><li><strong>Zookeeper：</strong>Kafka 集群依赖 Zookeeper 来保存集群的的元信息，来保证系统的可用性。</li></ul></blockquote><h2 id="四、Kafka-核心特性"><a href="#四、Kafka-核心特性" class="headerlink" title="四、Kafka 核心特性"></a>四、Kafka 核心特性</h2><h3 id="4-1-压缩"><a href="#4-1-压缩" class="headerlink" title="4.1 压缩"></a>4.1 压缩</h3><p>我们上面已经知道了Kafka支持以集合（batch）为单位发送消息，在此基础上，Kafka还支持对消息集合进行压缩，Producer端可以通过GZIP或Snappy格式对消息集合进行压缩。Producer端进行压缩之后，在Consumer端需进行解压。压缩的好处就是减少传输的数据量，减轻对网络传输的压力，在对大数据处理上，瓶颈往往体现在网络上而不是CPU（压缩和解压会耗掉部分CPU资源）。<br>那么如何区分消息是压缩的还是未压缩的呢，Kafka在消息头部添加了一个描述压缩属性字节，这个字节的后两位表示消息的压缩采用的编码，如果后两位为0，则表示消息未被压缩。</p><h3 id="4-2-消息可靠性"><a href="#4-2-消息可靠性" class="headerlink" title="4.2 消息可靠性"></a>4.2 消息可靠性</h3><p>在消息系统中，保证消息在生产和消费过程中的可靠性是十分重要的，在实际消息传递过程中，可能会出现如下三中情况：</p><ul><li>一个消息发送失败</li><li>一个消息被发送多次</li><li>最理想的情况：exactly-once ,一个消息发送成功且仅发送了一次</li></ul><p>有许多系统声称它们实现了exactly-once，但是它们其实忽略了生产者或消费者在生产和消费过程中有可能失败的情况。比如虽然一个Producer成功发送一个消息，但是消息在发送途中丢失，或者成功发送到broker，也被consumer成功取走，但是这个consumer在处理取过来的消息时失败了。<br>从Producer端看：Kafka是这么处理的，当一个消息被发送后，Producer会等待broker成功接收到消息的反馈（可通过参数控制等待时间），如果消息在途中丢失或是其中一个broker挂掉，Producer会重新发送（我们知道Kafka有备份机制，可以通过参数控制是否等待所有备份节点都收到消息）。<br>从Consumer端看：前面讲到过partition，broker端记录了partition中的一个offset值，这个值指向Consumer下一个即将消费message。当Consumer收到了消息，但却在处理过程中挂掉，此时Consumer可以通过这个offset值重新找到上一个消息再进行处理。Consumer还有权限控制这个offset值，对持久化到broker端的消息做任意处理。</p><h3 id="4-3-备份机制"><a href="#4-3-备份机制" class="headerlink" title="4.3 备份机制"></a>4.3 备份机制</h3><p>备份机制是Kafka0.8版本的新特性，备份机制的出现大大提高了Kafka集群的可靠性、稳定性。有了备份机制后，Kafka允许集群中的节点挂掉后而不影响整个集群工作。一个备份数量为n的集群允许n-1个节点失败。在所有备份节点中，有一个节点作为lead节点，这个节点保存了其它备份节点列表，并维持各个备份间的状体同步。下面这幅图解释了Kafka的备份机制:</p><p><img src="/2019/06/15/kafka-yuan-li/%E5%9B%BE%E7%89%873.png" alt="图片3"></p><h3 id="4-4-Kafka高效性相关设计"><a href="#4-4-Kafka高效性相关设计" class="headerlink" title="4.4 Kafka高效性相关设计"></a>4.4 Kafka高效性相关设计</h3><h4 id="4-4-1-消息的持久化"><a href="#4-4-1-消息的持久化" class="headerlink" title="4.4.1 消息的持久化"></a>4.4.1 消息的持久化</h4><p>Kafka高度依赖文件系统来存储和缓存消息，一般的人认为磁盘是缓慢的，这导致人们对持久化结构具有竞争性持怀疑态度。其实，磁盘远比你想象的要快或者慢，这决定于我们如何使用磁盘。<br>一个和磁盘性能有关的关键事实是：磁盘驱动器的吞吐量跟寻到延迟是相背离的，也就是说，线性写的速度远远大于随机写。比如：在一个7200rpm SATA RAID-5 的磁盘阵列上线性写的速度大概是600M/秒，但是随机写的速度只有100K/秒，两者相差将近6000倍。线性读写在大多数应用场景下是可以预测的，因此，操作系统利用read-ahead和write-behind技术来从大的数据块中预取数据，或者将多个逻辑上的写操作组合成一个大写物理写操作中。更多的讨论可以在<a href="http://queue.acm.org/detail.cfm?id=1563874" target="_blank" rel="noopener">ACMQueueArtical</a>中找到，他们发现，对磁盘的线性读在有些情况下可以比内存的随机访问要快一些。<br>为了补偿这个性能上的分歧，现代操作系统都会把空闲的内存用作磁盘缓存，尽管在内存回收的时候会有一点性能上的代价。所有的磁盘读写操作会在这个统一的缓存上进行。<br>此外，如果我们是在JVM的基础上构建的，熟悉java内存应用管理的人应该清楚以下两件事情：</p><ul><li>一个对象的内存消耗是非常高的，经常是所存数据的两倍或者更多；</li><li>随着堆内数据的增多，Java的垃圾回收会变得非常昂贵。</li></ul><p>基于这些事实，利用文件系统并且依靠页缓存比维护一个内存缓存或者其他结构要好——我们至少要使得可用的缓存加倍，通过自动访问可用内存，并且通过存储更紧凑的字节结构而不是一个对象，这将有可能再次加倍。这么做的结果就是在一台32GB的机器上，如果不考虑GC惩罚，将最多有28-30GB的缓存。此外，这些缓存将会一直存在即使服务重启，然而进程内缓存需要在内存中重构（10GB缓存需要花费10分钟）或者它需要一个完全冷缓存启动（非常差的初始化性能）。它同时也简化了代码，因为现在所有的维护缓存和文件系统之间内聚的逻辑都在操作系统内部了，这使得这样做比one-off in-process attempts更加高效与准确。如果你的磁盘应用更加倾向于顺序读取，那么read-ahead在每次磁盘读取中实际上获取到这人缓存中的有用数据。<br>以上这些建议了一个简单的设计：不同于维护尽可能多的内存缓存并且在需要的时候刷新到文件系统中，我们换一种思路。所有的数据不需要调用刷新程序，而是立刻将它写到一个持久化的日志中。事实上，这仅仅意味着，数据将被传输到内核页缓存中并稍后被刷新。我们可以增加一个配置项以让系统的用户来控制数据在什么时候被刷新到物理硬盘上。</p><h4 id="4-4-2-常数时间性能保证"><a href="#4-4-2-常数时间性能保证" class="headerlink" title="4.4.2 常数时间性能保证"></a>4.4.2 常数时间性能保证</h4><p>消息系统中持久化数据结构的设计通常是维护者一个和消费队列有关的B树或者其它能够随机存取结构的元数据信息。B树是一个很好的结构，可以用在事务型与非事务型的语义中。但是它需要一个很高的花费，尽管B树的操作需要O(logN)。通常情况下，这被认为与常数时间等价，但这对磁盘操作来说是不对的。磁盘寻道一次需要10ms，并且一次只能寻一个，因此并行化是受限的。<br>直觉上来讲，一个持久化的队列可以构建在对一个文件的读和追加上，就像一般情况下的日志解决方案。尽管和B树相比，这种结构不能支持丰富的语义，但是它有一个优点，所有的操作都是常数时间，并且读写之间不会相互阻塞。这种设计具有极大的性能优势：最终系统性能和数据大小完全无关，服务器可以充分利用廉价的硬盘来提供高效的消息服务。<br>事实上还有一点，磁盘空间的无限增大而不影响性能这点，意味着我们可以提供一般消息系统无法提供的特性。比如说，消息被消费后不是立马被删除，我们可以将这些消息保留一段相对比较长的时间（比如一个星期）。</p><h4 id="4-4-3-进一步提高效率"><a href="#4-4-3-进一步提高效率" class="headerlink" title="4.4.3 进一步提高效率"></a>4.4.3 进一步提高效率</h4><p>我们已经为效率做了非常多的努力。但是有一种非常主要的应用场景是：处理Web活动数据，它的特点是数据量非常大，每一次的网页浏览都会产生大量的写操作。更进一步，我们假设每一个被发布的消息都会被至少一个consumer消费，因此我们更要努力让消费变得更廉价。<br>通过上面的介绍，我们已经解决了磁盘方面的效率问题，除此之外，在此类系统中还有两类比较低效的场景：</p><ul><li>太多小的I/O操作</li><li>过多的字节拷贝</li></ul><p>为了减少大量小I/O操作的问题，kafka的协议是围绕消息集合构建的。Producer一次网络请求可以发送一个消息集合，而不是每一次只发一条消息。在server端是以消息块的形式追加消息到log中的，consumer在查询的时候也是一次查询大量的线性数据块。消息集合即MessageSet，实现本身是一个非常简单的API，它将一个字节数组或者文件进行打包。所以对消息的处理，这里没有分开的序列化和反序列化的步骤，消息的字段可以按需反序列化（如果没有需要，可以不用反序列化）。<br>另一个影响效率的问题就是字节拷贝。为了解决字节拷贝的问题，kafka设计了一种“标准字节消息”，Producer、Broker、Consumer共享这一种消息格式。Kakfa的message log在broker端就是一些目录文件，这些日志文件都是MessageSet按照这种“标准字节消息”格式写入到磁盘的。<br>维持这种通用的格式对这些操作的优化尤为重要：持久化log 块的网络传输。流行的unix操作系统提供了一种非常高效的途径来实现页面缓存和socket之间的数据传递。在Linux操作系统中，这种方式被称作：sendfile system call（Java提供了访问这个系统调用的方法：FileChannel.transferTo api）。</p><p>为了理解sendfile的影响，需要理解一般的将数据从文件传到socket的路径：</p><ul><li>操作系统将数据从磁盘读到内核空间的页缓存中；</li><li>应用将数据从内核空间读到用户空间的缓存中；</li><li>应用将数据写回内核空间的socket缓存中；</li><li>操作系统将数据从socket缓存写到网卡缓存中，以便将数据经网络发出。</li></ul><p>这种操作方式明显是非常低效的，这里有四次拷贝，两次系统调用。如果使用sendfile，就可以避免两次拷贝：操作系统将数据直接从页缓存发送到网络上。所以在这个优化的路径中，只有最后一步将数据拷贝到网卡缓存中是需要的。<br>我们期望一个主题上有多个消费者是一种常见的应用场景。利用上述的zero-copy，数据只被拷贝到页缓存一次，然后就可以在每次消费时被重复利用，而不需要将数据存在内存中，然后在每次读的时候拷贝到内核空间中。这使得消息消费速度可以达到网络连接的速度。这样以来，通过页面缓存和sendfile的结合使用，整个kafka集群几乎都已以缓存的方式提供服务，而且即使下游的consumer很多，也不会对整个集群服务造成压力。<br>关于sendfile和zero-copy，请参考：<a href="https://www.ibm.com/developerworks/linux/library/j-zerocopy/" target="_blank" rel="noopener">zero-copy</a></p><h3 id="4-5-Kafka-工作模式"><a href="#4-5-Kafka-工作模式" class="headerlink" title="4.5 Kafka 工作模式"></a>4.5 Kafka 工作模式</h3><h4 id="4-5-1-点对点模式"><a href="#4-5-1-点对点模式" class="headerlink" title="4.5.1 点对点模式"></a>4.5.1 点对点模式</h4><p><img src="/2019/06/15/kafka-yuan-li/%E5%9B%BE%E7%89%879.png" alt="图片9"></p><p>如上图所示，点对点模式通常是基于拉取或者轮询的消息传送模型，这个模型的特点是发送到队列的消息被一个且只有一个消费者进行处理。</p><p>生产者将消息放入消息队列后，由消费者主动的去拉取消息进行消费。点对点模型的优点是消费者拉取消息的频率可以由自己控制。</p><p>但是消息队列是否有消息需要消费，在消费者端无法感知，所以在消费者端需要额外的线程去监控。</p><h4 id="4-5-2-发布订阅模式"><a href="#4-5-2-发布订阅模式" class="headerlink" title="4.5.2 发布订阅模式"></a>4.5.2 发布订阅模式</h4><p><img src="/2019/06/15/kafka-yuan-li/%E5%9B%BE%E7%89%8710.png" alt="图片10"></p><p>如上图所示，发布订阅模式是一个基于消息送的消息传送模型，该模型可以有多种不同的订阅者。</p><p>生产者将消息放入消息队列后，队列会将消息推送给订阅过该类消息的消费者（类似微信公众号）。</p><p>由于是消费者被动接收推送，所以无需感知消息队列是否有待消费的消息！但是 Consumer1、Consumer2、Consumer3 由于机器性能不一样，所以处理消息的能力也会不一样，但消息队列却无法感知消费者消费的速度！</p><p>所以推送的速度成了发布订阅模式的一个问题！假设三个消费者处理速度分别是 8M/s、5M/s、2M/s，如果队列推送的速度为 5M/s，则 Consumer3 无法承受！</p><p>如果队列推送的速度为 2M/s，则 Consumer1、Consumer2 会出现资源的极大浪费！</p><h2 id="五、Kafka-工作流程分析"><a href="#五、Kafka-工作流程分析" class="headerlink" title="五、Kafka 工作流程分析"></a>五、Kafka 工作流程分析</h2><h3 id="5-1-发送数据"><a href="#5-1-发送数据" class="headerlink" title="5.1 发送数据"></a>5.1 发送数据</h3><p>我们看上面的架构图中，Producer 就是生产者，是数据的入口。注意看图中的红色箭头，Producer 在写入数据的时候永远在找 Leader，不会直接将数据写入 Follower。</p><p>那 Leader 怎么找呢？写入的流程又是什么样的呢？我们看下图：</p><p><img src="/2019/06/15/kafka-yuan-li/%E5%9B%BE%E7%89%874.png" alt="图片4"></p><p>需要注意的一点是，消息写入 Leader 后，Follower 是主动的去 Leader 进行同步的！</p><p>Producer 采用 Push 模式将数据发布到 Broker，每条消息追加到分区中，顺序写入磁盘，所以保证同一分区内的数据是有序的！</p><p>写入示意图如下：</p><p><img src="/2019/06/15/kafka-yuan-li/%E5%9B%BE%E7%89%875.png" alt="图片5"></p><p>上面说到数据会写入到不同的分区，分区的主要目的是：</p><ul><li>方便扩展。因为一个 Topic 可以有多个 Partition，所以我们可以通过扩展机器去轻松的应对日益增长的数据量；</li><li>提高并发。以 Partition 为读写单位，可以多个消费者同时消费数据，提高了消息的处理效率。</li></ul><p>熟悉负载均衡的朋友应该知道，当我们向某个服务器发送请求的时候，服务端可能会对请求做一个负载，将流量分发到不同的服务器。</p><p>那在 Kafka 中，如果某个 Topic 有多个 Partition，Producer 又怎么知道该将数据发往哪个 Partition 呢？</p><p><strong>Kafka 中有几个原则：</strong></p><ul><li>Partition 在写入的时候可以指定需要写入的 Partition，如果有指定，则写入对应的 Partition；</li><li>如果没有指定 Partition，但是设置了数据的 Key，则会根据 Key 的值 Hash 出一个 Partition；</li><li>如果既没指定 Partition，又没有设置 Key，则会轮询选出一个 Partition。</li></ul><p>保证消息不丢失是一个消息队列中间件的基本保证，那 Producer 在向 Kafka 写入消息的时候，怎么保证消息不丢失呢？</p><p>其实上面的写入流程图中有描述出来，那就是通过 ACK 应答机制！在生产者向队列写入数据的时候可以设置参数来确定是否确认 Kafka 接收到数据，这个参数可设置的值为 0、1、all：</p><ul><li>0 代表 Producer 往集群发送数据不需要等到集群的返回，不确保消息发送成功。安全性最低但是效率最高。</li><li>1 代表 Producer 往集群发送数据只要 Leader 应答就可以发送下一条，只确保 Leader 发送成功。</li><li>all 代表 Producer 往集群发送数据需要所有的 Follower 都完成从 Leader 的同步才会发送下一条，确保 Leader 发送成功和所有的副本都完成备份。安全性最高，但是效率最低。</li></ul><p>最后要注意的是，如果往不存在的 Topic 写数据，能不能写入成功呢？Kafka 会自动创建 Topic，分区和副本的数量根据默认配置都是 1。</p><h3 id="5-2-保存数据"><a href="#5-2-保存数据" class="headerlink" title="5.2 保存数据"></a>5.2 保存数据</h3><p>Producer 将数据写入 Kafka 后，集群就需要对数据进行保存了。Kafka 将数据保存在磁盘，可能在我们的一般的认知里，写入磁盘是比较耗时的操作，不适合这种高并发的组件。Kafka 初始会单独开辟一块磁盘空间，顺序写入数据（效率比随机写入高）。</p><h4 id="5-2-1-Partition-结构"><a href="#5-2-1-Partition-结构" class="headerlink" title="5.2.1 Partition 结构"></a>5.2.1 Partition 结构</h4><p>前面说过了每个 Topic 都可以分为一个或多个 Partition，如果你觉得 Topic 比较抽象，那 Partition 就是比较具体的东西了！</p><p>Partition 在服务器上的表现形式就是一个一个的文件夹，每个 Partition 的文件夹下面会有多组 Segment 文件。</p><p>每组 Segment 文件又包含 .index 文件、.log 文件、.timeindex 文件（早期版本中没有）三个文件。</p><p>Log 文件就是实际存储 Message 的地方，而 Index 和 Timeindex 文件为索引文件，用于检索消息。</p><p><img src="/2019/06/15/kafka-yuan-li/%E5%9B%BE%E7%89%876.png" alt="图片6"></p><p>如上图，这个 Partition 有三组 Segment 文件，每个 Log 文件的大小是一样的，但是存储的 Message 数量是不一定相等的（每条的 Message 大小不一致）。</p><p>文件的命名是以该 Segment 最小 Offset 来命名的，如 000.index 存储 Offset 为 0~368795 的消息，Kafka 就是利用分段+索引的方式来解决查找效率的问题。</p><h4 id="5-2-2-Message-结构"><a href="#5-2-2-Message-结构" class="headerlink" title="5.2.2 Message 结构"></a>5.2.2 Message 结构</h4><p>上面说到 Log 文件就实际是存储 Message 的地方，我们在 Producer 往 Kafka 写入的也是一条一条的 Message。</p><p>那存储在 Log 中的 Message 是什么样子的呢？消息主要包含消息体、消息大小、Offset、压缩类型……等等！</p><p>我们重点需要知道的是下面三个：</p><ul><li><strong>Offset：</strong>Offset 是一个占 8byte 的有序 id 号，它可以唯一确定每条消息在 Parition 内的位置；</li><li><strong>消息大小：</strong>消息大小占用 4byte，用于描述消息的大小；</li><li><strong>消息体：</strong>消息体存放的是实际的消息数据（被压缩过），占用的空间根据具体的消息而不一样。</li></ul><h4 id="5-2-3-存储策略"><a href="#5-2-3-存储策略" class="headerlink" title="5.2.3 存储策略"></a>5.2.3 存储策略</h4><p>无论消息是否被消费，Kafka 都会保存所有的消息。那对于旧数据有什么删除策略呢？</p><ul><li><strong>基于时间：</strong>默认配置是 168 小时（7 天）；</li><li><strong>基于大小：</strong>默认配置是 1073741824。</li></ul><p>需要注意的是，Kafka 读取特定消息的时间复杂度是 O(1)，所以这里删除过期的文件并不会提高 Kafka 的性能！</p><h3 id="5-3-消费数据"><a href="#5-3-消费数据" class="headerlink" title="5.3 消费数据"></a>5.3 消费数据</h3><p>消息存储在 Log 文件后，消费者就可以进行消费了。两种模式<strong>点对点模式</strong>和<strong>发布订阅模式</strong>。Kafka 采用的是点对点的模式，消费者主动的去 Kafka 集群拉取消息，与 Producer 相同的是，消费者在拉取消息的时候也是找 Leader 去拉取。多个消费者可以组成一个消费者组（Consumer Group），每个消费者组都有一个组 id。</p><p>同一个消费组者的消费者可以消费同一 Topic 下不同分区的数据，但是不会组内多个消费者消费同一分区的数据。</p><p>是不是有点绕？我们看下图：</p><p><img src="/2019/06/15/kafka-yuan-li/%E5%9B%BE%E7%89%877.png" alt="图片7"></p><p>图示是消费者组内的消费者小于 Partition 数量的情况，所以会出现某个消费者消费多个 Partition 数据的情况，消费的速度也就不及只处理一个 Partition 的消费者的处理速度。</p><p>如果是消费者组的消费者多于 Partition 的数量，那会不会出现多个消费者消费同一个 Partition 的数据呢？</p><p>上面已经提到过不会出现这种情况，多出来的消费者不消费任何 Partition 的数据。</p><p>所以在实际的应用中，建议消费者组的 Consumer 的数量与 Partition 的数量一致。</p><p>在保存数据的小节里面，我们聊到了 Partition 划分为多组 Segment，每个 Segment 又包含 .log、.index、.timeindex 文件，存放的每条 Message 包含 Offset、消息大小、消息体……</p><p>我们多次提到 Segment 和 Offset，查找消息的时候是怎么利用 Segment+Offset 配合查找的呢？</p><p>假如现在需要查找一个 Offset 为 368801 的 Message 是什么样的过程呢？我们先看看下面的图：</p><p><img src="/2019/06/15/kafka-yuan-li/%E5%9B%BE%E7%89%878.png" alt="图片8"></p><ol><li><p>先找到 Offset 的 368801message 所在的 Segment 文件（利用二分法查找），这里找到的就是在第二个 Segment 文件。</p></li><li><p>打开找到的 Segment 中的 .index 文件（也就是 368796.index 文件，该文件起始偏移量为 368796+1。</p><p>我们要查找的 Offset 为 368801 的 Message 在该 Index 内的偏移量为 368796+5=368801，所以这里要查找的相对 Offset 为 5）。</p><p>由于该文件采用的是稀疏索引的方式存储着相对 Offset 及对应 Message 物理偏移量的关系，所以直接找相对 Offset 为 5 的索引找不到。</p><p>这里同样利用二分法查找相对 Offset 小于或者等于指定的相对 Offset 的索引条目中最大的那个相对 Offset，所以找到的是相对 Offset 为 4 的这个索引。</p></li><li><p>根据找到的相对 Offset 为 4 的索引确定 Message 存储的物理偏移位置为 256。</p><p>打开数据文件，从位置为 256 的那个地方开始顺序扫描直到找到 Offset 为 368801 的那条 Message。</p><p>这套机制是建立在 Offset 为有序的基础上，利用 Segment+有序 Offset+稀疏索引+二分查找+顺序查找等多种手段来高效的查找数据。</p></li></ol><p>至此，消费者就能拿到需要处理的数据进行处理了。那每个消费者又是怎么记录自己消费的位置呢？</p><p>在早期的版本中，消费者将消费到的 Offset 维护在 Zookeeper 中，Consumer 每间隔一段时间上报一次，这里容易导致重复消费，且性能不好。</p><p>在新的版本中消费者消费到的 Offset 已经直接维护在 Kafka 集群的 __consumer_offsets 这个 Topic 中。</p></div><div><div><div style="text-align:center;color:#ccc;font-size:14px">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div></div></div><div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" rel="tag"><i class="fa fa-tag"></i> 消息队列</a><a href="/tags/Kafka/" rel="tag"><i class="fa fa-tag"></i> Kafka</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2019/06/02/prometheus-shi-yong-blackbox-exporter-mo-he-jian-kong/" rel="next" title="Prometheus使用blackbox_exporter墨盒监控"><i class="fa fa-chevron-left"></i> Prometheus使用blackbox_exporter墨盒监控</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2019/06/15/kafka-bu-shu/" rel="prev" title="Kafka部署">Kafka部署<i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"><div class="jiathis_style"><span class="jiathis_txt">分享到：</span> <a class="jiathis_button_fav">收藏夹</a> <a class="jiathis_button_copy">复制网址</a> <a class="jiathis_button_email">邮件</a> <a class="jiathis_button_weixin">微信</a> <a class="jiathis_button_qzone">QQ空间</a> <a class="jiathis_button_tqq">腾讯微博</a> <a class="jiathis_button_douban">豆瓣</a> <a class="jiathis_button_share">一键分享</a> <a href="http://www.jiathis.com/share?uid=2140465" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank">更多</a><a class="jiathis_counter_style"></a></div><script type="text/javascript">var jiathis_config={data_track_clickback:!0,summary:"",shortUrl:!1,hideMore:!1}</script><script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=" charset="utf-8"></script></div></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div id="sidebar-dimmer"></div><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/images/chen.png" alt="Zhongzhou Chen"><p class="site-author-name" itemprop="name">Zhongzhou Chen</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/%7C%7C%20archive"><span class="site-state-item-count">320</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">84</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">182</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#一-、Kafka-简介"><span class="nav-text">一 、Kafka 简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二、Kafka-技术概览"><span class="nav-text">二、Kafka 技术概览</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-Kafka-的特性"><span class="nav-text">2.1 Kafka 的特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-Kafka-设计思想"><span class="nav-text">2.2 Kafka 设计思想</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-kafka-应用场景"><span class="nav-text">2.3 kafka 应用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-Kafka-架构组件"><span class="nav-text">2.4 Kafka 架构组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-Kafka-Topic-amp-Partition"><span class="nav-text">2.5 Kafka Topic&amp;Partition</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三、Kafka-核心组件"><span class="nav-text">三、Kafka 核心组件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四、Kafka-核心特性"><span class="nav-text">四、Kafka 核心特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-压缩"><span class="nav-text">4.1 压缩</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-消息可靠性"><span class="nav-text">4.2 消息可靠性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-备份机制"><span class="nav-text">4.3 备份机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-Kafka高效性相关设计"><span class="nav-text">4.4 Kafka高效性相关设计</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-1-消息的持久化"><span class="nav-text">4.4.1 消息的持久化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-2-常数时间性能保证"><span class="nav-text">4.4.2 常数时间性能保证</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-3-进一步提高效率"><span class="nav-text">4.4.3 进一步提高效率</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-Kafka-工作模式"><span class="nav-text">4.5 Kafka 工作模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-5-1-点对点模式"><span class="nav-text">4.5.1 点对点模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-5-2-发布订阅模式"><span class="nav-text">4.5.2 发布订阅模式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#五、Kafka-工作流程分析"><span class="nav-text">五、Kafka 工作流程分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-发送数据"><span class="nav-text">5.1 发送数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-保存数据"><span class="nav-text">5.2 保存数据</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-1-Partition-结构"><span class="nav-text">5.2.1 Partition 结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-2-Message-结构"><span class="nav-text">5.2.2 Message 结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-3-存储策略"><span class="nav-text">5.2.3 存储策略</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-消费数据"><span class="nav-text">5.3 消费数据</span></a></li></ol></li></ol></div></div></section><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span id="scrollpercent"><span>0</span>%</span></div></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="copyright">&copy; <span itemprop="copyrightYear">2022</span><span class="with-love"><i class="fa fa-user"></i></span> <span class="author" itemprop="copyrightHolder">Zhongzhou Chen</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-area-chart"></i></span> <span class="post-meta-item-text">Site words total count&#58;</span> <span title="Site words total count">758.4k</span></div><span class="post-meta-divider"></span></div></footer></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><style>.copy-btn{display:inline-block;padding:6px 12px;font-size:13px;font-weight:700;line-height:20px;color:#333;white-space:nowrap;vertical-align:middle;cursor:pointer;background-color:#eee;background-image:linear-gradient(#fcfcfc,#eee);border:1px solid #d5d5d5;border-radius:3px;user-select:none;outline:0}.highlight-wrap .copy-btn{transition:opacity .3s ease-in-out;opacity:0;padding:2px 6px;position:absolute;right:4px;top:8px}.highlight-wrap .copy-btn:focus,.highlight-wrap:hover .copy-btn{opacity:1}.highlight-wrap{position:relative}</style><script>$(".highlight").each(function(t,e){var n=$("<div>").addClass("highlight-wrap");$(e).after(n),n.append($("<button>").addClass("copy-btn").append("复制").on("click",function(t){var e=$(this).parent().find(".code").find(".line").map(function(t,e){return $(e).text()}).toArray().join("\n"),n=document.createElement("textarea");document.body.appendChild(n),n.style.position="absolute",n.style.top="0px",n.style.left="0px",n.value=e,n.select(),n.focus();var o=document.execCommand("copy");document.body.removeChild(n),o?$(this).text("复制成功"):$(this).text("复制失败"),$(this).blur()})).on("mouseleave",function(t){var e=$(this).find(".copy-btn");setTimeout(function(){e.text("复制")},300)}).append(e)})</script><script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script><script type="text/javascript">function proceedsearch(){$("body").append('<div class="search-popup-overlay local-search-pop-overlay"></div>').css("overflow","hidden"),$(".search-popup-overlay").click(onPopupClose),$(".popup").toggle();var t=$("#local-search-input");t.attr("autocapitalize","none"),t.attr("autocorrect","off"),t.focus()}var isfetched=!1,isXml=!0,search_path="search.xml";0===search_path.length?search_path="search.xml":/json$/i.test(search_path)&&(isXml=!1);var path="/"+search_path,onPopupClose=function(t){$(".popup").hide(),$("#local-search-input").val(""),$(".search-result-list").remove(),$("#no-result").remove(),$(".local-search-pop-overlay").remove(),$("body").css("overflow","")},searchFunc=function(t,e,s){"use strict";$("body").append('<div class="search-popup-overlay local-search-pop-overlay"><div id="search-loading-icon"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div>').css("overflow","hidden"),$("#search-loading-icon").css("margin","20% auto 0 auto").css("text-align","center"),$.ajax({url:t,dataType:isXml?"xml":"json",async:!0,success:function(t){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var o=isXml?$("entry",t).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get():t,n=document.getElementById(e),r=document.getElementById(s);n.addEventListener("input",function(){var y=n.value.trim().toLowerCase(),T=y.split(/[\s\-]+/);1<T.length&&T.push(y);var b=[];if(0<y.length&&o.forEach(function(t){function e(t,e,o,n){for(var r=n[n.length-1],s=r.position,a=r.word,i=[],c=0;s+a.length<=o&&0!=n.length;){a===y&&c++,i.push({position:s,length:a.length});var l=s+a.length;for(n.pop();0!=n.length&&(s=(r=n[n.length-1]).position,a=r.word,s<l);)n.pop()}return h+=c,{hits:i,start:e,end:o,searchTextCount:c}}function o(o,t){var n="",r=t.start;return t.hits.forEach(function(t){n+=o.substring(r,t.position);var e=t.position+t.length;n+='<b class="search-keyword">'+o.substring(t.position,e)+"</b>",r=e}),n+=o.substring(r,t.end)}var n=!1,r=0,h=0,s=t.title.trim(),a=s.toLowerCase(),i=t.content.trim().replace(/<[^>]+>/g,""),c=i.toLowerCase(),l=decodeURIComponent(t.url),p=[],u=[];if(""!=s&&(T.forEach(function(t){function e(t,e,o){var n=t.length;if(0===n)return[];var r=0,s=[],a=[];for(o||(e=e.toLowerCase(),t=t.toLowerCase());-1<(s=e.indexOf(t,r));)a.push({position:s,word:t}),r=s+n;return a}p=p.concat(e(t,a,!1)),u=u.concat(e(t,c,!1))}),(0<p.length||0<u.length)&&(n=!0,r=p.length+u.length)),n){[p,u].forEach(function(t){t.sort(function(t,e){return e.position!==t.position?e.position-t.position:t.word.length-e.word.length})});var f=[];0!=p.length&&f.push(e(0,0,s.length,p));for(var d=[];0!=u.length;){var g=u[u.length-1],v=g.position,$=g.word,C=v-20,m=v+80;C<0&&(C=0),m<v+$.length&&(m=v+$.length),m>i.length&&(m=i.length),d.push(e(0,C,m,u))}d.sort(function(t,e){return t.searchTextCount!==e.searchTextCount?e.searchTextCount-t.searchTextCount:t.hits.length!==e.hits.length?e.hits.length-t.hits.length:t.start-e.start});var x=parseInt("1");0<=x&&(d=d.slice(0,x));var w="";w+=0!=f.length?"<li><a href='"+l+"' class='search-result-title'>"+o(s,f[0])+"</a>":"<li><a href='"+l+"' class='search-result-title'>"+s+"</a>",d.forEach(function(t){w+="<a href='"+l+'\'><p class="search-result">'+o(i,t)+"...</p></a>"}),w+="</li>",b.push({item:w,searchTextCount:h,hitCount:r,id:b.length})}}),1===T.length&&""===T[0])r.innerHTML='<div id="no-result"><i class="fa fa-search fa-5x" /></div>';else if(0===b.length)r.innerHTML='<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>';else{b.sort(function(t,e){return t.searchTextCount!==e.searchTextCount?e.searchTextCount-t.searchTextCount:t.hitCount!==e.hitCount?e.hitCount-t.hitCount:e.id-t.id});var e='<ul class="search-result-list">';b.forEach(function(t){e+=t.item}),e+="</ul>",r.innerHTML=e}}),$(".local-search-pop-overlay").remove(),$("body").css("overflow",""),proceedsearch()}})};$(".popup-trigger").click(function(t){t.stopPropagation(),!1===isfetched?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(onPopupClose),$(".popup").click(function(t){t.stopPropagation()}),$(document).on("keyup",function(t){27===t.which&&$(".search-popup").is(":visible")&&onPopupClose()})</script><script type="text/javascript" src="/js/src/love.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,log:!1,model:{jsonPath:"/live2dw/assets/shizuku.model.json"},display:{position:"right"},mobile:{show:!0,scale:.2},react:{opacityDefault:.7,opacityOnHover:.2,opacity:.4}})</script></body></html>