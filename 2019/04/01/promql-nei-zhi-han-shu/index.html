<!DOCTYPE html><html class="theme-next gemini use-motion" lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script><link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet"><script></script><meta name="theme-color" content="#222"><style>.pace .pace-progress{background:#1e92fb;height:3px}.pace .pace-progress-inner{box-shadow:0 0 10px #1e92fb,0 0 5px #1e92fb}.pace .pace-activity{border-top-color:#1e92fb;border-left-color:#1e92fb}</style><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="google-site-verification" content="HGM141IpbHrSmnAmR6W_zE4bo9Z3f-yXLeHYT3bg1fk"><meta name="baidu-site-verification" content="code-5Ai1DA8e6T"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4"><link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222"><meta name="keywords" content="监控系统,prometheus,"><link rel="alternate" href="/atom.xml" title="凡间的精灵" type="application/atom+xml"><meta name="description" content="Prometheus 提供了其它大量的内置函数，可以对时序数据进行丰富的处理。某些函数有默认的参数，例如：year(v=vector(time()) instant-vector)。其中参数 v 是一个瞬时向量，如果不提供该参数，将使用默认值 vector(time())。instant-vector 表示参数类型。abs()abs(v instant-vector) 返回输入向量的所有样本的绝对"><meta name="keywords" content="监控系统,prometheus"><meta property="og:type" content="article"><meta property="og:title" content="PromQL 内置函数"><meta property="og:url" content="http:&#x2F;&#x2F;chenzhonzhou.github.io&#x2F;2019&#x2F;04&#x2F;01&#x2F;promql-nei-zhi-han-shu&#x2F;index.html"><meta property="og:site_name" content="凡间的精灵"><meta property="og:description" content="Prometheus 提供了其它大量的内置函数，可以对时序数据进行丰富的处理。某些函数有默认的参数，例如：year(v=vector(time()) instant-vector)。其中参数 v 是一个瞬时向量，如果不提供该参数，将使用默认值 vector(time())。instant-vector 表示参数类型。abs()abs(v instant-vector) 返回输入向量的所有样本的绝对"><meta property="og:locale" content="zh-Hans"><meta property="og:updated_time" content="2020-11-20T06:15:12.627Z"><meta name="twitter:card" content="summary"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Gemini",version:"5.1.4",sidebar:{position:"left",display:"always",offset:12,b2t:!0,scrollpercent:!0,onmobile:!0},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://chenzhonzhou.github.io/2019/04/01/promql-nei-zhi-han-shu/"><title>PromQL 内置函数 | 凡间的精灵</title><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">凡间的精灵</span><span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">凡尘落素一精灵</p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-categories"><a href="/categories" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="menu-item-icon fa fa-fw fa-sitemap"></i><br>站点地图</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i></span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://chenzhonzhou.github.io/2019/04/01/promql-nei-zhi-han-shu/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Zhongzhou Chen"><meta itemprop="description" content=""><meta itemprop="image" content="/images/chen.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="凡间的精灵"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">PromQL 内置函数</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-01T15:29:15+08:00">2019-04-01</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">监控系统</span></a></span> ， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/prometheus/" itemprop="url" rel="index"><span itemprop="name">prometheus</span></a></span></span><div class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">4.3k</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span> <span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">17</span></div></div></header><div class="post-body" itemprop="articleBody"><p>Prometheus 提供了其它大量的内置函数，可以对时序数据进行丰富的处理。某些函数有默认的参数，例如：<code>year(v=vector(time()) instant-vector)</code>。其中参数 <code>v</code> 是一个瞬时向量，如果不提供该参数，将使用默认值 <code>vector(time())</code>。instant-vector 表示参数类型。</p><h1 id="abs"><a href="#abs" class="headerlink" title="abs()"></a>abs()</h1><p><code>abs(v instant-vector)</code> 返回输入向量的所有样本的绝对值。</p><h1 id="absent"><a href="#absent" class="headerlink" title="absent()"></a>absent()</h1><p><code>absent(v instant-vector)</code>，如果传递给它的向量参数具有样本数据，则返回空向量；如果传递的向量参数没有样本数据，则返回不带度量指标名称且带有标签的时间序列，且样本值为1。</p><p>当监控度量指标时，如果获取到的样本数据是空的， 使用 absent 方法对告警是非常有用的。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 这里提供的向量有样本数据</span><br><span class="line">absent(http_requests_total&#123;method=&quot;get&quot;&#125;)  =&gt; no </span><br><span class="line">dataabsent(sum(http_requests_total&#123;method=&quot;get&quot;&#125;))  =&gt; no data</span><br><span class="line"></span><br><span class="line"># 由于不存在度量指标 nonexistent，所以 返回不带度量指标名称且带有标签的时间序列，且样本值为1</span><br><span class="line">absent(nonexistent&#123;job=&quot;myjob&quot;&#125;)  =&gt; &#123;job=&quot;myjob&quot;&#125;  1</span><br><span class="line"></span><br><span class="line"># 正则匹配的 instance 不作为返回 labels 中的一部分</span><br><span class="line">absent(nonexistent&#123;job=&quot;myjob&quot;,instance=~&quot;.*&quot;&#125;)  =&gt; &#123;job=&quot;myjob&quot;&#125;  1</span><br><span class="line"></span><br><span class="line"># sum 函数返回的时间序列不带有标签，且没有样本数据</span><br><span class="line">absent(sum(nonexistent&#123;job=&quot;myjob&quot;&#125;))  =&gt; &#123;&#125;  1</span><br></pre></td></tr></table></figure><h1 id="ceil"><a href="#ceil" class="headerlink" title="ceil()"></a>ceil()</h1><p><code>ceil(v instant-vector)</code> 将 v 中所有元素的样本值向上四舍五入到最接近的整数。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node_load5&#123;instance=&quot;192.168.1.75:9100&quot;&#125; # 结果为 2.79ceil(node_load5&#123;instance=&quot;192.168.1.75:9100&quot;&#125;) # 结果为 3</span><br></pre></td></tr></table></figure><h1 id="changes"><a href="#changes" class="headerlink" title="changes()"></a>changes()</h1><p><code>changes(v range-vector)</code> 输入一个区间向量， 返回这个区间向量内每个样本数据值变化的次数（瞬时向量）。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 如果样本数据值没有发生变化，则返回结果为 1</span><br><span class="line">changes(node_load5&#123;instance=&quot;192.168.1.75:9100&quot;&#125;[1m]) # 结果为 1</span><br></pre></td></tr></table></figure><h1 id="clamp-max"><a href="#clamp-max" class="headerlink" title="clamp_max()"></a>clamp_max()</h1><p><code>clamp_max(v instant-vector, max scalar)</code> 函数，输入一个瞬时向量和最大值，样本数据值若大于 max，则改为 max，否则不变。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node_load5&#123;instance=&quot;192.168.1.75:9100&quot;&#125; # 结果为 </span><br><span class="line">2.79clamp_max(node_load5&#123;instance=&quot;192.168.1.75:9100&quot;&#125;, 2) # 结果为 2</span><br></pre></td></tr></table></figure><h1 id="clamp-min"><a href="#clamp-min" class="headerlink" title="clamp_min()"></a>clamp_min()</h1><p><code>clamp_min(v instant-vector, min scalar)</code> 函数，输入一个瞬时向量和最小值，样本数据值若小于 min，则改为 min，否则不变。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node_load5&#123;instance=&quot;192.168.1.75:9100&quot;&#125; # 结果为 </span><br><span class="line">2.79clamp_min(node_load5&#123;instance=&quot;192.168.1.75:9100&quot;&#125;, 3) # 结果为 3</span><br></pre></td></tr></table></figure><h1 id="day-of-month"><a href="#day-of-month" class="headerlink" title="day_of_month()"></a>day_of_month()</h1><p><code>day_of_month(v=vector(time()) instant-vector)</code> 函数，返回被给定 UTC 时间所在月的第几天。返回值范围：1~31。</p><h1 id="day-of-week"><a href="#day-of-week" class="headerlink" title="day_of_week()"></a>day_of_week()</h1><p><code>day_of_week(v=vector(time()) instant-vector)</code> 函数，返回被给定 UTC 时间所在周的第几天。返回值范围：0~6，0 表示星期天。</p><h1 id="days-in-month"><a href="#days-in-month" class="headerlink" title="days_in_month()"></a>days_in_month()</h1><p><code>days_in_month(v=vector(time()) instant-vector)</code> 函数，返回当月一共有多少天。返回值范围：28~31。</p><h1 id="delta"><a href="#delta" class="headerlink" title="delta()"></a>delta()</h1><p><code>delta(v range-vector)</code> 的参数是一个区间向量，返回一个瞬时向量。它计算一个区间向量 v 的第一个元素和最后一个元素之间的差值。由于这个值被外推到指定的整个时间范围，所以即使样本值都是整数，你仍然可能会得到一个非整数值。</p><p>例如，下面的例子返回过去两小时的 CPU 温度差：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delta(cpu_temp_celsius&#123;host=&quot;zeus&quot;&#125;[2h])</span><br></pre></td></tr></table></figure><p>这个函数一般只用在 Gauge 类型的时间序列上。</p><h1 id="deriv"><a href="#deriv" class="headerlink" title="deriv()"></a>deriv()</h1><p><code>deriv(v range-vector)</code> 的参数是一个区间向量,返回一个瞬时向量。它使用<a href="http://en.wikipedia.org/wiki/Simple_linear_regression" target="_blank" rel="noopener">简单的线性回归</a>计算区间向量 v 中各个时间序列的导数。</p><p>这个函数一般只用在 Gauge 类型的时间序列上。</p><h1 id="exp"><a href="#exp" class="headerlink" title="exp()"></a>exp()</h1><p><code>exp(v instant-vector)</code> 函数，输入一个瞬时向量，返回各个样本值的 <code>e</code> 的指数值，即 e 的 N 次方。当 N 的值足够大时会返回 <code>+Inf</code>。特殊情况为：</p><ul><li><code>Exp(+Inf) = +Inf</code></li><li><code>Exp(NaN) = NaN</code></li></ul><h1 id="floor"><a href="#floor" class="headerlink" title="floor()"></a>floor()</h1><p><code>floor(v instant-vector)</code> 函数与 ceil() 函数相反，将 v 中所有元素的样本值向下四舍五入到最接近的整数。</p><h1 id="histogram-quantile"><a href="#histogram-quantile" class="headerlink" title="histogram_quantile()"></a>histogram_quantile()</h1><p><code>histogram_quantile(φ float, b instant-vector)</code> 从 bucket 类型的向量 <code>b</code> 中计算 φ (0 ≤ φ ≤ 1) 分位数（百分位数的一般形式）的样本的最大值。（有关 φ 分位数的详细说明以及直方图指标类型的使用，请参阅<a href="https://prometheus.io/docs/practices/histograms" target="_blank" rel="noopener">直方图和摘要</a>）。向量 <code>b</code> 中的样本是每个 bucket 的采样点数量。每个样本的 labels 中必须要有 <code>le</code> 这个 label 来表示每个 bucket 的上边界，没有 <code>le</code> 标签的样本会被忽略。直方图指标类型自动提供带有 <code>_bucket</code> 后缀和相应标签的时间序列。</p><p>可以使用 <code>rate()</code> 函数来指定分位数计算的时间窗口。</p><p>例如，一个直方图指标名称为 <code>employee_age_bucket_bucket</code>，要计算过去 10 分钟内 第 90 个百分位数，请使用以下表达式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">histogram_quantile(0.9, rate(employee_age_bucket_bucket[10m]))</span><br></pre></td></tr></table></figure><p>返回：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;instance=&quot;10.0.86.71:8080&quot;,job=&quot;prometheus&quot;&#125; 35.714285714285715</span><br></pre></td></tr></table></figure><p>这表示最近 10 分钟之内 90% 的样本的最大值为 35.714285714285715。</p><p>这个计算结果是每组标签组合成一个时间序列。我们可能不会对所有这些维度（如 <code>job</code>、<code>instance</code> 和 <code>method</code>）感兴趣，并希望将其中的一些维度进行聚合，则可以使用 sum() 函数。例如，以下表达式根据 <code>job</code> 标签来对第 90 个百分位数进行聚合：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># histogram_quantile() 函数必须包含 le 标签</span><br><span class="line">histogram_quantile(0.9, sum(rate(employee_age_bucket_bucket[10m])) by (job, le))</span><br></pre></td></tr></table></figure><p>如果要聚合所有的标签，则使用如下表达式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">histogram_quantile(0.9,sum(rate(employee_age_bucket_bucket[10m])) by (le))</span><br></pre></td></tr></table></figure><blockquote><p><strong>[info] 注意</strong></p><p><code>histogram_quantile</code> 这个函数是根据假定每个区间内的样本分布是线性分布来计算结果值的(也就是说它的结果未必准确)，最高的 bucket 必须是 le=”+Inf” (否则就返回 NaN)。</p><p>如果分位数位于最高的 bucket（+Inf） 中，则返回第二个最高的 bucket 的上边界。如果该 bucket 的上边界大于 0，则假设最低的 bucket 的的下边界为 0，这种情况下在该 bucket 内使用常规的线性插值。</p><p>如果分位数位于最低的 bucket 中，则返回最低 bucket 的上边界。</p></blockquote><p>如果 b 含有少于 2 个 buckets，那么会返回 <code>NaN</code>，如果 φ &lt; 0 会返回 <code>-Inf</code>，如果 φ &gt; 1 会返回 <code>+Inf</code>。</p><h1 id="holt-winters"><a href="#holt-winters" class="headerlink" title="holt_winters()"></a>holt_winters()</h1><p><code>holt_winters(v range-vector, sf scalar, tf scalar)</code> 函数基于区间向量 v，生成时间序列数据平滑值。平滑因子 <code>sf</code> 越低, 对旧数据的重视程度越高。趋势因子 <code>tf</code> 越高，对数据的趋势的考虑就越多。其中，<code>0&lt; sf, tf &lt;=1</code>。</p><p>holt_winters 仅适用于 Gauge 类型的时间序列。</p><h1 id="hour"><a href="#hour" class="headerlink" title="hour()"></a>hour()</h1><p><code>hour(v=vector(time()) instant-vector)</code> 函数返回被给定 UTC 时间的当前第几个小时，时间范围：0~23。</p><h1 id="idelta"><a href="#idelta" class="headerlink" title="idelta()"></a>idelta()</h1><p>idelta(v range-vector) 的参数是一个区间向量, 返回一个瞬时向量。它计算最新的 2 个样本值之间的差值。</p><p>这个函数一般只用在 Gauge 类型的时间序列上。</p><h1 id="increase"><a href="#increase" class="headerlink" title="increase()"></a>increase()</h1><p><code>increase(v range-vector)</code> 函数获取区间向量中的第一个和最后一个样本并返回其增长量, 它会在单调性发生变化时(如由于采样目标重启引起的计数器复位)自动中断。由于这个值被外推到指定的整个时间范围，所以即使样本值都是整数，你仍然可能会得到一个非整数值。</p><p>例如，以下表达式返回区间向量中每个时间序列过去 5 分钟内 HTTP 请求数的增长数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">increase(http_requests_total&#123;job=&quot;apiserver&quot;&#125;[5m])</span><br></pre></td></tr></table></figure><p><code>increase</code> 的返回值类型只能是计数器类型，主要作用是增加图表和数据的可读性。使用 <code>rate</code> 函数记录规则的使用率，以便持续跟踪数据样本值的变化。</p><h1 id="irate"><a href="#irate" class="headerlink" title="irate()"></a>irate()</h1><p><code>irate(v range-vector)</code> 函数用于计算区间向量的增长率，但是其反应出的是瞬时增长率。irate 函数是通过区间向量中最后两个两本数据来计算区间向量的增长速率，它会在单调性发生变化时(如由于采样目标重启引起的计数器复位)自动中断。这种方式可以避免在时间窗口范围内的“长尾问题”，并且体现出更好的灵敏度，通过irate函数绘制的图标能够更好的反应样本数据的瞬时变化状态。</p><p>例如，以下表达式返回区间向量中每个时间序列过去 5 分钟内最后两个样本数据的 HTTP 请求数的增长率：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">irate(http_requests_total&#123;job=&quot;api-server&quot;&#125;[5m])</span><br></pre></td></tr></table></figure><p>irate 只能用于绘制快速变化的计数器，在长期趋势分析或者告警中更推荐使用 rate 函数。因为使用 irate 函数时，速率的简短变化会重置 <code>FOR</code> 语句，形成的图形有很多波峰，难以阅读。</p><blockquote><p><strong>[info] 注意</strong></p><p>当将 <code>irate()</code> 函数与<a href="https://prometheus.io/docs/prometheus/latest/querying/operators/#aggregation-operators" target="_blank" rel="noopener">聚合运算符</a>（例如 <code>sum()</code>）或随时间聚合的函数（任何以 <code>_over_time</code> 结尾的函数）一起使用时，必须先执行 irate 函数，然后再进行聚合操作，否则当采样目标重新启动时 irate() 无法检测到计数器是否被重置。</p></blockquote><h1 id="label-join"><a href="#label-join" class="headerlink" title="label_join()"></a>label_join()</h1><p><code>label_join(v instant-vector, dst_label string, separator string, src_label_1 string, src_label_2 string, ...)</code> 函数可以将时间序列 v 中多个标签 <code>src_label</code> 的值，通过 <code>separator</code> 作为连接符写入到一个新的标签 <code>dst_label</code> 中。可以有多个 src_label 标签。</p><p>例如，以下表达式返回的时间序列多了一个 <code>foo</code> 标签，标签值为 <code>etcd,etcd-k8s</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">up&#123;endpoint=&quot;api&quot;,instance=&quot;192.168.123.248:2379&quot;,job=&quot;etcd&quot;,namespace=&quot;monitoring&quot;,service=&quot;etcd-k8s&quot;&#125;=&gt; up&#123;endpoint=&quot;api&quot;,instance=&quot;192.168.123.248:2379&quot;,job=&quot;etcd&quot;,namespace=&quot;monitoring&quot;,service=&quot;etcd-k8s&quot;&#125;  1</span><br><span class="line"></span><br><span class="line">label_join(up&#123;endpoint=&quot;api&quot;,instance=&quot;192.168.123.248:2379&quot;,job=&quot;etcd&quot;,namespace=&quot;monitoring&quot;,service=&quot;etcd-k8s&quot;&#125;, &quot;foo&quot;, &quot;,&quot;, &quot;job&quot;, &quot;service&quot;)=&gt; up&#123;endpoint=&quot;api&quot;,foo=&quot;etcd,etcd-k8s&quot;,instance=&quot;192.168.123.248:2379&quot;,job=&quot;etcd&quot;,namespace=&quot;monitoring&quot;,service=&quot;etcd-k8s&quot;&#125;  1</span><br></pre></td></tr></table></figure><h1 id="label-replace"><a href="#label-replace" class="headerlink" title="label_replace()"></a>label_replace()</h1><p>为了能够让客户端的图标更具有可读性，可以通过 <code>label_replace</code> 函数为时间序列添加额外的标签。label_replace 的具体参数如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">label_replace(v instant-vector, dst_label string, replacement string, src_label string, regex string)</span><br></pre></td></tr></table></figure><p>该函数会依次对 v 中的每一条时间序列进行处理，通过 <code>regex</code> 匹配 src_label 的值，并将匹配部分 <code>relacement</code> 写入到 dst_label 标签中。如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">label_replace(up, &quot;host&quot;, &quot;$1&quot;, &quot;instance&quot;,  &quot;(.*):.*&quot;)</span><br></pre></td></tr></table></figure><p>函数处理后，时间序列将包含一个 <code>host</code> 标签，host 标签的值为 Exporter 实例的 IP 地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">up&#123;host=&quot;localhost&quot;,instance=&quot;localhost:8080&quot;,job=&quot;cadvisor&quot;&#125;   1</span><br><span class="line">up&#123;host=&quot;localhost&quot;,instance=&quot;localhost:9090&quot;,job=&quot;prometheus&quot;&#125;   1</span><br><span class="line">up&#123;host=&quot;localhost&quot;,instance=&quot;localhost:9100&quot;,job=&quot;node&quot;&#125;   1</span><br></pre></td></tr></table></figure><h1 id="ln"><a href="#ln" class="headerlink" title="ln()"></a>ln()</h1><p><code>ln(v instant-vector)</code> 计算瞬时向量 v 中所有样本数据的自然对数。特殊情况：</p><ul><li><code>ln(+Inf) = +Inf</code></li><li><code>ln(0) = -Inf</code></li><li><code>ln(x &lt; 0) = NaN</code></li><li><code>ln(NaN) = NaN</code></li></ul><h1 id="log2"><a href="#log2" class="headerlink" title="log2()"></a>log2()</h1><p><code>log2(v instant-vector)</code> 函数计算瞬时向量 v 中所有样本数据的二进制对数。特殊情况同上。</p><h1 id="log10"><a href="#log10" class="headerlink" title="log10()"></a>log10()</h1><p><code>log10(v instant-vector)</code> 计算瞬时向量 v 中所有样本数据的十进制对数。特殊情况同上。</p><h1 id="minute"><a href="#minute" class="headerlink" title="minute()"></a>minute()</h1><p><code>minute(v=vector(time()) instant-vector)</code> 函数返回给定 UTC 时间当前小时的第多少分钟。结果范围：0~59。</p><h1 id="month"><a href="#month" class="headerlink" title="month()"></a>month()</h1><p><code>month(v=vector(time()) instant-vector)</code> 函数返回给定 UTC 时间当前属于第几个月，结果范围：0~12。</p><h1 id="predict-linear"><a href="#predict-linear" class="headerlink" title="predict_linear()"></a>predict_linear()</h1><p><code>predict_linear(v range-vector, t scalar)</code> 函数可以预测时间序列 v 在 t 秒后的值。它基于简单线性回归的方式，对时间窗口内的样本数据进行统计，从而可以对时间序列的变化趋势做出预测。该函数的返回结果<strong>不带有度量指标</strong>，只有标签列表。</p><p>例如，基于 2 小时的样本数据，来预测主机可用磁盘空间的是否在 4 个小时候被占满，可以使用如下表达式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">predict_linear(node_filesystem_free&#123;job=&quot;node&quot;&#125;[2h], 4 * 3600) &lt; 0</span><br></pre></td></tr></table></figure><p>通过下面的例子来观察返回值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">predict_linear(http_requests_total&#123;code=&quot;200&quot;,instance=&quot;120.77.65.193:9090&quot;,job=&quot;prometheus&quot;,method=&quot;get&quot;&#125;[5m], 5)结果：</span><br><span class="line">&#123;code=&quot;200&quot;,handler=&quot;query_range&quot;,instance=&quot;120.77.65.193:9090&quot;,job=&quot;prometheus&quot;,method=&quot;get&quot;&#125;  1</span><br><span class="line">&#123;code=&quot;200&quot;,handler=&quot;prometheus&quot;,instance=&quot;120.77.65.193:9090&quot;,job=&quot;prometheus&quot;,method=&quot;get&quot;&#125;   4283.449995397104</span><br><span class="line">&#123;code=&quot;200&quot;,handler=&quot;static&quot;,instance=&quot;120.77.65.193:9090&quot;,job=&quot;prometheus&quot;,method=&quot;get&quot;&#125;   22.99999999999999</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这个函数一般只用在 Gauge 类型的时间序列上。</p><h1 id="rate"><a href="#rate" class="headerlink" title="rate()"></a>rate()</h1><p><code>rate(v range-vector)</code> 函数可以直接计算区间向量 v 在时间窗口内平均增长速率，它会在单调性发生变化时(如由于采样目标重启引起的计数器复位)自动中断。该函数的返回结果<strong>不带有度量指标</strong>，只有标签列表。</p><p>例如，以下表达式返回区间向量中每个时间序列过去 5 分钟内 HTTP 请求数的每秒增长率：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rate(http_requests_total[5m])结果：</span><br><span class="line">&#123;code=&quot;200&quot;,handler=&quot;label_values&quot;,instance=&quot;120.77.65.193:9090&quot;,job=&quot;prometheus&quot;,method=&quot;get&quot;&#125; 0</span><br><span class="line">&#123;code=&quot;200&quot;,handler=&quot;query_range&quot;,instance=&quot;120.77.65.193:9090&quot;,job=&quot;prometheus&quot;,method=&quot;get&quot;&#125;  0</span><br><span class="line">&#123;code=&quot;200&quot;,handler=&quot;prometheus&quot;,instance=&quot;120.77.65.193:9090&quot;,job=&quot;prometheus&quot;,method=&quot;get&quot;&#125;   0.2</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>rate() 函数返回值类型只能用计数器，在长期趋势分析或者告警中推荐使用这个函数。</p><blockquote><p><strong>[info] 注意</strong></p><p>当将 <code>rate()</code> 函数与<a href="https://prometheus.io/docs/prometheus/latest/querying/operators/#aggregation-operators" target="_blank" rel="noopener">聚合运算符</a>（例如 <code>sum()</code>）或随时间聚合的函数（任何以 <code>_over_time</code> 结尾的函数）一起使用时，必须先执行 rate 函数，然后再进行聚合操作，否则当采样目标重新启动时 rate() 无法检测到计数器是否被重置。</p></blockquote><h1 id="resets"><a href="#resets" class="headerlink" title="resets()"></a>resets()</h1><p><code>resets(v range-vector)</code> 的参数是一个区间向量。对于每个时间序列，它都返回一个计数器重置的次数。两个连续样本之间的值的减少被认为是一次计数器重置。</p><p>这个函数一般只用在计数器类型的时间序列上。</p><h1 id="round"><a href="#round" class="headerlink" title="round()"></a>round()</h1><p><code>round(v instant-vector, to_nearest=1 scalar)</code> 函数与 <code>ceil</code> 和 <code>floor</code> 函数类似，返回向量中所有样本值的最接近的整数。<code>to_nearest</code> 参数是可选的,默认为 1,表示样本返回的是最接近 1 的整数倍的值。你也可以将该参数指定为任意值（也可以是小数），表示样本返回的是最接近它的整数倍的值。</p><h1 id="scalar"><a href="#scalar" class="headerlink" title="scalar()"></a>scalar()</h1><p><code>scalar(v instant-vector)</code> 函数的参数是一个单元素的瞬时向量,它返回其唯一的时间序列的值作为一个标量。如果度量指标的样本数量大于 1 或者等于 0, 则返回 <code>NaN</code>。</p><h1 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h1><p><code>sort(v instant-vector)</code> 函数对向量按元素的值进行升序排序，返回结果：key: value = 度量指标：样本值[升序排列]。</p><h1 id="sort-desc"><a href="#sort-desc" class="headerlink" title="sort_desc()"></a>sort_desc()</h1><p><code>sort(v instant-vector)</code> 函数对向量按元素的值进行降序排序，返回结果：key: value = 度量指标：样本值[降序排列]。</p><h1 id="sqrt"><a href="#sqrt" class="headerlink" title="sqrt()"></a>sqrt()</h1><p><code>sqrt(v instant-vector)</code> 函数计算向量 v 中所有元素的平方根。</p><h1 id="time"><a href="#time" class="headerlink" title="time()"></a>time()</h1><p><code>time()</code> 函数返回从 1970-01-01 到现在的秒数。注意：它不是直接返回当前时间，而是时间戳</p><h1 id="timestamp"><a href="#timestamp" class="headerlink" title="timestamp()"></a>timestamp()</h1><p><code>timestamp(v instant-vector)</code> 函数返回向量 v 中的每个样本的时间戳（从 1970-01-01 到现在的秒数）。</p><p>该函数从 Prometheus 2.0 版本开始引入。</p><h1 id="vector"><a href="#vector" class="headerlink" title="vector()"></a>vector()</h1><p><code>vector(s scalar)</code> 函数将标量 s 作为没有标签的向量返回，即返回结果为：key: value= {}, s。</p><h1 id="year"><a href="#year" class="headerlink" title="year()"></a>year()</h1><p><code>year(v=vector(time()) instant-vector)</code> 函数返回被给定 UTC 时间的当前年份。</p><h1 id="over-time"><a href="#over-time" class="headerlink" title="_over_time()"></a>_over_time()</h1><p>下面的函数列表允许传入一个区间向量，它们会聚合每个时间序列的范围，并返回一个瞬时向量：</p><ul><li><code>avg_over_time(range-vector)</code> : 区间向量内每个度量指标的平均值。</li><li><code>min_over_time(range-vector)</code> : 区间向量内每个度量指标的最小值。</li><li><code>max_over_time(range-vector)</code> : 区间向量内每个度量指标的最大值。</li><li><code>sum_over_time(range-vector)</code> : 区间向量内每个度量指标的求和。</li><li><code>count_over_time(range-vector)</code> : 区间向量内每个度量指标的样本数据个数。</li><li><code>quantile_over_time(scalar, range-vector)</code> : 区间向量内每个度量指标的样本数据值分位数，φ-quantile (0 ≤ φ ≤ 1)。</li><li><code>stddev_over_time(range-vector)</code> : 区间向量内每个度量指标的总体标准差。</li><li><code>stdvar_over_time(range-vector)</code> : 区间向量内每个度量指标的总体标准方差。</li></ul><blockquote><p><strong>[info] 注意</strong></p><p>即使区间向量内的值分布不均匀，它们在聚合时的权重也是相同的。</p></blockquote><p>原文链接：<a href="https://ryanyang.gitbook.io/prometheus/di-san-zhang-prometheus/di-4-jie-cha-xun/functions" target="_blank" rel="noopener">https://ryanyang.gitbook.io/prometheus/di-san-zhang-prometheus/di-4-jie-cha-xun/functions</a></p></div><div><div><div style="text-align:center;color:#ccc;font-size:14px">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div></div></div><div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/" rel="tag"><i class="fa fa-tag"></i> 监控系统</a><a href="/tags/prometheus/" rel="tag"><i class="fa fa-tag"></i> prometheus</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2019/03/30/promql-cha-xun-biao-da-shi/" rel="next" title="promql查询表达式"><i class="fa fa-chevron-left"></i> promql查询表达式</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2019/04/04/mongodb-fu-ben-ji-ji-qun-bu-shu/" rel="prev" title="MongoDB副本集集群部署">MongoDB副本集集群部署<i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"><div class="jiathis_style"><span class="jiathis_txt">分享到：</span> <a class="jiathis_button_fav">收藏夹</a> <a class="jiathis_button_copy">复制网址</a> <a class="jiathis_button_email">邮件</a> <a class="jiathis_button_weixin">微信</a> <a class="jiathis_button_qzone">QQ空间</a> <a class="jiathis_button_tqq">腾讯微博</a> <a class="jiathis_button_douban">豆瓣</a> <a class="jiathis_button_share">一键分享</a> <a href="http://www.jiathis.com/share?uid=2140465" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank">更多</a><a class="jiathis_counter_style"></a></div><script type="text/javascript">var jiathis_config={data_track_clickback:!0,summary:"",shortUrl:!1,hideMore:!1}</script><script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=" charset="utf-8"></script></div></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div id="sidebar-dimmer"></div><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/images/chen.png" alt="Zhongzhou Chen"><p class="site-author-name" itemprop="name">Zhongzhou Chen</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/%7C%7C%20archive"><span class="site-state-item-count">320</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">84</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">182</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#abs"><span class="nav-text">abs()</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#absent"><span class="nav-text">absent()</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ceil"><span class="nav-text">ceil()</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#changes"><span class="nav-text">changes()</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#clamp-max"><span class="nav-text">clamp_max()</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#clamp-min"><span class="nav-text">clamp_min()</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#day-of-month"><span class="nav-text">day_of_month()</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#day-of-week"><span class="nav-text">day_of_week()</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#days-in-month"><span class="nav-text">days_in_month()</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#delta"><span class="nav-text">delta()</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#deriv"><span class="nav-text">deriv()</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#exp"><span class="nav-text">exp()</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#floor"><span class="nav-text">floor()</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#histogram-quantile"><span class="nav-text">histogram_quantile()</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#holt-winters"><span class="nav-text">holt_winters()</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#hour"><span class="nav-text">hour()</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#idelta"><span class="nav-text">idelta()</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#increase"><span class="nav-text">increase()</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#irate"><span class="nav-text">irate()</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#label-join"><span class="nav-text">label_join()</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#label-replace"><span class="nav-text">label_replace()</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ln"><span class="nav-text">ln()</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#log2"><span class="nav-text">log2()</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#log10"><span class="nav-text">log10()</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#minute"><span class="nav-text">minute()</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#month"><span class="nav-text">month()</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#predict-linear"><span class="nav-text">predict_linear()</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#rate"><span class="nav-text">rate()</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#resets"><span class="nav-text">resets()</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#round"><span class="nav-text">round()</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#scalar"><span class="nav-text">scalar()</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#sort"><span class="nav-text">sort()</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#sort-desc"><span class="nav-text">sort_desc()</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#sqrt"><span class="nav-text">sqrt()</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#time"><span class="nav-text">time()</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#timestamp"><span class="nav-text">timestamp()</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#vector"><span class="nav-text">vector()</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#year"><span class="nav-text">year()</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#over-time"><span class="nav-text">_over_time()</span></a></li></ol></div></div></section><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span id="scrollpercent"><span>0</span>%</span></div></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="copyright">&copy; <span itemprop="copyrightYear">2022</span><span class="with-love"><i class="fa fa-user"></i></span> <span class="author" itemprop="copyrightHolder">Zhongzhou Chen</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-area-chart"></i></span> <span class="post-meta-item-text">Site words total count&#58;</span> <span title="Site words total count">758.4k</span></div><span class="post-meta-divider"></span></div></footer></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><style>.copy-btn{display:inline-block;padding:6px 12px;font-size:13px;font-weight:700;line-height:20px;color:#333;white-space:nowrap;vertical-align:middle;cursor:pointer;background-color:#eee;background-image:linear-gradient(#fcfcfc,#eee);border:1px solid #d5d5d5;border-radius:3px;user-select:none;outline:0}.highlight-wrap .copy-btn{transition:opacity .3s ease-in-out;opacity:0;padding:2px 6px;position:absolute;right:4px;top:8px}.highlight-wrap .copy-btn:focus,.highlight-wrap:hover .copy-btn{opacity:1}.highlight-wrap{position:relative}</style><script>$(".highlight").each(function(t,e){var n=$("<div>").addClass("highlight-wrap");$(e).after(n),n.append($("<button>").addClass("copy-btn").append("复制").on("click",function(t){var e=$(this).parent().find(".code").find(".line").map(function(t,e){return $(e).text()}).toArray().join("\n"),n=document.createElement("textarea");document.body.appendChild(n),n.style.position="absolute",n.style.top="0px",n.style.left="0px",n.value=e,n.select(),n.focus();var o=document.execCommand("copy");document.body.removeChild(n),o?$(this).text("复制成功"):$(this).text("复制失败"),$(this).blur()})).on("mouseleave",function(t){var e=$(this).find(".copy-btn");setTimeout(function(){e.text("复制")},300)}).append(e)})</script><script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script><script type="text/javascript">function proceedsearch(){$("body").append('<div class="search-popup-overlay local-search-pop-overlay"></div>').css("overflow","hidden"),$(".search-popup-overlay").click(onPopupClose),$(".popup").toggle();var t=$("#local-search-input");t.attr("autocapitalize","none"),t.attr("autocorrect","off"),t.focus()}var isfetched=!1,isXml=!0,search_path="search.xml";0===search_path.length?search_path="search.xml":/json$/i.test(search_path)&&(isXml=!1);var path="/"+search_path,onPopupClose=function(t){$(".popup").hide(),$("#local-search-input").val(""),$(".search-result-list").remove(),$("#no-result").remove(),$(".local-search-pop-overlay").remove(),$("body").css("overflow","")},searchFunc=function(t,e,s){"use strict";$("body").append('<div class="search-popup-overlay local-search-pop-overlay"><div id="search-loading-icon"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div>').css("overflow","hidden"),$("#search-loading-icon").css("margin","20% auto 0 auto").css("text-align","center"),$.ajax({url:t,dataType:isXml?"xml":"json",async:!0,success:function(t){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var o=isXml?$("entry",t).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get():t,n=document.getElementById(e),r=document.getElementById(s);n.addEventListener("input",function(){var y=n.value.trim().toLowerCase(),T=y.split(/[\s\-]+/);1<T.length&&T.push(y);var b=[];if(0<y.length&&o.forEach(function(t){function e(t,e,o,n){for(var r=n[n.length-1],s=r.position,a=r.word,i=[],c=0;s+a.length<=o&&0!=n.length;){a===y&&c++,i.push({position:s,length:a.length});var l=s+a.length;for(n.pop();0!=n.length&&(s=(r=n[n.length-1]).position,a=r.word,s<l);)n.pop()}return h+=c,{hits:i,start:e,end:o,searchTextCount:c}}function o(o,t){var n="",r=t.start;return t.hits.forEach(function(t){n+=o.substring(r,t.position);var e=t.position+t.length;n+='<b class="search-keyword">'+o.substring(t.position,e)+"</b>",r=e}),n+=o.substring(r,t.end)}var n=!1,r=0,h=0,s=t.title.trim(),a=s.toLowerCase(),i=t.content.trim().replace(/<[^>]+>/g,""),c=i.toLowerCase(),l=decodeURIComponent(t.url),p=[],u=[];if(""!=s&&(T.forEach(function(t){function e(t,e,o){var n=t.length;if(0===n)return[];var r=0,s=[],a=[];for(o||(e=e.toLowerCase(),t=t.toLowerCase());-1<(s=e.indexOf(t,r));)a.push({position:s,word:t}),r=s+n;return a}p=p.concat(e(t,a,!1)),u=u.concat(e(t,c,!1))}),(0<p.length||0<u.length)&&(n=!0,r=p.length+u.length)),n){[p,u].forEach(function(t){t.sort(function(t,e){return e.position!==t.position?e.position-t.position:t.word.length-e.word.length})});var f=[];0!=p.length&&f.push(e(0,0,s.length,p));for(var d=[];0!=u.length;){var g=u[u.length-1],v=g.position,$=g.word,C=v-20,m=v+80;C<0&&(C=0),m<v+$.length&&(m=v+$.length),m>i.length&&(m=i.length),d.push(e(0,C,m,u))}d.sort(function(t,e){return t.searchTextCount!==e.searchTextCount?e.searchTextCount-t.searchTextCount:t.hits.length!==e.hits.length?e.hits.length-t.hits.length:t.start-e.start});var x=parseInt("1");0<=x&&(d=d.slice(0,x));var w="";w+=0!=f.length?"<li><a href='"+l+"' class='search-result-title'>"+o(s,f[0])+"</a>":"<li><a href='"+l+"' class='search-result-title'>"+s+"</a>",d.forEach(function(t){w+="<a href='"+l+'\'><p class="search-result">'+o(i,t)+"...</p></a>"}),w+="</li>",b.push({item:w,searchTextCount:h,hitCount:r,id:b.length})}}),1===T.length&&""===T[0])r.innerHTML='<div id="no-result"><i class="fa fa-search fa-5x" /></div>';else if(0===b.length)r.innerHTML='<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>';else{b.sort(function(t,e){return t.searchTextCount!==e.searchTextCount?e.searchTextCount-t.searchTextCount:t.hitCount!==e.hitCount?e.hitCount-t.hitCount:e.id-t.id});var e='<ul class="search-result-list">';b.forEach(function(t){e+=t.item}),e+="</ul>",r.innerHTML=e}}),$(".local-search-pop-overlay").remove(),$("body").css("overflow",""),proceedsearch()}})};$(".popup-trigger").click(function(t){t.stopPropagation(),!1===isfetched?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(onPopupClose),$(".popup").click(function(t){t.stopPropagation()}),$(document).on("keyup",function(t){27===t.which&&$(".search-popup").is(":visible")&&onPopupClose()})</script><script type="text/javascript" src="/js/src/love.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,log:!1,model:{jsonPath:"/live2dw/assets/shizuku.model.json"},display:{position:"right"},mobile:{show:!0,scale:.2},react:{opacityDefault:.7,opacityOnHover:.2,opacity:.4}})</script></body></html>