<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>凡间的精灵</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://chenzhonzhou.github.io/"/>
  <updated>2019-10-29T08:41:20.208Z</updated>
  <id>http://chenzhonzhou.github.io/</id>
  
  <author>
    <name>Zhongzhou Chen</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Pi币注册指南</title>
    <link href="http://chenzhonzhou.github.io/2019/10/29/pi-bi-zhu-ce-liu-cheng/"/>
    <id>http://chenzhonzhou.github.io/2019/10/29/pi-bi-zhu-ce-liu-cheng/</id>
    <published>2019-10-29T07:13:45.000Z</published>
    <updated>2019-10-29T08:41:20.208Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Oct 29 2019 16:41:52 GMT+0800 (GMT+08:00) --><p>在手机浏览器中，打开<a href="https://minepi.com/#download" target="_blank" rel="noopener">官方网站下载地址</a> :<a href="https://minepi.com/#download" target="_blank" rel="noopener">https://minepi.com/#download</a> 进行下载。</p><p><strong>安卓手机</strong></p><p>安卓手机可以通过<strong>Google Play</strong>下载，如果访问不了Google Play，可以点击官网的<strong>Download Directly The APK</strong>链接下载，如果地址不可用，可以选用备用<a href="https://github.com/minpi/minpi.github.io/blob/master/downloads/com.blockchainvault_1.21.0_apkcombo.com.apk?raw=true" target="_blank" rel="noopener">APK下载地址</a>，不要下载其他渠道的APK，尽量下载官方的渠道的APK！！！</p><p><strong>苹果手机</strong></p><p>因为这个应用是发布在海外的市场，大陆的APPID账号无法下载，需要临时切换APP账号到海外，然后在appstore搜pi network下载即可。</p><blockquote><p>注：有的时候网络连接很慢，因为是链接国外的服务器，所以需要你耐心等待，目前来看，联通4G链接的速度会好于电信和移动；不懂也可以私聊我。</p></blockquote><p>临时提供一些海外的APP账号使用，为了安全，使用完立即退出！</p><table><thead><tr><th align="left">账号</th><th align="left">密码</th></tr></thead><tbody><tr><td align="left"><a href="mailto:chenguancai781006@163.com" target="_blank" rel="noopener">chenguancai781006@163.com</a></td><td align="left">Bitmax0987</td></tr><tr><td align="left"><a href="mailto:kangsulin407187@163.com" target="_blank" rel="noopener">kangsulin407187@163.com</a></td><td align="left">Bitmax0987</td></tr><tr><td align="left"><a href="mailto:linlixiang624761@163.com" target="_blank" rel="noopener">linlixiang624761@163.com</a></td><td align="left">Bitmax0987</td></tr><tr><td align="left"><a href="mailto:xiaoweitao765643@163.com" target="_blank" rel="noopener">xiaoweitao765643@163.com</a></td><td align="left">Bitmax0987</td></tr><tr><td align="left"><a href="mailto:liangyunyu327650@163.com" target="_blank" rel="noopener">liangyunyu327650@163.com</a></td><td align="left">Bitmax0987</td></tr><tr><td align="left"><a href="mailto:longqingbin216101@163.com" target="_blank" rel="noopener">longqingbin216101@163.com</a></td><td align="left">Bitmax0987</td></tr><tr><td align="left"><a href="mailto:liubo959601@163.com" target="_blank" rel="noopener">liubo959601@163.com</a></td><td align="left">Bitmax0987</td></tr><tr><td align="left"><a href="mailto:linjie956236@163.com" target="_blank" rel="noopener">linjie956236@163.com</a></td><td align="left">Bitmax0987</td></tr></tbody></table><h2 id="注册步骤"><a href="#注册步骤" class="headerlink" title="注册步骤"></a>注册步骤</h2><ol><li>打开App，可以选择使用facebook或手机号注册，推荐使用手机号。</li></ol><p><img src="/2019/10/29/pi-bi-zhu-ce-liu-cheng/01.gif" alt="img"></p><ol><li>United State这里找到并选择China(+86)，然后输入手机号，点“GO”。如果网速慢加载不出来就点try again再试。</li></ol><p><img src="/2019/10/29/pi-bi-zhu-ce-liu-cheng/02.gif" alt="img"></p><p><img src="/2019/10/29/pi-bi-zhu-ce-liu-cheng/03.gif" alt="img"></p><ol><li>Passworld（输入密码，要复杂点，长度为8，要至少有一个大写字母，至少有一个小写字母，至少1个数字），Verlfy you password（确认密码），然后点“SUBMIT”提交。</li></ol><p><img src="/2019/10/29/pi-bi-zhu-ce-liu-cheng/04.gif" alt="img"></p><ol><li>填写名（中文）firstname、姓（中文）lastname；用户名(Choose your usename)建议取英文，这个同时也是你的个人邀请码，在你邀请他人时让他们填写。</li></ol><p><img src="/2019/10/29/pi-bi-zhu-ce-liu-cheng/05.gif" alt="img"></p><ol><li>Invitation code 这里输入邀请码victorysq，然后点“SUBMIT”提交。(一定要填写正确的邀请码）</li></ol><p><img src="/2019/10/29/pi-bi-zhu-ce-liu-cheng/06.gif" alt="img"></p><ol><li>再根据提示一直点确认按钮下去，按提示开启挖矿即可。</li></ol><p><img src="/2019/10/29/pi-bi-zhu-ce-liu-cheng/07.gif" alt="img"></p><p>重要说明：每隔24小时需要打开APP手动收矿，不然停止后就不会挖矿了。**</p><p><img src="/2019/10/29/pi-bi-zhu-ce-liu-cheng/08.gif" alt="img"></p><h2 id="手机认证"><a href="#手机认证" class="headerlink" title="手机认证"></a>手机认证</h2><p>最近app更新，出来了手机认证，虽然目前不强制认证，<strong>但是后续对于检验你是否是机器人或者是忘记密码后找回密码有莫大的帮助，</strong>所以我建议大家还是花几分钟时间完成一下手机认证。</p><p>注册完后，要记得验证手机号（点左上角，profile，VERIFY，Manual instructions进去复制一段接收短信带+的号码，点打叉退回来，再点START按钮，OPEN SMS，然后跳转去发短信，发送到刚才复制的那段号码就OK。如果一直验证不成功，尝试在+号后面加两个0）</p><p>步骤如下：</p><p><img src="/2019/10/29/pi-bi-zhu-ce-liu-cheng/11.gif" alt="img"></p><p><img src="/2019/10/29/pi-bi-zhu-ce-liu-cheng/12.gif" alt="img"></p><p><img src="/2019/10/29/pi-bi-zhu-ce-liu-cheng/13.png" alt="img"></p><p><img src="/2019/10/29/pi-bi-zhu-ce-liu-cheng/15.png" alt="img"></p><p>它会跳转到手机短信界面，并编写好短信，直接点击发送即可，发送短信后需要等待几秒钟，返回到软件界面，如下说明成功完成手机认证。</p><p><img src="/2019/10/29/pi-bi-zhu-ce-liu-cheng/16.png" alt="img"></p><h2 id="建立安全圈"><a href="#建立安全圈" class="headerlink" title="建立安全圈"></a>建立安全圈</h2><p>安全圈（Security circle）是由每个Pi成员各自建立的信任圈，由他们所信任的3-5个人组成。各个Pi成员的安全圈聚合在一起从而构建“全局信任图”来保护货币，防止不良行为者执行欺诈性交易。</p><p>【重要】：Pi的贡献者通过建立安全圈来指出和保证3-5个他们值得信任的Pi其它成员。安全圈应由您信任的人组成，你信任他们不会执行欺诈性交易。网络的安全圈叠加可形成一个全局信任图，用于确定谁可以被信任在Pi的账本上执行交易。此外，安全圈相当于一个挖矿战队，通过开启安全圈与好友共同挖矿，还可以提高挖矿算力！<br><strong>一、如何建立安全圈</strong></p><p><img src="/2019/10/29/pi-bi-zhu-ce-liu-cheng/21.gif" alt="img"></p><p><strong>二、当挖矿到72小时之后，系统会提醒你加入安全圈</strong></p><p><img src="/2019/10/29/pi-bi-zhu-ce-liu-cheng/22.gif" alt="img"></p><p><strong>三、点击小闪电进入后如果有EDIT SECURITY CIRCLE代表你已经挖矿72小时</strong></p><p><img src="/2019/10/29/pi-bi-zhu-ce-liu-cheng/23.gif" alt="img"></p><p><strong>四、点击：start 建立安全圈</strong></p><p><img src="/2019/10/29/pi-bi-zhu-ce-liu-cheng/24.gif" alt="img"></p><p>五、选择安全圈好友**</p><p><img src="/2019/10/29/pi-bi-zhu-ce-liu-cheng/25.gif" alt="img"></p><p><strong>六、安全圈成功开启之后，回到首页就可以看到右侧多了个盾牌标志，盾牌如果达到100%说明安全圈已经给你的算力加到最大化。点击盾牌可以查看你的安全圈详情。</strong></p><p><img src="/2019/10/29/pi-bi-zhu-ce-liu-cheng/26.gif" alt="img"></p><p><strong>注：下次点击闪电才会加速</strong></p><p><strong>目前用户数量快突破百万了，过百万后，算力就会减半，就是说同样的时间，挖到的π币会少一半</strong></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Oct 29 2019 16:41:52 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;在手机浏览器中，打开&lt;a href=&quot;https://minepi.com/#download&quot; target=&quot;_blank&quot; rel=&quot;no
      
    
    </summary>
    
    
      <category term="Pi network" scheme="http://chenzhonzhou.github.io/categories/Pi-network/"/>
    
    
      <category term="赚外快" scheme="http://chenzhonzhou.github.io/tags/%E8%B5%9A%E5%A4%96%E5%BF%AB/"/>
    
  </entry>
  
  <entry>
    <title>hexo博客自带图片显示问题处理方法</title>
    <link href="http://chenzhonzhou.github.io/2019/10/25/hexo-bo-ke-zi-dai-tu-pian-xian-shi-wen-ti-chu-li-fang-fa/"/>
    <id>http://chenzhonzhou.github.io/2019/10/25/hexo-bo-ke-zi-dai-tu-pian-xian-shi-wen-ti-chu-li-fang-fa/</id>
    <published>2019-10-25T06:40:59.000Z</published>
    <updated>2019-10-29T07:25:25.352Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Oct 29 2019 15:51:53 GMT+0800 (GMT+08:00) --><p><strong>mac用户推荐使用ipic，一个很牛的个人开发者开发的工具，使markdown插入图片的操作变得异常简单，链接：<a href="https://www.jianshu.com/p/e46a91ae20b9" target="_blank" rel="noopener">http://www.jianshu.com/p/e46a91ae20b9</a></strong></p><p>有两种方法，第一种是不用插件的情况，第二种是使用一种hexo的插件。</p><p>无论哪种方法都有一个共同的前提：修改<code>_config.yml</code>配置文件<code>post_asset_folder</code>项为<code>true</code>。</p><p>创建博客是使用命令创建：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><p>其中的layout项可以省略，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> <span class="string">"hexo博客自带图片显示问题处理方法"</span></span><br></pre></td></tr></table></figure><p>使用完命令之后，在source/_post文件夹里面就会出现一个“hexo博客自带图片显示问题处理方法.md”的文件和一个 “hexo博客自带图片显示问题处理方法”的文件夹。</p><p><img src="/2019/10/25/hexo-bo-ke-zi-dai-tu-pian-xian-shi-wen-ti-chu-li-fang-fa/hexo%E5%8D%9A%E5%AE%A2%E8%87%AA%E5%B8%A6%E5%9B%BE%E7%89%87%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95.png" alt="img"></p><p>下一步就是把需要的图片放到新创建的那个<strong>文件夹</strong>里面去。</p><h2 id="引用图片的第一种方法"><a href="#引用图片的第一种方法" class="headerlink" title="引用图片的第一种方法"></a>引用图片的第一种方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% asset_img hexo博客自带图片显示问题处理方法.png 这是图片的说明 %&#125;</span><br></pre></td></tr></table></figure><p>用此种方法，而不是以前的<code>![]()</code>方法，前提是你的hexo的版本是hexo3以上，到package.json里面看一下吧。如果不是hexo3以上的版本，那就只能用第二种方法了。</p><p>例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我现在写了一个段落，并且想在这个段落的某一个地方&#123;% asset_img hexo博客自带图片显示问题处理方法.jpg hexo博客自带图片显示问题处理方法 %&#125;引入一张图片</span><br></pre></td></tr></table></figure><p>错误的例子</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我现在写了一个段落，并且想在这个段落的某一个地方<span class="selector-attr">[图片上传失败...(image-b446bd-1510018038370)]</span>引入一张图片</span><br></pre></td></tr></table></figure><h2 id="下面是第二种方法，hexo插件的方法"><a href="#下面是第二种方法，hexo插件的方法" class="headerlink" title="下面是第二种方法，hexo插件的方法"></a>下面是第二种方法，hexo插件的方法</h2><p>这是插件的<a href="https://link.jianshu.com?t=https://github.com/CodeFalling/hexo-asset-image" target="_blank" rel="noopener">链接</a></p><p>安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure><p>如果安装失败使用 npm install <a href="https://github.com/CodeFalling/hexo-asset-image" target="_blank" rel="noopener">https://github.com/CodeFalling/hexo-asset-image</a> –save</p><p>安装之后就可以按照正常的方法使用的，比如：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% asset_img hexo博客自带图片显示问题处理方法.png 图片上传失败 %&#125;</span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!<span class="selector-attr">[图片上传失败]</span>(<span class="selector-tag">hexo</span>博客自带图片显示问题处理方法<span class="selector-class">.png</span>)</span><br></pre></td></tr></table></figure><p>都可以实现，而我比较喜欢使用后者。</p><p>此两种方法除了操作有些区别之外，在图片的显示上也略有不同，第一种的图片信息是会显示出来的，而第二种中括号里面的信息是不会显示的。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Oct 29 2019 15:51:53 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;strong&gt;mac用户推荐使用ipic，一个很牛的个人开发者开发的工具，使markdown插入图片的操作变得异常简单，链接：&lt;a href=
      
    
    </summary>
    
    
      <category term="hexo" scheme="http://chenzhonzhou.github.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://chenzhonzhou.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>hexo给博客添加宠物</title>
    <link href="http://chenzhonzhou.github.io/2019/10/24/hexo-gei-bo-ke-tian-jia-chong-wu/"/>
    <id>http://chenzhonzhou.github.io/2019/10/24/hexo-gei-bo-ke-tian-jia-chong-wu/</id>
    <published>2019-10-24T07:13:45.000Z</published>
    <updated>2019-10-25T02:14:06.350Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Oct 29 2019 15:51:53 GMT+0800 (GMT+08:00) --><h5 id="1-先安装live2d"><a href="#1-先安装live2d" class="headerlink" title="1.先安装live2d"></a>1.先安装live2d</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-helper-live2d</span><br></pre></td></tr></table></figure><h5 id="2-选择自己喜欢的萌妹子"><a href="#2-选择自己喜欢的萌妹子" class="headerlink" title="2.选择自己喜欢的萌妹子"></a>2.选择自己喜欢的萌妹子</h5><p>可以到<a href="https://github.com/xiazeyu/live2d-widget-models" target="_blank" rel="noopener">github</a>中查看，或查看<a href="https://huaji8.top/post/live2d-plugin-2.0/" target="_blank" rel="noopener">动态效果</a>选择喜欢的妹子造型</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">live2d-widget-<span class="keyword">model</span>-chitose</span><br><span class="line">live2d-widget-<span class="keyword">model</span>-epsilon2_1</span><br><span class="line">live2d-widget-<span class="keyword">model</span>-gf</span><br><span class="line">live2d-widget-<span class="keyword">model</span>-haru/<span class="number">01</span> (use npm install --save live2d-widget-<span class="keyword">model</span>-haru)</span><br><span class="line">live2d-widget-<span class="keyword">model</span>-haru/<span class="number">02</span> (use npm install --save live2d-widget-<span class="keyword">model</span>-haru)</span><br><span class="line">live2d-widget-<span class="keyword">model</span>-haruto</span><br><span class="line">live2d-widget-<span class="keyword">model</span>-hibiki</span><br><span class="line">live2d-widget-<span class="keyword">model</span>-hijiki</span><br><span class="line">live2d-widget-<span class="keyword">model</span>-izumi</span><br><span class="line">live2d-widget-<span class="keyword">model</span>-koharu</span><br><span class="line">live2d-widget-<span class="keyword">model</span>-miku</span><br><span class="line">live2d-widget-<span class="keyword">model</span>-ni-j</span><br><span class="line">live2d-widget-<span class="keyword">model</span>-nico</span><br><span class="line">live2d-widget-<span class="keyword">model</span>-nietzsche</span><br><span class="line">live2d-widget-<span class="keyword">model</span>-nipsilon</span><br><span class="line">live2d-widget-<span class="keyword">model</span>-nito</span><br><span class="line">live2d-widget-<span class="keyword">model</span>-shizuku</span><br><span class="line">live2d-widget-<span class="keyword">model</span>-tororo</span><br><span class="line">live2d-widget-<span class="keyword">model</span>-tsumiki</span><br><span class="line">live2d-widget-<span class="keyword">model</span>-unitychan</span><br><span class="line">live2d-widget-<span class="keyword">model</span>-wanko</span><br><span class="line">live2d-widget-<span class="keyword">model</span>-z16</span><br></pre></td></tr></table></figure><p>例如选择： live2d-widget-model-shizuku</p><h5 id="3-安装"><a href="#3-安装" class="headerlink" title="3.安装"></a>3.安装</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> live2d-widget-<span class="keyword">model</span>-shizuku</span><br></pre></td></tr></table></figure><h5 id="4-配置"><a href="#4-配置" class="headerlink" title="4.配置"></a>4.配置</h5><p>在站点hexo的 _config.yml 下配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 宠物设置</span></span><br><span class="line"><span class="attr">live2d:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  scriptFrom:</span> <span class="string">local</span></span><br><span class="line"><span class="attr">  pluginRootPath:</span> <span class="string">live2dw/</span></span><br><span class="line"><span class="attr">  pluginJsPath:</span> <span class="string">lib/</span></span><br><span class="line"><span class="attr">  pluginModelPath:</span> <span class="string">assets/</span></span><br><span class="line"><span class="attr">  tagMode:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  log:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  model:</span></span><br><span class="line"><span class="attr">    use:</span> <span class="string">live2d-widget-model-shizuku</span></span><br><span class="line"><span class="attr">  display:</span></span><br><span class="line"><span class="attr">    position:</span> <span class="string">right</span></span><br><span class="line"><span class="attr">  mobile:</span></span><br><span class="line"><span class="attr">    show:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    scale:</span> <span class="number">0.5</span></span><br><span class="line"><span class="attr">  react:</span></span><br><span class="line"><span class="attr">    opacityDefault:</span> <span class="number">0.7</span></span><br><span class="line"><span class="attr">    opacityOnHover:</span> <span class="number">0.2</span></span><br></pre></td></tr></table></figure><h5 id="5-本地重新启动查看"><a href="#5-本地重新启动查看" class="headerlink" title="5.本地重新启动查看"></a>5.本地重新启动查看</h5><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">hexo -s</span></span><br></pre></td></tr></table></figure><p>没有问题就可以推送到github上了</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">hexo</span> <span class="string">g</span></span><br><span class="line"><span class="attr">hexo</span> <span class="string">d</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Oct 29 2019 15:51:53 GMT+0800 (GMT+08:00) --&gt;&lt;h5 id=&quot;1-先安装live2d&quot;&gt;&lt;a href=&quot;#1-先安装live2d&quot; class=&quot;headerlink&quot; title=&quot;1.先安装
      
    
    </summary>
    
    
      <category term="hexo" scheme="http://chenzhonzhou.github.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://chenzhonzhou.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>hexo使用next主题菜单图标问题</title>
    <link href="http://chenzhonzhou.github.io/2019/10/23/hexo-shi-yong-next-zhu-ti-cai-dan-tu-biao-wen-ti/"/>
    <id>http://chenzhonzhou.github.io/2019/10/23/hexo-shi-yong-next-zhu-ti-cai-dan-tu-biao-wen-ti/</id>
    <published>2019-10-23T03:05:15.000Z</published>
    <updated>2019-10-29T07:01:03.461Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Oct 29 2019 15:51:53 GMT+0800 (GMT+08:00) --><p>nexo主题的简洁我个人非常喜欢，但在使用过程中当我按文档部署添加菜单后页面显示如下：<br><img src="/2019/10/23/hexo-shi-yong-next-zhu-ti-cai-dan-tu-biao-wen-ti/image-20191025104219831.png" alt="显示正常"></p><p>可以看到菜单显示正常，当我点开某个菜单后显示 <strong>Cannot GET /tags%20/</strong><br><img src="/2019/10/23/hexo-shi-yong-next-zhu-ti-cai-dan-tu-biao-wen-ti/image-20191025104523903.png" alt="显示不正常"></p><p>在网上找了很多文档都是如下配置，打开 <strong><em>主题配置文件\</em></strong> 找到<code>Menu Settings</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || home                          <span class="comment">//首页</span></span><br><span class="line">  archives: /archives/ || archive          <span class="comment">//归档</span></span><br><span class="line">  categories: /categories/ || th           <span class="comment">//分类</span></span><br><span class="line">  tags: /tags/ || tags                     <span class="comment">//标签</span></span><br><span class="line">  about: /about/ || user                   <span class="comment">//关于</span></span><br><span class="line">  <span class="meta">#schedule: /schedule/ || calendar        <span class="comment">//日程表</span></span></span><br><span class="line">  <span class="meta">#sitemap: /sitemap.xml || sitemap        <span class="comment">//站点地图</span></span></span><br><span class="line">  <span class="meta">#commonweal: /404/ || heartbeat          <span class="comment">//公益404</span></span></span><br></pre></td></tr></table></figure><p>让我们再回顾一下新建菜单的过程，注意看第三步：</p><p>例如，在<code>[Hexo+Next]</code>主题下新增一个资源分类页面。</p><h4 id="1-新建一个页面，命名为tags。"><a href="#1-新建一个页面，命名为tags。" class="headerlink" title="1.新建一个页面，命名为tags。"></a>1.新建一个页面，命名为tags。</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure><p>此时会在hexo &gt; source文件夹中会生成一个tag文件夹。</p><h4 id="2-编辑tags文件夹下的md页面"><a href="#2-编辑tags文件夹下的md页面" class="headerlink" title="2.编辑tags文件夹下的md页面"></a>2.编辑tags文件夹下的md页面</h4><p>将类型设置为tags，主题将自动为这个页面显示所有分类，<strong>别忘添加layout项。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">title: 常用工具</span><br><span class="line">date: 2019-10-23 13:05:38</span><br><span class="line"><span class="built_in">type</span>: <span class="string">"tags"</span></span><br><span class="line">layout: tags</span><br><span class="line">comments: <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>注意：如果有启用评论，默认页面也会带有评论。需要关闭的话，请添加字段<code>comments</code>并将值设置为<code>false</code>，如：</p><h4 id="3-在菜单中添加链接"><a href="#3-在菜单中添加链接" class="headerlink" title="3.在菜单中添加链接"></a>3.在菜单中添加链接</h4><p>编辑主题的<code>_config.yml</code>，在<code>menu</code>中的添加如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: /|| home                          <span class="comment">//首页</span></span><br><span class="line">  archives: /archives/|| archive          <span class="comment">//归档</span></span><br><span class="line">  categories: /categories/|| th           <span class="comment">//分类</span></span><br><span class="line">  tags: /tags/|| tags                     <span class="comment">//标签</span></span><br><span class="line">  about: /about/|| user                   <span class="comment">//关于</span></span><br><span class="line">  <span class="meta">#schedule: /schedule/ || calendar        <span class="comment">//日程表</span></span></span><br><span class="line">  <span class="meta">#sitemap: /sitemap.xml || sitemap        <span class="comment">//站点地图</span></span></span><br><span class="line">  <span class="meta">#commonweal: /404/ || heartbeat          <span class="comment">//公益404</span></span></span><br></pre></td></tr></table></figure><blockquote><p><code>||</code>之前的值是目标链接，之后的是分类页面的图标，图标名称来自于<a href="http://fontawesome.io/icons/" target="_blank" rel="noopener">FontAwesome icon</a>。若没有配置图标，默认会使用问号图标。</p><p>注意：这里的配置在原文中||前面是有空格的，也正是如此我前面点击菜单才会出现<strong>Cannot GET /tags%20/</strong>，当我把||前面的空格去掉后就好了。</p></blockquote><h4 id="4-新添加的菜单需要翻译对应的中文"><a href="#4-新添加的菜单需要翻译对应的中文" class="headerlink" title="4.新添加的菜单需要翻译对应的中文"></a>4.新添加的菜单需要翻译对应的中文</h4><p>打开<code>hexo&gt;theme&gt;next&gt;languages&gt;zh-Hans.yml</code>，在menu下添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: 首页</span><br><span class="line">  archives: 归档</span><br><span class="line">  categories: 分类</span><br><span class="line">  tags: 标签</span><br><span class="line">  about: 关于</span><br><span class="line">  search: 搜索</span><br><span class="line">  schedule: 日程表</span><br><span class="line">  sitemap: 站点地图</span><br><span class="line">  commonweal: 公益404</span><br><span class="line">  resources: 资源</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Oct 29 2019 15:51:53 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;nexo主题的简洁我个人非常喜欢，但在使用过程中当我按文档部署添加菜单后页面显示如下：&lt;br&gt;&lt;img src=&quot;/2019/10/23/hex
      
    
    </summary>
    
    
      <category term="hexo" scheme="http://chenzhonzhou.github.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://chenzhonzhou.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>hexo 创建文章、标签、分类</title>
    <link href="http://chenzhonzhou.github.io/2019/10/22/hexo-chuang-jian-wen-zhang-biao-qian-fen-lei/"/>
    <id>http://chenzhonzhou.github.io/2019/10/22/hexo-chuang-jian-wen-zhang-biao-qian-fen-lei/</id>
    <published>2019-10-22T11:53:15.000Z</published>
    <updated>2019-10-29T06:18:03.289Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Oct 29 2019 15:51:53 GMT+0800 (GMT+08:00) --><h3 id="1、创建文章"><a href="#1、创建文章" class="headerlink" title="1、创建文章"></a>1、创建文章</h3><h5 id="1-1在hexo下创建一个新的文章"><a href="#1-1在hexo下创建一个新的文章" class="headerlink" title="1.1在hexo下创建一个新的文章"></a>1.1在hexo下创建一个新的文章</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="string">"文章名称"</span></span><br></pre></td></tr></table></figure><p>生成后会提示你文件路径，一般在hexo/source/_posts下</p><h5 id="1-2文章基本设置"><a href="#1-2文章基本设置" class="headerlink" title="1.2文章基本设置"></a>1.2文章基本设置</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">layout：chenzhongzhou</span> <span class="comment">#作者</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">yum安装docker</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2019</span><span class="bullet">-10</span><span class="bullet">-22</span> <span class="number">19</span><span class="string">:01:24</span></span><br><span class="line"><span class="attr">comments:</span> <span class="literal">true</span> <span class="comment">#是否可评论</span></span><br><span class="line"><span class="attr">toc:</span> <span class="literal">true</span> <span class="comment">#是否显示文章目录</span></span><br><span class="line"><span class="attr">categories:</span> <span class="string">"云服务器"</span> <span class="comment">#分类</span></span><br><span class="line"><span class="attr">tags:</span>   <span class="comment">#标签</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">docker</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">yum</span></span><br><span class="line"><span class="attr">copyright:</span> <span class="literal">false</span> <span class="comment">#显示版权</span></span><br><span class="line"><span class="attr">categories:</span></span><br><span class="line"><span class="attr">password:</span> <span class="comment">#密码访问</span></span><br><span class="line"><span class="attr">top:</span> <span class="comment">#博文置顶 数值越大文章越靠前</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><h3 id="2、创建标签"><a href="#2、创建标签" class="headerlink" title="2、创建标签"></a>2、创建标签</h3><h5 id="2-1创建标签页面"><a href="#2-1创建标签页面" class="headerlink" title="2.1创建标签页面"></a>2.1创建标签页面</h5><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new<span class="built_in"> page </span>tags</span><br></pre></td></tr></table></figure><h5 id="2-2基本设置"><a href="#2-2基本设置" class="headerlink" title="2.2基本设置"></a>2.2基本设置</h5><p>source/tags目录下index.md文件</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: tags</span><br><span class="line">date: <span class="number">2019</span><span class="number">-10</span><span class="number">-22</span> <span class="number">19</span>:<span class="number">03</span>:<span class="number">11</span></span><br><span class="line">type: <span class="string">"tags"</span></span><br><span class="line">layout: <span class="string">"tags"</span></span><br></pre></td></tr></table></figure><h3 id="3、创建分类"><a href="#3、创建分类" class="headerlink" title="3、创建分类"></a>3、创建分类</h3><h5 id="3-1创建分类页面"><a href="#3-1创建分类页面" class="headerlink" title="3.1创建分类页面"></a>3.1创建分类页面</h5><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new<span class="built_in"> page </span>categories</span><br></pre></td></tr></table></figure><h5 id="3-2基本设置"><a href="#3-2基本设置" class="headerlink" title="3.2基本设置"></a>3.2基本设置</h5><p>source/categories目录下index.md文件</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: categories</span><br><span class="line">date: <span class="number">2019</span><span class="number">-10</span><span class="number">-22</span> <span class="number">19</span>:<span class="number">07</span>:<span class="number">45</span></span><br><span class="line">type: <span class="string">"categories"</span></span><br><span class="line">layout: <span class="string">"categories"</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Oct 29 2019 15:51:53 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;1、创建文章&quot;&gt;&lt;a href=&quot;#1、创建文章&quot; class=&quot;headerlink&quot; title=&quot;1、创建文章&quot;&gt;&lt;/a&gt;1、创
      
    
    </summary>
    
    
      <category term="hexo" scheme="http://chenzhonzhou.github.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://chenzhonzhou.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Prometheus部署+邮箱告警+企业微信告警+钉钉告警</title>
    <link href="http://chenzhonzhou.github.io/2019/03/01/prometheus-bu-shu-you-xiang-gao-jing-qi-ye-wei-xin-gao-jing-ding-ding-gao-jing/"/>
    <id>http://chenzhonzhou.github.io/2019/03/01/prometheus-bu-shu-you-xiang-gao-jing-qi-ye-wei-xin-gao-jing-ding-ding-gao-jing/</id>
    <published>2019-03-01T06:05:15.000Z</published>
    <updated>2019-10-25T02:23:10.423Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Oct 29 2019 15:51:53 GMT+0800 (GMT+08:00) --><h1 id="Prometheus部署-邮箱告警-企业微信告警-钉钉告警"><a href="#Prometheus部署-邮箱告警-企业微信告警-钉钉告警" class="headerlink" title="Prometheus部署+邮箱告警+企业微信告警+钉钉告警"></a>Prometheus部署+邮箱告警+企业微信告警+钉钉告警</h1><h5 id="1-部署Prometheus-server"><a href="#1-部署Prometheus-server" class="headerlink" title="1 部署Prometheus server"></a>1 部署Prometheus server</h5><h6 id="1-1-下载二进制包"><a href="#1-1-下载二进制包" class="headerlink" title="1.1 下载二进制包"></a>1.1 下载二进制包</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget https://github.com/prometheus/prometheus/releases/download/v2<span class="number">.12</span><span class="number">.0</span>/prometheus<span class="number">-2.12</span><span class="number">.0</span>.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure><h6 id="1-2-解压并move至-work-admin目录下"><a href="#1-2-解压并move至-work-admin目录下" class="headerlink" title="1.2 解压并move至/work/admin目录下"></a>1.2 解压并move至/work/admin目录下</h6><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ tar zcvf prometheus-<span class="number">2.7</span>.<span class="number">1</span>.linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line">$ mv prometheus-<span class="number">2.7</span>.<span class="number">1</span>.linux-amd64 /work/admin/prometheus</span><br></pre></td></tr></table></figure><h6 id="1-3-配置并启动"><a href="#1-3-配置并启动" class="headerlink" title="1.3 配置并启动"></a>1.3 配置并启动</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">$ cat prometheus.yml</span><br><span class="line"></span><br><span class="line">global:</span><br><span class="line"></span><br><span class="line">  scrape_interval:    15s <span class="comment"># 默认抓取间隔, 15秒向目标抓取一次数据。</span></span><br><span class="line"></span><br><span class="line">  evaluation_interval: 15s <span class="comment"># Evaluate rules every 15 seconds. The default is every 1 minute.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># scrape_timeout is set to the global default (10s).</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Alertmanager configuration</span></span><br><span class="line"></span><br><span class="line">alerting:</span><br><span class="line"></span><br><span class="line">  alertmanagers:</span><br><span class="line"></span><br><span class="line">  - static_configs:</span><br><span class="line"></span><br><span class="line">    - targets:</span><br><span class="line"></span><br><span class="line">      - <span class="string">"localhost:9093"</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># - alertmanager:9093</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Load rules once and periodically evaluate them according to the global 'evaluation_interval'.</span></span><br><span class="line"></span><br><span class="line">rule_files:</span><br><span class="line"></span><br><span class="line">  - <span class="string">"/usr/local/prometheus/rules/mysql*.rules"</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># - "first_rules.yml"</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># - "second_rules.yml"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># A scrape configuration containing exactly one endpoint to scrape:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Here it's Prometheus itself.</span></span><br><span class="line"></span><br><span class="line">scrape_configs:</span><br><span class="line"></span><br><span class="line">  <span class="comment"># The job name is added as a label `job=&lt;job_name&gt;` to any timeseries scraped from this config.</span></span><br><span class="line"></span><br><span class="line">  - job_name: <span class="string">'prometheus'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># metrics_path defaults to '/metrics'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># scheme defaults to 'http'.</span></span><br><span class="line"></span><br><span class="line">    static_configs:</span><br><span class="line"></span><br><span class="line">    - targets: [<span class="string">'localhost:9090'</span>]</span><br><span class="line"></span><br><span class="line">  - job_name: <span class="string">'linux'</span></span><br><span class="line"></span><br><span class="line">    static_configs:</span><br><span class="line"></span><br><span class="line">    - targets: [<span class="string">'localhost:9101'</span>]</span><br><span class="line"></span><br><span class="line">      labels:</span><br><span class="line"></span><br><span class="line">        instance: node1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  - job_name: <span class="string">'mysql'</span></span><br><span class="line"></span><br><span class="line">    static_configs:</span><br><span class="line"></span><br><span class="line">    - targets: [<span class="string">'192.168.1.11:9104'</span>]</span><br><span class="line"></span><br><span class="line">      labels:</span><br><span class="line"></span><br><span class="line">        instance: db1</span><br><span class="line"></span><br><span class="line">$ /usr/<span class="built_in">local</span>/prometheus/prometheus --config.file=/usr/<span class="built_in">local</span>/prometheus/prometheus.yml --storage.tsdb.path=/var/lib/prometheus</span><br></pre></td></tr></table></figure><h5 id="2-部署node-exporter"><a href="#2-部署node-exporter" class="headerlink" title="2 部署node_exporter"></a>2 部署node_exporter</h5><h6 id="2-1-下载二进制包"><a href="#2-1-下载二进制包" class="headerlink" title="2.1 下载二进制包"></a>2.1 下载二进制包</h6><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget <span class="symbol">https:</span>/<span class="regexp">/github.com/prometheus</span><span class="regexp">/node_exporter/releases</span><span class="regexp">/download/v</span><span class="number">0</span>.<span class="number">17.0</span>/node_exporter-<span class="number">0</span>.<span class="number">17.0</span>.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure><h6 id="2-2-解压并move至-usr-local-prometheus目录下"><a href="#2-2-解压并move至-usr-local-prometheus目录下" class="headerlink" title="2.2 解压并move至/usr/local/prometheus目录下"></a>2.2 解压并move至/usr/local/prometheus目录下</h6><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ tar zcvf node_exporter-<span class="number">0</span>.<span class="number">17.0</span>.linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line">$ mv node_exporter-<span class="number">0</span>.<span class="number">17.0</span>.linux-amd64 /usr/local/prometheus/node_exporter</span><br></pre></td></tr></table></figure><h6 id="2-3-启动"><a href="#2-3-启动" class="headerlink" title="2.3 启动"></a>2.3 启动</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ /usr/<span class="built_in">local</span>/prometheus/node_exporter/node_exporter --web.listen-address=:9100</span><br></pre></td></tr></table></figure><h5 id="3-部署mysqld-exporter"><a href="#3-部署mysqld-exporter" class="headerlink" title="3 部署mysqld_exporter"></a>3 部署mysqld_exporter</h5><h6 id="3-1-下载二进制包"><a href="#3-1-下载二进制包" class="headerlink" title="3.1 下载二进制包"></a>3.1 下载二进制包</h6><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget <span class="symbol">https:</span>/<span class="regexp">/github.com/prometheus</span><span class="regexp">/mysqld_exporter/releases</span><span class="regexp">/download/v</span><span class="number">0</span>.<span class="number">11.0</span>/mysqld_exporter-<span class="number">0</span>.<span class="number">11.0</span>.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure><h6 id="3-2-解压并move至-usr-local-prometheus目录下"><a href="#3-2-解压并move至-usr-local-prometheus目录下" class="headerlink" title="3.2 解压并move至/usr/local/prometheus目录下"></a>3.2 解压并move至/usr/local/prometheus目录下</h6><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ tar zcvf mysqld_exporter-<span class="number">0</span>.<span class="number">11.0</span>.linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line">$ mv mysqld_exporter-<span class="number">0</span>.<span class="number">11.0</span>.linux-amd64 /usr/local/prometheus/mysqld_exporter</span><br></pre></td></tr></table></figure><h6 id="3-3-为mysqld-exporter配置MySQL用户并授权，启动"><a href="#3-3-为mysqld-exporter配置MySQL用户并授权，启动" class="headerlink" title="3.3 为mysqld_exporter配置MySQL用户并授权，启动"></a>3.3 为mysqld_exporter配置MySQL用户并授权，启动</h6><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ cat .my.cnf</span><br><span class="line"></span><br><span class="line">[client]</span><br><span class="line"></span><br><span class="line">user=mysqld_exporter</span><br><span class="line"></span><br><span class="line">password=<span class="number">000000</span></span><br><span class="line"></span><br><span class="line">$ /usr/local/prometheus/mysqld_exporter/mysqld_exporter --config.my-cnf=<span class="regexp">/usr/local</span><span class="regexp">/prometheus/mysqld</span>_exporter/.my.cnf</span><br></pre></td></tr></table></figure><h5 id="4-部署alertmanager"><a href="#4-部署alertmanager" class="headerlink" title="4 部署alertmanager"></a>4 部署alertmanager</h5><h6 id="4-1-下载二进制包"><a href="#4-1-下载二进制包" class="headerlink" title="4.1 下载二进制包"></a>4.1 下载二进制包</h6><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget <span class="symbol">https:</span>/<span class="regexp">/github.com/prometheus</span><span class="regexp">/alertmanager/releases</span><span class="regexp">/download/v</span><span class="number">0</span>.<span class="number">16.1</span>/alertmanager-<span class="number">0</span>.<span class="number">16.1</span>.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure><h6 id="4-2-解压并move至-usr-local-prometheus目录下"><a href="#4-2-解压并move至-usr-local-prometheus目录下" class="headerlink" title="4.2 解压并move至/usr/local/prometheus目录下"></a>4.2 解压并move至/usr/local/prometheus目录下</h6><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ tar zcvf alertmanager-<span class="number">0</span>.<span class="number">16.1</span>.linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line">$ mv alertmanager-<span class="number">0</span>.<span class="number">16.1</span>.linux-amd64 /usr/local/prometheus/alertmanager</span><br></pre></td></tr></table></figure><h6 id="4-3-修改配置文件并启动"><a href="#4-3-修改配置文件并启动" class="headerlink" title="4.3 修改配置文件并启动"></a>4.3 修改配置文件并启动</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">$ cat alertmanager.yml</span><br><span class="line"></span><br><span class="line">global:</span><br><span class="line"></span><br><span class="line">  resolve_timeout: 5m</span><br><span class="line"></span><br><span class="line">  smtp_smarthost: <span class="string">'smtp.163.com:25'</span> <span class="comment"># 邮箱smtp服务器代理</span></span><br><span class="line"></span><br><span class="line">  smtp_from: <span class="string">'XXXXXX@163.com'</span> <span class="comment"># 发送邮箱名称</span></span><br><span class="line"></span><br><span class="line">  smtp_auth_username: <span class="string">'XXXXX@163.com'</span> <span class="comment"># 邮箱名称</span></span><br><span class="line"></span><br><span class="line">  smtp_auth_password: <span class="string">'XXXXXXXX'</span> <span class="comment"># 邮箱密码或授权码</span></span><br><span class="line"></span><br><span class="line">templates:</span><br><span class="line"></span><br><span class="line">  - <span class="string">'template/*.tmpl'</span></span><br><span class="line"></span><br><span class="line">route:</span><br><span class="line"></span><br><span class="line">  group_by: [<span class="string">'alertname'</span>]</span><br><span class="line"></span><br><span class="line">  group_wait: 10s</span><br><span class="line"></span><br><span class="line">  group_interval: 10s</span><br><span class="line"></span><br><span class="line">  repeat_interval: 24h</span><br><span class="line"></span><br><span class="line">  receiver: <span class="string">'ops_dingding'</span></span><br><span class="line"></span><br><span class="line">receivers:</span><br><span class="line"></span><br><span class="line">  - name: <span class="string">'email'</span></span><br><span class="line"></span><br><span class="line">    email_configs:</span><br><span class="line"></span><br><span class="line">    - to: <span class="string">'XXXXX@163.com'</span>  <span class="comment"># 接收警报的email配置</span></span><br><span class="line"></span><br><span class="line">      html: <span class="string">'&#123;&#123; template "test.html" . &#125;&#125;'</span> <span class="comment"># 设定邮箱的内容模板</span></span><br><span class="line"></span><br><span class="line">      headers: &#123; Subject: <span class="string">"[WARN] 报警邮件"</span>&#125; <span class="comment"># 接收邮件的标题</span></span><br><span class="line"></span><br><span class="line">  - name: <span class="string">'wechat'</span></span><br><span class="line"></span><br><span class="line">    wechat_configs:</span><br><span class="line"></span><br><span class="line">    - corp_id: <span class="string">'XXXXX'</span></span><br><span class="line"></span><br><span class="line">      to_party: <span class="string">'1'</span></span><br><span class="line"></span><br><span class="line">      agent_id: <span class="string">'1000002'</span></span><br><span class="line"></span><br><span class="line">      api_secret: <span class="string">'XXXXX'</span></span><br><span class="line"></span><br><span class="line">  - name: <span class="string">'ops_dingding'</span></span><br><span class="line"></span><br><span class="line">    webhook_configs:</span><br><span class="line"></span><br><span class="line">    - url: <span class="string">'http://localhost:8060/dingtalk/ops_dingding/send'</span></span><br><span class="line"></span><br><span class="line">inhibit_rules:</span><br><span class="line"></span><br><span class="line">  - source_match:</span><br><span class="line"></span><br><span class="line">      severity: <span class="string">'critical'</span></span><br><span class="line"></span><br><span class="line">    target_match:</span><br><span class="line"></span><br><span class="line">      severity: <span class="string">'warning'</span></span><br><span class="line"></span><br><span class="line">    equal: [<span class="string">'alertname'</span>, <span class="string">'dev'</span>, <span class="string">'instance'</span>]</span><br><span class="line"></span><br><span class="line">$ /usr/<span class="built_in">local</span>/prometheus/alertmanager/alertmanager --config.file=/usr/<span class="built_in">local</span>/prometheus/alertmanager/alertmanager.yml</span><br></pre></td></tr></table></figure><h5 id="5-prometheus通过webhook推送告警至钉钉"><a href="#5-prometheus通过webhook推送告警至钉钉" class="headerlink" title="5 prometheus通过webhook推送告警至钉钉"></a>5 prometheus通过webhook推送告警至钉钉</h5><h6 id="5-1-添加钉钉机器人，获取webhook"><a href="#5-1-添加钉钉机器人，获取webhook" class="headerlink" title="5.1 添加钉钉机器人，获取webhook"></a>5.1 添加钉钉机器人，获取webhook</h6><p>参考 <a href="https://open-doc.dingtalk.com/docs/doc.htm?treeId=257&amp;articleId=105735&amp;docType=1" target="_blank" rel="noopener">https://open-doc.dingtalk.com/docs/doc.htm?treeId=257&amp;articleId=105735&amp;docType=1</a></p><h6 id="5-2-下载插件（二进制文件）"><a href="#5-2-下载插件（二进制文件）" class="headerlink" title="5.2 下载插件（二进制文件）"></a>5.2 下载插件（二进制文件）</h6><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget <span class="symbol">https:</span>/<span class="regexp">/github.com/timonwong</span><span class="regexp">/prometheus-webhook-dingtalk/releases</span><span class="regexp">/download/v</span><span class="number">0</span>.<span class="number">3.0</span>/prometheus-webhook-dingtalk-<span class="number">0</span>.<span class="number">3.0</span>.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure><h6 id="5-3-解压并move至-usr-local-prometheus目录下"><a href="#5-3-解压并move至-usr-local-prometheus目录下" class="headerlink" title="5.3 解压并move至/usr/local/prometheus目录下"></a>5.3 解压并move至/usr/local/prometheus目录下</h6><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ tar zxvf prometheus-webhook-dingtalk-<span class="number">0</span>.<span class="number">3.0</span>.linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line">$ mv prometheus-webhook-dingtalk-<span class="number">0</span>.<span class="number">3.0</span>.linux-amd64/prometheus-webhook-dingtalk /usr/local/prometheus/alertmanager</span><br></pre></td></tr></table></figure><h6 id="5-4-编辑启动脚本（请替换为自己的webhook-URL-及-ding-profile）"><a href="#5-4-编辑启动脚本（请替换为自己的webhook-URL-及-ding-profile）" class="headerlink" title="5.4 编辑启动脚本（请替换为自己的webhook URL 及 ding.profile）"></a>5.4 编辑启动脚本（请替换为自己的webhook URL 及 ding.profile）</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat dingding_start.sh</span><br><span class="line"></span><br><span class="line">nohup /usr/<span class="built_in">local</span>/prometheus/alertmanager/prometheus-webhook-dingtalk --ding.profile=<span class="string">"ops_dingding=https://oapi.dingtalk.com/robot/send?access_token=XXXXXXX"</span>  2&gt;&amp;1 1&gt;/usr/<span class="built_in">local</span>/prometheus/alertmanager/dingding.log &amp;</span><br><span class="line"></span><br><span class="line">$ sh dingding_start.sh</span><br></pre></td></tr></table></figure><h6 id="5-5-编辑alertmanager-yml，增加web-hook配置并重启alertmanager"><a href="#5-5-编辑alertmanager-yml，增加web-hook配置并重启alertmanager" class="headerlink" title="5.5 编辑alertmanager.yml，增加web_hook配置并重启alertmanager"></a>5.5 编辑alertmanager.yml，增加web_hook配置并重启alertmanager</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- name: <span class="string">'ops_dingding'</span></span><br><span class="line"></span><br><span class="line">  webhook_configs:</span><br><span class="line"></span><br><span class="line">  - url: <span class="string">'http://localhost:8060/dingtalk/ops_dingding/send'</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Oct 29 2019 15:51:53 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;Prometheus部署-邮箱告警-企业微信告警-钉钉告警&quot;&gt;&lt;a href=&quot;#Prometheus部署-邮箱告警-企业微信告警-钉
      
    
    </summary>
    
    
      <category term="监控系统" scheme="http://chenzhonzhou.github.io/categories/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="prometheus" scheme="http://chenzhonzhou.github.io/categories/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/prometheus/"/>
    
    
      <category term="prometheus" scheme="http://chenzhonzhou.github.io/tags/prometheus/"/>
    
      <category term="监控系统" scheme="http://chenzhonzhou.github.io/tags/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>docker镜像、容器管理</title>
    <link href="http://chenzhonzhou.github.io/2018/09/05/docker-jing-xiang-rong-qi-guan-li/"/>
    <id>http://chenzhonzhou.github.io/2018/09/05/docker-jing-xiang-rong-qi-guan-li/</id>
    <published>2018-09-05T04:07:11.000Z</published>
    <updated>2019-10-23T02:18:04.501Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Oct 29 2019 15:51:53 GMT+0800 (GMT+08:00) --><h3 id="一、Docker简介"><a href="#一、Docker简介" class="headerlink" title="一、Docker简介"></a>一、Docker简介</h3><h5 id="Docker是什么"><a href="#Docker是什么" class="headerlink" title="Docker是什么?"></a>Docker是什么?</h5><p>Docker的英文本意是“搬运工”，在程序员的世界里，Docker搬运的是集装箱（Container），集装箱里装的是任意类型的App，开发者通过Docker可以将App变成一种标准化的、可移植的、自管理的组件，可以在任何主流系统中开发、调试和运行。</p><p>说白了,docker是一种用了新颖方式实现的轻量级虚拟机,类似于VM,但是在原理和应用上和VM的差别还是很大的.并且docker的专业叫法是应用容器(Application Container)。</p><p>为啥要用容器?<br>应用容器是个啥样子呢,一个做好的应用容器长得就像一个装好了一组特定应用的虚拟机一样,比如我现在想用mysql,那我就找个装好了mysql的容器就可以了,然后运行起来,我就能使用mysql了。</p><p>为啥不能直接安装一个mysql?安装一个SQL Server也可以啊,可是有的时候根据每个人电脑的不同,在安装的时候可能会报出各种各样的错误,万一你的机器中毒了,你的电脑挂了,你所有的服务都需要重新安装.但是有了docker,或者说有了容器就不同了,你就相当于有了一个可以运行起来的虚拟机,只要你能运行容器,mysql的配置就省了.而且如果你想换个电脑,直接把容器”端过来”就可以使用容器里面的服务.</p><p>Docker 基于 Go 语言开发，代码托管在Github上，并遵循Apache 2.0 开源协议。Docker 容器可以封装任何有效负载，几乎可以在任何服务器之间进行一致性运行。换句话说，开发者构建的应用只需一次构建即可多平台运行。运营人员只需配置他们的服务，即可运行所有的应用。</p><p>若是利用容器的话,那么开发直接在容器里开发,测试的时候把整个容器给测试,测好了把测试后容器再上线就好了.通过容器,整个开发,测试和生产环境可以保持高度一致。</p><p>此外容器也VM一样具有一定得隔离性,各个容器之间的数据和内存空间相互隔离,可以保证一定的安全性。</p><p>Hyper-V、KVM和Xen等虚拟机管理程序都“基于虚拟化硬件仿真机制。这意味着，它们对系统要求很高.然而，容器却使用共享的操作系统。这意味着它们在使用系统资源方面比虚拟机管理程序要高效得多。容器不是对硬件进行虚拟化处理，而是驻留在一个Linux实例上。<br>Docker可以解决虚拟机能够解决的问题，同时也能够解决虚拟机由于资源要求过高而无法解决的问题。</p><h5 id="为什么要使用docker？"><a href="#为什么要使用docker？" class="headerlink" title="为什么要使用docker？"></a>为什么要使用docker？</h5><h6 id="1-、快速交付应用程序"><a href="#1-、快速交付应用程序" class="headerlink" title="1 、快速交付应用程序"></a>1 、快速交付应用程序</h6><p>•开发者使用一个标准的 image 来构建开发容器，开发完成之后，系统管理员就可以使用这个容器来部署代码<br>•docker可以快速创建容器，快速迭代应用程序，并让整个过程可见，使团队中的其他成员更容易理解应用程序是如何创建和工作的。<br>•docker容器很轻！很快！容器的启动时间是次秒级的，节约开发、测试、部署的时间</p><h6 id="2-、更容易部署和扩展"><a href="#2-、更容易部署和扩展" class="headerlink" title="2 、更容易部署和扩展"></a>2 、更容易部署和扩展</h6><p>•docker容器可以在几乎所有的环境中运行，物理机、虚拟机、公有云、私有云、个人电脑、服务器等等。<br>•docker容器兼容很多平台，这样就可以把一个应用程序从一个平台迁移到另外一个。</p><h6 id="3-、效率更高"><a href="#3-、效率更高" class="headerlink" title="3 、效率更高"></a>3 、效率更高</h6><p>•docker容器不需要 hypervisor ，他是内核级的虚拟化。</p><h6 id="4-、快速部署也意味着更简单的管理"><a href="#4-、快速部署也意味着更简单的管理" class="headerlink" title="4 、快速部署也意味着更简单的管理"></a>4 、快速部署也意味着更简单的管理</h6><p>•通常只需要小小的改变就可以替代以往巨型和大量的更新工作。</p><ul><li>Docker 的常用案例包括：<br> 自动打包和部署应用<br> 创建轻量、私有的 PaaS 环境<br> 自动化测试和持续集成/部署<br> 部署并扩展 Web 应用、数据库和后端服务器</li></ul><h5 id="那么为啥不用VM"><a href="#那么为啥不用VM" class="headerlink" title="那么为啥不用VM?"></a>那么为啥不用VM?</h5><p>那么既然容器和VM这么类似为啥不用VM?docker容器相对于VM还是有很多优点的:<br>1.启动速度快,容器通常在一秒内可以启动.而VM要很久.<br>2.资源利用率高,一台普通服务器可以跑上千个容器，而跑VM就。。。。。。<br>3.性能开销小,VM需要额外的CPU和内存来完成OS的功能,这一部分占据了额外的资源.</p><p>为啥相似的功能在性能上会有如此巨大的差距呢?看一下他们的设计图,先看VM的:</p><p>下面的图片比较了 Docker 和传统虚拟化方式的不同之处，<br><img src="https://img2018.cnblogs.com/blog/1829796/201910/1829796-20191022105823671-1553838987.png" alt></p><p>可见容器是在操作系统层面上实现虚拟化，直接复用本地主机的操作系统，而传统方式则是在硬件层面实现。</p><p>Docker优势和劣势<br>作为一种新兴的虚拟化方式，Docker 跟传统的虚拟化方式相比具有众多的优势。<br>首先，Docker 容器的启动可以在秒级实现，这相比传统的虚拟机方式要快得多。<br>其次，Docker 对系统资源的利用率很高，一台主机上可以同时运行数千个 Docker 容器。<br>容器除了运行其中应用外，基本不消耗额外的系统资源，使得应用的性能很高，同时系统的开销尽量小。传统虚拟机方式运行 10 个不同的应用就要起 10 个虚拟机，而 Docker 只需要启动 10 个隔离的应用即可。</p><p>具体说来，Docker 在如下几个方面具有较大的优势。<br>更快速的交付和部署<br>对开发和运维（devop）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。开发者可以使用一个标准的镜像来构建一套开发容器，开发完成之后，运维人员可以直接使用这个容器来部署代码。 Docker 可以快速创建容器，快速迭代应用程序，并让整个过程全程可见，使团队中的其他成员更容易理解应用程序是如何创建和工作的。 Docker 容器很轻很快！容器的启动时间是秒级的，大量地节约开发、测试、部署的时间。<br>更高效的虚拟化<br>Docker 容器的运行不需要额外的 hypervisor 支持，它是内核级的虚拟化，因此可以实现更高的性能和效率。<br>更轻松的迁移和扩展<br>Docker 容器几乎可以在任意的平台上运行，包括物理机、虚拟机、公有云、私有云、个人电脑、服务器等。这种兼容性可以让用户把一个应用程序从一个平台直接迁移到另外一个。<br>更简单的管理<br>使用 Docker，只需要小小的修改，就可以替代以往大量的更新工作。所有的修改都以增量的方式被分发和更新，从而实现自动化并且高效的管理。</p><p>对比传统虚拟机总结<br>| 特性 | 容器 | 虚拟机 |<br>| ———- | —————— | ————– |<br>| 启动 | 秒级 | 分钟级 |<br>| 硬盘使用 | 一般为MB | 一般为GB |<br>| 性能 | 接近原生 | 弱于 |<br>| 系统支持量 | 单机支持上千个容器 | 单机最多几十个 |</p><h3 id="二、Docker-的体系结构"><a href="#二、Docker-的体系结构" class="headerlink" title="二、Docker 的体系结构"></a>二、Docker 的体系结构</h3><p>docker使用C/S 架构，docker daemon 作为 server 端接受 client 的请求，并处理（创建、运行、分发容器），他们可以运行在一个机器上，也通过 socket或者 RESTful API 通信<br><img src="https://img2018.cnblogs.com/blog/1829796/201910/1829796-20191022110500682-916327167.png" alt></p><p>Docker daemon 一般在宿主主机后台运行。<br>Docker client以系统命令的形式存在，用户用docker命令来跟docker daemon 交互。</p><p>Docker 守护进程（Docker daemon）<br>如上图所示，Docker 守护进程运行在一台主机上。用户并不直接和守护进程进行交互，而是通过 Docker 客户端间接和其通信。<br>Docker 客户端（Docker client）<br>Docker 客户端，实际上是docker的二进制程序，是用户与 Docker 交互方式。它接收用户指令并且与背后的 Docker 守护进程通信。<br><img src="https://img2018.cnblogs.com/blog/1829796/201910/1829796-20191022110512127-968965811.png" alt></p><h5 id="Docker-内部："><a href="#Docker-内部：" class="headerlink" title="Docker 内部："></a>Docker 内部：</h5><p>要理解 Docker 内部构建，需要理解以下三种部件：<br>1)Docker 镜像 - Docker images<br>2)Docker 仓库 - Docker registeries<br>3)Docker 容器 - Docker containers</p><h5 id="1、Docker-镜像-："><a href="#1、Docker-镜像-：" class="headerlink" title="1、Docker 镜像 ："></a>1、Docker 镜像 ：</h5><p>Docker 镜像是 Docker 容器运行时的只读模板，镜像可以用来创建 Docker 容器。每一个镜像由一系列的层 (layers) 组成。Docker 使用UnionFS（联合文件系统）来将这些层联合到单独的镜像中。UnionFS允许独立文件系统中的文件和文件夹(称之为分支)被透明覆盖，形成一个单独连贯的文件系统。正因为有了这些层的存在，Docker 是如此的轻量。当你改变了一个 Docker 镜像，比如升级到某个程序到新的版本，一个新的层会被创建。因此，不用替换整个原先的镜像或者重新建立(在使用虚拟机的时候你可能会这么做)，只是一个新的层被添加或升级了。现在你不用重新发布整个镜像，只需要升级，层使得分发 Docker 镜像变得简单和快速。<br>每个docker都有很多层次构成，docker使用 union file systems 将这些不同的层结合到一个image 中去。<br>例如：centos镜像中安装nginx，就成了nginx镜像”，其实在此时Docker镜像的层级概念就体现出来了。底层一个centos操作系统镜像，上面叠加一个ngnx层，就完成了一个nginx镜像的构建。层级概念就不难理解，此时我们一般centos操作系统镜像称为nginx镜像层的父镜像。<br><img src="https://img2018.cnblogs.com/blog/1829796/201910/1829796-20191022110524969-1070377586.png" alt></p><h5 id="2、Docker-仓库-："><a href="#2、Docker-仓库-：" class="headerlink" title="2、Docker 仓库 ："></a>2、Docker 仓库 ：</h5><p>Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。同样的，Docker 仓库也有公有和私有的概念。公有的 Docker 仓库名字是 Docker Hub。Docker Hub 提供了庞大的镜像集合供使用。这些镜像可以是自己创建，或者在别人的镜像基础上创建。<br>仓库是集中存放镜像文件的场所。有时候会把仓库和仓库注册服务器（Registry）混为一谈，并不严格区分。实际上，仓库注册服务器上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签（tag）。</p><p>仓库分为公开仓库（Public）和私有仓库（Private）两种形式，最大的公开仓库是 Docker Hub，存放了数量庞大的镜像供用户下载。国内的公开仓库包括 Docker Pool等，可以提供大陆用户更稳定快速的访问。</p><p>当然，用户也可以在本地网络内创建一个私有仓库。当用户创建了自己的镜像之后就可以使用push命令将它上传到公有或者私有仓库，这样下次在另外一台机器上使用这个镜像时候，只需要从仓库上pull下来就可以了。<br>*注：Docker 仓库的概念跟Git类似，注册服务器可以理解为 GitHub 这样的托管服务。</p><h5 id="3、Docker-容器-："><a href="#3、Docker-容器-：" class="headerlink" title="3、Docker 容器 ："></a>3、Docker 容器 ：</h5><p>Docker 容器用来运行应用，一个Docker容器包含了所有的某个应用运行所需要的环境。每一个 Docker 容器都是从 Docker 镜像创建的。Docker 容器可以运行、开始、停止、移动和删除。每一个 Docker 容器都是独立和安全的应用平台。<br>容器是从镜像创建的运行实例。它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。<br>可以把容器看做是一个简易版的 Linux 环境（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。<br>*注：镜像是只读的，容器在启动的时候创建一层可写层作为最上层。<br><img src="https://img2018.cnblogs.com/blog/1829796/201910/1829796-20191022110535409-1799935510.png" alt></p><p>与虚拟机相比，容器有一个很大的差异，它们被设计用来运行”单进程”，无法很好地模拟一个完整的环境。Docker设计者极力推崇“一个容器一个进程的方式”，如果你要选择在一个容器中运行多个进程，那唯一情况是：出于调试目的。<br>容器是设计来运行一个应用的，而非一台机器。你可能会把容器当虚拟机用，但你将失去很多的灵活性，因为Docker提供了用于分离应用与数据的工具，使得你可以快捷地更新运行中的代码/系统，而不影响数据。<br>Docker 从 0.9 版本开始使用 libcontainer 替代 lxc，libcontainer 和 Linux 系统的交互图如下：<br><img src="https://img2018.cnblogs.com/blog/1829796/201910/1829796-20191022110543385-1355070567.png" alt></p><p>Docker 底层技术<br>docker底层的 2 个核心技术分别是 Namespaces 和 Control groups<br>Namespaces用来隔离各个容器</p><h6 id="1-pid-namespace"><a href="#1-pid-namespace" class="headerlink" title="1)pid namespace"></a>1)pid namespace</h6><p>不同用户的进程就是通过pid namespace 隔离开的，且不同 namespace 中可以有相同pid。所有的LXC进程在docker中的父进程为docker进程，每个lxc进程具有不同的 namespace 。</p><h6 id="2-net-namespace"><a href="#2-net-namespace" class="headerlink" title="2) net namespace"></a>2) net namespace</h6><p>有了pid namespace, 每个 namespace 中的pid能够相互隔离，但是网络端口还是共享 host 的端口。网络隔离是通过 net namespace 实现的，每个 net namespace 有独立的 network devices, IP addresses, IP routing tables, /proc/net 目录。这样每个 container 的网络就能隔离开来。docker默认采用veth的方式将 container 中的虚拟网卡同 host 上的一个docker bridge: docker0 连接在一起。</p><h6 id="3-ipc-namespace"><a href="#3-ipc-namespace" class="headerlink" title="3) ipc namespace"></a>3) ipc namespace</h6><p>container 中进程交互还是采用linux常见的进程间交互方法 (interprocess communication - IPC),包括常见的信号量、消息队列和共享内存。container 的进程间交互实际上还是host 上具有相同pid namespace 中的进程间交互。</p><h6 id="4-mnt-namespace"><a href="#4-mnt-namespace" class="headerlink" title="4) mnt namespace"></a>4) mnt namespace</h6><p>类似chroot，将一个进程放到一个特定的目录执行。mnt namespace 允许不同 namespace 的进程看到的文件结构不同，这样每个 namespace 中的进程所看到的文件目录就被隔离开了。在container里头，看到的文件系统，就是一个完整的linux系统，有/etc、/lib 等，通过chroot实现。</p><h6 id="5-uts-namespace"><a href="#5-uts-namespace" class="headerlink" title="5) uts namespace"></a>5) uts namespace</h6><p>UTS(“UNIX Time-sharing System”) namespace 允许每个 container 拥有独立的 hostname 和 domain name, 使其在网络上可以被视作一个独立的节点而非 Host 上的一个进程。</p><h6 id="6-user-namespace"><a href="#6-user-namespace" class="headerlink" title="6) user namespace"></a>6) user namespace</h6><p>每个 container 可以有不同的 user 和 group id, 也就是说可以在 container 内部用 container 内部的用户执行程序而非 Host 上的用户。</p><p>有了以上 6 种 namespace 从进程、网络、IPC、文件系统、UTS和用户角度的隔离，一个 container 就可以对外展现出一个独立计算机的能力，并且不同 container 从 OS 层面实现了隔离。然而不同 namespace 之间资源还是相互竞争的，仍然需要类似ulimit来管理每个 container 所能使用的资源 - -cgroup。</p><p>资源配额「cgroups」<br>cgroups 实现了对资源的配额和度量。 cgroups 的使用非常简单，提供类似文件的接口，在 /cgroup 目录下新建一个文件夹即可新建一个 group，在此文件夹中新建 task 文件，并将 pid 写入该文件，即可实现对该进程的资源控制。具体的资源配置选项可以在该文件夹中新建子 subsystem ，{子系统前缀}.{资源项} 是典型的配置方法， 如 memory.usageinbytes 就定义了该 group 在 subsystem memory 中的一个内存限制选项。 另外，cgroups 中的 subsystem 可以随意组合，一个 subsystem 可以在不同的 group 中，也可以一个 group 包含多个 subsystem - 也就是说一个 subsystem。<br>memory<br>内存相关的限制<br>cpu<br>在 cgroup 中，并不能像硬件虚拟化方案一样能够定义 CPU 能力，但是能够定义 CPU 轮转的优先级，因此具有较高 CPU 优先级的进程会更可能得到 CPU 运算。 通过将参数写入 cpu.shares ,即可定义改 cgroup 的 CPU 优先级 - 这里是一个相对权重，而非绝对值<br>blkio<br>block IO 相关的统计和限制，byte/operation 统计和限制 (IOPS 等)，读写速度限制等，但是这里主要统计的都是同步 IO<br>devices<br>设备权限限制</p><h3 id="三、Docker-安装"><a href="#三、Docker-安装" class="headerlink" title="三、Docker 安装"></a>三、Docker 安装</h3><p>docker官网：<a href="https://docs.docker.com" target="_blank" rel="noopener">https://docs.docker.com</a><br>Docker值得关注的特性：<br>o文件系统隔离：每个进程容器运行在一个完全独立的根文件系统里。<br>o资源隔离：系统资源，像CPU和内存等可以分配到不同的容器中，使用cgroup。<br>o网络隔离：每个进程容器运行在自己的网络空间，虚拟接口和IP地址。<br>o日志记录：Docker将会收集和记录每个进程容器的标准流（stdout/stderr/stdin），用于实时检索或批量检索。<br>o变更管理：容器文件系统的变更可以提交到新的映像中，并可重复使用以创建更多的容器。无需使用模板或手动配置。<br>o交互式shell：Docker可以分配一个虚拟终端并关联到任何容器的标准输入上，</p><p>CentOS 系列安装 Docker，Docker 支持 CentOS6 及以后的版本。<br>CentOS6：<br>在RedHat/CentOS环境下安装Docker。官方文档要求Linux kernel至少3.8以上，且docker只能运行在64位的系统中。由于RHEL6和CentOS6的内核版本为2.6，因此必须要先升级内核。</p><p>升级内核（记住一定要升级，要不然会出现很多莫名奇怪的问题，建议用yum安装）</p><h5 id="1、Centos6系统安装docker"><a href="#1、Centos6系统安装docker" class="headerlink" title="1、Centos6系统安装docker:"></a>1、Centos6系统安装docker:</h5><p>1-1)yum安装带aufs模块的3.10内核</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@server4</span> ~]<span class="meta"># cd /etc/yum.repos.d/</span></span><br><span class="line">[root<span class="symbol">@server4</span> yum.repos.d]<span class="meta"># wget http://www.hop5.in/yum/el6/hop5.repo</span></span><br><span class="line">[root<span class="symbol">@server4</span> yum.repos.d]<span class="meta"># ls</span></span><br><span class="line">hop5.repo</span><br><span class="line">[root<span class="symbol">@server4</span> yum.repos.d]<span class="meta"># yum -y install kernel-ml-aufs kernel-ml-aufs-devel</span></span><br></pre></td></tr></table></figure><p>1-2)修改grub的主配置文件/etc/grub.conf，设置default=0，表示第一个title下的内容为默认启动的kernel（一般新安装的内核在第一个位置），</p><p>1-3)重启系统，这时候你的内核就成功升级了。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@server4 ~]</span># <span class="selector-tag">uname</span> <span class="selector-tag">-r</span></span><br><span class="line">3<span class="selector-class">.10</span><span class="selector-class">.0-327</span><span class="selector-class">.el7</span><span class="selector-class">.x86_64</span></span><br></pre></td></tr></table></figure><p>1-4)可以使用EPEL库安装 Docker，命令如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#yum</span> install http:<span class="comment">//mirrors.yun-idc.com/epel/6/i386/epel-release-6-8.noarch.rpm</span></span><br><span class="line"><span class="selector-id">#yum</span> install docker-io</span><br></pre></td></tr></table></figure><p>1-5)启动docker服务</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#service</span> docker start</span><br></pre></td></tr></table></figure><h5 id="2、CentOS7安装docker："><a href="#2、CentOS7安装docker：" class="headerlink" title="2、CentOS7安装docker："></a>2、CentOS7安装docker：</h5><p>2-1）Prerequisites（先决条件）<br>Docker requires a 64-bit installation regardless of your CentOS version. Also, your kernel must be 3.10 at minimum, which CentOS 7 runs.<br>To check your current kernel version, open a terminal and use uname -r to display your kernel version:<br>[root@server4 yum.repos.d]# uname -r<br>3.10.0-327.el7.x86_64</p><p>2-2）Docker 软件包已经包括在默认的 CentOS-Extras 软件源里。因此想要安装docker，只需要运行下面的 yum 命令：<br>[root@server4 yum.repos.d]# yum -y install docker<br>注：如出现以下报错<br>[root@server4 yum.repos.d]# yum -y install docker<br>Loaded plugins: plugins: fastestmirror, langpacks<br>Existing lock /var/run/yum.pid: another copy is running as pid 13120.<br>Another app is currently holding the yum lock; waiting for it to exit…<br>The other application is: PackageKit<br>Memory : 26 M RSS (429 MB VSZ)<br>Started: Fri Nov 11 10:27:44 2016 - 00:12 ago<br>State : Sleeping, pid: 13120<br>解决方法：<br>[root@server4 yum.repos.d]# rm -rf /var/run/yum.pid</p><p>2-3）启动 Docker 服务：<br>安装完成后，使用下面的命令来启动docker服务，并将其设置为开机启动：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@server4</span> ~]<span class="meta"># systemctl enable docker </span></span><br><span class="line">[root<span class="symbol">@server4</span> ~]<span class="meta"># systemctl start docker</span></span><br></pre></td></tr></table></figure><p>2-4)查看docker版本</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[<span class="symbol">root@</span>server4 ~]# docker version</span><br><span class="line">Client:</span><br><span class="line"> Version:         <span class="number">1.10</span><span class="number">.3</span></span><br><span class="line"> API version:     <span class="number">1.22</span></span><br><span class="line"> Package version: docker-common<span class="number">-1.10</span><span class="number">.3</span><span class="number">-46.</span>el7.centos<span class="number">.14</span>.x86_64</span><br><span class="line"> Go version:      go1<span class="number">.6</span><span class="number">.3</span></span><br><span class="line"> Git commit:      cb079f6-unsupported</span><br><span class="line"> Built:           Fri Sep <span class="number">16</span> <span class="number">13</span>:<span class="number">24</span>:<span class="number">25</span> <span class="number">2016</span></span><br><span class="line"> OS/Arch:         linux/amd64</span><br><span class="line"></span><br><span class="line">Server:</span><br><span class="line"> Version:         <span class="number">1.10</span><span class="number">.3</span></span><br><span class="line"> API version:     <span class="number">1.22</span></span><br><span class="line"> Package version: docker-common<span class="number">-1.10</span><span class="number">.3</span><span class="number">-46.</span>el7.centos<span class="number">.14</span>.x86_64</span><br><span class="line"> Go version:      go1<span class="number">.6</span><span class="number">.3</span></span><br><span class="line"> Git commit:      cb079f6-unsupported</span><br><span class="line"> Built:           Fri Sep <span class="number">16</span> <span class="number">13</span>:<span class="number">24</span>:<span class="number">25</span> <span class="number">2016</span></span><br><span class="line"> OS/Arch:         linux/amd64</span><br></pre></td></tr></table></figure><p>2-5)查看docker版本：docker info</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[root@server4 ~]# docker info</span><br><span class="line">Containers: 0</span><br><span class="line"> Running: 0</span><br><span class="line"> Paused: 0</span><br><span class="line"> Stopped: 0</span><br><span class="line">Images: 0</span><br><span class="line">Server Version: 1.10.3</span><br><span class="line">Storage Driver: devicemapper</span><br><span class="line"><span class="built_in"> Pool </span>Name: docker-253:0-1785801-pool</span><br><span class="line"><span class="built_in"> Pool </span>Blocksize: 65.54 kB</span><br><span class="line"> Base Device Size: 10.74 GB</span><br><span class="line"> Backing Filesystem: xfs</span><br><span class="line"> Data file: /dev/loop0</span><br><span class="line"> Metadata file: /dev/loop1</span><br><span class="line"> Data Space Used: 11.8 MB</span><br><span class="line"> Data Space Total: 107.4 GB</span><br><span class="line"> Data Space Available: 40.74 GB</span><br><span class="line"> Metadata Space Used: 581.6 kB</span><br><span class="line"> Metadata Space Total: 2.147 GB</span><br><span class="line"> Metadata Space Available: 2.147 GB</span><br><span class="line"> Udev Sync Supported: <span class="literal">true</span></span><br><span class="line"> Deferred Removal Enabled: <span class="literal">false</span></span><br><span class="line"> Deferred Deletion Enabled: <span class="literal">false</span></span><br><span class="line"> Deferred Deleted Device Count: 0</span><br><span class="line"> Data loop file: /var/lib/docker/devicemapper/devicemapper/data</span><br></pre></td></tr></table></figure><p>以上是使用centos7软件源提供的docker安装程序<br>附：也可以按照官方文档安装<br>1.Log into your machine as a user with sudo or root privileges.<br>2.Make sure your existing yum packages are up-to-date.<br>3．Add the yum repo<br>$ sudo tee /etc/yum.repos.d/docker.repo&lt;&lt;-‘EOF’<br>[dockerrepo]<br>name=DockerRepositorybaseurl=<a href="https://yum.dockerproject.org/repo/main/centos/7/" target="_blank" rel="noopener">https://yum.dockerproject.org/repo/main/centos/7/</a><br>enabled=1<br>gpgcheck=1<br>gpgkey=<a href="https://yum.dockerproject.org/gpg" target="_blank" rel="noopener">https://yum.dockerproject.org/gpg</a><br>EOF<br>注：如果我们既想把输出保存到文件中，又想在屏幕上看到输出内容，就可以使用tee命令了。tee命令读取标准输入，把这些内容同时输出到标准输出和（多个）文件中<br>4．Install the Docker package<br>$ sudo yum install docker-engine<br>5．Start the Docker daemon.<br>$ sudo service dockerstart<br>6．Verify docker is installed correctly by running a test image in a container.<br>验证docker安装正确</p><p>以上是使用centos7软件源提供的docker安装程序<br>附：也可以按照官方文档安装<br>1.Log into your machine as a user with sudo or root privileges.<br>2.Make sure your existing yum packages are up-to-date.<br>3．Add the yum repo<br>$ sudo tee /etc/yum.repos.d/docker.repo&lt;&lt;-‘EOF’<br>[dockerrepo]<br>name=DockerRepositorybaseurl=<a href="https://yum.dockerproject.org/repo/main/centos/7/" target="_blank" rel="noopener">https://yum.dockerproject.org/repo/main/centos/7/</a><br>enabled=1<br>gpgcheck=1<br>gpgkey=<a href="https://yum.dockerproject.org/gpg" target="_blank" rel="noopener">https://yum.dockerproject.org/gpg</a><br>EOF<br>注：如果我们既想把输出保存到文件中，又想在屏幕上看到输出内容，就可以使用tee命令了。tee命令读取标准输入，把这些内容同时输出到标准输出和（多个）文件中<br>4．Install the Docker package<br>$ sudo yum install docker-engine<br>5．Start the Docker daemon.<br>$ sudo service dockerstart<br>6．Verify docker is installed correctly by running a test image in a container.<br>验证docker安装正确</p><p>$ sudo docker run hello-world</p><p>7.docker默认使用的是unix socket</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="symbol">root@</span>server4 ~]# ss -ax | grep docker</span><br><span class="line">u_str  LISTEN     <span class="number">0</span>      <span class="number">128</span>    /var/lib/docker/network/files/<span class="number">8269</span>c2bdc34721cabf2d2fa89b52bafd7fd1cd3f7d0c7456518c74b5cb704bdf.sock <span class="number">53403</span>                 * <span class="number">0</span>                    </span><br><span class="line">u_str  LISTEN     <span class="number">0</span>      <span class="number">128</span>    /var/run/docker.sock <span class="number">53301</span>                 * <span class="number">0</span>                    </span><br><span class="line">u_str  ESTAB      <span class="number">0</span>      <span class="number">0</span>      /var/run/docker.sock <span class="number">55511</span>                 * <span class="number">48920</span></span><br></pre></td></tr></table></figure><p>​<br>附：直接输入docker命令来查看所有的Options和Commands，查看某一个command的详细使用方法：dockerCOMMAND–help</p><h3 id="四、Docker-image详细介绍"><a href="#四、Docker-image详细介绍" class="headerlink" title="四、Docker image详细介绍"></a>四、Docker image详细介绍</h3><p>在之前的介绍中，我们知道docker images 是docker的三大组件之一。<br>docker把下载的 images 存储到docker主机上，如果一个 image 不在主机上，docker会从一个镜像仓库下载，默认的仓库是 DOCKER HUB 公共仓库。<br>接下来将介绍更多关于docker images 的内容，包括：<br>•使用和管理本地主机上的 images<br>•创建一个基础的 images<br>•上传 images 到docker hub （公共 images 仓库）<br>•列出本地主机上已经存在的 images</p><h5 id="1）使用docker-images-显示本机上的-images"><a href="#1）使用docker-images-显示本机上的-images" class="headerlink" title="1）使用docker images  显示本机上的 images"></a>1）使用docker images 显示本机上的 images</h5><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="symbol">root@</span>localhost ~]# docker images </span><br><span class="line">REPOSITORY     TAG          IMAGE ID         CREATED         SIZE</span><br><span class="line">docker.io/centos  latest        <span class="number">50</span>dae1ee8677     <span class="number">3</span> months ago     <span class="number">196.7</span> MB</span><br></pre></td></tr></table></figure><p>在列出信息中，<br>•REPOSITORY:来自于哪个仓库，比如 docker.io/centos<br>•TAG的标记，比如 latest<br>•IMAGE ID:镜像它的 ID 号<br>•CREATED:创建时间<br>•SIZE:镜像的 SIZE<br>一个仓库可能有一个 images 的都个发行版，比如ubuntu，他们有 10.04 12.04 12.10 13.04 14.04,每个发行版的标记都不同，可以使用 tag 命令来指定 images<br>注：如果你不指定具体的发行版，比如仅使用ubuntu，那么docker会使用最新的发行版ubuntu:latest<br>提示：建议最好指定发行版，只有这样你才可以保证你真正使用的 image 是那个</p><h5 id="2）获取-images-网络"><a href="#2）获取-images-网络" class="headerlink" title="2）获取 images (网络)"></a>2）获取 images (网络)</h5><p>我们如何获取新的 images 呢？当我们启动容器使用的 image 不再本地主机上时，docker会自动下载他们。这很耗时，我们可以使用docker pull 命令来预先下载我们需要的 image 。下面的例子下载一个centos 镜像。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker pull docker.io/centos</span><br><span class="line">Using<span class="built_in"> default </span>tag: latest</span><br><span class="line">Trying <span class="keyword">to</span> pull repository docker.io/library/centos <span class="built_in">..</span>. </span><br><span class="line">latest: Pulling <span class="keyword">from</span> docker.io/library/centos</span><br><span class="line">08d48e6f1cff: Downloading [&gt;                                   ] 1.081 MB/70.48 MB</span><br></pre></td></tr></table></figure><p>这样当我们使用这个 image 来启动容器的时候，它就可以马上启动了。</p><p>这样当我们使用这个 image 来启动容器的时候，它就可以马上启动了。</p><h5 id="3）查找-images-网络"><a href="#3）查找-images-网络" class="headerlink" title="3）查找 images (网络)"></a>3）查找 images (网络)</h5><p>docker的一个特点是很多人因为各种不同的用途创建了各种不同的 images 。它们都被上传到了docker hub 共有仓库上，我们可以在docker hub 的网站上来查找它们。使用docker search 命令。比如，当我们需要 ruby 和sinatra作为 web 应用程序的开发时，我们使用docker search 来搜索合适的image ，使用关键字sinatra</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@localhost</span> ~]<span class="meta"># docker search sinatra</span></span><br></pre></td></tr></table></figure><p>我们看到返回了很多包含sinatra的 images 。其中包括 image 名字、描述、星级（表示该 image 的受欢迎程度）、是否官方创建、是否自动创建。官方的 images 是stackbrew项目组创建和维护的，automated 资源允许你验证 image 的来源和内容。</p><p>到目前为止，我们看到了 2种 images 资源。比如ubuntu，被称为基础或则根镜像。这些基础镜像是docker公司创建、验证、支持、提供。他们往往使用一个单词作为他们的名字。还有一种类型，比如我们选择的 training/sinatra镜像。它是由docker的用户创建并维护的，你可以通过指定 image 名字的前缀来指定他们，比如 training 。</p><h5 id="4）下载-images"><a href="#4）下载-images" class="headerlink" title="4）下载 images"></a>4）下载 images</h5><p>现在我们指定了一个 image ， training/sinatra，我们可以使用docker pull 命令来下载它</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@localhost</span> ~]<span class="meta"># docker pull  docker.io/jdeathe/centos-ssh</span></span><br></pre></td></tr></table></figure><p>下载过程中，会输出获取镜像的每一层信息。<br>该命令实际上相当于#docker pull registry.hub.docker.com/ubuntu:12.04 命令，即从注册服<br>务器 registry.hub.docker.com 中的ubuntu仓库来下载标记为 12.04 的镜像。<br>有时候官方仓库注册服务器下载较慢，可以从其他仓库下载。从其它仓库下载时需要指定完整的仓库注册服务器地址。例如</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#docker</span> pull <span class="selector-tag">dl</span><span class="selector-class">.dockerpool</span><span class="selector-class">.com</span>:<span class="number">5000</span>/ubuntu:<span class="number">12.04</span></span><br></pre></td></tr></table></figure><h5 id="5-查看镜像文件docker-images"><a href="#5-查看镜像文件docker-images" class="headerlink" title="5) 查看镜像文件docker images"></a>5) 查看镜像文件docker images</h5><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="symbol">root@</span>localhost ~]# docker images </span><br><span class="line">REPOSITORY      TAG             IMAGE ID          CREATED          SIZE</span><br><span class="line">docker.io/centos   latest           <span class="number">50</span>dae1ee8677      <span class="number">3</span> months ago      <span class="number">196.7</span> MB</span><br><span class="line">docker.io/centos   centos6         cf2c3ece5e41       <span class="number">4</span> months ago      <span class="number">194.6</span> MB</span><br></pre></td></tr></table></figure><h5 id="6-查看完整信息"><a href="#6-查看完整信息" class="headerlink" title="6) 查看完整信息"></a>6) 查看完整信息</h5><p>当镜像下载成功后，你可以看到 12 位的 hash 值像 05188b417f30，这是下载完整的镜像的精简 ID，这些短的镜像 ID 是完整镜像 ID 的前 12 个字符–可以使用docker inspect 或者docker images –no-trunc来获得完整的镜像 ID</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@localhost</span> ~]<span class="meta"># docker inspect docker.io/centos</span></span><br></pre></td></tr></table></figure><p>或: –no-trunc来获得完整的镜像 ID</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@localhost</span> ~]<span class="meta"># docker images --no-trunc</span></span><br></pre></td></tr></table></figure><h5 id="7）创建我们自己的-images"><a href="#7）创建我们自己的-images" class="headerlink" title="7）创建我们自己的 images"></a>7）创建我们自己的 images</h5><p>别人的镜像虽然好，但不一定适合我们。我们可以对他们做一些改变，有 2 个方法：<br>1.第一个方法：使用docker commit 来扩展一个 image<br>1-1先使用 image 启动容器，更新后提交结果到新的 image 。</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@localhost</span> ~]<span class="meta"># docker run -it docker.io/centos /bin/bash</span></span><br><span class="line">[root<span class="symbol">@cfd9c030875b</span> /]<span class="meta">#</span></span><br></pre></td></tr></table></figure><p>注意：记住容器的 ID ，稍后我们还会用到</p><p>注意：记住容器的 ID ，稍后我们还会用到</p><p>1-2在容器中添加mariadb-server应用。</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@cfd9c030875b</span> /]<span class="meta"># yum -y install httpd</span></span><br><span class="line">[root<span class="symbol">@cfd9c030875b</span> /]<span class="meta"># exit</span></span><br></pre></td></tr></table></figure><p>exit<br>当结束后，我们使用 exit 来退出，现在我们的容器已经被我们改变了</p><p>exit<br>当结束后，我们使用 exit 来退出，现在我们的容器已经被我们改变了</p><p>1-3使用docker commint命令来提交相应的副本。</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@localhost</span> ~]<span class="meta"># docker commit -m <span class="string">"added httpd app"</span> -a <span class="string">"docker chen"</span> cfd9c030875b centos:httpd</span></span><br><span class="line">sha256:<span class="number">05653</span>ceb4e74275edfbc16edaa1976410e0fd6a35b910d4d04d83f8e92353669</span><br></pre></td></tr></table></figure><p>其中:<br>-m 来指定提交的说明信息，跟我们使用的版本控制工具一样；<br>-a 可以指定更新的用户信息；之后是用来创建镜像的容器的 ID；<br>最后指定目标镜像的仓库名和 tag 信息。创建成功后会返回这个镜像的 ID信息。</p><p>其中:<br>-m 来指定提交的说明信息，跟我们使用的版本控制工具一样；<br>-a 可以指定更新的用户信息；之后是用来创建镜像的容器的 ID；<br>最后指定目标镜像的仓库名和 tag 信息。创建成功后会返回这个镜像的 ID信息。</p><p>1-4)使用docker images 来查看新创建的镜像。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="symbol">root@</span>localhost ~]# docker images </span><br><span class="line">REPOSITORY       TAG             IMAGE ID         CREATED            SIZE</span><br><span class="line">centos           httpd            <span class="number">05653</span>ceb4e74     About a minute ago   <span class="number">295.3</span> MB</span><br><span class="line">docker.io/centos   latest            <span class="number">50</span>dae1ee8677     <span class="number">3</span> months ago        <span class="number">196.7</span> MB</span><br><span class="line">docker.io/centos  centos6          cf2c3ece5e41       <span class="number">4</span> months ago         <span class="number">194.6</span> MB</span><br></pre></td></tr></table></figure><p>之后，可以使用新的镜像来启动容器</p><p>之后，可以使用新的镜像来启动容器</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="symbol">root@</span>localhost ~]# docker run  -it centos:httpd /bin/bash</span><br><span class="line">[<span class="symbol">root@</span><span class="number">392e3f</span>a371b7 /]# uname -r</span><br><span class="line"><span class="number">3.10</span><span class="number">.0</span><span class="number">-327.</span>el7.x86_64</span><br></pre></td></tr></table></figure><p>2.第二个办法：从dockerfile来创建 image<br>使用docker commit 来扩展一个 image 比较简单，但它不容易在一个团队中分享它。我们使用docker build 来创建一个新的 image 。为此，我们需要创建一个dockerfile，包含一些如何创建我们的image 的指令。<br>2-1）创建一个目录和一个dockerfile</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@localhost</span> ~]<span class="meta"># mkdir -p /docker/httpd</span></span><br><span class="line">[root<span class="symbol">@localhost</span> ~]<span class="meta"># cd /docker/httpd</span></span><br><span class="line">[root<span class="symbol">@localhost</span> httpd]<span class="meta"># vim dockerfile</span></span><br><span class="line"><span class="meta">#This is a comment</span></span><br><span class="line">FROM docker.io/centos</span><br><span class="line">MAINTAINER chen &lt;chen<span class="symbol">@mail</span>.com&gt;</span><br><span class="line"><span class="built_in">RUN</span> yum -y -q install httpd</span><br></pre></td></tr></table></figure><p>Dockerfile基本的语法是<br>使用#来注释<br>FROM指令告诉 Docker 使用哪个镜像作为基础（docker使用哪个 image 源）<br>MAINTAINER是维护者的信息<br>RUN开头的指令会在创建中运行，比如安装一个软件包，在这里使用 yum来安装了一些软件</p><p>Dockerfile基本的语法是<br>使用#来注释<br>FROM指令告诉 Docker 使用哪个镜像作为基础（docker使用哪个 image 源）<br>MAINTAINER是维护者的信息<br>RUN开头的指令会在创建中运行，比如安装一个软件包，在这里使用 yum来安装了一些软件</p><p>2-2）编写完成Dockerfile后可以使用docker build 来生成镜像。</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@localhost</span> httpd]<span class="meta"># docker build -t=<span class="string">"centos:httpd-1"</span> .</span></span><br></pre></td></tr></table></figure><p>其中:<br>-t 标记来添加 tag，指定新的镜像的用户信息。<br>“.”是Dockerfile所在的路径（当前目录），也可以替换为一个具体的Dockerfile的路径。<br>可以看到 build 进程在执行操作。它要做的第一件事情就是上传这个Dockerfile内容，因为所有的操作都要依据Dockerfile来进行。然后，Dockfile中的指令被一条一条的执行。每一步都创建了一个新的容器，在容器中执行指令并提交修改（就跟之前介绍过的docker commit 一样）。当所有的指令都执行完毕之后，返回了最终的镜像 id。所有的中间步骤所产生的容器都被删除和清理了。<br>*注意一个镜像不能超过 127 层</p><p>2-3）查看生成的镜像</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="symbol">root@</span>localhost httpd]# docker images </span><br><span class="line">REPOSITORY        TAG              IMAGE ID          CREATED           SIZE</span><br><span class="line">centos            httpd<span class="number">-1</span>           a7e5b7ebdc89      <span class="number">8</span> minutes ago      <span class="number">338.5</span> MB</span><br><span class="line">centos            httpd            f8cadf4f19b7       <span class="number">13</span> minutes ago      <span class="number">338.5</span> MB</span><br><span class="line">docker.io/centos    latest            <span class="number">50</span>dae1ee8677      <span class="number">3</span> months ago       <span class="number">196.7</span> MB</span><br><span class="line">docker.io/centos   centos6           cf2c3ece5e41       <span class="number">4</span> months ago       <span class="number">194.6</span> MB</span><br></pre></td></tr></table></figure><p>2-4）从我们新建的 images 开启容器</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@localhost</span> httpd]<span class="meta"># docker run -it centos:httod-1 /bin/bash</span></span><br><span class="line">[root<span class="symbol">@dafdc2b34c56</span> /]<span class="meta">#</span></span><br></pre></td></tr></table></figure><p>2-5）还可以用docker tag 命令来修改镜像的标签。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="symbol">root@</span>localhost httpd]# docker tag centos:httpd<span class="number">-1</span> centos:httod<span class="number">-1</span></span><br><span class="line">[<span class="symbol">root@</span>localhost httpd]# docker images </span><br><span class="line">REPOSITORY        TAG             IMAGE ID         CREATED            SIZE</span><br><span class="line">centos            httod<span class="number">-1</span>           a7e5b7ebdc89      <span class="number">12</span> minutes ago     <span class="number">338.5</span> MB</span><br><span class="line">centos            httpd<span class="number">-1</span>           a7e5b7ebdc89      <span class="number">12</span> minutes ago     <span class="number">338.5</span> MB</span><br><span class="line">centos            httpd            f8cadf4f19b7       <span class="number">17</span> minutes ago      <span class="number">338.5</span> MB</span><br><span class="line">docker.io/centos   latest             <span class="number">50</span>dae1ee8677      <span class="number">3</span> months ago       <span class="number">196.7</span> MB</span><br><span class="line">docker.io/centos   centos6           cf2c3ece5e41       <span class="number">4</span> months ago       <span class="number">194.6</span> MB</span><br></pre></td></tr></table></figure><p>3.从本地文件系统导入<br>要从本地文件系统导入一个镜像，可以使用openvz（容器虚拟化的先锋技术）的模板来创建：openvz的模板下载地址为<a href="http://openvz.org/Download/template/precreated。" target="_blank" rel="noopener">http://openvz.org/Download/template/precreated。</a><br>先下载了一个centos-6-x86_64.tar.gz的镜像，之后使用以下命令导入：<br><img src="https://img2018.cnblogs.com/blog/1829796/201910/1829796-20191022110637478-664814624.png" alt></p><h5 id="8）上传镜像"><a href="#8）上传镜像" class="headerlink" title="8）上传镜像"></a>8）上传镜像</h5><p>用户可以通过docker push 命令，把自己创建的镜像上传到仓库中来共享。例如，用户在 Docker Hub 上，完成注册后，可以推送自己的镜像到仓库中。<br>这里有两种访问可以创建和注册一个 Docker Hub 账户：<br>1.通过网站，（<a href="https://hub.docker.com）" target="_blank" rel="noopener">https://hub.docker.com）</a><br>2.通过命令行<br>你可以通过使用命令行输入 docker login 命令来创建一个 Docker Hub 账号</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#docker</span> login</span><br></pre></td></tr></table></figure><p>邮箱确认<br>一旦你填写完毕表格，请查看你的电子邮件，通过点击欢迎信息中的链接来激活您的账户。</p><p>邮箱确认<br>一旦你填写完毕表格，请查看你的电子邮件，通过点击欢迎信息中的链接来激活您的账户。</p><p>基本思路：<br>首先注册docker的账户，然后使用docker login登录。<br>使用docker push可以将自己的镜像上传上去了<br><img src="https://img2018.cnblogs.com/blog/1829796/201910/1829796-20191022110650983-1343036792.png" alt></p><p>如果有其他的仓库,例如:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push docker<span class="selector-class">.sina</span><span class="selector-class">.com</span><span class="selector-class">.cn</span>:<span class="number">5000</span>/commit</span><br></pre></td></tr></table></figure><h5 id="9）用dcokerrmi移除本地-images"><a href="#9）用dcokerrmi移除本地-images" class="headerlink" title="9）用dcokerrmi移除本地 images"></a>9）用dcokerrmi移除本地 images</h5><p>dockerrmi镜像名或镜像id</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="symbol">root@</span>localhost httpd]# docker rmi centos:httod<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>注意：在删除 images 之前要先用dockerrm删掉依赖于这个 images 的容器</p><p>注意：在删除 images 之前要先用dockerrm删掉依赖于这个 images 的容器</p><h5 id="10）存出和载入镜像"><a href="#10）存出和载入镜像" class="headerlink" title="10）存出和载入镜像"></a>10）存出和载入镜像</h5><p>当需要把一台机器上的镜像迁移到另一台机器的时候，需要存出镜像与载入镜像。<br>10-1）存出镜像<br>如果要导出镜像到本地文件，可以使用docker save 命令。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="symbol">root@</span>localhost ~]# docker save -o centos<span class="number">-6</span>-httpd.tar centos:httpd<span class="number">-1</span></span><br><span class="line">[<span class="symbol">root@</span>localhost ~]# ls centos<span class="number">-6</span>-httpd.tar </span><br><span class="line">centos<span class="number">-6</span>-httpd.tar</span><br></pre></td></tr></table></figure><p>10-2）载入镜像<br>可以使用docker load 从导出的本地文件中再导入到本地镜像库，例如</p><p>这将导入镜像以及其相关的元数据信息（包括标签等）</p><h3 id="五、Docker-容器"><a href="#五、Docker-容器" class="headerlink" title="五、Docker 容器"></a>五、Docker 容器</h3><p>容器是 Docker 又一核心概念,简单的说，容器是独立运行的一个或一组应用，以及它们的运行态环境。对应的，虚拟机可以理解为模拟运行的一整套操作系统（提供了运行态环境和其他系统环境）和跑在上面的应用。<br>本章将具体介绍如何来管理一个容器，包括创建、启动和停止等。<br>启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（stopped）的容器重新启动。</p><h5 id="1、新建并启动"><a href="#1、新建并启动" class="headerlink" title="1、新建并启动"></a>1、新建并启动</h5><p>所需要的命令主要为docker run<br>下面的命令则启动一个 bash 终端，允许用户进行交互。</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@localhost</span> ~]<span class="meta"># docker run -it docker.io/centos:centos6</span></span><br><span class="line">[root<span class="symbol">@c88f4fefd1ff</span> /]<span class="meta">#</span></span><br></pre></td></tr></table></figure><p>-t 选项让 Docker 分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上，<br>-i则让容器的标准输入保持打开(即交互式)，可以使用—name给容器起个形象的名称。<br>在交互模式下，用户可以通过所创建的终端来输入命令，例如</p><p>-t 选项让 Docker 分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上，<br>-i则让容器的标准输入保持打开(即交互式)，可以使用—name给容器起个形象的名称。<br>在交互模式下，用户可以通过所创建的终端来输入命令，例如</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="symbol">root@</span>c88f4fefd1ff /]# pwd</span><br><span class="line">/</span><br><span class="line">[<span class="symbol">root@</span>c88f4fefd1ff /]# ps -ef</span><br><span class="line">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class="line">root         <span class="number">1</span>     <span class="number">0</span>  <span class="number">0</span> <span class="number">08</span>:<span class="number">18</span> ?        <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> /bin/bash</span><br><span class="line">root        <span class="number">12</span>     <span class="number">1</span>  <span class="number">0</span> <span class="number">08</span>:<span class="number">20</span> ?        <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> ps -ef</span><br></pre></td></tr></table></figure><p>容器的核心为所执行的应用程序，所需要的资源都是应用程序运行所必需的。除此之外，并没有其它的资源。可以在伪终端中利用ps或 top 来查看进程信息。</p><p>容器的核心为所执行的应用程序，所需要的资源都是应用程序运行所必需的。除此之外，并没有其它的资源。可以在伪终端中利用ps或 top 来查看进程信息。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="symbol">root@</span>c88f4fefd1ff /]# ps</span><br><span class="line">  PID TTY          TIME CMD</span><br><span class="line">    <span class="number">1</span> ?        <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> bash</span><br><span class="line">   <span class="number">13</span> ?        <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> ps</span><br></pre></td></tr></table></figure><p>可见，容器中仅运行了指定的 bash 应用。这种特点使得 Docker 对资源的利用率极高，是货真价实的轻量级虚拟化。</p><p>可见，容器中仅运行了指定的 bash 应用。这种特点使得 Docker 对资源的利用率极高，是货真价实的轻量级虚拟化。</p><p>如果这个时候我们正常退出，logout 或者 exit 或者Ctrl+d或者Ctrl+c，dockerps–a 查看容器处于 Exit 状态如果需要正常退出可以使用 CTRL –p + CTRL -q —-就像先按 CTRL -p 然后 CTRL –q 退出伪终端<br>下面的命令输出一个“Hello World”，之后终止容器。</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@localhost</span> ~]<span class="meta"># docker run docker.io/centos:latest /bin/echo <span class="string">'hello world'</span></span></span><br><span class="line">htool world</span><br></pre></td></tr></table></figure><p>这跟在本地直接执行 /bin/echo ‘hello world’ 几乎感觉不出任何区别。</p><p>这跟在本地直接执行 /bin/echo ‘hello world’ 几乎感觉不出任何区别。</p><p>当利用docker run 来创建容器时，Docker 在后台运行的标准操作包括：<br>1.检查本地是否存在指定的镜像，不存在就从公有仓库下载<br>2.利用镜像创建并启动一个容器<br>3.分配一个文件系统，并在只读的镜像层外面挂载一层可读写层<br>4.从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去<br>5.从地址池配置一个ip地址给容器<br>6.执行用户指定的应用程序<br>7.执行完毕后容器被终止</p><h5 id="2、查看容器dockerps"><a href="#2、查看容器dockerps" class="headerlink" title="2、查看容器dockerps"></a>2、查看容器dockerps</h5><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker ps -a</span></span><br><span class="line">![](https:<span class="regexp">//img</span>2018.cnblogs.com<span class="regexp">/blog/</span><span class="number">1829796</span><span class="regexp">/201910/</span><span class="number">1829796</span>-<span class="number">20191022110725324</span>-<span class="number">901966730</span>.png)</span><br></pre></td></tr></table></figure><p>附：养成查看帮助的习惯</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker ps -h</span><br><span class="line"></span><br><span class="line"><span class="keyword">Usage</span>:docker ps [<span class="keyword">OPTIONS</span>]</span><br><span class="line"></span><br><span class="line">List containers</span><br><span class="line"></span><br><span class="line">  -a, <span class="comment">--all          Show all containers (default shows just running)</span></span><br><span class="line">  -f, <span class="comment">--filter=[]    Filter output based on conditions provided</span></span><br><span class="line">  <span class="comment">--format           Pretty-print containers using a Go template</span></span><br><span class="line">  <span class="comment">--help             Print usage</span></span><br><span class="line">  -l, <span class="comment">--latest       Show the latest created container (includes all states)</span></span><br><span class="line">  -n=<span class="number">-1</span>              <span class="keyword">Show</span> n last created containers (includes <span class="keyword">all</span> states)</span><br><span class="line">  <span class="comment">--no-trunc         Don't truncate output</span></span><br><span class="line">  -q, <span class="comment">--quiet        Only display numeric IDs</span></span><br><span class="line">  -s, <span class="comment">--size         Display total file sizes</span></span><br></pre></td></tr></table></figure><h5 id="3、可以利用docker-start-命令，直接将一个已经终止的容器启动运行。"><a href="#3、可以利用docker-start-命令，直接将一个已经终止的容器启动运行。" class="headerlink" title="3、可以利用docker start  命令，直接将一个已经终止的容器启动运行。"></a>3、可以利用docker start 命令，直接将一个已经终止的容器启动运行。</h5><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start <span class="string">[contraiID]</span></span><br></pre></td></tr></table></figure><p>容器处于 Exited 状态，可以直接启动<br><img src="https://img2018.cnblogs.com/blog/1829796/201910/1829796-20191022110738858-1203258864.png" alt></p><h5 id="4、终止容器"><a href="#4、终止容器" class="headerlink" title="4、终止容器"></a>4、终止容器</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">stop</span> [容器 <span class="keyword">ID</span>]</span><br><span class="line"></span><br><span class="line">docker <span class="keyword">kill</span> [容器 <span class="keyword">ID</span>]</span><br></pre></td></tr></table></figure><p>可以使用docker stop 来终止一个运行中的容器。此外，当Docker容器中指定的应用终结时，容器也自动终止。例如对于前面所讲中启动了一个终端的容器，用户通过 exit 命令或Ctrl+d来退出终端时，所创建的容器立刻终止<br>终止状态的容器可以用docker ps -a 命令看到。例如<br><img src="https://img2018.cnblogs.com/blog/1829796/201910/1829796-20191022110749689-485534913.png" alt></p><p>状态由 Up -&gt; Exit<br>处于终止状态的容器，可以通过docker start 命令来重新启动。</p><h5 id="5、重启容器"><a href="#5、重启容器" class="headerlink" title="5、重启容器"></a>5、重启容器</h5><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">restart</span>  命令会将一个运行态的容器终止，然后再重新启动它。</span><br><span class="line"></span><br><span class="line">docker <span class="built_in">restart</span> [容器 ID]</span><br></pre></td></tr></table></figure><p><img src="https://img2018.cnblogs.com/blog/1829796/201910/1829796-20191022110800024-2009126343.png" alt></p><h5 id="6、守护状态运行"><a href="#6、守护状态运行" class="headerlink" title="6、守护状态运行"></a>6、守护状态运行</h5><p>更多的时候，需要让 Docker 容器在后台以守护状态（Daemonized）形式运行。此时，可以通过添加 -d 参数来实现。例如下面的命令会在后台运行容器。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker run -d docker.io/centos /bin/bash -c "while true ; do echo hello world ; sleep 1 ; done"</span></span><br><span class="line">![](https:<span class="regexp">//img</span>2018.cnblogs.com<span class="regexp">/blog/</span><span class="number">1829796</span><span class="regexp">/201910/</span><span class="number">1829796</span>-<span class="number">20191022110819599</span>-<span class="number">2000970667</span>.png)</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@localhost</span> ~]<span class="meta"># docker run -dt docker.io/centos /bin/bash</span></span><br><span class="line"><span class="number">56</span>c3adf740ba870818af856ab76fe43fa7f44d7a0f2fc26fc4b4558788585e3a</span><br><span class="line">[root<span class="symbol">@localhost</span> ~]<span class="meta">#</span></span><br></pre></td></tr></table></figure><p>容器启动后会返回一个唯一的 id，也可以通过docker ps命令来查看容器信息。<br>1．docker run -d 运行提个新的容器，我们通过-d 命令让他作为一个后台运行<br>2．centos:centos6 是一个我们想要在内部运行命令的镜像<br>3．/bin/sh -c 是我们想要在容器内部运行的命令<br>4．while true; do echo hello weibo; sleep 1; done 这是一个简单的脚本，我们仅仅只是每秒打印一次 hello word 一直到我们结束它</p><p>容器启动后会返回一个唯一的 id，也可以通过docker ps命令来查看容器信息。<br>1．docker run -d 运行提个新的容器，我们通过-d 命令让他作为一个后台运行<br>2．centos:centos6 是一个我们想要在内部运行命令的镜像<br>3．/bin/sh -c 是我们想要在容器内部运行的命令<br>4．while true; do echo hello weibo; sleep 1; done 这是一个简单的脚本，我们仅仅只是每秒打印一次 hello word 一直到我们结束它</p><h5 id="7、用docker-inspect查看容器的信息"><a href="#7、用docker-inspect查看容器的信息" class="headerlink" title="7、用docker  inspect查看容器的信息"></a>7、用docker inspect查看容器的信息</h5><p>命令格式：docker inspect 容器ID或容器名</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">root@localhost ~</span>]<span class="meta"># docker inspect 56c3adf740ba</span></span><br><span class="line"> [<span class="meta"></span></span><br><span class="line"><span class="meta">    &#123;</span></span><br><span class="line"><span class="meta">        <span class="meta-string">"Id"</span>: <span class="meta-string">"56c3adf740ba870818af856ab76fe43fa7f44d7a0f2fc26fc4b4558788585e3a"</span>,</span></span><br><span class="line"><span class="meta">        <span class="meta-string">"Created"</span>: <span class="meta-string">"2016-11-15T10:50:58.658378757Z"</span>,</span></span><br><span class="line"><span class="meta">        <span class="meta-string">"Path"</span>: <span class="meta-string">"/bin/bash"</span>,</span></span><br><span class="line"><span class="meta">        <span class="meta-string">"Args"</span>: [</span>],</span><br><span class="line">        <span class="string">"State"</span>: &#123;</span><br><span class="line">            <span class="string">"Status"</span>: <span class="string">"running"</span>,</span><br><span class="line">            <span class="string">"Running"</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="string">"Paused"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"Restarting"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"OOMKilled"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"Dead"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"Pid"</span>: <span class="number">42710</span>,</span><br><span class="line">            <span class="string">"ExitCode"</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="string">"Error"</span>: <span class="string">""</span>,</span><br><span class="line">            <span class="string">"StartedAt"</span>: <span class="string">"2016-11-15T10:50:59.092432423Z"</span>,</span><br><span class="line">            <span class="string">"FinishedAt"</span>: <span class="string">"0001-01-01T00:00:00Z"</span></span><br><span class="line">        &#125;,</span><br></pre></td></tr></table></figure><p>用docker inspect查看容器的ip地址</p><p>用docker inspect查看容器的ip地址</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="symbol">root@</span>localhost ~]# docker inspect -f <span class="string">'&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;'</span> <span class="number">56</span>c3adf740ba</span><br><span class="line"><span class="number">172.17</span><span class="number">.0</span><span class="number">.4</span></span><br></pre></td></tr></table></figure><p>用docker inspect查看容器执行的程序</p><p>用docker inspect查看容器执行的程序</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@localhost</span> ~]<span class="meta"># docker inspect  -f <span class="string">'&#123;&#123;.Config.Cmd&#125;&#125;'</span> 56c3adf740ba </span></span><br><span class="line">&#123;[/bin/bash]&#125;</span><br></pre></td></tr></table></figure><h5 id="8、进入容器"><a href="#8、进入容器" class="headerlink" title="8、进入容器"></a>8、进入容器</h5><p>在使用 -d 参数时，容器启动后会进入后台。某些时候需要进入容器进行操作，有很多种方法，包括使用docker attach 命令或nsenter命令。<br>使用docker attach进入容器<br>docker attach 是Docker自带的命令。下面示例如何使用该命令。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="symbol">root@</span>localhost ~]# docker attach <span class="number">56</span>c3adf740ba </span><br><span class="line">[<span class="symbol">root@</span><span class="number">56</span>c3adf740ba /]#</span><br></pre></td></tr></table></figure><p>或：</p><p>或：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="symbol">root@</span>localhost ~]# docker attach --sig-proxy=<span class="literal">false</span> <span class="number">56</span>c3adf740ba </span><br><span class="line">[<span class="symbol">root@</span><span class="number">56</span>c3adf740ba /]#</span><br></pre></td></tr></table></figure><p>1．docker attach 允许我们进入后台进程.<br>2．–sig-proxy=false 不使用容器转发信号，允许我们使用 ctrl -c 来退出，执行dockerps查看在后台运行<br>但是使用 attach命令有时候并不方便。当多个窗口同时 attach 到同一个容器的时候，所有窗口都会同步显示。当某个窗口因命令阻塞时,其他窗口也无法执行操作了。</p><p>1．docker attach 允许我们进入后台进程.<br>2．–sig-proxy=false 不使用容器转发信号，允许我们使用 ctrl -c 来退出，执行dockerps查看在后台运行<br>但是使用 attach命令有时候并不方便。当多个窗口同时 attach 到同一个容器的时候，所有窗口都会同步显示。当某个窗口因命令阻塞时,其他窗口也无法执行操作了。</p><p>也可以执行docker exec进入运行的容器</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker  exec  -<span class="keyword">it</span>  容器ID/名称 /bin/bash</span><br></pre></td></tr></table></figure><p>以上命令返回一个命令界面，exec代表直接在容器中运行命令</p><p>以上命令返回一个命令界面，exec代表直接在容器中运行命令</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="symbol">root@</span>localhost ~]# docker exec -it <span class="number">56</span>c3adf740ba</span><br><span class="line">[<span class="symbol">root@</span><span class="number">56</span>c3adf740ba /]#</span><br></pre></td></tr></table></figure><h5 id="9、使用nsenter进入容器"><a href="#9、使用nsenter进入容器" class="headerlink" title="9、使用nsenter进入容器"></a>9、使用nsenter进入容器</h5><p>安装<br>nsenter工具在util-linux包2.23版本后包含。如果系统中util-linux包没有该命令，可以按照下面的方法从源码安装</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#wgethttps</span>:<span class="comment">//www.kernel.org/pub/linux/utils/util-linux/v2.24/util-linux-2.24.tar.gz</span></span><br><span class="line"><span class="selector-id">#tar</span> util-linux-<span class="number">2.24</span><span class="selector-class">.tar</span><span class="selector-class">.gz</span></span><br><span class="line"><span class="selector-id">#cd</span> util-linux-<span class="number">2.24</span></span><br><span class="line"></span><br><span class="line">./configure --without-ncurses&amp;&amp; make nsenter</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#cpnsenter</span> /usr/local/bin</span><br></pre></td></tr></table></figure><p>nsenter可以访问另一个进程的名字空间。nsenter要正常工作需要有 root 权限<br>庆幸的是centos7使用的是util-linux-2.23，所以就直接使用系统提供的util-linux包了。</p><p>nsenter可以访问另一个进程的名字空间。nsenter要正常工作需要有 root 权限<br>庆幸的是centos7使用的是util-linux-2.23，所以就直接使用系统提供的util-linux包了。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># <span class="selector-tag">rpm</span> <span class="selector-tag">-q</span> <span class="selector-tag">util-linux</span></span><br><span class="line"><span class="selector-tag">util-linux-2</span><span class="selector-class">.23</span><span class="selector-class">.2-26</span><span class="selector-class">.el7</span><span class="selector-class">.x86_64</span></span><br></pre></td></tr></table></figure><p>为了连接到容器，你还需要找到容器的第一个进程的PID，可以通过下面的命令获取。</p><p>为了连接到容器，你还需要找到容器的第一个进程的PID，可以通过下面的命令获取。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PID=<span class="constructor">$(<span class="params">docker</span> <span class="params">inspect</span> --<span class="params">format</span> <span class="string">"&#123;&#123; .State.Pid &#125;&#125;"</span> &lt;<span class="params">container</span>&gt;)</span></span><br></pre></td></tr></table></figure><p>通过这个PID，就可以连接到这个容器：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">nsenter</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">target</span> <span class="comment">$PID</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">mount</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">uts</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">ipc</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">net</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">pid</span></span><br></pre></td></tr></table></figure><p>下面给出一个完整的例子。<br><img src="https://img2018.cnblogs.com/blog/1829796/201910/1829796-20191022110908741-1979087383.png" alt></p><p>下面给出一个完整的例子。</p><p>通过这个PID，就可以连接到这个容器：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">nsenter</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">target</span> <span class="comment">$PID</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">mount</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">uts</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">ipc</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">net</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">pid</span></span><br></pre></td></tr></table></figure><p>下面给出一个完整的例子。</p><p>下面给出一个完整的例子。</p><p>附：更简单的，建议大家下载 .bashrc_docker，并将内容放到 .bashrc中。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#wget</span>  ~ https:<span class="comment">//github.com/yeasy/docker_practice/raw/master/_local/.bashrc_docker</span></span><br><span class="line"><span class="selector-id">#echo</span> <span class="string">"[ -f ~/.bashrc_docker ] &amp;&amp;. ~/.bashrc_docker"</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="selector-id">#source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><p>这个文件中定义了很多方便使用 Docker 的命令，例如docker-pid可以获取某个容器的PID；而docker-enter 可以进入容器或直接在容器内执行命令。</p><p>这个文件中定义了很多方便使用 Docker 的命令，例如docker-pid可以获取某个容器的PID；而docker-enter 可以进入容器或直接在容器内执行命令。</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo $(docker-pid&lt;<span class="keyword">container</span>&gt;)</span><br><span class="line">docker-enter &lt;<span class="keyword">container</span>&gt; <span class="keyword">ls</span></span><br></pre></td></tr></table></figure><p>容器导入和导出<br>导出容器：<br>docker export [容器 id] &gt; [导出文件]<br>如果要导出本地某个容器，可以使用docker export 命令。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># <span class="selector-tag">docker</span> <span class="selector-tag">export</span> 56<span class="selector-tag">c3adf740ba</span> &gt; <span class="selector-tag">centos_web</span><span class="selector-class">.tar</span></span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span># <span class="selector-tag">ls</span></span><br><span class="line"><span class="selector-tag">anaconda-ks</span><span class="selector-class">.cfg</span></span><br><span class="line"><span class="selector-tag">centos6</span><span class="selector-class">.tar</span></span><br><span class="line"><span class="selector-tag">centos7</span><span class="selector-class">.tar</span></span><br><span class="line"><span class="selector-tag">centos_web</span><span class="selector-class">.tar</span></span><br></pre></td></tr></table></figure><p>这样将导出容器快照到本地文件</p><p>这样将导出容器快照到本地文件</p><p>导入容器：<br>可以使用docker import 从容器快照文件中再导入为镜像</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">cat</span> centos6.tar | docker <span class="keyword">import</span> – centos6:test</span><br></pre></td></tr></table></figure><p>docker images</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="symbol">root@</span>localhost ~]# cat centos_web.tar | docker <span class="keyword">import</span> - centos:web</span><br><span class="line">sha256:<span class="number">4429751684</span>b5529cb70ddd080ada1462b3dfe2f48651c02a42c8ebd794a11c7d</span><br><span class="line">[<span class="symbol">root@</span>localhost ~]# docker images </span><br><span class="line">REPOSITORY       TAG               IMAGE ID          CREATED           SIZE</span><br><span class="line">centos            web              <span class="number">4429751684</span>b5      <span class="number">4</span> seconds ago     <span class="number">196.7</span> MB</span><br></pre></td></tr></table></figure><p>此外，也可以通过指定 URL 或者某个目录来导入，例如<br>docker import <a href="http://example.com/exampleimage.tgzexample/imagerepo" target="_blank" rel="noopener">http://example.com/exampleimage.tgzexample/imagerepo</a><br>*注：用户既可以使用docker load 来导入镜像存储文件到本地镜像库，也可以使用docker import 来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</p><p>此外，也可以通过指定 URL 或者某个目录来导入，例如<br>docker import <a href="http://example.com/exampleimage.tgzexample/imagerepo" target="_blank" rel="noopener">http://example.com/exampleimage.tgzexample/imagerepo</a><br>*注：用户既可以使用docker load 来导入镜像存储文件到本地镜像库，也可以使用docker import 来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</p><p>删除容器<br>可以使用dockerrm来删除一个处于终止状态的容器。<br>如果要删除一个运行中的容器，可以添加 -f 参数。Docker 会发送SIGKILL信号给容器。</p><p>docker rm [容器 id/容器 name]</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="symbol">root@</span>localhost ~]# docker rm -f <span class="number">3</span>db07fa904c9</span><br><span class="line"><span class="number">3</span>db07fa904c9</span><br></pre></td></tr></table></figure><p>批量删除多个容器<br>docker rm $(docker ps –a –q)</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">[<span class="identifier">root</span>@<span class="identifier">localhost</span> ~]</span># docker rm -f <span class="constructor">$(<span class="params">docker</span> <span class="params">ps</span> -<span class="params">a</span>)</span></span><br><span class="line"><span class="number">56</span>c3adf740ba</span><br><span class="line">e674da52f432</span><br><span class="line">acb16411ba25</span><br><span class="line">eea3221f0dac</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Oct 29 2019 15:51:53 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;一、Docker简介&quot;&gt;&lt;a href=&quot;#一、Docker简介&quot; class=&quot;headerlink&quot; title=&quot;一、Docke
      
    
    </summary>
    
    
      <category term="docker" scheme="http://chenzhonzhou.github.io/categories/docker/"/>
    
    
      <category term="docker" scheme="http://chenzhonzhou.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>yum 安装docker</title>
    <link href="http://chenzhonzhou.github.io/2018/09/01/yum-an-zhuang-docker/"/>
    <id>http://chenzhonzhou.github.io/2018/09/01/yum-an-zhuang-docker/</id>
    <published>2018-09-01T03:05:15.000Z</published>
    <updated>2019-10-25T02:25:42.303Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Oct 29 2019 15:51:53 GMT+0800 (GMT+08:00) --><h4 id="1-安装docker-1-13-0"><a href="#1-安装docker-1-13-0" class="headerlink" title="1. 安装docker 1.13.0"></a>1. 安装docker 1.13.0</h4><h5 id="1-1-安装yum源"><a href="#1-1-安装yum源" class="headerlink" title="1.1 安装yum源"></a>1.1 安装yum源</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -f sSL https://get.docker.com/ | sh -s -- --mirror AzureChinaCloud</span><br></pre></td></tr></table></figure><p>或：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://docs.docker.com/v1.13/engine/installation/linux/repo_files/centos/docker.repo</span><br></pre></td></tr></table></figure><h5 id="1-2-安装最新版的docker"><a href="#1-2-安装最新版的docker" class="headerlink" title="1.2 安装最新版的docker"></a>1.2 安装最新版的docker</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum makecache fast</span><br><span class="line">yum -y install docker-engine</span><br></pre></td></tr></table></figure><p>或者安装其他版本docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum list docker-engine.x86_64  --showduplicates |sort -r</span><br><span class="line">yum -y install docker-engine-&lt;VERSION_STRING&gt;</span><br></pre></td></tr></table></figure><h5 id="1-3-把当前用户加入docker用户组"><a href="#1-3-把当前用户加入docker用户组" class="headerlink" title="1.3 把当前用户加入docker用户组"></a>1.3 把当前用户加入docker用户组</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo groupadd docker</span><br><span class="line">sudo usermod -aG docker <span class="variable">$USER</span></span><br></pre></td></tr></table></figure><h4 id="2-yum-安装docker-1-26"><a href="#2-yum-安装docker-1-26" class="headerlink" title="2. yum 安装docker 1.26"></a>2. yum 安装docker 1.26</h4><h5 id="2-1-配置docker-yum-源"><a href="#2-1-配置docker-yum-源" class="headerlink" title="2.1 配置docker yum 源"></a>2.1 配置docker yum 源</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /etc/yum.repos.d/docker.repo &lt;&lt;-EOF</span><br><span class="line">[dockerrepo]</span><br><span class="line">name=Docker Repository</span><br><span class="line">baseurl=https://yum.dockerproject.org/repo/experimental/centos/7/</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=https://yum.dockerproject.org/gpg</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h5 id="2-2-安装组件"><a href="#2-2-安装组件" class="headerlink" title="2.2 安装组件"></a>2.2 安装组件</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum -y install docker-engine</span><br><span class="line">curl -fsSL https://get.docker.com/ | sh 或者 wget -qO- https://get.docker.com/ |sh</span><br></pre></td></tr></table></figure><h5 id="2-3-启动"><a href="#2-3-启动" class="headerlink" title="2.3 启动"></a>2.3 启动</h5><p>systemctl start docker 启动 docker<br>systemctl enable docker 设置开机启动</p><h5 id="2-4-docker-compose环境安装"><a href="#2-4-docker-compose环境安装" class="headerlink" title="2.4 docker-compose环境安装"></a>2.4 docker-compose环境安装</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum install python-pip -y</span><br><span class="line">pip install docker-compose</span><br><span class="line"></span><br><span class="line">docker-compose -version</span><br></pre></td></tr></table></figure><p>下载二进制可执行文件的方式安装Docker-compose(推荐)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -L https://github.com/docker/compose/releases/download/1.14.0/docker-compose-`uname -s`-`uname -m` &gt; /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line">chmod +x /usr/<span class="built_in">local</span>/bin/docker-compose</span><br></pre></td></tr></table></figure><h5 id="2-5-docker加速（链接为阿里云docker镜像仓库，登录即可领取属于你的加速地址）"><a href="#2-5-docker加速（链接为阿里云docker镜像仓库，登录即可领取属于你的加速地址）" class="headerlink" title="2.5 docker加速（链接为阿里云docker镜像仓库，登录即可领取属于你的加速地址）"></a>2.5 docker加速（链接为阿里云docker镜像仓库，登录即可领取属于你的加速地址）</h5><p><a href="https://account.aliyun.com/login/login.htm?oauth_callback=https%3A%2F%2Fcr.console.aliyun.com%2F&amp;lang=zh#/accelerator" target="_blank" rel="noopener">https://account.aliyun.com/login/login.htm?oauth_callback=https%3A%2F%2Fcr.console.aliyun.com%2F&amp;lang=zh#/accelerator</a></p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim <span class="meta-keyword">/etc/</span>docker/daemon.json</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"registry-mirrors"</span>: [<span class="string">"https://av7k0o0o.mirror.aliyuncs.com"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-6-harbor-删除镜像及资源回收"><a href="#2-6-harbor-删除镜像及资源回收" class="headerlink" title="2.6 harbor 删除镜像及资源回收"></a>2.6 harbor 删除镜像及资源回收</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose stop</span><br><span class="line">$ docker run -it --name gc --rm --volumes-from deploy_registry_1 registry:2.5.0 garbage-collect --dry-run /etc/registry/config.yml</span><br><span class="line">$ docker-compose start</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Oct 29 2019 15:51:53 GMT+0800 (GMT+08:00) --&gt;&lt;h4 id=&quot;1-安装docker-1-13-0&quot;&gt;&lt;a href=&quot;#1-安装docker-1-13-0&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
      <category term="docker" scheme="http://chenzhonzhou.github.io/categories/docker/"/>
    
    
      <category term="docker" scheme="http://chenzhonzhou.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>mm_wiki部署企业文档平台</title>
    <link href="http://chenzhonzhou.github.io/2018/08/10/mm-wiki-bu-shu-qi-ye-wen-dang-ping-tai/"/>
    <id>http://chenzhonzhou.github.io/2018/08/10/mm-wiki-bu-shu-qi-ye-wen-dang-ping-tai/</id>
    <published>2018-08-10T07:13:45.000Z</published>
    <updated>2019-10-22T12:21:59.499Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Oct 29 2019 15:51:53 GMT+0800 (GMT+08:00) --><p><strong>github地址：</strong></p><p><a href="https://github.com/phachon/mm-wiki" target="_blank" rel="noopener">https://github.com/phachon/mm-wiki</a></p><p>github项目上安装非常简单，不做介绍</p><p>修改分享文档最下方显示公司版权，修改 ./views/page/display.html 文件。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Oct 29 2019 15:51:53 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;strong&gt;github地址：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/phachon/mm-
      
    
    </summary>
    
    
      <category term="wiki" scheme="http://chenzhonzhou.github.io/categories/wiki/"/>
    
    
      <category term="wiki" scheme="http://chenzhonzhou.github.io/tags/wiki/"/>
    
  </entry>
  
  <entry>
    <title>markdown语法之文字对齐</title>
    <link href="http://chenzhonzhou.github.io/2018/07/15/markdown-yu-fa-zhi-wen-zi-dui-qi/"/>
    <id>http://chenzhonzhou.github.io/2018/07/15/markdown-yu-fa-zhi-wen-zi-dui-qi/</id>
    <published>2018-07-15T07:13:45.000Z</published>
    <updated>2019-10-25T02:28:07.055Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Oct 29 2019 15:51:53 GMT+0800 (GMT+08:00) --><p>在markdown中文字对齐方式有左对齐、居中对齐、右对齐：</p><p>右对齐效果如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">align</span>=<span class="string">"right"</span>&gt;</span>右对齐<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p align="right">右对齐</p>居中对齐效果如下：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">center</span>&gt;</span>居中<span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br></pre></td></tr></table></figure><center>居中</center>左对齐效果如下：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">align</span>=<span class="string">"left"</span>&gt;</span>左对齐<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>左对齐</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Oct 29 2019 15:51:53 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;在markdown中文字对齐方式有左对齐、居中对齐、右对齐：&lt;/p&gt;&lt;p&gt;右对齐效果如下：&lt;/p&gt;&lt;figure class=&quot;highligh
      
    
    </summary>
    
    
      <category term="markdown" scheme="http://chenzhonzhou.github.io/categories/markdown/"/>
    
    
      <category term="markdown" scheme="http://chenzhonzhou.github.io/tags/markdown/"/>
    
  </entry>
  
</feed>
