<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>凡间的精灵</title>
  
  <subtitle>凡尘落素一精灵</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://chenzhonzhou.github.io/"/>
  <updated>2023-12-03T03:33:59.311Z</updated>
  <id>http://chenzhonzhou.github.io/</id>
  
  <author>
    <name>Zhongzhou Chen</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Go 序列化和反序列化</title>
    <link href="http://chenzhonzhou.github.io/2023/07/20/go-xu-lie-hua-he-fan-xu-lie-hua/"/>
    <id>http://chenzhonzhou.github.io/2023/07/20/go-xu-lie-hua-he-fan-xu-lie-hua/</id>
    <published>2023-07-20T03:16:28.000Z</published>
    <updated>2023-12-03T03:33:59.311Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、json-序列化和反序列化"><a href="#一、json-序列化和反序列化" class="headerlink" title="一、json 序列化和反序列化"></a>一、json 序列化和反序列化</h2><p>JSON是一种轻量级的数据交换格式，常用在前后端数据交换，Go语言的<a href="https://golang.org/pkg/encoding/json/" target="_blank" rel="noopener"> encoding/json</a> 提供了对json的支持，主要是编码和解码两个函数。</p><h2 id="二、序列化Marshal函数"><a href="#二、序列化Marshal函数" class="headerlink" title="二、序列化Marshal函数"></a>二、序列化Marshal函数</h2><p>GO提供了<a href="https://golang.org/pkg/encoding/json/#Marshal" target="_blank" rel="noopener"> Marshal </a>方法：Go <a href="https://so.csdn.net/so/search?q=Struct&amp;spm=1001.2101.3001.7020" target="_blank" rel="noopener">Struct</a>转换为JSON对象，函数签名：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Marshal</span><span class="params">(v <span class="keyword">interface</span>{})</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span></span><br></pre></td></tr></tbody></table></figure><p>Marshal函数返回v的json编码</p><p>注意：</p><p>布尔类型编码为json布尔类型。<br>浮点数、整数和Number类型的值编码为json数字类型。<br>字符串编码为json字符串。<br>数组和切片类型的值编码为json数组，但[]byte编码为base64编码字符串，nil切片编码为null<br>结构体的值编码为json对象。每一个导出字段变成该对象的一个成员，除非以下两种情况：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">字段的标签是<span class="string">"-"</span></span><br><span class="line">字段是空值，而其标签指定了omitempty选项</span><br></pre></td></tr></tbody></table></figure><p>空值是false、0、””、nil指针、nil接口、长度为0的数组、切片、映射。对象默认键字符串是结构体的字段名，但可以在结构体字段的标签里指定。结构体标签值里的”json”键为键名，后跟可选的逗号和选项，举例如下：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Age <span class="keyword">int</span> <span class="string">`json:"-"`</span> <span class="comment">// 字段被本包忽略</span></span><br><span class="line">Name <span class="keyword">string</span> <span class="string">`json:"myName"`</span> <span class="comment">// 字段在json里的键为"myName"</span></span><br><span class="line">Sex <span class="keyword">int</span> <span class="string">`json:"mySex,omitempty"`</span> <span class="comment">// 字段在json里的键为"myName"且如果字段为空值将在对象中省略掉</span></span><br><span class="line">Hobby <span class="keyword">int</span> <span class="string">`json:",omitempty"`</span><span class="comment">// 字段在json里的键为"Hobby"（默认值），但如果字段为空值会跳过；注意前导的逗号</span></span><br></pre></td></tr></tbody></table></figure><p>“string”选项标记一个字段在编码json时应编码为字符串。它只适用于字符串、浮点数、整数类型的字段</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Int64String <span class="keyword">int64</span> <span class="string">`json:",string"`</span></span><br></pre></td></tr></tbody></table></figure><p>如果键名是只含有unicode字符、数字、美元符号、百分号、连字符、下划线和斜杠的非空字符串，将使用它代替字段名。</p><p>匿名的结构体字段一般序列化为他们内部的导出字段就好像位于外层结构体中一样。如果一个匿名结构体字段的标签给其提供了键名，则会使用键名代替字段名，而不视为匿名。</p><p>Go结构体字段的可视性规则用于供json决定那个字段应该序列化或反序列化时是经过修正了的。如果同一层次有多个（匿名）字段且该层次是最小嵌套的（嵌套层次则使用默认go规则），会应用如下额外规则：</p><ul><li>json标签为”-“的匿名字段强行忽略，不作考虑；</li><li>json标签提供了键名的匿名字段，视为非匿名字段；</li><li>其余字段中如果只有一个匿名字段，则使用该字段；</li><li>其余字段中如果有多个匿名字段，但压平后不会出现冲突，所有匿名字段压平；</li><li>其余字段中如果有多个匿名字段，但压平后出现冲突，全部忽略，不产生错误。</li></ul><p>对匿名结构体字段的管理是从go1.1开始的，在之前的版本，匿名字段会直接忽略掉。</p><p>Map类型的值编码为json对象。Map的键必须是字符串，对象的键直接使用映射的键。</p><p>指针类型的值编码为其指向的值（的json编码）。nil指针编码为null。</p><p>接口类型的值编码为接口内保持的具体类型的值（的json编码）。nil接口编码为null。</p><p>通道、复数、函数类型的值不能编码进json。会导致Marshal函数返回UnsupportedTypeError错误</p><h2 id="三、反序列化Unmarshal函数"><a href="#三、反序列化Unmarshal函数" class="headerlink" title="三、反序列化Unmarshal函数"></a>三、反序列化Unmarshal函数</h2><p>反序列化函数<a href="https://golang.org/pkg/encoding/json/#Unmarshal" target="_blank" rel="noopener"> Unmarshal </a>，函数签名：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Unmarshal</span><span class="params">(data []<span class="keyword">byte</span>, v <span class="keyword">interface</span>{})</span> <span class="title">error</span></span></span><br></pre></td></tr></tbody></table></figure><p>Unmarshal函数解析json编码的数据并将结果存入v指向的值。</p><p>Unmarshal和Marshal做相反的操作，必要时申请map、切片或指针，遵循如下规则：<br>要将json数据解码写入一个指针，Unmarshal函数首先处理json数据是json字面值null的情况。此时，函数将指针设为nil；否则，函数将json数据解码写入指针指向的值；如果指针本身是nil，函数会先申请一个值并使指针指向它。<br>要将json数据解码写入一个结构体，函数会匹配输入对象的键和Marshal使用的键（结构体字段名或者它的标签指定的键名），优先选择精确的匹配，但也接受大小写不敏感的匹配。<br>要将json数据解码写入一个接口类型值，函数会将数据解码为如下类型写入接口：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Bool                   对应JSON布尔类型</span><br><span class="line"><span class="keyword">float64</span>                对应JSON数字类型</span><br><span class="line"><span class="keyword">string</span>                 对应JSON字符串类型</span><br><span class="line">[]<span class="keyword">interface</span>{}          对应JSON数组</span><br><span class="line"><span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>{} 对应JSON对象</span><br><span class="line"><span class="literal">nil</span>                    对应JSON的null</span><br></pre></td></tr></tbody></table></figure><p>如果一个JSON值不匹配给出的目标类型，或者如果一个json数字写入目标类型时溢出，Unmarshal函数会跳过该字段并尽量完成其余的解码操作。如果没有出现更加严重的错误，本函数会返回一个描述第一个此类错误的详细信息的UnmarshalTypeError。</p><p>JSON的null值解码为go的接口、指针、切片时会将它们设为nil，因为null在json里一般表示“不存在”。解码json的null值到其他go类型时，不会造成任何改变，也不会产生错误。</p><p>当解码字符串时，不合法的utf-8或utf-16代理（字符）对不视为错误，而是将非法字符替换为unicode字符U+FFFD。</p><h2 id="四、示例"><a href="#四、示例" class="headerlink" title="四、示例"></a>四、示例</h2><h3 id="4-1-序列化-struct"><a href="#4-1-序列化-struct" class="headerlink" title="4.1 序列化 struct"></a>4.1 序列化 struct</h3><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"encoding/json"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个简单的结构体 Person</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> {</span><br><span class="line">Name     <span class="keyword">string</span></span><br><span class="line">Age      <span class="keyword">int</span></span><br><span class="line">Birthday <span class="keyword">string</span></span><br><span class="line">Sex      <span class="keyword">float32</span></span><br><span class="line">Hobby    <span class="keyword">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//写一个 testStruct()结构体的序列化方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testStruct</span><span class="params">()</span></span> {</span><br><span class="line">person := Person{</span><br><span class="line">Name:     <span class="string">"小崽子"</span>,</span><br><span class="line">Age:      <span class="number">50</span>,</span><br><span class="line">Birthday: <span class="string">"2019-09-27"</span>,</span><br><span class="line">Sex:      <span class="number">1000.01</span>,</span><br><span class="line">Hobby:    <span class="string">"泡妞"</span>,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将Monster结构体序列化</span></span><br><span class="line">data, err := json.Marshal(&amp;person)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">fmt.Printf(<span class="string">"序列化错误 err is %v"</span>, err)</span><br><span class="line">}</span><br><span class="line"><span class="comment">//输出序列化结果</span></span><br><span class="line">fmt.Printf(<span class="string">"person序列化后 = %v"</span>, <span class="keyword">string</span>(data))</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反序列化</span></span><br><span class="line">person2 := Person{}</span><br><span class="line">json.Unmarshal(data,&amp;person2)</span><br><span class="line">fmt.Println(person2)</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  {</span><br><span class="line">testStruct()</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="4-2-序列化-map"><a href="#4-2-序列化-map" class="headerlink" title="4.2 序列化 map"></a>4.2 序列化 map</h3><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"encoding/json"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testMap</span><span class="params">()</span></span> {</span><br><span class="line"><span class="comment">//定义一个map</span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>{}</span><br><span class="line"><span class="comment">//使用map之前 必须make一下</span></span><br><span class="line">a = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>{})</span><br><span class="line">a[<span class="string">"name"</span>] = <span class="string">"小崽子"</span></span><br><span class="line">a[<span class="string">"age"</span>] = <span class="number">8</span></span><br><span class="line">a[<span class="string">"address"</span>] = <span class="string">"上海市浦东新区"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将a map结构体序列化</span></span><br><span class="line">data, err := json.Marshal(a)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">fmt.Printf(<span class="string">"序列化错误 err is %v"</span>, err)</span><br><span class="line">}</span><br><span class="line"><span class="comment">//输出序列化结果</span></span><br><span class="line">fmt.Printf(<span class="string">"map序列化后 = %v"</span>, <span class="keyword">string</span>(data))</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反序列化</span></span><br><span class="line"><span class="keyword">var</span> a1 <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>{}</span><br><span class="line">json.Unmarshal(data,&amp;a1)</span><br><span class="line">fmt.Println(a1)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">testMap()</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="4-3-序列化-slice"><a href="#4-3-序列化-slice" class="headerlink" title="4.3 序列化 slice"></a>4.3 序列化 slice</h3><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"encoding/json"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// slice进行序列化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testSlice</span><span class="params">()</span></span> {</span><br><span class="line"><span class="keyword">var</span> slice []<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>{} <span class="comment">// 定义了一个切片，里面是map格式 map[string]interface{}</span></span><br><span class="line"><span class="keyword">var</span> m1 <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>{}      <span class="comment">//定义切片中的第一个map M1</span></span><br><span class="line">m1 = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>{})</span><br><span class="line">m1[<span class="string">"name"</span>] = <span class="string">"小崽子"</span></span><br><span class="line">m1[<span class="string">"age"</span>] = <span class="number">16</span></span><br><span class="line">m1[<span class="string">"address"</span>] = [<span class="number">2</span>]<span class="keyword">string</span>{<span class="string">"上海市"</span>, <span class="string">"浦东新区"</span>}</span><br><span class="line">slice = <span class="built_in">append</span>(slice, m1)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m2 <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>{} <span class="comment">//定义切片中的第2个map M2</span></span><br><span class="line">m2 = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>{})</span><br><span class="line">m2[<span class="string">"name"</span>] = <span class="string">"大崽子"</span></span><br><span class="line">m2[<span class="string">"age"</span>] = <span class="number">36</span></span><br><span class="line">m2[<span class="string">"address"</span>] = <span class="string">"北京市"</span></span><br><span class="line">slice = <span class="built_in">append</span>(slice, m2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将slice进行序列化</span></span><br><span class="line">data, err := json.Marshal(slice)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">fmt.Printf(<span class="string">"序列化错误 err is %v"</span>, err)</span><br><span class="line">}</span><br><span class="line"><span class="comment">//输出序列化结果</span></span><br><span class="line">fmt.Printf(<span class="string">"slice序列化后 = %v"</span>, <span class="keyword">string</span>(data))</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反序列化结果</span></span><br><span class="line"><span class="keyword">var</span> slice2 []<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>{}</span><br><span class="line">json.Unmarshal(data,&amp;slice2)</span><br><span class="line">fmt.Println(slice2)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">testSlice()</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><!-- rebuild by neat --><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、json-序列化和反序列化&quot;&gt;&lt;a href=&quot;#一、json-序列化和反序列化&quot; class=&quot;headerlink&quot; title=&quot;一、json 序列化和反序列化&quot;&gt;&lt;/a&gt;一、json 序列化和反序列化&lt;/h2&gt;&lt;p&gt;JSON是一种轻量级的数据交换格式，
      
    
    </summary>
    
    
      <category term="Go" scheme="http://chenzhonzhou.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="http://chenzhonzhou.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go 泛型</title>
    <link href="http://chenzhonzhou.github.io/2023/07/03/go-fan-xing/"/>
    <id>http://chenzhonzhou.github.io/2023/07/03/go-fan-xing/</id>
    <published>2023-07-03T01:52:21.000Z</published>
    <updated>2023-12-03T03:06:28.339Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、什么是泛型"><a href="#一、什么是泛型" class="headerlink" title="一、什么是泛型"></a>一、什么是泛型</h2><p>泛型的英文是Generics，就是函数的参数，或者容器元素的类型，支持更广泛的类型，不再是特定的类型。</p><p>下面只搬运一下对泛型的简单介绍</p><ul><li>函数和类型声明的语法接受类型参数</li><li>可以通过方括号中的类型参数列表来实例化参数化函数和类型</li><li>接口类型的语法现在允许嵌入任意类型以及Union和〜T类型元素。这些接口只能用作类型约束。接口现在可以定义一组类型和一组方法</li><li>新的预声明标识符any是空接口的别名，可以使用any代替interface{}</li><li>新的预声明标识符comparable表示可以使用==或!=做比较的所有类型的一个接口，它可以被用作类型约束</li><li>有三个实验性的package在使用泛型.golang.org/x/exp下的所有package都属于试验性质或者被废除的package，不倡议应用。<blockquote><p>golang.org/x/exp/constraints<br>golang.org/x/exp/slices<br>golang.org/x/exp/maps</p></blockquote></li></ul><p>在Golang、Java、C++等这类静态语言中，是需要严格定义传入变量的类型的，斌不是随心所欲，例如在golang中：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sum</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> {</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在函数Sum中，不仅要严格定义传入参数a和b的变量类型，而且返回值的类型也需要严格定义，所有你只能传入int类型进行调用：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sum(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 3</span></span><br></pre></td></tr></tbody></table></figure><p>如果传入其它类型的变量就会报错：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(Sum(<span class="number">1.23</span>, <span class="number">2.54</span>)) </span><br><span class="line"></span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">33</span>:<span class="number">18</span>: cannot use <span class="number">1.23</span> (untyped float constant) as <span class="keyword">int</span> value in argument to Sum (truncated)</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">33</span>:<span class="number">24</span>: cannot use <span class="number">2.54</span> (untyped float constant) as <span class="keyword">int</span> value in argument to Sum (truncated)</span><br></pre></td></tr></tbody></table></figure><p>因此，如果当golang开发者想开发类似实现两个float类型变量相加的功能，只能另写一个函数：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SumFloat</span><span class="params">(a, b float)</span> <span class="title">float</span></span> {</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>或者写一个通用的Sum函数使用interface反射来判断：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sum</span><span class="params">(a, b <span class="keyword">interface</span>{})</span> <span class="title">interface</span></span>{} {</span><br><span class="line">  <span class="keyword">switch</span> a.(<span class="keyword">type</span>) {</span><br><span class="line">  <span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">    a1 := a.(<span class="keyword">int</span>)</span><br><span class="line">    b1 := b.(<span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">return</span> a1 + b1</span><br><span class="line">  <span class="keyword">case</span> <span class="keyword">float64</span>:</span><br><span class="line">    a1 := a.(<span class="keyword">float64</span>)</span><br><span class="line">    b1 := b.(<span class="keyword">float64</span>)</span><br><span class="line">    <span class="keyword">return</span> a1 + b1</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这样的话，不仅重复很多代码，而且类型频繁转换导致不仅性能低效，安全性上也不高。</p><p>所以泛型诞生了。</p><p>然而泛型是一把双刃剑，在给开发者带来便利的同时，同样会带来编译和效率的问题，因为泛型需要系统去推倒和计算变量的类型的，这在无形中会增加编译的时间和降低运行效率。</p><h2 id="二、Golang中的泛型"><a href="#二、Golang中的泛型" class="headerlink" title="二、Golang中的泛型"></a>二、Golang中的泛型</h2><p>首先来看一下，在Golang 1.18版本中是如何利用泛型来实现Sum函数的</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sum</span>[<span class="title">T</span> <span class="title">int</span>|<span class="title">float64</span>]<span class="params">(a,b T)</span> <span class="title">T</span></span> {</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>然后再调用一下：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(Sum[<span class="keyword">int</span>](<span class="number">1</span>, <span class="number">2</span>))  <span class="comment">//3</span></span><br><span class="line">fmt.Println(Sum[<span class="keyword">float64</span>](<span class="number">1.23</span>, <span class="number">2.54</span>))  <span class="comment">//3.77</span></span><br></pre></td></tr></tbody></table></figure><p>先不去理解函数中各组件的含义，仅仅看代码就简洁了不少，函数也实现了多个类型的功能。</p><h2 id="三、泛型语法"><a href="#三、泛型语法" class="headerlink" title="三、泛型语法"></a>三、泛型语法</h2><h3 id="3-1-泛型的语法"><a href="#3-1-泛型的语法" class="headerlink" title="3.1 泛型的语法"></a>3.1 泛型的语法</h3><blockquote><p>MyType[T1 constraint1 | constraint2, T2 constraint3…] …</p></blockquote><p>泛型的语法非常简单, 就类似于上面这样, 其中:</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyType 可以是函数名, 结构体名, 类型名…</span><br><span class="line">T1, T2… 是泛型名, 可以随便取</span><br><span class="line">constraint 的意思是约束, 也是泛型中最重要的概念, 接下来会详解constraint</span><br><span class="line">使用 | 可以分隔多个constraint, T满足其中之一即可(如T1可以是constraint1和constraint2中的任何一个)</span><br></pre></td></tr></tbody></table></figure><h3 id="3-2-Constraint-约束"><a href="#3-2-Constraint-约束" class="headerlink" title="3.2 Constraint(约束)"></a>3.2 Constraint(约束)</h3><p>约束的意思是限定范围, constraint的作用就是限定范围, 将T限定在某种范围内</p><p>而常用的范围, 我们自然会想到的有:</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">any(<span class="keyword">interface</span>{}, 任何类型都能接收, 多方便啊!)</span><br><span class="line">Interger(所有<span class="keyword">int</span>, 多方便啊, <span class="keyword">int64</span> <span class="keyword">int32</span>…一网打尽)</span><br><span class="line">Float(同上)</span><br><span class="line">comparable(所有可以比较的类型, 我们可以给所有可以比较的类型定制一些方法)</span><br><span class="line">…</span><br></pre></td></tr></tbody></table></figure><p>这些约束, 不是被官方定义为内置类型, 就是被涵盖在了constraints包内!!!</p><p>下面是builtin.go的部分官方源码:</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// any is an alias for interface{} and is equivalent to interface{} in all ways.</span></span><br><span class="line"><span class="keyword">type</span> any = <span class="keyword">interface</span>{}</span><br><span class="line"></span><br><span class="line"><span class="comment">// comparable is an interface that is implemented by all comparable types</span></span><br><span class="line"><span class="comment">// (booleans, numbers, strings, pointers, channels, interfaces,</span></span><br><span class="line"><span class="comment">// arrays of comparable types, structs whose fields are all comparable types).</span></span><br><span class="line"><span class="comment">// The comparable interface may only be used as a type parameter constraint,</span></span><br><span class="line"><span class="comment">// not as the type of a variable.</span></span><br><span class="line"><span class="keyword">type</span> comparable comparable</span><br></pre></td></tr></tbody></table></figure><p>下面是constraints.go的部分官方源码:</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Integer is a constraint that permits any integer type.</span></span><br><span class="line"><span class="comment">// If future releases of Go add new predeclared integer types,</span></span><br><span class="line"><span class="comment">// this constraint will be modified to include them.</span></span><br><span class="line"><span class="keyword">type</span> Integer <span class="keyword">interface</span> {</span><br><span class="line">  Signed | Unsigned</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Float is a constraint that permits any floating-point type.</span></span><br><span class="line"><span class="comment">// If future releases of Go add new predeclared floating-point types,</span></span><br><span class="line"><span class="comment">// this constraint will be modified to include them.</span></span><br><span class="line"><span class="keyword">type</span> Float <span class="keyword">interface</span> {</span><br><span class="line">  ~<span class="keyword">float32</span> | ~<span class="keyword">float64</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">//......</span></span><br></pre></td></tr></tbody></table></figure><h3 id="3-3-自定义constraint-约束"><a href="#3-3-自定义constraint-约束" class="headerlink" title="3.3 自定义constraint(约束)"></a>3.3 自定义constraint(约束)</h3><p>下面是constraints包中的官方源码:</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Signed <span class="keyword">interface</span> {</span><br><span class="line">  ~<span class="keyword">int</span> | ~<span class="keyword">int8</span> | ~<span class="keyword">int16</span> | ~<span class="keyword">int32</span> | ~<span class="keyword">int64</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>Signed约束就是这样被写出来的, 其中需要我们掌握的点有如下几个:</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">使用<span class="keyword">interface</span>{}就可以自定义约束</span><br><span class="line">使用 | 就可以在该约束中包含不同的类型, 例如<span class="keyword">int</span>, <span class="keyword">int8</span>, <span class="keyword">int64</span>均满足Signed约束</span><br><span class="line">你可能会有疑问, ~是什么??? <span class="keyword">int</span>我认识, ~<span class="keyword">int</span>我可不认识呀??? 没关系, 实际上~非常简单, 它的意思就是模糊匹配, 例如:</span><br><span class="line"><span class="keyword">type</span> MyInt <span class="keyword">int64</span></span><br><span class="line">此时 MyInt并不等同于<span class="keyword">int64</span>类型(Go语言特性)</span><br><span class="line">若我们使用<span class="keyword">int64</span>来约束MyInt, 则Myint不满足该约束</span><br><span class="line">若我们使用~<span class="keyword">int64</span>来约束MyInt, 则Myint满足该约束(也就是说, ~<span class="keyword">int64</span>只要求该类型的底层是<span class="keyword">int64</span>, 也就是模糊匹配了)</span><br><span class="line">官方为了鲁棒性, 自然把所有的类型前面都加上了~</span><br></pre></td></tr></tbody></table></figure><p>例如：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> My_constraint_Num <span class="keyword">interface</span> {</span><br><span class="line">  ~<span class="keyword">int64</span> | ~<span class="keyword">float64</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="3-3-1-声明一个泛型函数"><a href="#3-3-1-声明一个泛型函数" class="headerlink" title="3.3.1 声明一个泛型函数"></a>3.3.1 声明一个泛型函数</h4><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span>[<span class="title">T</span> <span class="title">int</span> | <span class="title">int64</span> | <span class="title">float64</span> | <span class="title">string</span>]<span class="params">(data []T)</span></span> {</span><br><span class="line">  <span class="keyword">for</span> _, v := <span class="keyword">range</span> data {</span><br><span class="line">    fmt.Println(v)</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSliceAny</span>[<span class="title">T</span> <span class="title">any</span>]<span class="params">(data []T)</span></span> {</span><br><span class="line">  <span class="keyword">for</span> _, v := <span class="keyword">range</span> data {</span><br><span class="line">    fmt.Println(v)</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//多个泛型参数语法：</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSliceDemo01</span>[<span class="title">T</span>, <span class="title">M</span> <span class="title">any</span>]<span class="params">(data01 []T, data02 []M)</span></span> {</span><br><span class="line">  fmt.Println(<span class="string">"printSliceDemo01================"</span>)</span><br><span class="line">  fmt.Println(data01)</span><br><span class="line">  fmt.Println(<span class="string">"printSliceDemo01================"</span>)</span><br><span class="line">  fmt.Println(data02)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// []里写一个类型，传入的data01和data02 必须是同一种数据类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSliceDemo02</span>[<span class="title">T</span> <span class="title">any</span>]<span class="params">(data01 []T, data02 []T)</span></span> {</span><br><span class="line">  fmt.Println(<span class="string">"printSliceDemo02================"</span>)</span><br><span class="line">  fmt.Println(data01)</span><br><span class="line">  fmt.Println(<span class="string">"printSliceDemo02================"</span>)</span><br><span class="line">  fmt.Println(data02)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// []里写一个类型，传入的data01和data02 必须是同一种数据类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSliceDemo03</span>[<span class="title">T</span> <span class="title">any</span>]<span class="params">(data01, data02 []T)</span></span> {</span><br><span class="line">  fmt.Println(<span class="string">"printSliceDemo03================"</span>)</span><br><span class="line">  fmt.Println(data01)</span><br><span class="line">  fmt.Println(<span class="string">"printSliceDemo03================"</span>)</span><br><span class="line">  fmt.Println(data02)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSliceDemo04</span>[<span class="title">T</span> <span class="title">any</span>, <span class="title">M</span> <span class="title">any</span>]<span class="params">(data01 []T, data02 []M)</span></span> {</span><br><span class="line">  fmt.Println(<span class="string">"printSliceDemo04================"</span>)</span><br><span class="line">  fmt.Println(data01)</span><br><span class="line">  fmt.Println(<span class="string">"printSliceDemo04================"</span>)</span><br><span class="line">  fmt.Println(data02)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">  <span class="comment">// 显示类型调用</span></span><br><span class="line">  printSlice[<span class="keyword">int</span>]([]<span class="keyword">int</span>{<span class="number">66</span>, <span class="number">77</span>, <span class="number">88</span>, <span class="number">99</span>, <span class="number">100</span>})</span><br><span class="line">  printSlice[<span class="keyword">float64</span>]([]<span class="keyword">float64</span>{<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">5.5</span>})</span><br><span class="line">  printSlice[<span class="keyword">string</span>]([]<span class="keyword">string</span>{<span class="string">"烤鸡"</span>, <span class="string">"烤鸭"</span>, <span class="string">"烤鱼"</span>, <span class="string">"烤面筋"</span>})</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 省略显示类型调用</span></span><br><span class="line">  printSlice([]<span class="keyword">int64</span>{<span class="number">55</span>, <span class="number">44</span>, <span class="number">33</span>, <span class="number">22</span>, <span class="number">11</span>})</span><br><span class="line">  printSliceAny([]<span class="keyword">int64</span>{<span class="number">55</span>, <span class="number">44</span>, <span class="number">33</span>, <span class="number">22</span>, <span class="number">11</span>})</span><br><span class="line"></span><br><span class="line">  printSliceDemo01([]<span class="keyword">int64</span>{<span class="number">55</span>, <span class="number">44</span>, <span class="number">33</span>, <span class="number">22</span>, <span class="number">11</span>}, []<span class="keyword">string</span>{<span class="string">"烤鸡"</span>, <span class="string">"烤鸭"</span>, <span class="string">"烤鱼"</span>, <span class="string">"烤面筋"</span>})</span><br><span class="line">  printSliceDemo02([]<span class="keyword">int64</span>{<span class="number">55</span>, <span class="number">44</span>, <span class="number">33</span>, <span class="number">22</span>, <span class="number">11</span>}, []<span class="keyword">int64</span>{<span class="number">55</span>, <span class="number">44</span>, <span class="number">33</span>, <span class="number">22</span>, <span class="number">11</span>})</span><br><span class="line">  printSliceDemo03([]<span class="keyword">int64</span>{<span class="number">55</span>, <span class="number">44</span>, <span class="number">33</span>, <span class="number">22</span>, <span class="number">11</span>}, []<span class="keyword">int64</span>{<span class="number">55</span>, <span class="number">44</span>, <span class="number">33</span>, <span class="number">22</span>, <span class="number">11</span>})</span><br><span class="line">  printSliceDemo04([]<span class="keyword">int64</span>{<span class="number">55</span>, <span class="number">44</span>, <span class="number">33</span>, <span class="number">22</span>, <span class="number">11</span>}, []<span class="keyword">string</span>{<span class="string">"烤鸡"</span>, <span class="string">"烤鸭"</span>, <span class="string">"烤鱼"</span>, <span class="string">"烤面筋"</span>})</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>[T any]参数的类型，意思是该函数支持任何T类型; 底层是 type any = interface{}</p></blockquote><p>多个泛型参数语法：</p><blockquote><p>[T, M any]<br>[T any, M any]<br>[T any, M comparable]</p></blockquote><p>在调用这个泛型函数的时候</p><p>可以显示指定类型参数</p><p>如: <code>printSlice[int]([]int{66, 77, 88, 99, 100})</code></p><p>也可以省略显示类型 自动推断类型</p><p>如 <code>printSlice([]int64{55, 44, 33, 22, 11})</code></p><h4 id="3-3-2-声明一个泛型切片"><a href="#3-3-2-声明一个泛型切片" class="headerlink" title="3.3.2 声明一个泛型切片"></a>3.3.2 声明一个泛型切片</h4><p>带有类型参数的类型被叫做泛型类型。下面定义一个底层类型为切片类型的新类型 vector。它是可以存储任何类型的的切片。要使用泛型类型，要先对其进行实例化，就是给类型参数指定一个实参。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"sort"</span></span><br><span class="line">  <span class="string">"strings"</span></span><br><span class="line"></span><br><span class="line">  <span class="string">"golang.org/x/exp/constraints"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> vector[T any] []T</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span>[<span class="title">T</span> <span class="title">any</span>]<span class="params">(data []T)</span></span> {</span><br><span class="line">  fmt.Println(data)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">  <span class="comment">//dome01()</span></span><br><span class="line">  <span class="comment">//sortSliceDome()</span></span><br><span class="line">  <span class="comment">//ContainsSliceDome()</span></span><br><span class="line">  findFuncDemo()</span><br><span class="line">  <span class="comment">//filterSliceDome()</span></span><br><span class="line">  <span class="comment">//Contains[comparable]([int]{58, 1881},58)</span></span><br><span class="line">  <span class="comment">//testMinMax() </span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dome01</span><span class="params">()</span></span> {</span><br><span class="line">  v := vector[<span class="keyword">int</span>]{<span class="number">58</span>, <span class="number">1881</span>}</span><br><span class="line">  printSlice(v)</span><br><span class="line">  v2 := vector[<span class="keyword">string</span>]{<span class="string">"烤鸡"</span>, <span class="string">"烤鸭"</span>, <span class="string">"烤鱼"</span>, <span class="string">"烤面筋"</span>}</span><br><span class="line">  printSlice(v2)</span><br><span class="line">  v3 := vector[<span class="keyword">float64</span>]{<span class="number">10.2</span>, <span class="number">2.5</span>}</span><br><span class="line">  printSlice(v3)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> v4 vector[<span class="keyword">int</span>] = []<span class="keyword">int</span>{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>}</span><br><span class="line">  v4[<span class="number">2</span>] = <span class="number">4</span></span><br><span class="line">  printSlice(v4)</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortSliceDome</span><span class="params">()</span></span> {</span><br><span class="line">  floatSlice := []<span class="keyword">float64</span>{<span class="number">2.3</span>, <span class="number">1.2</span>, <span class="number">0.2</span>, <span class="number">51.2</span>}</span><br><span class="line">  sortSlice(floatSlice, <span class="string">"asc"</span>)</span><br><span class="line">  fmt.Println(floatSlice)</span><br><span class="line"></span><br><span class="line">  stringSlice := []<span class="keyword">string</span>{<span class="string">"z"</span>, <span class="string">"a"</span>, <span class="string">"b"</span>}</span><br><span class="line">  sortSlice(stringSlice, <span class="string">"asc"</span>)</span><br><span class="line">  fmt.Println(stringSlice)</span><br><span class="line"></span><br><span class="line">  intSlice := []<span class="keyword">int</span>{<span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">6</span>}</span><br><span class="line">  sortSlice(intSlice, <span class="string">"desc"</span>)</span><br><span class="line">  fmt.Println(intSlice)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 切片排序 order asc|desc</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortSlice</span>[<span class="title">T</span> <span class="title">constraints</span>.<span class="title">Ordered</span>]<span class="params">(s []T, order <span class="keyword">string</span>)</span></span> {</span><br><span class="line">  <span class="keyword">if</span> strings.ToUpper(order) == <span class="string">"ASC"</span> || order == <span class="string">""</span> {</span><br><span class="line">    sort.Slice(s, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> {</span><br><span class="line">      <span class="keyword">return</span> s[i] &lt; s[j]</span><br><span class="line">    })</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    sort.Slice(s, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> {</span><br><span class="line">      <span class="keyword">return</span> s[i] &gt; s[j]</span><br><span class="line">    })</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ContainsSliceDome</span><span class="params">()</span></span> {</span><br><span class="line">  floatSlice := []<span class="keyword">float64</span>{<span class="number">2.3</span>, <span class="number">1.2</span>, <span class="number">0.2</span>, <span class="number">51.2</span>}</span><br><span class="line">  fmt.Println(ContainsSlice(floatSlice, <span class="number">2.3</span>))</span><br><span class="line"></span><br><span class="line">  stringSlice := []<span class="keyword">string</span>{<span class="string">"z"</span>, <span class="string">"a"</span>, <span class="string">"b"</span>}</span><br><span class="line">  fmt.Println(ContainsSlice(stringSlice, <span class="string">"c"</span>))</span><br><span class="line"></span><br><span class="line">  intSlice := []<span class="keyword">int</span>{<span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">6</span>}</span><br><span class="line">  fmt.Println(ContainsSlice(intSlice, <span class="number">0</span>))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// ContainsSlice 是否包涵</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ContainsSlice</span>[<span class="title">E</span> <span class="title">constraints</span>.<span class="title">Ordered</span>]<span class="params">(s []E, v E)</span> <span class="title">bool</span></span> {</span><br><span class="line">  <span class="keyword">for</span> _, vs := <span class="keyword">range</span> s {</span><br><span class="line">    <span class="keyword">if</span> v == vs {</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findFuncDemo</span><span class="params">()</span></span> {</span><br><span class="line">  fmt.Println(FindFunc([]<span class="keyword">int</span>{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>}, <span class="number">2</span>)) <span class="comment">//1</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//FindFunc 查找元素</span></span><br><span class="line"><span class="comment">//该方法应用于在已知切片中查找给定元素是否存在，若存在则返回元素所在切片下标，不存在则返回 -1。</span></span><br><span class="line"><span class="comment">//支持泛型类型：comparable。即属于相同泛型类型的不同元素之间必须可以比较是否相等。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FindFunc</span>[<span class="title">T</span> <span class="title">comparable</span>]<span class="params">(a []T, v T)</span> <span class="title">int</span></span> {</span><br><span class="line">  <span class="keyword">for</span> i, e := <span class="keyword">range</span> a {</span><br><span class="line">    <span class="keyword">if</span> e == v {</span><br><span class="line">      <span class="keyword">return</span> i</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">filterSliceDome</span><span class="params">()</span></span> {</span><br><span class="line">  websites := []<span class="keyword">string</span>{<span class="string">"http://foo.com"</span>, <span class="string">"https://bar.com"</span>, <span class="string">"https://gosamples.dev"</span>}</span><br><span class="line">  httpsWebsites := FilterSlice(websites, <span class="function"><span class="keyword">func</span><span class="params">(v <span class="keyword">string</span>)</span> <span class="title">bool</span></span> {</span><br><span class="line">    <span class="keyword">return</span> !strings.HasPrefix(v, <span class="string">"https://"</span>)</span><br><span class="line">  })</span><br><span class="line">  fmt.Println(httpsWebsites)</span><br><span class="line"></span><br><span class="line">  httpsWebsites2 := FilterSlice(websites, <span class="function"><span class="keyword">func</span><span class="params">(v <span class="keyword">string</span>)</span> <span class="title">bool</span></span> {</span><br><span class="line">    <span class="keyword">return</span> strings.HasPrefix(v, <span class="string">"https://"</span>)</span><br><span class="line">  })</span><br><span class="line">  fmt.Println(httpsWebsites2)</span><br><span class="line"></span><br><span class="line">  numbers := []<span class="keyword">int</span>{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>}</span><br><span class="line">  divisibleBy2 := FilterSlice(numbers, <span class="function"><span class="keyword">func</span><span class="params">(v <span class="keyword">int</span>)</span> <span class="title">bool</span></span> {</span><br><span class="line">    <span class="keyword">return</span> v%<span class="number">2</span> == <span class="number">0</span></span><br><span class="line">  })</span><br><span class="line">  fmt.Println(divisibleBy2)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//输出：</span></span><br><span class="line">  <span class="comment">//[https://bar.com https://gosamples.dev]</span></span><br><span class="line">  <span class="comment">//[2 4 6]</span></span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//FilterSlice 过滤出符合传入方法的数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FilterSlice</span>[<span class="title">T</span> <span class="title">any</span>]<span class="params">(slice []T, f <span class="keyword">func</span>(T)</span> <span class="title">bool</span>) []<span class="title">T</span></span> {</span><br><span class="line">  <span class="keyword">var</span> n []T</span><br><span class="line">  <span class="keyword">for</span> _, e := <span class="keyword">range</span> slice {</span><br><span class="line">    <span class="keyword">if</span> f(e) {</span><br><span class="line">      n = <span class="built_in">append</span>(n, e)</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> n</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testMinMax</span><span class="params">()</span></span> {</span><br><span class="line">  vi := []<span class="keyword">int</span>{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>}</span><br><span class="line">  result := Max(vi)</span><br><span class="line">  fmt.Println(result)</span><br><span class="line"></span><br><span class="line">  vi = []<span class="keyword">int</span>{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>}</span><br><span class="line">  result = Min(vi)</span><br><span class="line">  fmt.Println(result)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//输出</span></span><br><span class="line">  <span class="comment">//10</span></span><br><span class="line">  <span class="comment">//1</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> minmax <span class="keyword">interface</span> {</span><br><span class="line">  ~<span class="keyword">int</span> | ~<span class="keyword">int8</span> | ~<span class="keyword">int16</span> | ~<span class="keyword">int32</span> | ~<span class="keyword">int64</span> | ~<span class="keyword">uint</span> | ~<span class="keyword">uint8</span> | ~<span class="keyword">uint16</span> | ~<span class="keyword">uint32</span> | ~<span class="keyword">uint64</span> | ~<span class="keyword">uintptr</span> | ~<span class="keyword">float32</span> | ~<span class="keyword">float64</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Max</span>[<span class="title">T</span> <span class="title">minmax</span>]<span class="params">(a []T)</span> <span class="title">T</span></span> {</span><br><span class="line">  m := a[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">for</span> _, v := <span class="keyword">range</span> a {</span><br><span class="line">    <span class="keyword">if</span> m &lt; v {</span><br><span class="line">      m = v</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> m</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Min</span>[<span class="title">T</span> <span class="title">minmax</span>]<span class="params">(a []T)</span> <span class="title">T</span></span> {</span><br><span class="line">  m := a[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">for</span> _, v := <span class="keyword">range</span> a {</span><br><span class="line">    <span class="keyword">if</span> m &gt; v {</span><br><span class="line">      m = v</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> m</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>golang.org/x/exp</strong> 包<br>文档地址：<a href="https://pkg.go.dev/golang.org/x/exp" target="_blank" rel="noopener">https://pkg.go.dev/golang.org/x/exp</a></p><p>注意：<br>不建议使用这个包：<br>详细参考下面文档：<br>关于golang: <a href="https://lequ7.com/guan-yu-golang-zhong-bang-go118-jiang-yi-chu-yong-yu-fan-xing-de-constraints-bao.html" target="_blank" rel="noopener">重磅Go-118将移除用于泛型的constraints包</a></p><p>golang.org/x下所有package的源码独立于Go源码的骨干分支，也不在Go的二进制安装包里。如果须要应用golang.org/x下的package，能够应用go get来装置。<br>golang.org/x/exp下的所有package都属于试验性质或者被废除的package，不倡议应用。<br>因为泛型的存在，相同的功能对于不同类型的slice可以少写一份代码，如果想使用slice泛型的相关操作，建议复制golang.org/x/exp中的函数进行使用或修改</p><p>constraints包里定义了Signed，Unsigned, Integer, Float, Complex和Ordered共6个interface类型，能够用于泛型里的类型束缚(type constraint)。</p><p>官方也引入了一些官方包来方面泛型的使用，具体如下：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// constraints 定义了一组与类型参数一起使用的约束</span></span><br><span class="line"><span class="keyword">package</span> constraints</span><br><span class="line"></span><br><span class="line"><span class="comment">// Signed是允许任何有符号整数类型的约束。</span></span><br><span class="line"><span class="keyword">type</span> Signed <span class="keyword">interface</span> { ... }</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unsigned是允许任何无符号整数类型的约束。</span></span><br><span class="line"><span class="keyword">type</span> Unsigned <span class="keyword">interface</span> { ... }</span><br><span class="line"></span><br><span class="line"><span class="comment">// Integer是允许任何整数类型的约束。</span></span><br><span class="line"><span class="keyword">type</span> Integer <span class="keyword">interface</span> { ... }</span><br><span class="line"></span><br><span class="line"><span class="comment">// Float是一个允许任何浮点类型的约束。</span></span><br><span class="line"><span class="keyword">type</span> Float <span class="keyword">interface</span> { ... }</span><br><span class="line"></span><br><span class="line"><span class="comment">// Complex是允许任何复杂数值类型的约束。</span></span><br><span class="line"><span class="keyword">type</span> Complex <span class="keyword">interface</span> { ... }</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ordered是一个约束，允许任何有序类型:任何支持操作符&lt; &lt;= &gt;= &gt;的类型。</span></span><br><span class="line"><span class="keyword">type</span> Ordered <span class="keyword">interface</span> { ... }</span><br></pre></td></tr></tbody></table></figure><p>使用方式示例如下：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"golang.org/x/exp/maps"</span></span><br><span class="line">  <span class="string">"golang.org/x/exp/slices"</span></span><br><span class="line">  <span class="string">"sort"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">  EqualDome()</span><br><span class="line">  <span class="comment">//ContainsDome()</span></span><br><span class="line">  <span class="comment">//ContainsFuncDome()</span></span><br><span class="line">  <span class="comment">//InsertDome()</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// EqualDome 是否等于</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EqualDome</span><span class="params">()</span></span> {</span><br><span class="line">  <span class="keyword">var</span> m1 = <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>{<span class="number">1</span>: <span class="number">2</span>, <span class="number">2</span>: <span class="number">4</span>, <span class="number">4</span>: <span class="number">8</span>, <span class="number">8</span>: <span class="number">16</span>}</span><br><span class="line">  wantKeys := []<span class="keyword">int</span>{<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>}</span><br><span class="line">  gotKeys := maps.Keys(m1)</span><br><span class="line">  sort.Ints(gotKeys)</span><br><span class="line">  <span class="comment">// gotKeys 是否等于 wantKeys</span></span><br><span class="line">  fmt.Println(slices.Equal(gotKeys, wantKeys))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> m2 = <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>{<span class="number">1</span>: <span class="string">"a"</span>, <span class="number">2</span>: <span class="string">"b"</span>, <span class="number">4</span>: <span class="string">"c"</span>, <span class="number">8</span>: <span class="string">"d"</span>}</span><br><span class="line">  wantValsAsc := []<span class="keyword">string</span>{<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>}</span><br><span class="line">  wantValsDesc := []<span class="keyword">string</span>{<span class="string">"d"</span>, <span class="string">"c"</span>, <span class="string">"b"</span>, <span class="string">"a"</span>}</span><br><span class="line"></span><br><span class="line">  gotVals := maps.Values(m2)</span><br><span class="line"></span><br><span class="line">  sort.Strings(gotVals) <span class="comment">// 升序</span></span><br><span class="line">  <span class="comment">// gotKeys 是否等于 wantKeys</span></span><br><span class="line">  fmt.Println(slices.Equal(gotVals, wantValsAsc))</span><br><span class="line"></span><br><span class="line">  sort.Sort(sort.Reverse(sort.StringSlice(gotVals))) <span class="comment">//降序</span></span><br><span class="line">  <span class="comment">// gotKeys 是否等于 wantValsDesc</span></span><br><span class="line">  fmt.Println(slices.Equal(gotVals, wantValsDesc))</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 打印结果</span></span><br><span class="line">  <span class="comment">//true</span></span><br><span class="line">  <span class="comment">//true</span></span><br><span class="line">  <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ContainsDome</span><span class="params">()</span></span> {</span><br><span class="line">  floatSlice := []<span class="keyword">float64</span>{<span class="number">2.3</span>, <span class="number">1.2</span>, <span class="number">0.2</span>, <span class="number">51.2</span>}</span><br><span class="line">  <span class="comment">// floatSlice 是否包涵 2.3</span></span><br><span class="line">  fmt.Println(slices.Contains(floatSlice, <span class="number">2.3</span>))</span><br><span class="line"></span><br><span class="line">  stringSlice := []<span class="keyword">string</span>{<span class="string">"z"</span>, <span class="string">"a"</span>, <span class="string">"b"</span>}</span><br><span class="line">  fmt.Println(slices.Contains(stringSlice, <span class="string">"c"</span>))</span><br><span class="line"></span><br><span class="line">  intSlice := []<span class="keyword">int</span>{<span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">6</span>}</span><br><span class="line">  fmt.Println(slices.Contains(intSlice, <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 打印结果</span></span><br><span class="line">  <span class="comment">//true</span></span><br><span class="line">  <span class="comment">//false</span></span><br><span class="line">  <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ContainsFuncDome</span><span class="params">()</span></span> {</span><br><span class="line">  floatSlice := []<span class="keyword">float64</span>{<span class="number">2.3</span>, <span class="number">1.2</span>, <span class="number">0.2</span>, <span class="number">51.2</span>}</span><br><span class="line">  <span class="comment">// floatSlice 是否包涵  &gt; 1.0</span></span><br><span class="line">  fmt.Println(slices.ContainsFunc(floatSlice, <span class="function"><span class="keyword">func</span><span class="params">(v <span class="keyword">float64</span>)</span> <span class="title">bool</span></span> {</span><br><span class="line">    <span class="keyword">return</span> v &gt; <span class="number">1.0</span></span><br><span class="line">  }))</span><br><span class="line"></span><br><span class="line">  stringSlice := []<span class="keyword">string</span>{<span class="string">"z"</span>, <span class="string">"a"</span>, <span class="string">"b"</span>}</span><br><span class="line">  <span class="comment">// stringSlice 是否包涵  == "c"</span></span><br><span class="line">  fmt.Println(slices.ContainsFunc(stringSlice, <span class="function"><span class="keyword">func</span><span class="params">(v <span class="keyword">string</span>)</span> <span class="title">bool</span></span> {</span><br><span class="line">    <span class="keyword">return</span> v == <span class="string">"c"</span></span><br><span class="line">  }))</span><br><span class="line"></span><br><span class="line">  intSlice := []<span class="keyword">int</span>{<span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">6</span>}</span><br><span class="line">  <span class="comment">// intSlice 是否包涵 v%2 == 0</span></span><br><span class="line">  fmt.Println(slices.ContainsFunc(intSlice, <span class="function"><span class="keyword">func</span><span class="params">(v <span class="keyword">int</span>)</span> <span class="title">bool</span></span> {</span><br><span class="line">    <span class="keyword">return</span> v%<span class="number">2</span> == <span class="number">0</span></span><br><span class="line">  }))</span><br><span class="line">  <span class="comment">// 打印结果</span></span><br><span class="line">  <span class="comment">//true</span></span><br><span class="line">  <span class="comment">//false</span></span><br><span class="line">  <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InsertDome</span><span class="params">()</span></span> {</span><br><span class="line">  i := []<span class="keyword">int</span>{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>}</span><br><span class="line">  <span class="comment">// i中第1个角标位置插入4 5</span></span><br><span class="line">  gotInt := slices.Insert(i, <span class="number">1</span>, []<span class="keyword">int</span>{<span class="number">4</span>, <span class="number">5</span>}...)</span><br><span class="line">  fmt.Println(gotInt)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// f中第1个角标位置插入4.1, 5.6</span></span><br><span class="line">  f := []<span class="keyword">float64</span>{<span class="number">1.2</span>, <span class="number">2.2</span>, <span class="number">3.3</span>}</span><br><span class="line">  gotFloat64 := slices.Insert(f, <span class="number">1</span>, []<span class="keyword">float64</span>{<span class="number">4.1</span>, <span class="number">5.6</span>}...)</span><br><span class="line">  fmt.Println(gotFloat64)</span><br><span class="line"></span><br><span class="line">  s := []<span class="keyword">string</span>{<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>}</span><br><span class="line">  <span class="comment">// s中第1个角标位置插入"e", "f"</span></span><br><span class="line">  gotString := slices.Insert(s, <span class="number">1</span>, []<span class="keyword">string</span>{<span class="string">"e"</span>, <span class="string">"f"</span>}...)</span><br><span class="line">  fmt.Println(gotString)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 打印结果</span></span><br><span class="line">  <span class="comment">//[1 4 5 2 3]</span></span><br><span class="line">  <span class="comment">//[1.2 4.1 5.6 2.2 3.3]</span></span><br><span class="line">  <span class="comment">//[a e f b c]</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>更多介绍：<br>Go1.18 新特性–泛型<br>javascript:void(0)</p><h4 id="3-3-3-声明一个泛型map"><a href="#3-3-3-声明一个泛型map" class="headerlink" title="3.3.3 声明一个泛型map"></a>3.3.3 声明一个泛型map</h4><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">  testDemo01()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testDemo01</span><span class="params">()</span></span> {</span><br><span class="line">  <span class="keyword">type</span> M[K <span class="keyword">string</span>, V any] <span class="keyword">map</span>[K]V <span class="comment">//这里的K不支持any,由于底层map不支持,所以使用string</span></span><br><span class="line">  m1 := M[<span class="keyword">string</span>, <span class="keyword">int</span>]{<span class="string">"key"</span>: <span class="number">1</span>}</span><br><span class="line">  m1[<span class="string">"key"</span>] = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">  m2 := M[<span class="keyword">string</span>, <span class="keyword">string</span>]{<span class="string">"key"</span>: <span class="string">"value"</span>}</span><br><span class="line">  m2[<span class="string">"key"</span>] = <span class="string">"new value"</span></span><br><span class="line">  fmt.Println(m1, m2)</span><br><span class="line">  <span class="comment">//打印</span></span><br><span class="line">  <span class="comment">//map[key:2] map[key:new value]</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="3-3-4-声明一个泛型通道"><a href="#3-3-4-声明一个泛型通道" class="headerlink" title="3.3.4 声明一个泛型通道"></a>3.3.4 声明一个泛型通道</h4><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> C[T any] <span class="keyword">chan</span> T</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">  c1 := <span class="built_in">make</span>(C[<span class="keyword">int</span>], <span class="number">10</span>)</span><br><span class="line">  c1 &lt;- <span class="number">1</span></span><br><span class="line">  c1 &lt;- <span class="number">2</span></span><br><span class="line"></span><br><span class="line">  c2 := <span class="built_in">make</span>(C[<span class="keyword">string</span>], <span class="number">10</span>)</span><br><span class="line">  c2 &lt;- <span class="string">"hello"</span></span><br><span class="line">  c2 &lt;- <span class="string">"world"</span></span><br><span class="line"></span><br><span class="line">  fmt.Println(&lt;-c1, &lt;-c2)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//打印</span></span><br><span class="line">  <span class="comment">//1 hello</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="3-3-5-声明一个泛型struct"><a href="#3-3-5-声明一个泛型struct" class="headerlink" title="3.3.5 声明一个泛型struct"></a>3.3.5 声明一个泛型struct</h4><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"golang.org/x/exp/constraints"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vector[T constraints.Ordered] <span class="keyword">struct</span> {</span><br><span class="line">  x, y T</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vector[T])</span> <span class="title">Add</span><span class="params">(x, y T)</span></span> {</span><br><span class="line">  v.x += x</span><br><span class="line">  v.y += y</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vector[T])</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> {</span><br><span class="line">  <span class="keyword">return</span> fmt.Sprintf(<span class="string">"{x: %v, y: %v}"</span>, v.x, v.y)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewVector</span>[<span class="title">T</span> <span class="title">constraints</span>.<span class="title">Ordered</span>]<span class="params">(x, y T)</span> *<span class="title">Vector</span>[<span class="title">T</span>]</span> {</span><br><span class="line">  <span class="keyword">return</span> &amp;Vector[T]{x: x, y: y}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">  v := NewVector[<span class="keyword">float64</span>](<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">  v.Add(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">  fmt.Println(v)</span><br><span class="line"></span><br><span class="line">  v2 := NewVector[<span class="keyword">string</span>](<span class="string">"a"</span>, <span class="string">"b"</span>)</span><br><span class="line">  v2.Add(<span class="string">"1"</span>, <span class="string">"2"</span>)</span><br><span class="line">  fmt.Println(v2)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//打印：</span></span><br><span class="line">  <span class="comment">//{x: 3, y: 5}</span></span><br><span class="line">  <span class="comment">//{x: a1, y: b2}</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="3-3-6-泛型约束"><a href="#3-3-6-泛型约束" class="headerlink" title="3.3.6 泛型约束"></a>3.3.6 泛型约束</h4><p><strong>3.3.6.1 使用interface中规定的类型约束泛型函数的参数</strong></p><p>NumStr，新增了类型列表表达式，它是对类型参数进行约束。<br>使用 | 表示取并集<br>如果传入参数不在集合限制范围内，就会报错。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> NumStr <span class="keyword">interface</span> {</span><br><span class="line">  Num | Str</span><br><span class="line">}</span><br><span class="line"><span class="keyword">type</span> Num <span class="keyword">interface</span> {</span><br><span class="line">  ~<span class="keyword">int</span> | ~<span class="keyword">int8</span> | ~<span class="keyword">int16</span> | ~<span class="keyword">int32</span> | ~<span class="keyword">int64</span> | ~<span class="keyword">uint</span> | ~<span class="keyword">uint8</span> | ~<span class="keyword">uint16</span> | ~<span class="keyword">uint32</span> | ~<span class="keyword">uint64</span> | ~<span class="keyword">uintptr</span> | ~<span class="keyword">float32</span> | ~<span class="keyword">float64</span> | ~<span class="keyword">complex64</span> | ~<span class="keyword">complex128</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">type</span> Str <span class="keyword">interface</span> {</span><br><span class="line">  ~<span class="keyword">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span>[<span class="title">T</span> <span class="title">NumStr</span>]<span class="params">(a, b T)</span> <span class="title">T</span></span> {</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用interface中规定的类型约束泛型函数的参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">  fmt.Println(add(<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">  fmt.Println(add(<span class="string">"hello"</span>, <span class="string">"world"</span>))</span><br><span class="line"></span><br><span class="line">  <span class="comment">//打印</span></span><br><span class="line">  <span class="comment">//7</span></span><br><span class="line">  <span class="comment">//helloworld</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>3.3.6.2 使用interface中规定的方法来约束泛型的参数</strong></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"strconv"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ShowPrice <span class="keyword">interface</span> {</span><br><span class="line">  String() <span class="keyword">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Price <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i Price)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> {</span><br><span class="line">  <span class="keyword">return</span> strconv.Itoa(<span class="keyword">int</span>(i))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Price2 <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i Price2)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> {</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">string</span>(i)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ShowPriceList</span>[<span class="title">T</span> <span class="title">ShowPrice</span>]<span class="params">(s []T)</span> <span class="params">(ret []<span class="keyword">string</span>)</span></span> {</span><br><span class="line">  <span class="keyword">for</span> _, v := <span class="keyword">range</span> s {</span><br><span class="line">    ret = <span class="built_in">append</span>(ret, v.String())</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用interface中规定的方法来约束泛型的参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">  fmt.Printf(<span class="string">"%T %+v \n"</span>, ShowPriceList([]Price{<span class="number">1</span>, <span class="number">2</span>}), ShowPriceList([]Price{<span class="number">1</span>, <span class="number">2</span>}))</span><br><span class="line">  fmt.Printf(<span class="string">"%T %+v \n"</span>, ShowPriceList([]Price2{<span class="string">"a"</span>, <span class="string">"b"</span>}), ShowPriceList([]Price2{<span class="string">"a"</span>, <span class="string">"b"</span>}))</span><br><span class="line"></span><br><span class="line">  <span class="comment">//打印</span></span><br><span class="line">  <span class="comment">//[]string [1 2]</span></span><br><span class="line">  <span class="comment">//[]string [a b]</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>3.3.6.3 使用interface中规定的方法和类型来双重约束泛型的参数</strong></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"strconv"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ShowPrice <span class="keyword">interface</span> {</span><br><span class="line">  String() <span class="keyword">string</span></span><br><span class="line">  <span class="keyword">int</span> | <span class="keyword">string</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">type</span> Price <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i Price)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> {</span><br><span class="line">  <span class="keyword">return</span> strconv.Itoa(<span class="keyword">int</span>(i))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ShowPriceList</span>[<span class="title">T</span> <span class="title">ShowPrice</span>]<span class="params">(s []T)</span> <span class="params">(ret []<span class="keyword">string</span>)</span></span> {</span><br><span class="line">  <span class="keyword">for</span> _, v := <span class="keyword">range</span> s {</span><br><span class="line">    ret = <span class="built_in">append</span>(ret, v.String())</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用interface中规定的方法和类型来双重约束泛型的参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">  fmt.Printf(<span class="string">"%T %+v"</span>, ShowPriceList([]Price{<span class="number">1</span>, <span class="number">2</span>}), ShowPriceList([]Price{<span class="number">1</span>, <span class="number">2</span>}))</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//传入浮点参数，就会因为不是约束类型而报错</span></span><br><span class="line"><span class="comment">// .\main.go:27:36: Price does not implement ShowPrice (possibly missing ~ for int in constraint ShowPrice)</span></span><br></pre></td></tr></tbody></table></figure><p><strong>3.3.6.4 使用泛型自带comparable约束，判断比较</strong></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findFunc</span>[<span class="title">T</span> <span class="title">comparable</span>]<span class="params">(a []T, v T)</span> <span class="title">int</span></span> {</span><br><span class="line">  <span class="keyword">for</span> i, e := <span class="keyword">range</span> a {</span><br><span class="line">    <span class="keyword">if</span> e == v {</span><br><span class="line">      <span class="keyword">return</span> i</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">  fmt.Println(findFunc([]<span class="keyword">int</span>{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>}, <span class="number">5</span>))</span><br><span class="line">  fmt.Println(findFunc([]<span class="keyword">string</span>{<span class="string">"烤鸡"</span>, <span class="string">"烤鸭"</span>, <span class="string">"烤鱼"</span>, <span class="string">"烤面筋"</span>}, <span class="string">"烤面筋"</span>))</span><br><span class="line">  <span class="comment">// 打印</span></span><br><span class="line">  <span class="comment">// 4</span></span><br><span class="line">  <span class="comment">// 3</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4><a href="#" class="headerlink"></a></h4><p>参考文档：<br><a href="http://www.golang.ren/article/193584" target="_blank" rel="noopener">http://www.golang.ren/article/193584</a></p><p><a href="https://cdn.modb.pro/db/528594" target="_blank" rel="noopener">https://cdn.modb.pro/db/528594</a></p><!-- rebuild by neat --><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、什么是泛型&quot;&gt;&lt;a href=&quot;#一、什么是泛型&quot; class=&quot;headerlink&quot; title=&quot;一、什么是泛型&quot;&gt;&lt;/a&gt;一、什么是泛型&lt;/h2&gt;&lt;p&gt;泛型的英文是Generics，就是函数的参数，或者容器元素的类型，支持更广泛的类型，不再是特定的类型
      
    
    </summary>
    
    
      <category term="Go" scheme="http://chenzhonzhou.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="http://chenzhonzhou.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go 随机数</title>
    <link href="http://chenzhonzhou.github.io/2023/06/23/go-sui-ji-shu/"/>
    <id>http://chenzhonzhou.github.io/2023/06/23/go-sui-ji-shu/</id>
    <published>2023-06-23T12:48:53.000Z</published>
    <updated>2023-12-02T12:51:03.017Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go-随机数"><a href="#Go-随机数" class="headerlink" title="Go 随机数"></a>Go 随机数</h2><h3 id="math-rand"><a href="#math-rand" class="headerlink" title="math/rand"></a>math/rand</h3><p><code>math/rand</code>实现了伪随机数算法，和其它的编程语言类似，操作逻辑都是先设置随机数种子，然后再获取随机数序列。这样每次生成的随机数序列都是不一样的。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"math/rand"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">rand.Seed(time.Now().UnixNano())</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ {</span><br><span class="line"><span class="comment">// 生成0～99的随机数</span></span><br><span class="line">fmt.Println(rand.Intn(<span class="number">100</span>))</span><br><span class="line">        <span class="comment">// 生成1-99的随机数</span></span><br><span class="line">fmt.Println(rand.Intn(<span class="number">0</span><span class="number">-99</span>) + <span class="number">1</span>)</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>并且go还保证了上述的代码生成随机数是线程安全的，因为里面的操作加锁了，但可能有很少的场景强调效率，也可以自己创建一个伪随机源，这样就不会加锁了。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"math/rand"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">r := rand.New(rand.NewSource(time.Now().UnixNano()))</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ {</span><br><span class="line"><span class="comment">// 生成0～99的随机数</span></span><br><span class="line">fmt.Println(r.Intn(<span class="number">100</span>))</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="crypto-rand"><a href="#crypto-rand" class="headerlink" title="crypto/rand"></a>crypto/rand</h3><p>上面<code>math/rand</code>包生成的随机数是伪随机的，可以根据上一个随机数的值计算出下一个，只是在总体的分布上是均匀的，来模拟随机。<br>但有些场景需要密码学安全的随机数，也就是无法预测的随机数，所以go语言提供了<code>crypto/rand</code>包，里面提供了真随机数产生接口，满足密码学安全的需求。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"crypto/rand"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="comment">// Reader is a global, shared instance of a cryptographically</span></span><br><span class="line">    <span class="comment">// secure random number generator.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// On Linux and FreeBSD, Reader uses getrandom(2) if available, /dev/urandom otherwise.</span></span><br><span class="line">    <span class="comment">// On OpenBSD, Reader uses getentropy(2).</span></span><br><span class="line">    <span class="comment">// On other Unix-like systems, Reader reads from /dev/urandom.</span></span><br><span class="line">    <span class="comment">// On Windows systems, Reader uses the CryptGenRandom API.</span></span><br><span class="line">    <span class="comment">// On Wasm, Reader uses the Web Crypto API.</span></span><br><span class="line">rand.Read(b)</span><br><span class="line">fmt.Println(b)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="linux-真随机数"><a href="#linux-真随机数" class="headerlink" title="linux 真随机数"></a>linux 真随机数</h3><p>为了获得真正意义上的随机数，需要一个外部的噪声源。Linux内核找到了一个完美的噪声源产生者–就是使用计算机的人。<br>内核根据非确定性的设备事件维护着一个熵池，池中的数据是完全随机的。当有新的设备事件到来，内核会估计新加入的数据的随机性，当我们从熵池中取出数据时，内核会减少熵的估计值。<br><code>/dev/random</code>和<code>/dev/urandom</code>这两个特殊设备都是字符型设备。我们可以在用户空间通过read系统调用读这两个设备文件以此获取随机数。这两个设备文件的区别在于：如果内核熵池的估计值为0时，<code>/dev/random</code>将被阻塞，而<code>/dev/urandom</code>不会有这个限制。</p><!-- rebuild by neat --><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go-随机数&quot;&gt;&lt;a href=&quot;#Go-随机数&quot; class=&quot;headerlink&quot; title=&quot;Go 随机数&quot;&gt;&lt;/a&gt;Go 随机数&lt;/h2&gt;&lt;h3 id=&quot;math-rand&quot;&gt;&lt;a href=&quot;#math-rand&quot; class=&quot;headerlink
      
    
    </summary>
    
    
      <category term="Go" scheme="http://chenzhonzhou.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="http://chenzhonzhou.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go 使用toml配置文件</title>
    <link href="http://chenzhonzhou.github.io/2023/06/08/go-shi-yong-toml-pei-zhi-wen-jian/"/>
    <id>http://chenzhonzhou.github.io/2023/06/08/go-shi-yong-toml-pei-zhi-wen-jian/</id>
    <published>2023-06-08T13:37:11.000Z</published>
    <updated>2023-12-02T13:53:21.150Z</updated>
    
    <content type="html"><![CDATA[<p>我们常见的一些配置文件包括，yaml、xml、toml、json和ini。</p><p>今天我们就来介绍这个toml配置文件，在go语言中的使用。<br>toml（Tom’s Obvious， Minimal Language），简约又明显的语言。</p><p>使用的包是：<a href="https://github.com/BurntSushi/toml" target="_blank" rel="noopener">github.com/BurntSushi/toml</a></p><h3 id="安装-toml-包"><a href="#安装-toml-包" class="headerlink" title="安装 toml 包"></a>安装 toml 包</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/BurntSushi/toml@latest</span><br></pre></td></tr></tbody></table></figure><h3 id="创建-toml-配置文件"><a href="#创建-toml-配置文件" class="headerlink" title="创建 toml 配置文件"></a>创建 toml 配置文件</h3><p>首先，创建一个 TOML 配置文件，例如 <code>config.toml</code>，并在其中存储你的配置信息。以下是一个简单的 TOML 配置文件示例</p><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This is a TOML document. Boom.</span></span><br><span class="line"></span><br><span class="line"><span class="attr">title</span> = <span class="string">"TOML Example"</span></span><br><span class="line"></span><br><span class="line"><span class="section">[owner]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">"Tom Preston-Werner"</span></span><br><span class="line"><span class="attr">organization</span> = <span class="string">"ABC"</span></span><br><span class="line"><span class="attr">bio</span> = <span class="string">"GitHub Cofounder &amp; CEO\nLikes tater tots and beer."</span></span><br><span class="line"><span class="attr">dob</span> = <span class="number">1979</span>-<span class="number">05</span>-<span class="number">27</span>T07:<span class="number">32</span>:<span class="number">00</span>Z <span class="comment"># First class dates? Why not?</span></span><br><span class="line"></span><br><span class="line"><span class="section">[database]</span></span><br><span class="line"><span class="attr">server</span> = <span class="string">"192.168.1.1"</span></span><br><span class="line"><span class="attr">ports</span> = [ <span class="number">8001</span>, <span class="number">8001</span>, <span class="number">8002</span> ]</span><br><span class="line"><span class="attr">connection_max</span> = <span class="number">5000</span></span><br><span class="line"><span class="attr">enabled</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="section">[servers]</span></span><br><span class="line">  <span class="comment"># You can indent as you please. Tabs or spaces. TOML don't care.</span></span><br><span class="line"><span class="section">  [servers.alpha]</span></span><br><span class="line">  ip = "10.0.0.1"</span><br><span class="line">  dc = "eqdc10"</span><br><span class="line"></span><br><span class="line"><span class="section">  [servers.beta]</span></span><br><span class="line">  ip = "10.0.0.2"</span><br><span class="line">  dc = "eqdc10"</span><br><span class="line"></span><br><span class="line"><span class="section">[clients]</span></span><br><span class="line"><span class="attr">data</span> = [ [<span class="string">"gamma"</span>, <span class="string">"delta"</span>], [<span class="number">1</span>, <span class="number">2</span>],[<span class="literal">true</span>, <span class="literal">false</span>] ] <span class="comment"># just an update to make sure parsers support it</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Line breaks are OK when inside arrays</span></span><br><span class="line"><span class="attr">hosts</span> = [</span><br><span class="line">  "alpha",</span><br><span class="line">  "omega"</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure><h3 id="读取-toml-配置文件"><a href="#读取-toml-配置文件" class="headerlink" title="读取 toml 配置文件"></a>读取 toml 配置文件</h3><p>更复杂的示例：<a href="https://github.com/BurntSushi/toml/tree/master/_example" target="_blank" rel="noopener">https://github.com/BurntSushi/toml/tree/master/_example</a></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/BurntSushi/toml"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> tomlConfig <span class="keyword">struct</span> {</span><br><span class="line">Title   <span class="keyword">string</span></span><br><span class="line">Owner   ownerInfo</span><br><span class="line">DB      database <span class="string">`toml:"database"`</span></span><br><span class="line">Servers <span class="keyword">map</span>[<span class="keyword">string</span>]server</span><br><span class="line">Clients clients</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ownerInfo <span class="keyword">struct</span> {</span><br><span class="line">Name <span class="keyword">string</span>    <span class="string">`toml:"name"`</span></span><br><span class="line">Org  <span class="keyword">string</span>    <span class="string">`toml:"organization"`</span></span><br><span class="line">Bio  <span class="keyword">string</span>    <span class="string">`toml:"bio"`</span></span><br><span class="line">DOB  time.Time <span class="string">`toml:"bob"`</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> database <span class="keyword">struct</span> {</span><br><span class="line">Server  <span class="keyword">string</span> <span class="string">`toml:"server"`</span></span><br><span class="line">Ports   []<span class="keyword">int</span>  <span class="string">`toml:"ports"`</span></span><br><span class="line">CommMax <span class="keyword">int64</span>  <span class="string">`toml:"connection_max"`</span></span><br><span class="line">Enabled <span class="keyword">bool</span>   <span class="string">`toml:"enabled"`</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> server <span class="keyword">struct</span> {</span><br><span class="line">IP <span class="keyword">string</span> <span class="string">`toml:"ip"`</span></span><br><span class="line">DC <span class="keyword">string</span> <span class="string">`toml:"dc"`</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> clients <span class="keyword">struct</span> {</span><br><span class="line">Data  [][]<span class="keyword">interface</span>{} <span class="string">`toml:"data"`</span></span><br><span class="line">Hosts []<span class="keyword">string</span>        <span class="string">`toml:"hosts"`</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readToml</span><span class="params">()</span></span> {</span><br><span class="line"><span class="keyword">var</span> config tomlConfig</span><br><span class="line"><span class="keyword">if</span> _, err := toml.DecodeFile(<span class="string">"conf/config.toml"</span>, &amp;config); err != <span class="literal">nil</span> {</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"Title: %s\n"</span>, config.Title)</span><br><span class="line">fmt.Println()</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"Owner: %s (%s, %s), Born: %s\n"</span>,</span><br><span class="line">config.Owner.Name, config.Owner.Org, config.Owner.Bio, config.Owner.DOB)</span><br><span class="line">fmt.Println()</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"Database: %s %v (Max conn, %d), Enable? %v\n"</span>,</span><br><span class="line">config.DB.Server, config.DB.Ports, config.DB.CommMax, config.DB.Enabled)</span><br><span class="line">fmt.Println()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> serverName, server := <span class="keyword">range</span> config.Servers {</span><br><span class="line">fmt.Printf(<span class="string">"Server: %s (%s, %s)\n"</span>, serverName, server.IP, server.DC)</span><br><span class="line">}</span><br><span class="line">fmt.Println()</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"Client data: %v\n"</span>, config.Clients.Data)</span><br><span class="line">fmt.Printf(<span class="string">"Client hosts: %v\n"</span>, config.Clients.Hosts)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">readToml()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>输出结果：</strong></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Title: TOML Example</span><br><span class="line"></span><br><span class="line">Owner: Tom Preston-Werner (ABC, GitHub Cofounder &amp; CEO</span><br><span class="line">Likes tater tots and beer.), Born: <span class="number">0001</span><span class="number">-01</span><span class="number">-01</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> +<span class="number">0000</span> UTC</span><br><span class="line"></span><br><span class="line">Database: <span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span> [<span class="number">8001</span> <span class="number">8001</span> <span class="number">8002</span>] (Max conn, <span class="number">5000</span>), Enable? <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">Server: alpha (<span class="number">10.0</span><span class="number">.0</span><span class="number">.1</span>, eqdc10)</span><br><span class="line">Server: beta (<span class="number">10.0</span><span class="number">.0</span><span class="number">.2</span>, eqdc10)</span><br><span class="line"></span><br><span class="line">Client data: [[gamma delta] [<span class="number">1</span> <span class="number">2</span>] [<span class="literal">true</span> <span class="literal">false</span>]]</span><br><span class="line">Client hosts: [alpha omega]</span><br></pre></td></tr></tbody></table></figure><!-- rebuild by neat --><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们常见的一些配置文件包括，yaml、xml、toml、json和ini。&lt;/p&gt;&lt;p&gt;今天我们就来介绍这个toml配置文件，在go语言中的使用。&lt;br&gt;toml（Tom’s Obvious， Minimal Language），简约又明显的语言。&lt;/p&gt;&lt;p&gt;使用的包是：
      
    
    </summary>
    
    
      <category term="Go" scheme="http://chenzhonzhou.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="http://chenzhonzhou.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go Protobuf 编解码使用</title>
    <link href="http://chenzhonzhou.github.io/2023/05/18/go-protobuf-bian-jie-ma-shi-yong/"/>
    <id>http://chenzhonzhou.github.io/2023/05/18/go-protobuf-bian-jie-ma-shi-yong/</id>
    <published>2023-05-18T09:29:26.000Z</published>
    <updated>2023-12-02T09:33:28.039Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Protobuf"><a href="#Protobuf" class="headerlink" title="Protobuf"></a>Protobuf</h2><p>Protobuf是Protocol Buffers的简称，它是Google公司开发的一种数据描述语言，并于2008年对外开源。Protobuf刚开源时的定位类似于XML、JSON等数据描述语言，通过附带工具生成代码并实现将结构化数据序列化的功能。但是我们更关注的是Protobuf作为接口规范的描述语言，可以作为设计安全的跨语言PRC接口的基础工具</p><h3 id="为什么选择Protobuf"><a href="#为什么选择Protobuf" class="headerlink" title="为什么选择Protobuf"></a>为什么选择Protobuf</h3><p>一般而言我们需要一种编解码工具会参考:</p><ul><li>编解码效率</li><li>高压缩比</li><li>多语言支持</li></ul><p>其中压缩与效率 最被关注的点:</p><p><img src="/2023/05/18/go-protobuf-bian-jie-ma-shi-yong/%E5%9B%BE%E7%89%871.png" alt="图片1"></p><h3 id="使用流程"><a href="#使用流程" class="headerlink" title="使用流程"></a>使用流程</h3><p>首先需要定义我们的数据，通过编译器，来生成不同语言的代码</p><p><img src="/2023/05/18/go-protobuf-bian-jie-ma-shi-yong/%E5%9B%BE%E7%89%872.png" alt="图片2"></p><p>首先创建hello.proto文件，其中包装HelloService服务中用到的字符串类型</p><figure class="highlight protobuf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;comment&gt;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span>  &lt;<span class="title">message_name</span>&gt; </span>{</span><br><span class="line">  &lt;filed_rule&gt;  &lt;filed_type&gt; &lt;filed_name&gt; = &lt;field_number&gt; </span><br><span class="line">        类型         名称             编号  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>comment: 注射 /* */或者 //</li><li>message_name: 同一个pkg内，必须唯一</li><li>filed_rule: 可以没有, 常用的有repeated, oneof</li><li>filed_type: 数据类型, protobuf定义的数据类型, 生产代码的会映射成对应语言的数据类型</li><li>filed_name: 字段名称, 同一个message 内必须唯一</li><li>field_number: 字段的编号, 序列化成二进制数据时的字段编号, 同一个message 内必须唯一, 1 ~ 15 使用1个Byte表示, 16 ～ 2047 使用2个Byte表示</li></ul><h2 id="安装编译器"><a href="#安装编译器" class="headerlink" title="安装编译器"></a>安装编译器</h2><p>protobuf的编译器叫: protoc(protobuf compiler), 我们需要到这里下载编译器: <a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fprotocolbuffers%2Fprotobuf%2Freleases">Github Protobuf</a></p><p>压缩包文件包含：</p><ul><li>include, 头文件或者库文件</li><li>bin, protoc编译器</li><li>readme.txt, 一定要看，按照这个来进行安装</li></ul><h3 id="安装编译器二进制"><a href="#安装编译器二进制" class="headerlink" title="安装编译器二进制"></a>安装编译器二进制</h3><p>linux/unix系统直接:</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv bin/protoc usr/bin</span><br></pre></td></tr></tbody></table></figure><p>windows系统:</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">注意: Windows 上的 git-bash 上默认的 /usr/bin 目录在：C:\Program Files\Git\usr\bin\</span><br><span class="line"></span><br><span class="line">因此我们首先将bin下的 protoc 编译器 挪到C:\Program Files\Git\usr\bin\</span><br></pre></td></tr></tbody></table></figure><h3 id="安装编译器库"><a href="#安装编译器库" class="headerlink" title="安装编译器库"></a>安装编译器库</h3><p>include 下的库文件需要安装到: /usr/local/include/</p><p>linux/unix系统直接:</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv include/google /usr/local/include</span><br></pre></td></tr></tbody></table></figure><p>windows系统:</p><figure class="highlight bat"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">Program</span> <span class="title">Files</span>\<span class="title">Git</span>\<span class="title">usr</span>\<span class="title">lib</span>\<span class="title">include</span></span></span><br></pre></td></tr></tbody></table></figure><h3 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> protoc --version</span></span><br><span class="line">libprotoc 3.19.1</span><br></pre></td></tr></tbody></table></figure><h3 id="安装Go语言插件"><a href="#安装Go语言插件" class="headerlink" title="安装Go语言插件"></a>安装Go语言插件</h3><p>Protobuf核心的工具集是C++语言开发的，在官方的protoc编译器中并不支持Go语言。要想基于上面的hello.proto文件生成相应的Go代码，需要安装相应的插件</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> install google.golang.org/protobuf/cmd/protoc-gen-<span class="keyword">go</span>@latest</span><br></pre></td></tr></tbody></table></figure><p>接下来 我们就可以使用protoc 来生成我们对应的Go语言的数据结构</p><h2 id="定义Protobuf消息类型"><a href="#定义Protobuf消息类型" class="headerlink" title="定义Protobuf消息类型"></a>定义Protobuf消息类型</h2><h3 id="编写-proto包文件"><a href="#编写-proto包文件" class="headerlink" title="编写.proto包文件"></a>编写.proto包文件</h3><p>消息类型定义在.proto包中，我们这里创建个person.proto 文件，将以下的经典的示例写法写入：</p><figure class="highlight protobuf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">"proto3"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span> go_package = <span class="string">"/person"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> example;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Person</span> </span>{</span><br><span class="line">    <span class="built_in">string</span> name = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">int32</span> age = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">repeated</span> <span class="built_in">string</span> hobbies = <span class="number">3</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>syntax: 表示采用proto3的语法。第三版的Protobuf对语言进行了提炼简化，所有成员均采用类似Go语言中的零值初始化（不再支持自定义默认值），因此消息成员也不再需要支持required特性。</li><li>package example：指定消息类型所在的包名，这里包名是 example`。</li><li>option go_package = “/person”;用于指定生成的 Go 代码的包名（package name）及导入路径（import path）。</li><li>message Person { … }：定义一个名为 Person 的消息类型。</li><li>string name = 1：定义一个名为 name 的字符串类型字段，该字段的标签号为 1。int32 age = 2：定义一个名为 age 的整型字段，该字段的标签号为 2。</li><li>repeated string hobbies = 3：定义一个名为 hobbies 的字符串数组类型字段，该字段的标签号为 3。repeated 关键字表示该字段是一个数组类型。</li></ul><p>这个.proto文件中定义了一个名为 Person 的消息类型，包含了 name、age 和 hobbies 三个字段。name 和 age 都是普通的单值类型字段，hobbies 是一个字符串数组类型字段。在这个文件中，每个字段都有一个唯一的标签号，用于标识这个字段在二进制编码中的位置和类型</p><h3 id="使用protoc生成GO代码"><a href="#使用protoc生成GO代码" class="headerlink" title="使用protoc生成GO代码"></a>使用protoc生成GO代码</h3><p>在此文件的目录下，运行以下命令，即可生成GO代码。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --go_out=. *.proto</span><br></pre></td></tr></tbody></table></figure><p>运行后，我们可以看到该目录下多出了一个person文件夹，里面包含 Go 文件 person.pb.go。这个文件内部定义了一个结构体 Person，以及相关的方法:</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> {</span><br><span class="line">   state         protoimpl.MessageState</span><br><span class="line">   sizeCache     protoimpl.SizeCache</span><br><span class="line">   unknownFields protoimpl.UnknownFields</span><br><span class="line"></span><br><span class="line">   Name    <span class="keyword">string</span>   <span class="string">`protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`</span></span><br><span class="line">   Age     <span class="keyword">int32</span>    <span class="string">`protobuf:"varint,2,opt,name=age,proto3" json:"age,omitempty"`</span></span><br><span class="line">   Hobbies []<span class="keyword">string</span> <span class="string">`protobuf:"bytes,3,rep,name=hobbies,proto3" json:"hobbies,omitempty"`</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>除了结构体外，还有很多方法，这些方法提供了对 Protocol Buffers 消息进行编码、解码和操作的基础设施，有以下几个主要的方法。</p><p>除了结构体外，还有很多方法，这些方法提供了对 Protocol Buffers 消息进行编码、解码和操作的基础设施，有以下几个主要的方法。</p><ul><li><code>func (*Person) Reset()</code>: 将 Person 消息重置为默认值。</li><li><code>func (*Person) String() string</code>: 返回一个字符串，包含 Person 消息的文本表示形式。</li><li><code>func (*Person) ProtoMessage()</code>: 使 Person 结构体实现 proto.Message 接口，这是在序列化和反序列化 Protobuf 消息时所需的。</li><li><code>func (*Person) Descriptor() ([]byte, []int)</code>: 返回关于 Person 消息类型的描述符信息。</li><li><code>func (*Person) GetName() string</code>: 返回 Person 消息中 Name 字段的值。</li><li><code>func (*Person) GetAge() int32</code>: 返回 Person 消息中 Age 字段的值。</li></ul><p>写一个简单的测试</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">p := &amp;Person.Person{Name: <span class="string">"yzy"</span>, Age: <span class="number">23</span>, Hobbies: []<span class="keyword">string</span>{<span class="string">"music"</span>, <span class="string">"sport"</span>}}</span><br><span class="line">fmt.Println(<span class="string">"string"</span>, p.String())</span><br><span class="line">fmt.Println(<span class="string">"the data:"</span>, p.Name, p.Age, p.Hobbies)</span><br><span class="line"></span><br><span class="line"><span class="comment">// fmt.Println("-----------")</span></span><br><span class="line">fmt.Println(<span class="string">"reset the person"</span>)</span><br><span class="line">fmt.Println(<span class="string">"-----------"</span>)</span><br><span class="line"></span><br><span class="line">p.Reset()</span><br><span class="line">fmt.Println(<span class="string">"string"</span>, p.String())</span><br><span class="line">fmt.Println(<span class="string">"the data:"</span>, p.Name, p.Age, p.Hobbies)</span><br><span class="line"><span class="comment">// 运行后可以看到，get、string、reset都正常运行。</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="序列化和反序列化消息"><a href="#序列化和反序列化消息" class="headerlink" title="序列化和反序列化消息"></a>序列化和反序列化消息</h3><p>序列化和反序列化函数在<code>github.com/golang/protobuf/proto</code>包中，这个包刚刚我们已经通过go get获取过了，所以可以直接使用，以下是一个序列化和非序列化的使用示例，并且比较了序列化前和经过序列化后的数据是否一致。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestPersonSerialization</span><span class="params">(t *testing.T)</span></span> {</span><br><span class="line"><span class="comment">// 创建一个 Person 消息实例并设置其字段</span></span><br><span class="line">p := &amp;Person{Name: <span class="string">"yzy"</span>, Age: <span class="number">23</span>, Hobbies: []<span class="keyword">string</span>{<span class="string">"music"</span>, <span class="string">"sport"</span>}}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将消息序列化为二进制格式</span></span><br><span class="line">data, err := proto.Marshal(p)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">t.Fatal(<span class="string">"marshaling error: "</span>, err)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反序列化消息</span></span><br><span class="line">p2 := &amp;Person{}</span><br><span class="line">err = proto.Unmarshal(data, p2)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">t.Fatal(<span class="string">"unmarshaling error: "</span>, err)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较原始消息和反序列化后的消息</span></span><br><span class="line"><span class="keyword">if</span> p.String() != p2.String() {</span><br><span class="line">t.Fatalf(<span class="string">"original message %v != unmarshaled message %v"</span>, p, p2)</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">fmt.Println(<span class="string">"数据一致"</span>)</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="字段类型"><a href="#字段类型" class="headerlink" title="字段类型"></a>字段类型</h3><p>字段类型部分参考<a href="https://geektutu.com/post/quick-go-protobuf.html" target="_blank" rel="noopener">Go Protobuf 简明教程 </a>.</p><h4 id="标量类型-Scalar"><a href="#标量类型-Scalar" class="headerlink" title="标量类型(Scalar)"></a>标量类型(Scalar)</h4><table><thead><tr><th>proto类型</th><th>go类型</th><th>备注</th></tr></thead><tbody><tr><td>double</td><td>float64</td><td></td></tr><tr><td>float</td><td>float32</td><td></td></tr><tr><td>int32</td><td>int32</td><td></td></tr><tr><td>int64</td><td>int64</td><td></td></tr><tr><td>uint32</td><td>uint32</td><td></td></tr><tr><td>uint64</td><td>uint64</td><td></td></tr><tr><td>sint32</td><td>int32</td><td>适合负数</td></tr><tr><td>sint64</td><td>int64</td><td>适合负数</td></tr><tr><td>fixed32</td><td>uint32</td><td>固长编码，适合大于2^28的值</td></tr><tr><td>fixed64</td><td>uint64</td><td>固长编码，适合大于2^56的值</td></tr><tr><td>sfixed32</td><td>int32</td><td>固长编码</td></tr><tr><td>sfixed64</td><td>int64</td><td>固长编码</td></tr><tr><td>bool</td><td>bool</td><td></td></tr><tr><td>string</td><td>string</td><td>UTF8 编码，长度不超过 2^32</td></tr><tr><td>bytes</td><td>[]byte</td><td>任意字节序列，长度不超过 2^32</td></tr></tbody></table><p>标量类型如果没有被赋值，则不会被序列化，解析时，会赋予默认值。</p><ul><li>strings：空字符串</li><li>bytes：空序列</li><li>bools：false</li><li>数值类型：0</li></ul><h4 id="枚举-Enumerations"><a href="#枚举-Enumerations" class="headerlink" title="枚举(Enumerations)"></a>枚举(Enumerations)</h4><p>枚举类型适用于提供一组预定义的值，选择其中一个。例如我们将性别定义为枚举类型。</p><figure class="highlight protobuf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Student</span> </span>{</span><br><span class="line">  <span class="built_in">string</span> name = <span class="number">1</span>;</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">Gender</span> </span>{</span><br><span class="line">    FEMALE = <span class="number">0</span>;</span><br><span class="line">    MALE = <span class="number">1</span>;</span><br><span class="line">  }</span><br><span class="line">  Gender gender = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">repeated</span> <span class="built_in">int32</span> scores = <span class="number">3</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>枚举类型的第一个选项的标识符必须是0，这也是枚举类型的默认值。</li><li>别名（Alias），允许为不同的枚举值赋予相同的标识符，称之为别名，需要打开<code>allow_alias</code>选项。</li><li>预留值，枚举也支持<code>reserved</code> 预留值</li></ul><figure class="highlight protobuf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">EnumAllowAlias</span> </span>{</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">Status</span> </span>{</span><br><span class="line">    <span class="keyword">option</span> allow_alias = <span class="literal">true</span>;</span><br><span class="line">    UNKOWN = <span class="number">0</span>;</span><br><span class="line">    STARTED = <span class="number">1</span>;</span><br><span class="line">    RUNNING = <span class="number">1</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">Foo</span> </span>{</span><br><span class="line">    A = <span class="number">0</span>;</span><br><span class="line">    B = <span class="number">1</span>;</span><br><span class="line">    reserved <span class="number">2</span>, <span class="number">15</span>, <span class="number">9</span> to <span class="number">11</span>, <span class="number">40</span> to max;</span><br><span class="line">    reserved <span class="string">"FOO"</span>, <span class="string">"BAR"</span>;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h4><p>如果我们想声明: <code>[]string</code>,<code>[]Item</code> 这在数组类型怎么办? <code>filed_rule: repeated</code> 可以胜任</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">message SearchResponse {</span><br><span class="line">  repeated Result results = 1;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 会编译为:</span><br><span class="line">// type SearchResponse SearchResponse {</span><br><span class="line">//    results []*Result</span><br><span class="line">// }</span><br></pre></td></tr></tbody></table></figure><h4 id="使用其他消息类"><a href="#使用其他消息类" class="headerlink" title="使用其他消息类"></a>使用其他消息类</h4><p><code>Result</code>是另一个消息类型，在 SearchReponse 作为一个消息字段类型使用。</p><figure class="highlight protobuf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">SearchResponse</span> </span>{</span><br><span class="line">  <span class="keyword">repeated</span> Result results = <span class="number">1</span>; </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Result</span> </span>{</span><br><span class="line">  <span class="built_in">string</span> url = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">string</span> title = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">repeated</span> <span class="built_in">string</span> snippets = <span class="number">3</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>嵌套写也是支持的：</p><figure class="highlight protobuf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">SearchResponse</span> </span>{</span><br><span class="line">  <span class="class"><span class="keyword">message</span> <span class="title">Result</span> </span>{</span><br><span class="line">    <span class="built_in">string</span> url = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">string</span> title = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">repeated</span> <span class="built_in">string</span> snippets = <span class="number">3</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">repeated</span> Result results = <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果定义在其他文件中，可以导入其他消息类型来使用：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"myproject/other_protos.proto"</span>;</span><br></pre></td></tr></tbody></table></figure><h4 id="任意类型-Any"><a href="#任意类型-Any" class="headerlink" title="任意类型(Any)"></a>任意类型(Any)</h4><p>当我们无法明确定义数据类型的时候， 可以使用Any表示</p><figure class="highlight protobuf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"google/protobuf/any.proto"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">ErrorStatus</span> </span>{</span><br><span class="line">  <span class="built_in">string</span> <span class="class"><span class="keyword">message</span> = 1;</span></span><br><span class="line"><span class="class">  <span class="title">repeated</span> google.protobuf.Any details = 2;</span></span><br><span class="line"><span class="class">}</span></span><br></pre></td></tr></tbody></table></figure><p>any本质上就是一个bytes数据结构</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ErrorStatus <span class="keyword">struct</span> {</span><br><span class="line">state         protoimpl.MessageState</span><br><span class="line">sizeCache     protoimpl.SizeCache</span><br><span class="line">unknownFields protoimpl.UnknownFields</span><br><span class="line"></span><br><span class="line">Message <span class="keyword">string</span>       <span class="string">`protobuf:"bytes,1,opt,name=message,proto3" json:"message,omitempty"`</span></span><br><span class="line">Details []*anypb.Any <span class="string">`protobuf:"bytes,2,rep,name=details,proto3" json:"details,omitempty"`</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="oneof"><a href="#oneof" class="headerlink" title="oneof"></a>oneof</h4><p>很像范型 比如 test_oneof 字段的类型 必须是 string name 和 SubMessage sub_message 其中之一:</p><figure class="highlight protobuf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Sub1</span> </span>{</span><br><span class="line">    <span class="built_in">string</span> name = <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Sub2</span> </span>{</span><br><span class="line">    <span class="built_in">string</span> name = <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">SampleMessage</span> </span>{</span><br><span class="line">    <span class="keyword">oneof</span> test_oneof {</span><br><span class="line">        Sub1 sub1 = <span class="number">1</span>;</span><br><span class="line">        Sub2 sub2 = <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">protoc -I=. --go_out=./pb --go_opt=module=<span class="string">"/pb"</span> pb/<span class="keyword">oneof</span>.proto</span><br></pre></td></tr></tbody></table></figure><p>编译过后结构体</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SampleMessage <span class="keyword">struct</span> {</span><br><span class="line">state         protoimpl.MessageState</span><br><span class="line">sizeCache     protoimpl.SizeCache</span><br><span class="line">unknownFields protoimpl.UnknownFields</span><br><span class="line"></span><br><span class="line"><span class="comment">// Types that are assignable to TestOneof:</span></span><br><span class="line"><span class="comment">//*SampleMessage_Sub1</span></span><br><span class="line"><span class="comment">//*SampleMessage_Sub2</span></span><br><span class="line">TestOneof isSampleMessage_TestOneof <span class="string">`protobuf_oneof:"test_oneof"`</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>那我们如何使用喃:</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">of := &amp;pb.SampleMessage{}</span><br><span class="line">of.GetSub1()</span><br><span class="line">of.GetSub2()</span><br></pre></td></tr></tbody></table></figure><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p>如果我们想声明一个map, 可以如下进行</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">map</span>&lt;<span class="keyword">string</span>, Project&gt; projects = <span class="number">3</span>;</span><br><span class="line"><span class="comment">// projects map[string, Project]</span></span><br></pre></td></tr></tbody></table></figure><p>protobuf 声明map的语法:</p><figure class="highlight protobuf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map&lt;key_type, value_type&gt; map_field = N;</span><br></pre></td></tr></tbody></table></figure><figure class="highlight protobuf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">MapRequest</span> </span>{</span><br><span class="line">  map&lt;<span class="built_in">string</span>, <span class="built_in">int32</span>&gt; points = <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="类型嵌套"><a href="#类型嵌套" class="headerlink" title="类型嵌套"></a>类型嵌套</h4><p>我们可以再message里面嵌套message</p><figure class="highlight protobuf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Outer</span> </span>{                  <span class="comment">// Level 0</span></span><br><span class="line">  <span class="class"><span class="keyword">message</span> <span class="title">MiddleAA</span> </span>{  <span class="comment">// Level 1</span></span><br><span class="line">    <span class="class"><span class="keyword">message</span> <span class="title">Inner</span> </span>{   <span class="comment">// Level 2</span></span><br><span class="line">      <span class="built_in">int64</span> ival = <span class="number">1</span>;</span><br><span class="line">      <span class="built_in">bool</span>  booly = <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="class"><span class="keyword">message</span> <span class="title">MiddleBB</span> </span>{  <span class="comment">// Level 1</span></span><br><span class="line">    <span class="class"><span class="keyword">message</span> <span class="title">Inner</span> </span>{   <span class="comment">// Level 2</span></span><br><span class="line">      <span class="built_in">int32</span> ival = <span class="number">1</span>;</span><br><span class="line">      <span class="built_in">bool</span>  booly = <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>与Go结构体嵌套一样, 但是不允许 匿名嵌套, 必须指定字段名称</p><h3 id="定义服务-Services"><a href="#定义服务-Services" class="headerlink" title="定义服务(Services)"></a>定义服务(Services)</h3><p>如果消息类型是用来远程通信的(Remote Procedure Call, RPC)，可以在 .proto 文件中定义 RPC 服务接口。例如我们定义了一个名为 SearchService 的 RPC 服务，提供了 <code>Search</code> 接口，入参是 <code>SearchRequest</code> 类型，返回类型是 <code>SearchResponse</code></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">service SearchService {</span><br><span class="line">  rpc Search (SearchRequest) returns (SearchResponse);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>官方仓库也提供了一个<a href="https://github.com/protocolbuffers/protobuf/blob/master/docs/third_party.md" target="_blank" rel="noopener">插件列表</a>，帮助开发基于 Protocol Buffer 的 RPC 服务。</p><h3 id="protoc-其他参数"><a href="#protoc-其他参数" class="headerlink" title="protoc 其他参数"></a>protoc 其他参数</h3><p>命令行使用方法</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --proto_path=IMPORT_PATH --&lt;lang&gt;_out=DST_DIR path/to/file.proto</span><br></pre></td></tr></tbody></table></figure><ul><li><code>--proto_path=IMPORT_PATH</code>：可以在 .proto 文件中 import 其他的 .proto 文件，proto_path 即用来指定其他 .proto 文件的查找目录。如果没有引入其他的 .proto 文件，该参数可以省略。</li><li><code>--&lt;lang&gt;_out=DST_DIR</code>：指定生成代码的目标文件夹，例如 –go_out=. 即生成 GO 代码在当前文件夹，另外支持 cpp/java/python/ruby/objc/csharp/php 等语言</li></ul><p>更多请参考 <a href="https://protobuf.dev/programming-guides/proto3/#updating" target="_blank" rel="noopener">Updating A Message Type</a></p><h3 id="推荐风格"><a href="#推荐风格" class="headerlink" title="推荐风格"></a>推荐风格</h3><ul><li>文件(Files)<ul><li>文件名使用小写下划线的命名风格，例如 lower_snake_case.proto</li><li>每行不超过 80 字符</li><li>使用 2 个空格缩进</li></ul></li><li>包(Packages)<ul><li>包名应该和目录结构对应，例如文件在<code>my/package/</code>目录下，包名应为 <code>my.package</code></li></ul></li><li>消息和字段(Messages &amp; Fields)<ul><li>消息名使用首字母大写驼峰风格(CamelCase)，例如<code>message StudentRequest { ... }</code></li><li>字段名使用小写下划线的风格，例如 <code>string status_code = 1</code></li><li>枚举类型，枚举名使用首字母大写驼峰风格，例如 <code>enum FooBar</code>，枚举值使用全大写下划线隔开的风格(CAPITALS_WITH_UNDERSCORES )，例如 FOO_DEFAULT=1</li></ul></li><li>服务(Services)<ul><li>RPC 服务名和方法名，均使用首字母大写驼峰风格，例如<code>service FooService{ rpc GetSomething() }</code></li></ul></li></ul><!-- rebuild by neat --><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Protobuf&quot;&gt;&lt;a href=&quot;#Protobuf&quot; class=&quot;headerlink&quot; title=&quot;Protobuf&quot;&gt;&lt;/a&gt;Protobuf&lt;/h2&gt;&lt;p&gt;Protobuf是Protocol Buffers的简称，它是Google公司开发的一种数据
      
    
    </summary>
    
    
      <category term="Go" scheme="http://chenzhonzhou.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="http://chenzhonzhou.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>GO GORM库</title>
    <link href="http://chenzhonzhou.github.io/2023/05/15/go-gorm-ku/"/>
    <id>http://chenzhonzhou.github.io/2023/05/15/go-gorm-ku/</id>
    <published>2023-05-15T03:32:35.000Z</published>
    <updated>2023-12-02T09:36:28.245Z</updated>
    
    <content type="html"><![CDATA[<h3 id="GORM"><a href="#GORM" class="headerlink" title="GORM"></a>GORM</h3><p>gorm是Golang语言中一款性能极好的ORM库，对开发人员相对是比较友好的。它提供了强大的功能和简洁的 API，让数据库操作变得更加简单和易维护。</p><p><strong>文档</strong></p><p>英文 <a href="https://gorm.io/docs/" target="_blank" rel="noopener">https://gorm.io/docs/</a></p><p>中文 <a href="https://gorm.io/zh_CN/docs/index.html" target="_blank" rel="noopener">https://gorm.io/zh_CN/docs/index.html</a></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go get -u gorm.io/gorm</span><br><span class="line">go get -u gorm.io/driver/sqlite</span><br></pre></td></tr></tbody></table></figure><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p><a href="https://gorm.io/zh_CN/docs/connecting_to_the_database.html#MySQL" target="_blank" rel="noopener">https://gorm.io/zh_CN/docs/connecting_to_the_database.html#MySQL</a></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"gorm.io/driver/mysql"</span></span><br><span class="line"><span class="string">"gorm.io/gorm"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line"><span class="comment">// 参考 https://github.com/go-sql-driver/mysql#dsn-data-source-name 获取详情</span></span><br><span class="line">dsn := <span class="string">"user:pass@tcp(127.0.0.1:3306)/dbname?charset=utf8mb4&amp;parseTime=True&amp;loc=Local"</span></span><br><span class="line">db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config{})</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">}</span><br><span class="line">fmt.Println(db)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="模型定义"><a href="#模型定义" class="headerlink" title="模型定义"></a>模型定义</h3><p><a href="https://gorm.io/zh_CN/docs/models.html" target="_blank" rel="noopener">https://gorm.io/zh_CN/docs/models.html</a></p><p>GORM 倾向于约定优于配置，如果不遵从约定就要写自定义配置</p><ul><li>使用名为ID的属性会作为主键</li><li>使用snake_cases作为表名<ul><li>结构体命名为employee，那么数据库表名就是employees</li></ul></li><li>使用snake_case作为字段名，字段首字母大写</li></ul><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不符合约定的定义，很多都需要配置，直接用不行</span></span><br><span class="line"><span class="keyword">type</span> Emp <span class="keyword">struct</span> { <span class="comment">// 默认表名emps</span></span><br><span class="line">emp_no     <span class="keyword">int</span>    <span class="comment">// 不是ID为主键，需要配置</span></span><br><span class="line">first_name <span class="keyword">string</span> <span class="comment">// 首字母未大写，也需要配置</span></span><br><span class="line">last_name  <span class="keyword">string</span></span><br><span class="line">gender     <span class="keyword">byte</span></span><br><span class="line">birth_date <span class="keyword">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 符合约定的定义如下</span></span><br><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> { <span class="comment">// 默认表名students</span></span><br><span class="line">ID   <span class="keyword">int</span>    <span class="comment">// Id也可以</span></span><br><span class="line">Name <span class="keyword">string</span> <span class="comment">// 字段首字母要大写</span></span><br><span class="line">Age  <span class="keyword">int</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="表名配置"><a href="#表名配置" class="headerlink" title="表名配置"></a>表名配置</h4><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表名并没有遵守约定</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Emp)</span> <span class="title">TableName</span><span class="params">()</span> <span class="title">string</span></span> {</span><br><span class="line"><span class="keyword">return</span> <span class="string">"employees"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="字段配置"><a href="#字段配置" class="headerlink" title="字段配置"></a>字段配置</h4><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"gorm.io/driver/mysql"</span></span><br><span class="line"><span class="string">"gorm.io/gorm"</span></span><br><span class="line"><span class="string">"gorm.io/gorm/logger"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> db *gorm.DB</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> {</span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line">dsn := <span class="string">"root:123456@tcp(localhost:3306)/test?charset=utf8mb4"</span></span><br><span class="line">db, err = gorm.Open(mysql.Open(dsn), &amp;gorm.Config{</span><br><span class="line">Logger: logger.Default.LogMode(logger.Info),</span><br><span class="line">}) <span class="comment">// 不要用:=</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">}</span><br><span class="line">fmt.Println(db)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Emp <span class="keyword">struct</span> {</span><br><span class="line">emp_no     <span class="keyword">int</span>    <span class="string">`gorm:"primarykey"`</span> <span class="comment">// 不是ID为主键</span></span><br><span class="line">First_name <span class="keyword">string</span> <span class="comment">// 首字母大写，对应字段first_name</span></span><br><span class="line">Last_name  <span class="keyword">string</span></span><br><span class="line">Gender     <span class="keyword">int16</span></span><br><span class="line">Birth_date <span class="keyword">string</span> <span class="comment">//BirthDate  string `gorm:"column:birth_date"`</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> {</span><br><span class="line">ID        <span class="keyword">int</span> <span class="comment">//主键</span></span><br><span class="line">Name      <span class="keyword">string</span></span><br><span class="line">Age       <span class="keyword">byte</span></span><br><span class="line">BirthDate <span class="keyword">string</span></span><br><span class="line">Gender    <span class="keyword">byte</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表名并没有遵守约定</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Emp)</span> <span class="title">TableName</span><span class="params">()</span> <span class="title">string</span></span> {</span><br><span class="line"><span class="keyword">return</span> <span class="string">"employees"</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line"><span class="keyword">var</span> e Emp</span><br><span class="line">result := db.Take(&amp;e) <span class="comment">// 等价于Limit 1，取1条数据</span></span><br><span class="line">fmt.Println(result.Error)</span><br><span class="line">fmt.Println(result.RowsAffected)</span><br><span class="line">fmt.Println(e)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>使用 <code>gorm:"primaryKey"</code> 来指定字段为主键，默认使用名为ID的属性作为主键。primaryKey是tag名，大小写不敏感，但建议小驼峰。</p><h4 id="列名"><a href="#列名" class="headerlink" title="列名"></a>列名</h4><p>如果未按照约定定义字段，需要定义结构体属性时指定数据库字段名称是什么。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BirthDate <span class="keyword">string</span> <span class="string">`gorm:"column:birth_date"`</span> <span class="comment">// 字段名可以不符合约定，但字段名首字母一定要大写</span></span><br><span class="line">Xyz <span class="keyword">string</span> <span class="string">`gorm:"column:birth_date"`</span> <span class="comment">// 可以用注解映射在数据库中的列名</span></span><br></pre></td></tr></tbody></table></figure><h3 id="GORM常用操作"><a href="#GORM常用操作" class="headerlink" title="GORM常用操作"></a>GORM常用操作</h3><p><a href="https://gorm.io/zh_CN/docs/migration.html#%E8%A1%A8" target="_blank" rel="noopener">https://gorm.io/zh_CN/docs/migration.html#%E8%A1%A8</a></p><p>下面，新建一个students表，来看看结构体中属性类型和数据库表中字段类型的对应关系</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> db *gorm.DB</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> {</span><br><span class="line">ID       <span class="keyword">int</span>       <span class="comment">// 缺省主键bigint AUTO_INCREMENT</span></span><br><span class="line">Name     <span class="keyword">string</span>    <span class="string">`gorm:"not null;type:varchar(48);comment:姓名"`</span></span><br><span class="line">Age      <span class="keyword">byte</span>      <span class="comment">// byte=&gt;tinyint unsigned</span></span><br><span class="line">Birthday time.Time <span class="comment">// datetime</span></span><br><span class="line">Gender   <span class="keyword">byte</span>      <span class="string">`gorm:"type:tinyint"`</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">db.Migrator().CreateTable(&amp;Student{})</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 对应建表语句</span></span><br><span class="line"><span class="comment">CREATE TABLE `students` (</span></span><br><span class="line"><span class="comment">`id` bigint AUTO_INCREMENT,</span></span><br><span class="line"><span class="comment">`name` varchar(48) NOT NULL COMMENT '姓名',</span></span><br><span class="line"><span class="comment">`age` tinyint unsigned,</span></span><br><span class="line"><span class="comment">`birthday` datetime(3) NULL,</span></span><br><span class="line"><span class="comment">`gender` tinyint,</span></span><br><span class="line"><span class="comment">PRIMARY KEY (`id`)</span></span><br><span class="line"><span class="comment">)</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></tbody></table></figure><p>由于int =&gt; bigint、string =&gt; longtext，这些默认转换不符合我们的要求，所以，在tag中使用type指定字段类型。</p><p>属性是用来构建结构体实例的，生成的SQL语句也要使用这些数据。而tag是用来生成迁移</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Name     <span class="keyword">string</span>    <span class="string">`gorm:"size:48"`</span> <span class="comment">// 定义为varchar(48)</span></span><br><span class="line">Age      <span class="keyword">int</span>       <span class="string">`gorm:"size:32"`</span> <span class="comment">// 定义为4字节的int</span></span><br><span class="line">Age      <span class="keyword">int</span>       <span class="string">`gorm:"size:64"`</span> <span class="comment">// 定义为8字节的bigint</span></span><br></pre></td></tr></tbody></table></figure><p>迁移用的较少，主要是理解其作用。</p><p>结构体属性类型用来封装实例的数据，Tag中类型指定迁移到数据库表中字段的类型</p><h4 id="新增记录"><a href="#新增记录" class="headerlink" title="新增记录"></a>新增记录</h4><p>参考 <a href="https://gorm.io/zh_CN/docs/create.html#%E5%88%9B%E5%BB%BA%E8%AE%B0%E5%BD%95" target="_blank" rel="noopener">https://gorm.io/zh_CN/docs/create.html#%E5%88%9B%E5%BB%BA%E8%AE%B0%E5%BD%95</a></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"gorm.io/driver/mysql"</span></span><br><span class="line"><span class="string">"gorm.io/gorm"</span></span><br><span class="line"><span class="string">"gorm.io/gorm/logger"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> db *gorm.DB</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> {</span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line">dsn := <span class="string">"root:123456@tcp(localhost:3306)/test?charset=utf8mb4"</span></span><br><span class="line">db, err = gorm.Open(mysql.Open(dsn), &amp;gorm.Config{</span><br><span class="line">Logger: logger.Default.LogMode(logger.Info),</span><br><span class="line">}) <span class="comment">// 不要用:=</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">}</span><br><span class="line">fmt.Println(db)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> {</span><br><span class="line">ID       <span class="keyword">int</span>       <span class="comment">// 缺省主键bigint AUTO_INCREMENT</span></span><br><span class="line">Name     <span class="keyword">string</span>    <span class="string">`gorm:"not null;type:varchar(48);comment:姓名"`</span></span><br><span class="line">Age      <span class="keyword">byte</span>      <span class="comment">// byte=&gt;tinyint unsigned</span></span><br><span class="line">Birthday time.Time <span class="comment">// datetime</span></span><br><span class="line">Gender   <span class="keyword">byte</span>      <span class="string">`gorm:"type:tinyint"`</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Student)</span> <span class="title">string</span><span class="params">()</span> <span class="title">string</span></span> {</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">"%d"</span>, s.ID)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line"><span class="comment">// 建表</span></span><br><span class="line"><span class="comment">// db.Migrator().CreateTable(&amp;Student{})</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新增一条记录</span></span><br><span class="line">n := time.Now()</span><br><span class="line">s := Student{Name: <span class="string">"Tom"</span>, Age: <span class="number">23</span>, Birthday: n}</span><br><span class="line">fmt.Println(s)</span><br><span class="line">result := db.Create(&amp;s) <span class="comment">// 新增，传入指针</span></span><br><span class="line">fmt.Println(s)          <span class="comment">// 注意前后ID的变化</span></span><br><span class="line">fmt.Println(result.Error)</span><br><span class="line">fmt.Println(result.RowsAffected)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新增多条记录</span></span><br><span class="line">n = time.Now()</span><br><span class="line">s = Student{Name: <span class="string">"Tom"</span>, Age: <span class="number">23</span>, Birthday: n}</span><br><span class="line">fmt.Println(s)</span><br><span class="line">result = db.Create([]*Student{&amp;s, &amp;s, &amp;s, &amp;s}) <span class="comment">// 传入指针切片</span></span><br><span class="line">fmt.Println(s)</span><br><span class="line">fmt.Println(result.Error)</span><br><span class="line">fmt.Println(result.RowsAffected)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="查询一条记录"><a href="#查询一条记录" class="headerlink" title="查询一条记录"></a>查询一条记录</h4><p>Take被转换为Limit 1</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line"><span class="keyword">var</span> s = Student</span><br><span class="line">fmt.Println(s)     <span class="comment">// 零值</span></span><br><span class="line">row := db.Take(&amp;s) <span class="comment">// Limit 1</span></span><br><span class="line">fmt.Println(s)</span><br><span class="line">fmt.Println(row)</span><br><span class="line">fmt.Println(row.Error)</span><br><span class="line">    row.Scan(&amp;s)</span><br><span class="line">fmt.Println(s)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">row := db.First(&amp;s) <span class="comment">// ORDER BY `students`.`id` LIMIT 1</span></span><br><span class="line">row := db.Last(&amp;s)  <span class="comment">// ORDER BY `students`.`id` DESC LIMIT 1</span></span><br></pre></td></tr></tbody></table></figure><p>根据id查，可以使用下面的方式</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">row := db.First(&amp;s, <span class="number">15</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = Student{ID: <span class="number">16</span>}</span><br><span class="line">row := db.First(&amp;s)</span><br></pre></td></tr></tbody></table></figure><h4 id="时间相关错误"><a href="#时间相关错误" class="headerlink" title="时间相关错误"></a>时间相关错误</h4><p>1、时间类型字段</p><p>上例错误如下，主要是使用了*time.Time，而不是string。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sql: Scan error on column index <span class="number">3</span>, name <span class="string">"birthday"</span>: unsupported Scan, storing driver.Value <span class="keyword">type</span> []<span class="keyword">uint8</span> into <span class="keyword">type</span> *time.Time</span><br><span class="line">[]<span class="keyword">byte</span> 转 *time.Time失败了</span><br></pre></td></tr></tbody></table></figure><p><strong>解决方案</strong></p><p>在连接字符串中增加parseTime=true，这样时间类型就会自动转化为time.Time类型</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dsn := <span class="string">"root:123456@tcp(localhost:3306)/test?charset=utf8mb4&amp;parseTime=true"</span></span><br></pre></td></tr></tbody></table></figure><p>也可以 Birthday string ，拿到Birthday字符串后，必要时，自行转换成时间类型</p><p>2、UTC时间</p><p>Create写入的时间，也就是说time.Now()取当前时区时间，但是存入数据库的时间是UTC时间。</p><p>Take拿回的时间也是UTC时间，可以通过s.Birthday.Local()转成当前时区时间。</p><p>如果想存入的时间或读取的时间直接是当前时区时间，可以使用loc参数loc=Local。</p><p>如果loc=Local</p><ul><li>存入时，数据库字段中的时间就是当前时区的时间值</li><li>读取时，数据库字段中的时间就被解读为当前时区</li></ul><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dsn := <span class="string">"root:123456@tcp(localhost:3306)/test?charset=utf8mb4&amp;parseTime=true&amp;loc=Local"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadLocation</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(*Location, error)</span></span> {</span><br><span class="line"><span class="keyword">if</span> name == <span class="string">""</span> || name == <span class="string">"UTC"</span> {</span><br><span class="line"><span class="keyword">return</span> UTC, <span class="literal">nil</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> name == <span class="string">"Local"</span> {</span><br><span class="line"><span class="keyword">return</span> Local, <span class="literal">nil</span></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>千万不要存入数据库时采用Local存入，却使用UTC解读时间，会造成时间时区的混乱。应该保证时间存入、读取时区一致。</p><p>一定要统一项目中数据库中时间类型字段的时区。可以考虑统一采用UTC，为了本地化显示转换为当前时区即可。</p><h4 id="查询所有数据"><a href="#查询所有数据" class="headerlink" title="查询所有数据"></a>查询所有数据</h4><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> students []*Student</span><br><span class="line">db.Find(&amp;students)</span><br><span class="line">rows := db.Find(&amp;students)</span><br><span class="line">fmt.Println(students)</span><br><span class="line">fmt.Println(rows)</span><br><span class="line">fmt.Println(rows.Error)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, i := <span class="keyword">range</span> students {</span><br><span class="line">    fmt.Println(*i)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a>distinct</h4><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rows := db.Distinct(<span class="string">"name"</span>).Find(&amp;students)</span><br></pre></td></tr></tbody></table></figure><h4 id="投影"><a href="#投影" class="headerlink" title="投影"></a>投影</h4><p>投影是关系模型的操作，就是选择哪些字段</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rows := db.Select(<span class="string">"id"</span>, <span class="string">"name"</span>, <span class="string">"age"</span>).Find(&amp;students)</span><br><span class="line">rows := db.Select([]<span class="keyword">string</span>{<span class="string">"id"</span>, <span class="string">"name"</span>, <span class="string">"age"</span>}).Find(&amp;students)</span><br></pre></td></tr></tbody></table></figure><h4 id="Limit和Offset"><a href="#Limit和Offset" class="headerlink" title="Limit和Offset"></a>Limit和Offset</h4><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> students []*Student</span><br><span class="line">rows := db.Limit(<span class="number">2</span>).Offset(<span class="number">2</span>).Find(&amp;students)</span><br></pre></td></tr></tbody></table></figure><h4 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h4><p>1、字符串条件</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> students []*Student</span><br><span class="line">rows := db.Where(<span class="string">"name=?"</span>, <span class="string">"Tom"</span>).Find(&amp;students)</span><br><span class="line">rows := db.Where(<span class="string">"name &lt;&gt; ?"</span>, <span class="string">"Tom"</span>).Find(&amp;students)</span><br><span class="line">rows := db.Where(<span class="string">"name in ?"</span>, []<span class="keyword">string</span>{<span class="string">"jerry"</span>, <span class="string">"tom"</span>}).Find(&amp;students)</span><br><span class="line">rows := db.Where(<span class="string">"name like ?"</span>, <span class="string">"t%"</span>).Find(&amp;students)</span><br><span class="line">rows := db.Where(<span class="string">"name like binary ?"</span>, <span class="string">"T%"</span>).Find(&amp;students)</span><br><span class="line">rows := db.Where(<span class="string">"name like ? and age &gt;?"</span>, <span class="string">"t%"</span>, <span class="number">20</span>).Find(&amp;students)</span><br><span class="line">rows := db.Where(<span class="string">"id between ? and ?"</span>, <span class="number">15</span>, <span class="number">17</span>).Find(&amp;students)</span><br><span class="line">rows := db.Where(<span class="string">"id = ? or id = ?"</span>, <span class="number">15</span>, <span class="number">17</span>).Find(&amp;students)</span><br></pre></td></tr></tbody></table></figure><p>2、struct 或map 条件</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> students []*Student</span><br><span class="line">rows := db.Where([]<span class="keyword">int</span>{<span class="number">14</span>, <span class="number">16</span>, <span class="number">17</span>}).Find(&amp;students) <span class="comment">// WHERE students.id IN (14,16,17)</span></span><br><span class="line">rows := db.Where(&amp;Student{}).Find(&amp;students)        <span class="comment">// 查询所有数据</span></span><br><span class="line">rows := db.Where(&amp;Student{ID: <span class="number">5</span>}).Find(&amp;students)</span><br><span class="line">rows := db.Where(&amp;Student{ID: <span class="number">5</span>, Name: <span class="string">"Tom"</span>}).Find(&amp;students)</span><br><span class="line">rows := db.Where(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>{}{<span class="string">"name"</span>: <span class="string">"Tom"</span>, <span class="string">"id"</span>: <span class="number">5</span>}).Find(&amp;students)</span><br><span class="line">rows := db.Select([]<span class="keyword">string</span>{<span class="string">"id"</span>, <span class="string">"name"</span>, <span class="string">"age"</span>}).Find(&amp;students)</span><br></pre></td></tr></tbody></table></figure><p>3、Not</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> students []*Student</span><br><span class="line">rows := db.Not(<span class="string">"id = ? or id = ?"</span>, <span class="number">5</span>, <span class="number">1</span>).Find(&amp;students)</span><br><span class="line">rows := db.Not(<span class="string">"name = ?"</span>, <span class="string">"Tom"</span>).Find(&amp;students)</span><br></pre></td></tr></tbody></table></figure><p>4、Or</p><p>Or的用法和Where一样，Where().Where()是And关系，Where().Or()是Or关系</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> students []*Student</span><br><span class="line">rows := db.Where(<span class="string">"name = ?"</span>, <span class="string">"Tom"</span>).Or(<span class="string">"name = ?"</span>, <span class="string">"Jerry"</span>).Find(&amp;students)</span><br><span class="line">rows := db.Where(<span class="string">"name = ?"</span>, <span class="string">"Tom"</span>).Or(&amp;Student{Name: <span class="string">"Jerry"</span>}).Find(&amp;students)</span><br></pre></td></tr></tbody></table></figure><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> students []*Student</span><br><span class="line">rows := db.Order(<span class="string">"id desc"</span>).Find(&amp;students)</span><br><span class="line">rows := db.Order(<span class="string">"name,id desc"</span>).Find(&amp;students)</span><br><span class="line">rows := db.Order(<span class="string">"name"</span>).Order(<span class="string">"id desc"</span>).Find(&amp;students)</span><br></pre></td></tr></tbody></table></figure><h4 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h4><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> students []*Student</span><br><span class="line">rows := db.Group(<span class="string">"id"</span>).Find(&amp;students)</span><br><span class="line">rows := db.Group(<span class="string">"name"</span>).Group(<span class="string">"id"</span>).Find(&amp;students)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是students中没有属性来保存count的值</span></span><br><span class="line">rows := db.Select(<span class="string">"name,count(id) as c"</span>).Group(<span class="string">"name"</span>).Find(&amp;students)</span><br></pre></td></tr></tbody></table></figure><p>可以使用以下方式保存count的值</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用Scan填充容器</span></span><br><span class="line"><span class="keyword">type</span> Result <span class="keyword">struct</span> {</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">C    <span class="keyword">int</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rows = []*Result{}</span><br><span class="line">db.Table(<span class="string">"students"</span>).Select(<span class="string">"name,count(id) as c"</span>).Group(<span class="string">"name"</span>).Having(<span class="string">"c &gt; 3"</span>).Scan(&amp;rows)</span><br><span class="line"><span class="keyword">for</span> i, r := <span class="keyword">range</span> rows {</span><br><span class="line">    fmt.Printf(<span class="string">"%d, %T %#[2]v\n"</span>, i, r)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用Rows()返回所有行，自行获取字段值，但是要用Table指定表名</span></span><br><span class="line"><span class="keyword">type</span> Result <span class="keyword">struct</span> {</span><br><span class="line">name  <span class="keyword">string</span></span><br><span class="line">count <span class="keyword">int</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> r = Result{}</span><br><span class="line">rows, err := db.Table(<span class="string">"students"</span>).Select(<span class="string">"name,count(id) as c"</span>).Group(<span class="string">"name"</span>).Having(<span class="string">"c &gt; 3"</span>).Rows()</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="comment">// 遍历每一行，填充2个属性的结构体实例</span></span><br><span class="line"><span class="keyword">for</span> rows.Next() {</span><br><span class="line">    rows.Scan(&amp;r.name, &amp;r.count)</span><br><span class="line">    fmt.Println(r, <span class="string">"==="</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="Join"><a href="#Join" class="headerlink" title="Join"></a>Join</h4><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Join</span></span><br><span class="line"><span class="keyword">type</span> Result <span class="keyword">struct</span> {</span><br><span class="line">EmpNo     <span class="keyword">int</span></span><br><span class="line">FirstName <span class="keyword">string</span></span><br><span class="line">LastName  <span class="keyword">string</span></span><br><span class="line">Salary    <span class="keyword">int</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Join 1</span></span><br><span class="line"><span class="keyword">var</span> results = []*Result{}</span><br><span class="line">rows := db.Table(<span class="string">"employees as e"</span>).Select(<span class="string">"e.emp_no,first_name,last_name,salary"</span>).</span><br><span class="line">    Joins(<span class="string">"join salaries on e.emp_no = salaries.emp_no"</span>).Find(&amp;results)</span><br><span class="line">fmt.Println(rows)</span><br><span class="line">fmt.Println(rows.RowsAffected)</span><br><span class="line"><span class="keyword">for</span> i, r := <span class="keyword">range</span> results {</span><br><span class="line">    fmt.Println(i, *r)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Join 2</span></span><br><span class="line">rows, err := db.Table(<span class="string">"employees as e"</span>).Select(<span class="string">"e.emp_no,first_name,last_name,salary"</span>).</span><br><span class="line">    Joins(<span class="string">"join salaries as s on e.emp_no = s.emp_no"</span>).Rows()</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">var</span> r Result</span><br><span class="line"><span class="keyword">for</span> rows.Next() {</span><br><span class="line">    rows.Scan(&amp;r.EmpNo, &amp;r.FirstName, &amp;r.LastName, &amp;r.Salary)</span><br><span class="line">    fmt.Println(r, <span class="string">"==="</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Join 3</span></span><br><span class="line"><span class="keyword">var</span> results = []*Result{}</span><br><span class="line">db.Table(<span class="string">"employees as e"</span>).Select(<span class="string">"e.emp_no,first_name,last_name,salary"</span>).</span><br><span class="line">    Joins(<span class="string">"join salaries as s on e.emp_no = s.emp_no"</span>).Scan(&amp;results)</span><br><span class="line"><span class="keyword">for</span> i, r := <span class="keyword">range</span> results {</span><br><span class="line">    fmt.Println(i, *r)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><p><a href="https://gorm.io/zh_CN/docs/update.html" target="_blank" rel="noopener">https://gorm.io/zh_CN/docs/update.html</a></p><p>先查后改：先查到一个实例，对这个实例属性进行修改，然后调用db.Save()方法保存。</p><p>db.Save()方法会保存所有字段，对于没有主键的实例相当于Insert into，有主键的实例相当于Update。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更新</span></span><br><span class="line"><span class="comment">// 先查</span></span><br><span class="line"><span class="keyword">var</span> student Student</span><br><span class="line">db.First(&amp;student)</span><br><span class="line">fmt.Println(student)</span><br><span class="line"></span><br><span class="line">student.Age += <span class="number">10</span></span><br><span class="line">student.Name = <span class="string">"Jerry"</span></span><br><span class="line"><span class="comment">// 后改</span></span><br><span class="line">db.Save(&amp;student)</span><br><span class="line">fmt.Println(student)</span><br></pre></td></tr></tbody></table></figure><p>Update 更新单个字段</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Update 更新单个字段</span></span><br><span class="line">db.Model(&amp;Student{ID: <span class="number">5</span>}).Update(<span class="string">"age"</span>, <span class="number">19</span>) <span class="comment">// 更新符合条件的所有记录的一个字段</span></span><br><span class="line"><span class="comment">// UPDATE `students` SET `age`=5 WHERE `id` = 19</span></span><br><span class="line"></span><br><span class="line">r := db.Model(&amp;Student{}).Update(<span class="string">"age"</span>, <span class="number">20</span>) <span class="comment">// 没有指定ID或where条件，是全表更新age字段，这是非常危险的</span></span><br><span class="line">fmt.Println(r.Error)</span><br></pre></td></tr></tbody></table></figure><p>Updates 更新多列</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Updates 更新多个字段</span></span><br><span class="line">r := db.Model(&amp;Student{}).Where(<span class="string">"age &lt; ?"</span>, <span class="number">20</span>).Updates(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>{}{<span class="string">"name"</span>: <span class="string">"John"</span>, <span class="string">"age"</span>: <span class="number">25</span>})</span><br><span class="line">fmt.Println(r.Error)</span><br><span class="line"></span><br><span class="line">r := db.Model(&amp;Student{}).Where(<span class="string">"age &lt; ?"</span>, <span class="number">24</span>).Updates(Student{Name: <span class="string">"John"</span>, Age: <span class="number">18</span>})</span><br><span class="line">fmt.Println(r.Error)</span><br></pre></td></tr></tbody></table></figure><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p><a href="https://gorm.io/zh_CN/docs/delete.html" target="_blank" rel="noopener">https://gorm.io/zh_CN/docs/delete.html</a></p><p>删除操作是危险的，慎重操作！</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除</span></span><br><span class="line">result := db.Delete(&amp;Student{})</span><br><span class="line">fmt.Println(result.Error)</span><br><span class="line"><span class="comment">// 报WHERE conditions required错误，这是全表删除，危险</span></span><br><span class="line"></span><br><span class="line">result = db.Delete(&amp;Student{}, <span class="number">5</span>) <span class="comment">// 指定主键</span></span><br><span class="line">fmt.Println(result.Error)</span><br><span class="line"></span><br><span class="line">db.Delete(&amp;Student{}, []<span class="keyword">int</span>{<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>}) <span class="comment">// DELETE FROM `students` WHERE `students`.`id` IN (15,16,18)</span></span><br><span class="line"></span><br><span class="line">result = db.Where(<span class="string">"id &gt; ?"</span>, <span class="number">5</span>).Delete(&amp;Student{})</span><br><span class="line">fmt.Println(result.Error)</span><br></pre></td></tr></tbody></table></figure><!-- rebuild by neat --><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;GORM&quot;&gt;&lt;a href=&quot;#GORM&quot; class=&quot;headerlink&quot; title=&quot;GORM&quot;&gt;&lt;/a&gt;GORM&lt;/h3&gt;&lt;p&gt;gorm是Golang语言中一款性能极好的ORM库，对开发人员相对是比较友好的。它提供了强大的功能和简洁的 API，让数据库
      
    
    </summary>
    
    
      <category term="Go" scheme="http://chenzhonzhou.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="http://chenzhonzhou.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go 连接 MySql 数据库</title>
    <link href="http://chenzhonzhou.github.io/2023/05/11/go-lian-jie-mysql-shu-ju-ku/"/>
    <id>http://chenzhonzhou.github.io/2023/05/11/go-lian-jie-mysql-shu-ju-ku/</id>
    <published>2023-05-11T03:31:27.000Z</published>
    <updated>2023-12-02T09:27:18.865Z</updated>
    
    <content type="html"><![CDATA[<h3 id="驱动"><a href="#驱动" class="headerlink" title="驱动"></a>驱动</h3><p>为了Go语言可以提前定义操作一个数据库的所有行为（接口）和数据（结构体）的规范，这些定义在database/sql下。</p><p>MySQL驱动</p><ul><li><a href="https://github.com/go-sql-driver/mysql" target="_blank" rel="noopener">https://github.com/go-sql-driver/mysql</a> 支持 database/sql，<strong>推荐</strong></li><li><a href="https://github.com/ziutek/mymysql" target="_blank" rel="noopener">https://github.com/ziutek/mymysql</a> 支持 database/sql，支持自定义接口</li><li><a href="https://github.com/Philio/GoMySQL" target="_blank" rel="noopener">https://github.com/Philio/GoMySQL</a> 不支持 database/sql，支持自定义接口</li></ul><p>go-sql-driver/mysql库是Go语言官方推荐的MySQL驱动库，可以很方便地实现对MySQL数据库的连接和操作。</p><h4 id="安装mysql-Go驱动"><a href="#安装mysql-Go驱动" class="headerlink" title="安装mysql Go驱动"></a>安装mysql Go驱动</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go get -u github.com/go-sql-driver/mysql</span></span><br></pre></td></tr></tbody></table></figure><p>导入</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="string">"github.com/go-sql-driver/mysql"</span> <span class="comment">// 当导入带有空白标识符前缀 _ 的包时，将调用包的 init 函数。该函数注册驱动程序</span></span><br></pre></td></tr></tbody></table></figure><p>注册驱动</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// github.com/go-sql-driver/mysql/mysql/driver.go 代码中有注册驱动</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> { <span class="comment">// 83行</span></span><br><span class="line"> sql.Register(<span class="string">"mysql"</span>, &amp;MySQLDriver{})</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h3><p>DSN例子 <a href="https://github.com/go-sql-driver/mysql#examples" target="_blank" rel="noopener">https://github.com/go-sql-driver/mysql#examples</a></p><p><code>[username[:password]@][protocol[(address)]]/dbname[?param1=value1&amp;...&amp;paramN=valueN]</code></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"database/sql"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">_ <span class="string">"github.com/go-sql-driver/mysql"</span> <span class="comment">// 1 驱动安装和导入</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> db *sql.DB</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> {</span><br><span class="line"><span class="comment">// 2 连接数据库</span></span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line">db, err = sql.Open(<span class="string">"mysql"</span>, <span class="string">"root:123456@tcp(localhost:3306)/test"</span>) <span class="comment">// 不要使用:=</span></span><br><span class="line"><span class="keyword">defer</span> db.Close()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">log.Fatal(err)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看README.md https://github.com/go-sql-driver/mysql#usage</span></span><br><span class="line">db.SetConnMaxLifetime(time.Second * <span class="number">30</span>) <span class="comment">// 超时时间</span></span><br><span class="line">db.SetMaxOpenConns(<span class="number">0</span>)                   <span class="comment">// 设置最大连接数，默认为0表示不限制</span></span><br><span class="line">db.SetMaxIdleConns(<span class="number">10</span>)                  <span class="comment">// 设置空闲连接数</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>db类型是<code>*sql.DB</code>，是一个操作数据库的句柄，底层是一个多协程安全的连接池。</p><h3 id="操作数据库"><a href="#操作数据库" class="headerlink" title="操作数据库"></a>操作数据库</h3><h4 id="获取mysql版本"><a href="#获取mysql版本" class="headerlink" title="获取mysql版本"></a>获取mysql版本</h4><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取mysql版本</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">showMysqlVersion</span><span class="params">()</span></span> {</span><br><span class="line">db, err := sql.Open(<span class="string">"mysql"</span>, <span class="string">"root:123456@tcp(127.0.0.1:3306)/test?charset=utf8mb4"</span>)</span><br><span class="line">db.Ping()</span><br><span class="line"><span class="keyword">defer</span> db.Close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">fmt.Println(<span class="string">"数据库连接失败！"</span>)</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> version <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">err2 := db.QueryRow(<span class="string">"SELECT VERSION()"</span>).Scan(&amp;version)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err2 != <span class="literal">nil</span> {</span><br><span class="line">log.Fatal(err2)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">fmt.Println(version)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h4><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createTable</span><span class="params">()</span></span> {</span><br><span class="line">db, err := sql.Open(<span class="string">"mysql"</span>, <span class="string">"root:123456@tcp(127.0.0.1:3306)/Test"</span>)</span><br><span class="line">db.Ping()</span><br><span class="line"><span class="keyword">defer</span> db.Close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">fmt.Println(<span class="string">"connect DB error !"</span>)</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">_, err2 := db.Exec(<span class="string">"CREATE TABLE user(id INT NOT NULL , name VARCHAR(20), PRIMARY KEY(ID));"</span>)</span><br><span class="line"><span class="keyword">if</span> err2 != <span class="literal">nil</span> {</span><br><span class="line">log.Fatal(err2)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"successfully create table"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h4><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertItem</span><span class="params">()</span></span> {</span><br><span class="line">db, err := sql.Open(<span class="string">"mysql"</span>, <span class="string">"root:123456@tcp(127.0.0.1:3306)/Test?charset=utf8mb4"</span>)</span><br><span class="line">db.Ping()</span><br><span class="line"><span class="keyword">defer</span> db.Close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">fmt.Println(<span class="string">"connect DB error !"</span>)</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">_, err2 := db.Query(<span class="string">"INSERT INTO user VALUES(1, 'zhangsan')"</span>)</span><br><span class="line"><span class="keyword">if</span> err2 != <span class="literal">nil</span> {</span><br><span class="line">log.Fatal(err2)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"successfully insert item"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteItem</span><span class="params">()</span></span> {</span><br><span class="line">db, err := sql.Open(<span class="string">"mysql"</span>, <span class="string">"root:123456@tcp(127.0.0.1:3306)/Test?charset=utf8mb4"</span>)</span><br><span class="line">db.Ping()</span><br><span class="line"><span class="keyword">defer</span> db.Close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">fmt.Println(<span class="string">"connect DB error !"</span>)</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">sql := <span class="string">"DELETE FROM user WHERE id = 1"</span></span><br><span class="line">res, err2 := db.Exec(sql)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err2 != <span class="literal">nil</span> {</span><br><span class="line"><span class="built_in">panic</span>(err2.Error())</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">affectedRows, err := res.RowsAffected()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">log.Fatal(err)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"delete item success, statement affected %d rows\n"</span>, affectedRows)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h4><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">alterItem</span><span class="params">()</span></span> {</span><br><span class="line">db, err := sql.Open(<span class="string">"mysql"</span>, <span class="string">"root:123456@tcp(127.0.0.1:3306)/Test?charset=utf8mb4"</span>)</span><br><span class="line">db.Ping()</span><br><span class="line"><span class="keyword">defer</span> db.Close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">fmt.Println(<span class="string">"connect DB error !"</span>)</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">sql := <span class="string">"update user set name = ? WHERE id = ?"</span></span><br><span class="line">res, err2 := db.Exec(sql, <span class="string">"lisi"</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err2 != <span class="literal">nil</span> {</span><br><span class="line"><span class="built_in">panic</span>(err2.Error())</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">affectedRows, err := res.RowsAffected()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">log.Fatal(err)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"alter item success, statement affected %d rows\n"</span>, affectedRows)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h4><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询数据</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"database/sql"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line"></span><br><span class="line">_ <span class="string">"github.com/go-sql-driver/mysql"</span> <span class="comment">// 1 驱动安装和导入</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> db *sql.DB</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> {</span><br><span class="line"><span class="comment">// 2 连接数据库</span></span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line">db, err = sql.Open(<span class="string">"mysql"</span>, <span class="string">"root:123456@tcp(127.0.0.1:3306)/test?charset=utf8mb4"</span>) <span class="comment">// 不要使用:=</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">log.Fatal(err)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看README.md https://github.com/go-sql-driver/mysql#usage</span></span><br><span class="line">db.SetConnMaxLifetime(time.Second * <span class="number">30</span>) <span class="comment">// 超时时间</span></span><br><span class="line">db.SetMaxOpenConns(<span class="number">0</span>)                   <span class="comment">// 设置最大连接数，默认为0表示不限制</span></span><br><span class="line">db.SetMaxIdleConns(<span class="number">10</span>)                  <span class="comment">// 设置空闲连接数</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Emp <span class="keyword">struct</span> { <span class="comment">// 和字段对应的变量或结构体定义，最好和数据库中字段顺序对应</span></span><br><span class="line">emp_no     <span class="keyword">int</span></span><br><span class="line">birth_date <span class="keyword">string</span></span><br><span class="line">first_name <span class="keyword">string</span></span><br><span class="line">last_name  <span class="keyword">string</span></span><br><span class="line">gender     <span class="keyword">int16</span></span><br><span class="line">hire_date  <span class="keyword">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line"><span class="comment">// 3 操作</span></span><br><span class="line"><span class="comment">// 预编译</span></span><br><span class="line">stmt, err := db.Prepare(<span class="string">"select * from employees where emp_no &gt; ?"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">log.Fatal(err)</span><br><span class="line">}</span><br><span class="line"><span class="keyword">defer</span> stmt.Close()</span><br><span class="line"><span class="comment">// 批量查询</span></span><br><span class="line">rows, err := stmt.Query(<span class="number">10018</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">log.Fatal(err)</span><br><span class="line">}</span><br><span class="line"><span class="keyword">defer</span> rows.Close()</span><br><span class="line">emp := Emp{}</span><br><span class="line"><span class="keyword">for</span> rows.Next() {</span><br><span class="line">err = rows.Scan(&amp;emp.emp_no, &amp;emp.birth_date, &amp;emp.first_name,</span><br><span class="line">&amp;emp.last_name, &amp;emp.gender, &amp;emp.hire_date) <span class="comment">// 取字段</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">log.Fatal(err)</span><br><span class="line">}</span><br><span class="line">fmt.Println(emp)</span><br><span class="line">fmt.Printf(<span class="string">"%T %[1]v\n"</span>, emp.birth_date)</span><br><span class="line">t, err := time.Parse(<span class="string">"2006-01-02"</span>, emp.birth_date) <span class="comment">// 时间解析</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">log.Fatal(err)</span><br><span class="line">}</span><br><span class="line">fmt.Printf(<span class="string">"%T %[1]v\n"</span>, t)</span><br><span class="line">}</span><br><span class="line">fmt.Println(<span class="string">"~~~~~~~~~~~~~~~~~~~~~~~~~~~"</span>)</span><br><span class="line"><span class="comment">// 单行查询</span></span><br><span class="line">row := db.QueryRow(<span class="string">"select * from employees where emp_no = ?"</span>, <span class="number">10010</span>)</span><br><span class="line">err = row.Scan(&amp;emp.emp_no, &amp;emp.birth_date, &amp;emp.first_name,</span><br><span class="line">&amp;emp.last_name, &amp;emp.gender, &amp;emp.hire_date) <span class="comment">// 取字段</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">log.Fatal(err)</span><br><span class="line">}</span><br><span class="line">fmt.Println(emp)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h4><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dropTable</span><span class="params">()</span></span> {</span><br><span class="line">db, err := sql.Open(<span class="string">"mysql"</span>, <span class="string">"root:123456@tcp(127.0.0.1:3306)/Test"</span>)</span><br><span class="line">db.Ping()</span><br><span class="line"><span class="keyword">defer</span> db.Close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">fmt.Println(<span class="string">"connect DB error !"</span>)</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">_, err2 := db.Exec(<span class="string">"DROP TABLE user;"</span>)</span><br><span class="line"><span class="keyword">if</span> err2 != <span class="literal">nil</span> {</span><br><span class="line">log.Fatal(err2)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"successfully drop table"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><!-- rebuild by neat --><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;驱动&quot;&gt;&lt;a href=&quot;#驱动&quot; class=&quot;headerlink&quot; title=&quot;驱动&quot;&gt;&lt;/a&gt;驱动&lt;/h3&gt;&lt;p&gt;为了Go语言可以提前定义操作一个数据库的所有行为（接口）和数据（结构体）的规范，这些定义在database/sql下。&lt;/p&gt;&lt;p&gt;MySQ
      
    
    </summary>
    
    
      <category term="Go" scheme="http://chenzhonzhou.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="http://chenzhonzhou.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go 连接 MongoDB</title>
    <link href="http://chenzhonzhou.github.io/2023/05/10/go-lian-jie-mongodb/"/>
    <id>http://chenzhonzhou.github.io/2023/05/10/go-lian-jie-mongodb/</id>
    <published>2023-05-10T03:29:27.000Z</published>
    <updated>2023-12-02T12:46:37.075Z</updated>
    
    <content type="html"><![CDATA[<h3 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h3><p>MongoDB是一种高性能、开源、文档型的NoSQL数据库，被广泛应用于Web应用、大数据以及云计算领域。MongoDB属于非关系型数据库，它是由C++编写的分布式文档数据库。内部使用类似于Json的bson二进制格式。</p><p>中文手册</p><p><a href="https://www.w3cschool.cn/mongodb/" target="_blank" rel="noopener">https://www.w3cschool.cn/mongodb/</a></p><h3 id="驱动"><a href="#驱动" class="headerlink" title="驱动"></a>驱动</h3><p>驱动 <a href="https://www.mongodb.com/docs/drivers/" target="_blank" rel="noopener">https://www.mongodb.com/docs/drivers/</a></p><p>Go驱动 <a href="https://www.mongodb.com/docs/drivers/go/current/" target="_blank" rel="noopener">https://www.mongodb.com/docs/drivers/go/current/</a></p><h4 id="驱动安装"><a href="#驱动安装" class="headerlink" title="驱动安装"></a>驱动安装</h4><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> get <span class="keyword">go</span>.mongodb.org/mongo-driver/mongo</span><br></pre></td></tr></tbody></table></figure><h4 id="连接字符串"><a href="#连接字符串" class="headerlink" title="连接字符串"></a>连接字符串</h4><p><a href="https://www.mongodb.com/docs/manual/reference/connection-string/#examples" target="_blank" rel="noopener">https://www.mongodb.com/docs/manual/reference/connection-string/#examples</a></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mongodb:<span class="comment">//[username:password@]host1[:port1][,...hostN[:portN]] [/[defaultauthdb][?options]]</span></span><br><span class="line">mongodb:<span class="comment">//wayne:wayne@mongodb0.example.com:27017</span></span><br></pre></td></tr></tbody></table></figure><p>连接例子 <a href="https://www.mongodb.com/docs/drivers/go/current/fundamentals/connection/#connection-example" target="_blank" rel="noopener">https://www.mongodb.com/docs/drivers/go/current/fundamentals/connection/#connection-example</a></p><p>快速入门 <a href="https://www.mongodb.com/docs/drivers/go/current/quick-start/" target="_blank" rel="noopener">https://www.mongodb.com/docs/drivers/go/current/quick-start/</a></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"go.mongodb.org/mongo-driver/mongo"</span></span><br><span class="line"><span class="string">"go.mongodb.org/mongo-driver/mongo/options"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> client *mongo.Client</span><br><span class="line"><span class="keyword">var</span> db *mongo.Database</span><br><span class="line"><span class="keyword">var</span> users *mongo.Collection</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> {</span><br><span class="line">url := <span class="string">"mongodb://root:123456@127.0.0.1:27017//"</span></span><br><span class="line">opts := options.Client()</span><br><span class="line">opts.ApplyURI(url).SetConnectTimeout(<span class="number">5</span> * time.Second).</span><br><span class="line">SetAuth(options.Credential{Username: <span class="string">"root"</span>, Password: <span class="string">"123456"</span>, AuthSource: <span class="string">"admin"</span>})</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line">client, err = mongo.Connect(context.TODO(), opts) <span class="comment">// context.TODO() 空上下文</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">err = client.Ping(context.TODO(), <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">}</span><br><span class="line">fmt.Println(<span class="string">"----------------------------"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不使用:=</span></span><br><span class="line">db = client.Database(<span class="string">"test"</span>)   <span class="comment">// 连接test库</span></span><br><span class="line">users = db.Collection(<span class="string">"users"</span>) <span class="comment">// 集合，相当于表</span></span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 断开连接放到其它函数里</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line"><span class="keyword">if</span> err := c.Disconnect(context.TODO()); err != <span class="literal">nil</span> {</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">}</span><br><span class="line">}()</span><br></pre></td></tr></tbody></table></figure><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>MongoDB中可以创建使用多个库，但有一些数据库名是保留的，可以直接访问这些有特殊作用的数据库。</p><ul><li>admin： 从权限的角度来看，这是”root”数据库。要是将一个用户添加到这个数据库，这个用户自动继承所有数据库的权限。一些特定的服务器端命令也只能从这个数据库运行，比如列出所有的数据库或者关闭服务器。</li><li>local: 这个数据永远不会被复制，可以用来存储限于本地单台服务器的任意集合。</li><li>config: 当Mongo用于分片设置时，config数据库在内部使用，用于保存分片的相关信息。</li></ul><table><thead><tr><th>RDBMS</th><th>MongoDB</th></tr></thead><tbody><tr><td>Database</td><td>Database</td></tr><tr><td>Table</td><td>Collection</td></tr><tr><td>Row</td><td>Document</td></tr><tr><td>Column</td><td>Field</td></tr><tr><td>Join</td><td>Embedded Document嵌入文档或Reference引用</td></tr><tr><td>Primary Key</td><td>主键(MongoDB提供了key为_id)</td></tr></tbody></table><p>Go Driver使用，官方博客 <a href="https://www.mongodb.com/blog/post/mongodb-go-driver-tutorial" target="_blank" rel="noopener">https://www.mongodb.com/blog/post/mongodb-go-driver-tutorial</a></p><h3 id="数据封装"><a href="#数据封装" class="headerlink" title="数据封装"></a>数据封装</h3><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> {</span><br><span class="line">ID   primitive.ObjectID <span class="string">`bson:"_id,omitempty"`</span></span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">Age  <span class="keyword">int</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u User)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> {</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">"&lt;%s: %s,%d"</span>, u.ID, u.Name, u.Age)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>Tag参考 <a href="https://www.mongodb.com/docs/drivers/go/upcoming/fundamentals/bson/#struct-tags" target="_blank" rel="noopener">https://www.mongodb.com/docs/drivers/go/upcoming/fundamentals/bson/#struct-tags</a></p><p>User结构体中ID一定要使用omitempty，新增时结构体ID不设置则为零值，提交时不会提交ID，数据库自动生成_id</p><p>ObjectId有12字节组成，参考 bson/primitive/objectid.go/NewObjectID()函数</p><ul><li>4字节时间戳</li><li>5字节进程唯一值</li><li>3字节随机数，每次加1</li></ul><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><p>操作参考 <a href="https://www.mongodb.com/docs/drivers/go/current/usage-examples/" target="_blank" rel="noopener">https://www.mongodb.com/docs/drivers/go/current/usage-examples/</a></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入一条数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertOne</span><span class="params">()</span></span> {</span><br><span class="line">tom := User{Name: <span class="string">"tom"</span>, Age: <span class="number">35</span>}</span><br><span class="line">insertResult, err := users.InsertOne(context.TODO(), tom)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">}</span><br><span class="line">fmt.Println(insertResult.InsertedID)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入多条数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertMany</span><span class="params">()</span></span> {</span><br><span class="line">jerry := User{Name: <span class="string">"jerry"</span>, Age: <span class="number">23</span>}</span><br><span class="line">ben := User{Name: <span class="string">"ben"</span>, Age: <span class="number">19</span>}</span><br><span class="line">insertManyResult, err := users.InsertMany(context.TODO(), []<span class="keyword">interface</span>{}{jerry, ben})</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">}</span><br><span class="line">fmt.Println(insertManyResult.InsertedIDs...)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="BSON"><a href="#BSON" class="headerlink" title="BSON"></a>BSON</h3><p><a href="https://www.mongodb.com/docs/drivers/go/upcoming/fundamentals/bson/" target="_blank" rel="noopener">https://www.mongodb.com/docs/drivers/go/upcoming/fundamentals/bson/</a></p><p>MOngoDB的Go库提供的构建BSON的数据类型分为4种</p><ul><li>D : An ordered representation of a BSON document (slice)，表示有序的，切片且元素是二元的</li><li>M : An unordered representation of a BSON document (map)，表示无序的，map且元素是kv对</li><li>A : An ordered representation of a BSON array</li><li>E : A single element inside a D type</li></ul><p>具体使用看以下的例子</p><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><h4 id="单条查询"><a href="#单条查询" class="headerlink" title="单条查询"></a>单条查询</h4><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询一条数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findOne</span><span class="params">()</span></span> {</span><br><span class="line"><span class="comment">// 条件</span></span><br><span class="line"><span class="comment">// filter := bson.D{{"name": "tom"}} // slice</span></span><br><span class="line"><span class="comment">// filter := bson.D{{"name", bson.D{{"$eq", "tom"}}}}</span></span><br><span class="line">filter := bson.M{<span class="string">"name"</span>: <span class="string">"tom"</span>} <span class="comment">// map</span></span><br><span class="line"><span class="comment">// filter := bson.M{"name": bson.M{"$ne": "jerry"}}</span></span><br><span class="line"><span class="comment">// filter := bson.D{{}} // 没有条件全部都符合</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> u User</span><br><span class="line">err := users.FindOne(context.TODO(), filter).Decode(&amp;u)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line"><span class="keyword">if</span> err == mongo.ErrNoDocuments {</span><br><span class="line"><span class="comment">// 说明没有任务匹配文档</span></span><br><span class="line">log.Println(<span class="string">"没有匹配的文档"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">}</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">}</span><br><span class="line">fmt.Println(u)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="多条查询"><a href="#多条查询" class="headerlink" title="多条查询"></a>多条查询</h4><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询多条数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMany1</span><span class="params">()</span></span> {</span><br><span class="line">filter := bson.M{} <span class="comment">// 无条件，全部符合</span></span><br><span class="line">cursor, err := users.Find(context.TODO(), filter)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">}</span><br><span class="line"><span class="keyword">var</span> results []*User</span><br><span class="line"><span class="keyword">for</span> cursor.Next(context.TODO()) {</span><br><span class="line"><span class="keyword">var</span> u User</span><br><span class="line">err = cursor.Decode(&amp;u)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">}</span><br><span class="line">results = <span class="built_in">append</span>(results, &amp;u) <span class="comment">// 装入容器</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> err := cursor.Err(); err != <span class="literal">nil</span> {</span><br><span class="line">log.Fatal(err)</span><br><span class="line">}</span><br><span class="line">cursor.Close(context.TODO()) <span class="comment">// 关闭游标</span></span><br><span class="line">fmt.Println(results)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询多条数据，成批装入容器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMany2</span><span class="params">()</span></span> {</span><br><span class="line">filter := bson.M{} <span class="comment">// 无条件，全部符合</span></span><br><span class="line"><span class="keyword">var</span> results []*User</span><br><span class="line">cursor, err := users.Find(context.TODO(), filter)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">}</span><br><span class="line">err = cursor.All(context.TODO(), &amp;results)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">}</span><br><span class="line">cursor.Close(context.TODO()) <span class="comment">// 关闭游标</span></span><br><span class="line"><span class="keyword">for</span> i, j := <span class="keyword">range</span> results {</span><br><span class="line">fmt.Println(i, j)</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h4><p>改造上面的findMany2函数，可以使用下面表格中不同filter</p><p><a href="https://www.mongodb.com/docs/manual/reference/operator/query/and/" target="_blank" rel="noopener">https://www.mongodb.com/docs/manual/reference/operator/query/and/</a></p><table><thead><tr><th>比较符号</th><th>含义</th><th>filter示例</th></tr></thead><tbody><tr><td>$lt</td><td>小于</td><td><code>bson.M{"age": bson.M{"$lt": 20}}</code></td></tr><tr><td>$gt</td><td>大于</td><td><code>bson.M{"age": bson.M{"$gt": 20}}</code></td></tr><tr><td>$lte</td><td>小于等于</td><td><code>bson.M{"age": bson.M{"$lte": 20}}</code></td></tr><tr><td>$gte</td><td>大于等于</td><td><code>bson.M{"age": bson.M{"$gte": 20}}</code></td></tr><tr><td>$ne</td><td>不等于</td><td><code>bson.M{"age": bson.M{"$ne": 20}}</code></td></tr><tr><td>$eq</td><td>等于，可以不用这个符号</td><td><code>bson.M{"age": bson.M{"$eq": 20}}</code> <code>bson.M{"age": 20}</code></td></tr><tr><td>$in</td><td>在范围内</td><td><code>bson.M{"age": bson.M{"$in": []int{16, 33}}}</code></td></tr><tr><td>$nin</td><td>不在范围内</td><td><code>bson.M{"age": bson.M{"$nin": []int{16, 33}}}</code></td></tr></tbody></table><table><tbody><tr><td><b>逻辑符号</b></td><td><b>含义</b></td><td><b>filter 示例</b></td></tr><tr></tr><tr><td>$and</td><td>与</td><td>bson.M{"$and": []bson.M{{"name": "tom"}, {"age": 33}}}<br>bson.M{"$and": []bson.M{{"name": "tom"}, {"age": bson.M{"$gt":40}}}}</td></tr><tr></tr><tr><td>$or</td><td>或</td><td>bson.M{"$or": []bson.M{{"name": "tom"}, {"age": bson.M{"$lt":20}}}}</td></tr><tr><td rowspan="1">$not</td><td>非</td><td>bson.M{"age": bson.M{"$not": bson.M{"$gte": 20}}}</td></tr></tbody></table><table><thead><tr><th>元素</th><th>含义</th><th>示例</th></tr></thead><tbody><tr><td>$exists</td><td>文档中是否有这个字段</td><td><code>bson.M{"Name": bson.M{"$exists": true}}</code></td></tr><tr><td>$type</td><td>字段是否是指定的类型</td><td><code>bson.M{"age": bson.M{"$type": 16}}</code></td></tr></tbody></table><p>常用类型，参考 <a href="https://docs.mongodb.com/manual/reference/operator/query/type/#op._S_type" target="_blank" rel="noopener">https://docs.mongodb.com/manual/reference/operator/query/type/#op._S_type</a></p><ul><li>字符串类型编码为2，别名为string</li><li>整型编码为16，别名为int</li><li>长整型编码为18，别名为long</li></ul><p>改造函数<code>findByFilter</code>为<code>findAll</code>，如下</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findAll</span><span class="params">(filter <span class="keyword">interface</span>{}, opt *options.FindOptions)</span></span> {</span><br><span class="line"><span class="keyword">var</span> results []*User</span><br><span class="line">cursor, err := users.Find(context.TODO(), filter, opt)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">}</span><br><span class="line">err = cursor.All(context.TODO(), &amp;results)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">}</span><br><span class="line">cursor.Close(context.TODO()) <span class="comment">// 关闭游标</span></span><br><span class="line">fmt.Println(results)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="投影"><a href="#投影" class="headerlink" title="投影"></a>投影</h4><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">filter := bson.M{<span class="string">"age"</span>: bson.M{<span class="string">"$gt"</span>: <span class="number">20</span>}}</span><br><span class="line">opt := options.Find()</span><br><span class="line">opt.SetProjection(bson.M{<span class="string">"name"</span>: <span class="literal">false</span>, <span class="string">"age"</span>: <span class="literal">false</span>}) <span class="comment">// name、age字段不投影，都显示为零值</span></span><br><span class="line">findAll(filter, opt)</span><br><span class="line"></span><br><span class="line">opt.SetProjection(bson.M{<span class="string">"name"</span>: <span class="literal">true</span>}) <span class="comment">// name投影，age字段零值显示 1</span></span><br><span class="line">findAll(filter, opt)</span><br></pre></td></tr></tbody></table></figure><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">opt.SetSort(bson.M{<span class="string">"age"</span>: <span class="number">1</span>})  <span class="comment">// 升序</span></span><br><span class="line">opt.SetSort(bson.M{<span class="string">"age"</span>: <span class="number">-1</span>}) <span class="comment">// 降序</span></span><br></pre></td></tr></tbody></table></figure><h4 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h4><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">opt.SetSkip(<span class="number">1</span>)  <span class="comment">// offset</span></span><br><span class="line">opt.SetLimit(<span class="number">1</span>) <span class="comment">// limit</span></span><br><span class="line">findAll(filter, opt)</span><br></pre></td></tr></tbody></table></figure><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><table><thead><tr><th>更新操作符</th><th>含义</th><th>示例</th></tr></thead><tbody><tr><td>$inc</td><td>对给定字段数字值增减</td><td><code>bson.M{"$inc": bson.M{"age": -5}}</code></td></tr><tr><td>$set</td><td>设置字段值，如果字段不存在则创建</td><td><code>bson.M{"$set": bson.M{"gender": "M"}}</code></td></tr><tr><td>$unset</td><td>移除字段</td><td><code>{'$unset':{'Name':""}}</code></td></tr></tbody></table><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更新一条</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">updateOne</span><span class="params">()</span></span> {</span><br><span class="line">filter := bson.M{<span class="string">"age"</span>: bson.M{<span class="string">"$exists"</span>: <span class="literal">true</span>}} <span class="comment">// 所有有age字段的文档</span></span><br><span class="line">update := bson.M{<span class="string">"$inc"</span>: bson.M{<span class="string">"age"</span>: <span class="number">-5</span>}}      <span class="comment">// age字段减5</span></span><br><span class="line">ur, err := users.UpdateOne(context.TODO(), filter, update)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">log.Fatal(err)</span><br><span class="line">}</span><br><span class="line">fmt.Println(ur.MatchedCount, ur.ModifiedCount)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新多条</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">updateMany</span><span class="params">()</span></span> {</span><br><span class="line">filter := bson.M{<span class="string">"age"</span>: bson.M{<span class="string">"$exists"</span>: <span class="literal">true</span>}} <span class="comment">// 所有有age字段的文档</span></span><br><span class="line">update := bson.M{<span class="string">"$set"</span>: bson.M{<span class="string">"gender"</span>: <span class="string">"M"</span>}}  <span class="comment">// 为符合条件的文档设置gender字段</span></span><br><span class="line">    <span class="comment">// update := bson.M{"$unset": bson.M{"gender": ""}} // 为符合条件的文档移除gender字段</span></span><br><span class="line">users.UpdateMany(context.TODO(), filter, update)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除一条</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteOne</span><span class="params">()</span></span> {</span><br><span class="line">filter := bson.M{} <span class="comment">// 没有条件，匹配所有文档</span></span><br><span class="line">dr, err := users.DeleteOne(context.TODO(), filter)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">log.Fatal(err)</span><br><span class="line">}</span><br><span class="line">fmt.Println(dr.DeletedCount)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除多条</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteMany</span><span class="params">()</span></span> {</span><br><span class="line"><span class="comment">// filter := bson.M{} // 没有条件，匹配所有文档</span></span><br><span class="line">filter := bson.M{<span class="string">"name"</span>: <span class="string">"tom"</span>}</span><br><span class="line">dr, err := users.DeleteMany(context.TODO(), filter)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">log.Fatal(err)</span><br><span class="line">}</span><br><span class="line">fmt.Println(dr.DeletedCount)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><!-- rebuild by neat --><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;MongoDB&quot;&gt;&lt;a href=&quot;#MongoDB&quot; class=&quot;headerlink&quot; title=&quot;MongoDB&quot;&gt;&lt;/a&gt;MongoDB&lt;/h3&gt;&lt;p&gt;MongoDB是一种高性能、开源、文档型的NoSQL数据库，被广泛应用于Web应用、大数据以及云计算
      
    
    </summary>
    
    
      <category term="Go" scheme="http://chenzhonzhou.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="http://chenzhonzhou.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go 协程</title>
    <link href="http://chenzhonzhou.github.io/2023/05/05/go-xie-cheng/"/>
    <id>http://chenzhonzhou.github.io/2023/05/05/go-xie-cheng/</id>
    <published>2023-05-05T03:20:35.000Z</published>
    <updated>2023-12-02T03:29:01.418Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、概念："><a href="#一、概念：" class="headerlink" title="一、概念："></a>一、概念：</h2><p>协程术语”0coroutine”最早出现在<strong>1963年美国计算机科学家Melvin E. Conway</strong>（马尔文·爱德华·康威）发表的论文中。</p><p>也许读者听说过著名的<strong>康威定律</strong>：<strong>“设计系统的架构受制于产生这些设计的组织的沟通结构”。</strong>即系统设计本质上反映了企业的组织机构，系统各个模块间的接口也反映了企业各个部门之间的信息流动和合作方式。</p><p>支持协程的编程语言有很多，比如Python、Perl等，但没有哪个语言能像Go一样把协程支持得如此优雅，Go在语言层面直接提供对协程的支持称为goroutine。</p><h2 id="二、相关概念："><a href="#二、相关概念：" class="headerlink" title="二、相关概念："></a>二、相关概念：</h2><h3 id="1）进程："><a href="#1）进程：" class="headerlink" title="1）进程："></a>1）进程：</h3><p>进程是应用程序的启动实例，每个进程都有独立的内存空间，不同进程通过进程间的通信方式来通信。</p><h3 id="2）线程："><a href="#2）线程：" class="headerlink" title="2）线程："></a>2）线程：</h3><p>线程从属于进程，每个进程至少包含一个线程，线程是CPU调度的基本单位，多个线程之间可以共享进程的资源并通过共享内存等线程间的通信方式来通信。</p><h3 id="3）协程："><a href="#3）协程：" class="headerlink" title="3）协程："></a>3）协程：</h3><p>协程可理解为一种<strong>轻量级线程</strong>，与线程相比，协程不受操作系统调度，协程调度器由用户应用程序提供，协程调度器按照调度策略把协程调度到线程中运行。</p><p>Go应用程序的协程调度器由runtime包提供，用户使用go关键字即可创建协程，这也就是在语言层面直接支持协程的含义。</p><h2 id="三、协程的优势："><a href="#三、协程的优势：" class="headerlink" title="三、协程的优势："></a>三、协程的优势：</h2><p>我们知道，在高并发应用中频繁创建线程会造成不必要的开销，所以有了线程池技术。在线程池中预先保存一定数量的线程，新任务将不再以创建线程的方式去执行，而是将任务发布到任务队列中，线程池中的线程不断地从任务队列中取出任务并执行，这样可以有效地减少线程的创建和销毁所带来的开销。</p><h2 id="四、GMP模型"><a href="#四、GMP模型" class="headerlink" title="四、GMP模型"></a>四、GMP模型</h2><p>Robert Griesemer、Rob Pike、Ken Thompson三位Go语言创始人，对新语言商在讨论时，就决定了要让Go语言成为面向未来的语言。当时多核CPU已经开始普及，但是众多“古老”编程语言却不能很好的适应新的硬件进步，Go语言诞生之初就为多核CPU并行而设计。</p><p>Go语言协程中，非常重要的就是协程调度器scheduler和网络轮询器netpoller。</p><p>Go协程调度中，有三个重要角色：</p><ul><li><p>M：Machine Thread，对系统线程抽象、封装。所有代码最终都要在系统线程上运行，协程最终也是代码，也不例外</p></li><li><p>G：Goroutine，Go协程。存储了协程的执行栈信息、状态和任务函数等。初始栈大小约为2~4k，理论上开启百万个Goroutine不是问题</p></li><li><p>P：Go1.1版本引入，Processor，虚拟处理器</p><ul><li><p>可以通过环境变量GOMAXPROCS或runtime.GOMAXPROCS()设置，默认为CPU核心数</p></li><li><p>P的数量决定着最大可并行的G的数量</p></li><li><p>P有自己的队列（长度256），里面放着待执行的G</p></li><li><p>M和P需要绑定在一起，这样P队列中的G才能真正在线程上执行</p></li></ul></li></ul><p><img src="/2023/05/05/go-xie-cheng/Go%E5%8D%8F%E7%A8%8B1.png" alt="图片1"></p><p>1、使用go func创建一个Goroutine g1</p><p>2、当前P为p1，将g1加入当前P的本地队列LRQ(Local Run Queue)。如果LRQ满了，就加入到GRQ（Global Run Queue）</p><p>3、p1和m1绑定，m1先尝试从p1的LRQ中请求G。如果没有，就从GRQ中请求G。如果还没有，就随机从别的P的LRQ中偷（work stealing）一部分G到本地LRQ中。</p><p>4、假设m1最终拿到了g1</p><p>5、执行，让g1的代码在m1线程上运行</p><p>5.1、g1正常执行完了（函数调用完成了），g1和m1解绑，执行第3步的获取下一个可执行的g</p><p>5.2、g1中代码主动让出控制权，g1和m1解绑，将g1加入到GRQ中，执行第3步的获取下一个可执行的g</p><p>5.3、g1中进行channel、互斥锁等操作进入阻塞态，g1和m1解绑，执行第3步的获取下一个可执行的g。如果阻塞态的g1被其他协程g唤醒后，就尝试加入到唤醒者的LRQ中，如果LRQ满了，就连同g和LRQ中一半转移到GRQ中。</p><p>5.4、系统调用</p><p>5.4.1 <strong>同步</strong>系统调用时，执行如下：</p><p>如果遇到了同步阻塞系统调用，g1阻塞，m1也被阻塞了，m1和p1解绑。</p><p>从休眠线程队列中获取一个空闲线程，和p1绑定，并从p1队列中获取下一个可执行的g来执行；如果休眠队列中无空闲线程，就创建一个线程提供给p1。</p><p>如果m1阻塞结束，需要和一个空闲的p绑定，优先和原来的p1绑定。如果没有空闲的P，g1会放到GRQ中，m1加入到休眠线程队列中。</p><p>5.4.2 <strong>异步</strong>网络IO调用时，如下：</p><p><img src="/2023/05/05/go-xie-cheng/Go%E5%8D%8F%E7%A8%8B2.png" alt="图片2"></p><p>网络IO代码会被Go在底层变成非阻塞IO，这样就可以使用IO多路复用了。</p><p>m1执行g1，执行过程中发生了非阻塞IO调用（读/写）时，g1和m1解绑，g1会被网络轮询器Netpoller接手。m1再从p1的LRQ中获取下一个Goroutine g2执行。注意，m1和p1不解绑。</p><p>g1等待的IO就绪后，g1从网络轮询器移回P的LRQ（本地运行队列）或全局GRQ中，重新进入可执行状态。</p><p>就大致相当于网络轮询器Netpoller内部就是使用了IO多路复用和非阻塞IO，类似我们课件代码中的select的循环。GO对不同操作系统MAC（kqueue）、Linux（epoll）、Windows（iocp）提供了支持。</p><p>问题：如果GOMAXPROCS为1，说明什么？</p><h2 id="五、Goroutine"><a href="#五、Goroutine" class="headerlink" title="五、Goroutine"></a>五、Goroutine</h2><h3 id="5-1-协程创建"><a href="#5-1-协程创建" class="headerlink" title="5.1 协程创建"></a>5.1 协程创建</h3><p>使用go关键字就可以把一个函数定义为一个协程，非常方便。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"runtime"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> {</span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">int</span></span><br><span class="line"><span class="keyword">defer</span> fmt.Printf(<span class="string">"1 return %d\n"</span>, c)              <span class="comment">// 打印的c是什么？</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> { fmt.Printf(<span class="string">"2 return %d\n"</span>, c) }() <span class="comment">// 打印的c是什么？</span></span><br><span class="line">fmt.Printf(<span class="string">"add called: x=%d, y=%d\n"</span>, x, y)</span><br><span class="line">c = x + y</span><br><span class="line"><span class="keyword">return</span> c</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line"><span class="comment">// fmt.Println("main start")</span></span><br><span class="line"><span class="comment">// add(4, 5)</span></span><br><span class="line"><span class="comment">// fmt.Println("main end")</span></span><br><span class="line">fmt.Println(runtime.NumGoroutine())</span><br><span class="line">fmt.Println(<span class="string">"main start"</span>)</span><br><span class="line"><span class="keyword">go</span> add(<span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">fmt.Println(runtime.NumGoroutine())</span><br><span class="line"><span class="comment">// time.Sleep(2 * time.Second)</span></span><br><span class="line">fmt.Println(<span class="string">"main end"</span>)</span><br><span class="line">fmt.Println(runtime.NumGoroutine())</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果没有 <code>time.Sleep(2 * time.Second)</code> ，结果如下</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line">main start</span><br><span class="line"><span class="number">2</span></span><br><span class="line">main end</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></tbody></table></figure><p>放开了 ，结果如下</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line">main start</span><br><span class="line"><span class="number">2</span></span><br><span class="line">add called: x=<span class="number">4</span>, y=<span class="number">5</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">return</span> <span class="number">9</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">main end</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></tbody></table></figure><p>为什么？</p><p>因为会启动协程来运行add，那么go add(4, 5)这一句没有必要等到函数返回才结束，所以程序执行下一行打印Main Exit。这时main函数无事可做，Go程序启动时也创建了一个协程，main函数运行其中，可以称为main goroutine（主协程）。但是主协程一旦执行结束，则进程结束，根本不会等待未执行完的其它协程。</p><p>那么，除了像<code>time.Sleep(2 * time.Second)</code>这样一直等，如何才能让主线程优雅等待协程执行结束呢？等待组</p><h3 id="5-2-等待组"><a href="#5-2-等待组" class="headerlink" title="5.2 等待组"></a>5.2 等待组</h3><p>使用参考 <a href="https://pkg.go.dev/sync#WaitGroup" target="_blank" rel="noopener">https://pkg.go.dev/sync#WaitGroup</a></p><p>使用等待组修改上例</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"runtime"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="keyword">int</span>, wg *sync.WaitGroup)</span> <span class="title">int</span></span> {</span><br><span class="line"><span class="keyword">defer</span> wg.Done() <span class="comment">// add执行完后计数器减1</span></span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">int</span></span><br><span class="line"><span class="keyword">defer</span> fmt.Printf(<span class="string">"1 return %d\n"</span>, c)              <span class="comment">// 打印的c是什么？</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> { fmt.Printf(<span class="string">"2 return %d\n"</span>, c) }() <span class="comment">// 打印的c是什么？</span></span><br><span class="line">fmt.Printf(<span class="string">"add called: x=%d, y=%d\n"</span>, x, y)</span><br><span class="line">c = x + y</span><br><span class="line">fmt.Printf(<span class="string">"add called: c=%d\n"</span>, c)</span><br><span class="line"><span class="keyword">return</span> c</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup <span class="comment">// 定义等待组</span></span><br><span class="line">fmt.Println(runtime.NumGoroutine())</span><br><span class="line">fmt.Println(<span class="string">"main start"</span>)</span><br><span class="line">wg.Add(<span class="number">1</span>)         <span class="comment">// 计数加1</span></span><br><span class="line"><span class="keyword">go</span> add(<span class="number">4</span>, <span class="number">5</span>, &amp;wg) <span class="comment">// 协程</span></span><br><span class="line">fmt.Println(runtime.NumGoroutine())</span><br><span class="line"><span class="comment">// time.Sleep(2 * time.Second) // 这一句不需要了</span></span><br><span class="line">wg.Wait() <span class="comment">// 阻塞到wg的计数为0</span></span><br><span class="line">fmt.Println(<span class="string">"main end"</span>)</span><br><span class="line">fmt.Println(runtime.NumGoroutine())</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>执行结果如下</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line">main start</span><br><span class="line"><span class="number">2</span></span><br><span class="line">add called: x=<span class="number">4</span>, y=<span class="number">5</span></span><br><span class="line">add called: c=<span class="number">9</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">return</span> <span class="number">9</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">main end</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></tbody></table></figure><h3 id="5-3-父子协程"><a href="#5-3-父子协程" class="headerlink" title="5.3 父子协程"></a>5.3 父子协程</h3><p>一个协程A中创建了另外一个协程B，A称作父协程，B称为子协程。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup <span class="comment">// 定义等待组</span></span><br><span class="line">fmt.Println(<span class="string">"main start"</span>)</span><br><span class="line">count := <span class="number">6</span></span><br><span class="line">wg.Add(count)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">fmt.Println(<span class="string">"父协程开始，准备启动子协程"</span>)</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">wg.Done() <span class="comment">// 注意wg的作用域</span></span><br><span class="line">fmt.Println(<span class="string">"父协程结束了~~~~"</span>)</span><br><span class="line">}()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; count<span class="number">-1</span>; i++ {</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(id <span class="keyword">int</span>)</span></span> {</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">fmt.Printf(<span class="string">"子协程 %d 运行中\n"</span>, id)</span><br><span class="line">time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">fmt.Printf(<span class="string">"子协程 %d 结束\n"</span>, id)</span><br><span class="line">}(i)</span><br><span class="line">}</span><br><span class="line">}()</span><br><span class="line">wg.Wait() <span class="comment">// 阻塞到wg的计数为0</span></span><br><span class="line">fmt.Println(<span class="string">"main end"</span>)</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 注：上例协程最好写成独立的函数，而不是这样嵌套，只是为了演示。</span></span><br></pre></td></tr></tbody></table></figure><p>执行结果如下</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">main start</span><br><span class="line">父协程开始，准备启动子协程</span><br><span class="line">父协程结束了~~~~</span><br><span class="line">子协程 <span class="number">1</span> 运行中</span><br><span class="line">子协程 <span class="number">0</span> 运行中</span><br><span class="line">子协程 <span class="number">2</span> 运行中</span><br><span class="line">子协程 <span class="number">3</span> 运行中</span><br><span class="line">子协程 <span class="number">4</span> 运行中</span><br><span class="line">子协程 <span class="number">4</span> 结束</span><br><span class="line">子协程 <span class="number">2</span> 结束</span><br><span class="line">子协程 <span class="number">1</span> 结束</span><br><span class="line">子协程 <span class="number">3</span> 结束</span><br><span class="line">子协程 <span class="number">0</span> 结束</span><br><span class="line">main end</span><br></pre></td></tr></tbody></table></figure><p>父协程结束执行，子协程不会有任何影响。当然子协程结束执行，也不会对父协程有什么影响。父子协程没有什么特别的依赖关系，各自独立运行。</p><p>只有主协程特殊，它结束程序结束。</p><!-- rebuild by neat --><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、概念：&quot;&gt;&lt;a href=&quot;#一、概念：&quot; class=&quot;headerlink&quot; title=&quot;一、概念：&quot;&gt;&lt;/a&gt;一、概念：&lt;/h2&gt;&lt;p&gt;协程术语”0coroutine”最早出现在&lt;strong&gt;1963年美国计算机科学家Melvin E. Conway
      
    
    </summary>
    
    
      <category term="Go" scheme="http://chenzhonzhou.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="http://chenzhonzhou.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go Channel通道</title>
    <link href="http://chenzhonzhou.github.io/2023/04/15/go-channel-tong-dao/"/>
    <id>http://chenzhonzhou.github.io/2023/04/15/go-channel-tong-dao/</id>
    <published>2023-04-15T03:18:50.000Z</published>
    <updated>2023-12-02T03:19:48.736Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Go-Channel通道"><a href="#Go-Channel通道" class="headerlink" title="Go Channel通道"></a>Go Channel通道</h3><p>Channel底层是一个先进先出的环形队列（固定大小环形数组实现）</p><ul><li>full或empty就会阻塞</li><li>send发送</li><li>recv接收并移除</li><li>sendx表示最后一次插入元素的index</li><li>recvx表示最后一次接收元素的index</li><li>发送、接收的操作符号都是 <code>&lt;-</code></li></ul><h3 id="通道构造"><a href="#通道构造" class="headerlink" title="通道构造"></a>通道构造</h3><p>源码runtime/chan.go/makechan</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c1 <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">fmt.Printf(<span class="string">"c1: %d, %d, %v\n"</span>, <span class="built_in">len</span>(c1), <span class="built_in">cap</span>(c1), c1) <span class="comment">// c1: 0, 0, &lt;nil&gt;</span></span><br><span class="line">c1 &lt;- <span class="number">111</span> <span class="comment">// 阻塞，不报错。由于没有初始化容器，111塞不进去</span></span><br><span class="line">&lt;- c1 <span class="comment">// 也阻塞，不报错，什么都拿不出来</span></span><br></pre></td></tr></tbody></table></figure><p>chan零值是nil，即可以理解未被初始化通道这个容器。nil通道可以认为是一个只要操作就阻塞当前协程的容器。这种通道不要创建和使用，阻塞后无法解除，底层源码中写明了无法解除。</p><p>更多的时候，使用make来创建channel。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 容量为0的非缓冲通道</span></span><br><span class="line">c2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">fmt.Printf(<span class="string">"c2: %d, %d, %v\n"</span>, <span class="built_in">len</span>(c2), <span class="built_in">cap</span>(c2), c2)</span><br><span class="line">c3 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">fmt.Printf(<span class="string">"c3: %d, %d, %v\n"</span>, <span class="built_in">len</span>(c3), <span class="built_in">cap</span>(c3), c3)</span><br></pre></td></tr></tbody></table></figure><p><strong>非缓冲通道</strong>：容量为0的通道，也叫同步通道。这种通道发送第一个元素时，如果没有接收操作就立即阻塞，直到被接收。同样接收时，如果没有数据被发送就立即阻塞，直到有数据发送。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line"><span class="keyword">var</span> c1 <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">fmt.Printf(<span class="string">"c1: %d, %d, %v\n"</span>, <span class="built_in">len</span>(c1), <span class="built_in">cap</span>(c1), c1)</span><br><span class="line">fmt.Println(<span class="string">"准备发送数据111"</span>)</span><br><span class="line">c1 &lt;- <span class="number">111</span> <span class="comment">// 往c1里面发送，阻塞在这一句，死锁，因为本例子无人接收</span></span><br><span class="line">fmt.Println(<span class="string">"发送数据111结束"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>缓冲通道</strong>：容量不为0的通道。通道已满，发送操作会被阻塞；通道为空，接收操作会被阻塞。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">c4 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">8</span>) <span class="comment">// 缓冲通道，容量为8，长度为0</span></span><br><span class="line">fmt.Printf(<span class="string">"c4: %d, %d, %v\n"</span>, <span class="built_in">len</span>(c4), <span class="built_in">cap</span>(c4), c4)</span><br><span class="line"><span class="comment">// 发送数据</span></span><br><span class="line">c4 &lt;- <span class="number">111</span></span><br><span class="line">c4 &lt;- <span class="number">222</span></span><br><span class="line">fmt.Printf(<span class="string">"c4: %d, %d, %v\n"</span>, <span class="built_in">len</span>(c4), <span class="built_in">cap</span>(c4), c4) <span class="comment">// len 2</span></span><br><span class="line"><span class="comment">// 接收</span></span><br><span class="line">&lt;-c4</span><br><span class="line">t := &lt;-c4</span><br><span class="line">fmt.Printf(<span class="string">"%T %[1]v\n"</span>, t)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="单向通道"><a href="#单向通道" class="headerlink" title="单向通道"></a>单向通道</h3><p><code>&lt;- chan type</code> 这种定义表示只从一个channel里面拿，说明这是只读的；</p><p><code>chan &lt;- type</code> 这种定义表示只往一个channel里面写，说明这是只写的。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"math/rand"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">produce</span><span class="params">(ch <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> { <span class="comment">// 生产，只写。只要该通道具有写能力就行</span></span><br><span class="line"><span class="keyword">for</span> {</span><br><span class="line">num := rand.Intn(<span class="number">10</span>)</span><br><span class="line">ch &lt;- num</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">fmt.Println(<span class="string">"生产，写入通道"</span>, num)</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consume</span><span class="params">(ch &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> { <span class="comment">// 消费，只读。只要该通道具有读能力就行</span></span><br><span class="line"><span class="keyword">for</span> {</span><br><span class="line">t := &lt;-ch</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">fmt.Println(<span class="string">"消费，从只读通道接收"</span>, t)</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">wg.Add(<span class="number">2</span>)</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">// 创建可读/写非缓冲通道</span></span><br><span class="line"><span class="keyword">go</span> produce(c)</span><br><span class="line"><span class="keyword">go</span> consume(c)</span><br><span class="line">wg.Wait()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="通道关闭"><a href="#通道关闭" class="headerlink" title="通道关闭"></a>通道关闭</h3><ul><li>使用close(ch)关闭一个通道</li><li>只有发送方才能关闭通道，一旦通道关闭，发送者不能再往其中发送数据，否则panic</li><li>通道关闭作用：告诉接收者再无新数据可以到达了</li><li>通道关闭<ul><li><code>t, ok := &lt;-ch</code> 或 <code>t := &lt;-ch</code> 从通道中读取数据</li><li>正在阻塞等待通道中的数据的接收者，由于通道被关闭，接收者将<strong>不再阻塞</strong>，获取数据失败ok为false，返回零值</li><li>接收者依然可以访问关闭的通道而<strong>不阻塞</strong><ul><li>如果通道内还有剩余数据，ok为true，接收数据</li><li>如果通道内剩余的数据被拿完了，继续接收不阻塞，ok为false，返回零值</li></ul></li></ul></li><li>已经关闭的通道，若再次关闭则panic，因此不要重复关闭</li></ul><h3 id="通道遍历"><a href="#通道遍历" class="headerlink" title="通道遍历"></a>通道遍历</h3><p>1、nil通道</p><p>发送、接收、遍历都阻塞</p><p>2、缓冲的、未关闭的通道</p><p>相当于一个无限元素的通道，迭代不完，阻塞在等下一个元素到达。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">c1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">5</span>) <span class="comment">// 缓冲，未关闭通道</span></span><br><span class="line">fmt.Printf(<span class="string">"c1: %d, %d, %v\n"</span>, <span class="built_in">len</span>(c1), <span class="built_in">cap</span>(c1), c1)</span><br><span class="line">c1 &lt;- <span class="number">111</span></span><br><span class="line">c1 &lt;- <span class="number">222</span></span><br><span class="line">c1 &lt;- <span class="number">333</span></span><br><span class="line">fmt.Println(&lt;-c1, <span class="string">"###"</span>) <span class="comment">// 故意读走一个</span></span><br><span class="line"><span class="keyword">for</span> v := <span class="keyword">range</span> c1 {</span><br><span class="line">fmt.Println(v, <span class="string">"~~~"</span>) <span class="comment">// 打印元素</span></span><br><span class="line">}</span><br><span class="line">fmt.Println(<span class="string">"~~~~~~~~~~~~~~~~~~~~~~~~~~~"</span>) <span class="comment">// 看不到这一句</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>3、缓冲的、关闭的通道</p><p>关闭后，通道不能在进入新的元素，那么相当于遍历有限个元素容器，遍历完就结束了。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">c1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">5</span>) <span class="comment">// 缓冲，未关闭通道</span></span><br><span class="line">fmt.Printf(<span class="string">"c1: %d, %d, %v\n"</span>, <span class="built_in">len</span>(c1), <span class="built_in">cap</span>(c1), c1)</span><br><span class="line">c1 &lt;- <span class="number">111</span></span><br><span class="line">c1 &lt;- <span class="number">222</span></span><br><span class="line">c1 &lt;- <span class="number">333</span></span><br><span class="line"><span class="built_in">close</span>(c1)</span><br><span class="line">fmt.Println(&lt;-c1, <span class="string">"###"</span>) <span class="comment">// 故意读走一个</span></span><br><span class="line"><span class="keyword">for</span> v := <span class="keyword">range</span> c1 {</span><br><span class="line">fmt.Println(v, <span class="string">"~~~"</span>) <span class="comment">// 打印元素</span></span><br><span class="line">}</span><br><span class="line">fmt.Println(<span class="string">"~~~~~~~~~~~~~~~~~~~~~~~~~~~"</span>) <span class="comment">// 看不到这一句</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>4、非缓冲、未关闭通道</p><p>相当于一个无限元素的通道，迭代不完，阻塞在等下一个元素到达。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">c1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">// 非缓冲，未关闭通道</span></span><br><span class="line">fmt.Printf(<span class="string">"c1: %d, %d, %v\n"</span>, <span class="built_in">len</span>(c1), <span class="built_in">cap</span>(c1), c1)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">count := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> {</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">c1 &lt;- count</span><br><span class="line">count++</span><br><span class="line">}</span><br><span class="line">}()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> v := <span class="keyword">range</span> c1 {</span><br><span class="line">fmt.Println(v, <span class="string">"~~~"</span>) <span class="comment">// 打印元素</span></span><br><span class="line">}</span><br><span class="line">fmt.Println(<span class="string">"~~~~~~~~~~~~~~~~~~~~~~~~~~~"</span>) <span class="comment">// 看不到这一句</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>5、非缓冲、关闭通道</p><p>关闭后，通道不能在进入新的元素，那么相当于遍历有限个元素容器，遍历完就结束了。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">c1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">// 非缓冲，未关闭通道</span></span><br><span class="line">fmt.Printf(<span class="string">"c1: %d, %d, %v\n"</span>, <span class="built_in">len</span>(c1), <span class="built_in">cap</span>(c1), c1)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(c1)</span><br><span class="line">count := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ {</span><br><span class="line">time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">c1 &lt;- count</span><br><span class="line">count++</span><br><span class="line">}</span><br><span class="line">}()</span><br><span class="line"><span class="keyword">for</span> v := <span class="keyword">range</span> c1 {</span><br><span class="line">fmt.Println(v, <span class="string">"~~~"</span>) <span class="comment">// 打印元素</span></span><br><span class="line">}</span><br><span class="line">fmt.Println(<span class="string">"~~~~~~~~~~~~~~~~~~~~~~~~~~~"</span>) <span class="comment">// 打印了这一句</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>除nil通道外</p><ul><li>未关闭通道，如同一个无限的容器，将一直迭代通道内元素，没有元素就阻塞</li><li>已关闭通道，将不能加入新的元素，迭代完当前通道内的元素，哪怕是0个元素，然后结束迭代</li></ul><h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">t := time.NewTicker(<span class="number">2</span> * time.Second)</span><br><span class="line"><span class="keyword">for</span> {</span><br><span class="line">fmt.Println(&lt;-t.C) <span class="comment">// 通道每阻塞2秒就接收一次</span></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">t := time.NewTimer(<span class="number">5</span> * time.Second)</span><br><span class="line"><span class="keyword">for</span> {</span><br><span class="line">fmt.Println(&lt;-t.C) <span class="comment">// 通道阻塞2秒后只能接受一次</span></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="通道死锁"><a href="#通道死锁" class="headerlink" title="通道死锁"></a>通道死锁</h3><p>channel满了，就阻塞写；channel空了，就阻塞读。容量为0的通道可以理解为有1个元素都满了。</p><p>阻塞了当前协程之后会交出CPU，去执行其他协程，希望其他协程帮助自己解除阻塞。</p><p>main函数结束了，整个进程结束了。</p><p>如果在main协程中，执行语句阻塞时，环顾四周，如果已经没有其他子协程可以执行，只剩主协程自己，解锁无望了，就自己把自己杀掉，报一个fatal error deadlock</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">c1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">// 非缓冲，未关闭通道</span></span><br><span class="line">fmt.Printf(<span class="string">"c1: %d, %d, %v\n"</span>, <span class="built_in">len</span>(c1), <span class="built_in">cap</span>(c1), c1)</span><br><span class="line">c1 &lt;- <span class="number">111</span> <span class="comment">// 当前协程阻塞，无人能解，死锁</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 运行结果如下</span></span><br><span class="line">$ <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line">c1: <span class="number">0</span>, <span class="number">0</span>, <span class="number">0xc00001a120</span></span><br><span class="line">fatal error: all goroutines are asleep - deadlock!</span><br><span class="line">goroutine <span class="number">1</span> [<span class="keyword">chan</span> send]:</span><br><span class="line">main.main()</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp;O:/pros/main.<span class="keyword">go</span>:<span class="number">10</span> +<span class="number">0xea</span></span><br><span class="line">exit status <span class="number">2</span></span><br></pre></td></tr></tbody></table></figure><p>如果通道阻塞不在main协程中发生，而是发生在子协程中，子协程会继续阻塞着，也可能发生死锁。但是由于至少main协程是一个值得等待的希望，编译器不能帮你识别出死锁。如果真的无任何协程帮助该协程解除阻塞状，那么事实上该子协程解锁无望，已经死锁了。</p><p>死锁的危害可能会导致进程活着，但实际上某些协程未真正工作而阻塞，应该有良好的编码习惯，来减少死锁的出现。</p><h3 id="struct-型通道"><a href="#struct-型通道" class="headerlink" title="struct{}型通道"></a>struct{}型通道</h3><p>前面我们讲过定义结构体<code>时struct{}</code>部分才是类型本身。如果一个结构体类型就是<code>struct{}</code>，说明该结构体的实例没有数据成员，也就是实例内存占用为0。</p><p>这种类型数据构成的通道，非常节约内存，仅仅是为了传递一个信号标志。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">flag := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>{}) <span class="comment">// 比 chan bool省内存</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">flag &lt;- <span class="keyword">struct</span>{}{} <span class="comment">// 无数据成员的结构体实例</span></span><br><span class="line">}()</span><br><span class="line">fmt.Printf(<span class="string">"终于等到了信号, %T, %[1]v"</span>, &lt;-flag)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="通道多路复用"><a href="#通道多路复用" class="headerlink" title="通道多路复用"></a>通道多路复用</h3><p>Go语言提供了select来监听多个channel。</p><p>非阻塞</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">count := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">4</span>)</span><br><span class="line">fin := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> { fin &lt;- <span class="literal">true</span> }()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ {</span><br><span class="line">count &lt;- i</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">}</span><br><span class="line">}()</span><br><span class="line"><span class="keyword">for</span> {</span><br><span class="line"><span class="keyword">select</span> { <span class="comment">// 监听多路通道</span></span><br><span class="line"><span class="keyword">case</span> n := &lt;-count:</span><br><span class="line">fmt.Println(<span class="string">"count ="</span>, n)</span><br><span class="line"><span class="keyword">case</span> &lt;-fin:</span><br><span class="line">fmt.Println(<span class="string">"结束"</span>)</span><br><span class="line"><span class="keyword">goto</span> END</span><br><span class="line"><span class="comment">// default:</span></span><br><span class="line"><span class="comment">// fmt.Println("缺省，以上都不匹配就进入缺省")</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">END:</span><br><span class="line">fmt.Println(<span class="string">"~~~~~~~~~~~~~~~~~~~~~~~~~~~"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>永远阻塞</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">count := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">4</span>)</span><br><span class="line">fin := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">global := <span class="number">1000</span></span><br><span class="line">t1 := time.NewTimer(time.Second)</span><br><span class="line">t2 := time.NewTimer(<span class="number">5</span> * time.Second)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> { fin &lt;- <span class="literal">true</span> }()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ {</span><br><span class="line">count &lt;- i</span><br><span class="line"><span class="comment">// time.Sleep(1 * time.Second)</span></span><br><span class="line">}</span><br><span class="line">}()</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(count), <span class="string">"~~~~@@@"</span>)</span><br><span class="line"><span class="keyword">for</span> {</span><br><span class="line">        <span class="comment">// 永远阻塞</span></span><br><span class="line"><span class="keyword">select</span> { <span class="comment">// 监听多路通道</span></span><br><span class="line"><span class="keyword">case</span> &lt;-t1.C:</span><br><span class="line">fmt.Println(<span class="string">"每隔一秒看看长度"</span>, <span class="built_in">len</span>(count))</span><br><span class="line"><span class="keyword">case</span> &lt;-t2.C:</span><br><span class="line">fmt.Println(<span class="string">"每隔5秒取一次"</span>, &lt;-count)</span><br><span class="line"><span class="keyword">case</span> count &lt;- global: <span class="comment">// 发送数据成功进入通道执行该case</span></span><br><span class="line">global++</span><br><span class="line">fmt.Println(<span class="string">"~~~~~~~~~~~~~~~~~~~~~~~~~~~"</span>)</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="通道并发"><a href="#通道并发" class="headerlink" title="通道并发"></a>通道并发</h3><p>Go语言采用并发同步模型叫做Communication Sequential Process通讯顺序进程，这是一种消息传递模型，在goroutine间传递消息， 而不是对数据进行加锁来实现同步访问。在goroutine之间使用channel来同步和传递数据。</p><ul><li>多个协程之间通讯的管道</li><li>一端推入数据，一端拿走数据</li><li>同一时间，只有一个协程可以访问通道的数据</li><li>协调协程的执行顺序</li></ul><p>如果多个线程都使用了同一个数据，就会出现竞争问题。因为线程的切换不会听从程序员的意志，时间片用完就切换了。解决办法往往需要加锁，让其他线程不能共享数据进行修改，从而保证逻辑正确。但锁的引入严重影响并行效率。</p><p>需求：</p><p>1、有一个全局数count，初始为0。编写一个函数inc，能够对count增加10万次。执行5次inc函数，请问最终count值是多少？</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"runtime"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> count <span class="keyword">int64</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inc</span><span class="params">()</span></span> {</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++ {</span><br><span class="line"><span class="comment">// count = count + 1</span></span><br><span class="line">count++</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">start := time.Now()</span><br><span class="line">inc()</span><br><span class="line">inc()</span><br><span class="line">inc()</span><br><span class="line">inc()</span><br><span class="line">inc()</span><br><span class="line">fmt.Printf(<span class="string">"Go协程数：%d\n"</span>, runtime.NumGoroutine())</span><br><span class="line">fmt.Println(<span class="string">"~~~~~~~~~~~~~~~~~~~~~~~~~~~"</span>)</span><br><span class="line">fmt.Printf(<span class="string">"执行时长：%d 微秒\n"</span>, time.Since(start).Microseconds())</span><br><span class="line">fmt.Printf(<span class="string">"Go协程数：%d\n"</span>, runtime.NumGoroutine())</span><br><span class="line">fmt.Printf(<span class="string">"count：%d\n"</span>, count)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  执行结果</span></span><br><span class="line">Go协程数：<span class="number">1</span></span><br><span class="line">~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">执行时长：<span class="number">1130</span> 微秒</span><br><span class="line">Go协程数：<span class="number">1</span></span><br><span class="line">count：<span class="number">500000</span></span><br></pre></td></tr></tbody></table></figure><p>这是串行，没有并发。</p><p>2、如果并发执行inc函数，该怎么做呢，请问最终count值是多少？</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"runtime"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">var</span> count <span class="keyword">int64</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inc</span><span class="params">()</span></span> {</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++ {</span><br><span class="line"><span class="comment">// count = count + 1</span></span><br><span class="line">count++</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">start := time.Now()</span><br><span class="line">wg.Add(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ {</span><br><span class="line"><span class="keyword">go</span> inc()</span><br><span class="line">}</span><br><span class="line">fmt.Printf(<span class="string">"Go协程数：%d\n"</span>, runtime.NumGoroutine())</span><br><span class="line">fmt.Println(<span class="string">"~~~~~~~~~~~~~~~~~~~~~~~~~~~"</span>)</span><br><span class="line">fmt.Printf(<span class="string">"执行时长：%d 微秒\n"</span>, time.Since(start).Microseconds())</span><br><span class="line">fmt.Printf(<span class="string">"Go协程数：%d\n"</span>, runtime.NumGoroutine())</span><br><span class="line">fmt.Printf(<span class="string">"count：%d\n"</span>, count)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line">Go协程数：<span class="number">6</span></span><br><span class="line">~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">执行时长：<span class="number">545</span> 微秒</span><br><span class="line">Go协程数：<span class="number">1</span></span><br><span class="line">count：<span class="number">251991</span></span><br></pre></td></tr></tbody></table></figure><p>开了5个协程并发，count结果不为50万了。为什么？count随机了。</p><p>原因在于count++不是原子操作，会被打断。所以，即使使用goroutine也会有竞争，一样会有并发安全问题。换成下句试一试</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">atomic.AddInt64(&amp;count, <span class="number">1</span>) <span class="comment">// count++</span></span><br><span class="line">Go协程数：<span class="number">6</span></span><br><span class="line">~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">执行时长：<span class="number">6891</span> 微秒</span><br><span class="line">Go协程数：<span class="number">1</span></span><br><span class="line">count：<span class="number">500000</span></span><br></pre></td></tr></tbody></table></figure><p>结果正确了，但是这种共享内存的方式执行时长明显增加。</p><p>也可以使用互斥锁来保证count++的原子性操作</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">var</span> count <span class="keyword">int64</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> mx sync.Mutex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inc</span><span class="params">()</span></span> {</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++ {</span><br><span class="line">mx.Lock()</span><br><span class="line">count++</span><br><span class="line">mx.Unlock()</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">start := time.Now()</span><br><span class="line">wg.Add(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ {</span><br><span class="line"><span class="keyword">go</span> inc()</span><br><span class="line">}</span><br><span class="line">fmt.Printf(<span class="string">"Go协程数：%d\n"</span>, runtime.NumGoroutine())</span><br><span class="line">fmt.Println(<span class="string">"~~~~~~~~~~~~~~~~~~~~~~~~~~~"</span>)</span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Printf(<span class="string">"执行时长：%d 微秒\n"</span>, time.Since(start).Microseconds())</span><br><span class="line">fmt.Printf(<span class="string">"Go协程数：%d\n"</span>, runtime.NumGoroutine())</span><br><span class="line">fmt.Printf(<span class="string">"count：%d\n"</span>, count)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>3、是否能使用通道，来同步多个协程</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"runtime"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">var</span> ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int64</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inc</span><span class="params">()</span></span> {</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++ {</span><br><span class="line">t := &lt;-ch</span><br><span class="line">t++</span><br><span class="line">ch &lt;- t</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">start := time.Now()</span><br><span class="line">ch &lt;- <span class="number">0</span></span><br><span class="line">wg.Add(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ {</span><br><span class="line"><span class="keyword">go</span> inc()</span><br><span class="line">}</span><br><span class="line">fmt.Printf(<span class="string">"Go协程数：%d\n"</span>, runtime.NumGoroutine())</span><br><span class="line">fmt.Println(<span class="string">"~~~~~~~~~~~~~~~~~~~~~~~~~~~"</span>)</span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Printf(<span class="string">"执行时长：%d 微秒\n"</span>, time.Since(start).Microseconds())</span><br><span class="line">fmt.Printf(<span class="string">"Go协程数：%d\n"</span>, runtime.NumGoroutine())</span><br><span class="line">fmt.Printf(<span class="string">"count：%d\n"</span>, &lt;-ch)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line">Go协程数：<span class="number">6</span></span><br><span class="line">~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">执行时长：<span class="number">122860</span> 微秒</span><br><span class="line">Go协程数：<span class="number">1</span></span><br><span class="line">count：<span class="number">500000</span></span><br></pre></td></tr></tbody></table></figure><p>上例是计算密集型，对同一个数据进行争抢，<strong>不是</strong>能发挥并行计算优势的例子，也不适合使用通道，用锁实现更有效率，更有优势。</p><p>上例只是为了让大家体会串行、并行执行，以及不同并行方式的思维和差异。</p><p>通道适合数据流动的场景</p><ul><li>如同管道一样，一级一级处理，一个协程处理完后，发送给其他协程</li><li>生产者、消费者模型，M:N</li></ul><h3 id="协程泄露"><a href="#协程泄露" class="headerlink" title="协程泄露"></a>协程泄露</h3><p>原因</p><ul><li>协程阻塞，未能如期结束，之后就会大量累积</li><li>协程阻塞最常见的原因都跟通道有关</li><li>由于每个协程都要占用内存，所以协程泄露也会导致内存泄露</li></ul><p>因此，如果你不知道你创建的协程何时能够结束，就不要使用它。否则可能协程泄露。</p><!-- rebuild by neat --><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Go-Channel通道&quot;&gt;&lt;a href=&quot;#Go-Channel通道&quot; class=&quot;headerlink&quot; title=&quot;Go Channel通道&quot;&gt;&lt;/a&gt;Go Channel通道&lt;/h3&gt;&lt;p&gt;Channel底层是一个先进先出的环形队列（固定大小环形数组
      
    
    </summary>
    
    
      <category term="Go" scheme="http://chenzhonzhou.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="http://chenzhonzhou.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go 加解密</title>
    <link href="http://chenzhonzhou.github.io/2023/04/11/go-jia-jie-mi/"/>
    <id>http://chenzhonzhou.github.io/2023/04/11/go-jia-jie-mi/</id>
    <published>2023-04-11T03:15:25.000Z</published>
    <updated>2023-12-02T03:18:34.628Z</updated>
    
    <content type="html"><![CDATA[<h3 id="加密解密系统"><a href="#加密解密系统" class="headerlink" title="加密解密系统"></a>加密解密系统</h3><p>通常一个密钥加密解密系统应该包括以下部分</p><ul><li>消息空间M（Message），就是未加密的数据空间</li><li>密文空间C（Ciphertext），加密后得到的数据空间</li><li>密钥空间K（Key），可以使用的各种密码</li><li>加密算法E（Encryption Algorithm）</li><li>解密算法D（Decryption Algorithm）</li></ul><p>加密过程：消息空间中的某一个消息M1（明文）使用密钥空间中的摸一个密钥K1，通过加密算法E加密</p><p>后得到密文C1，记作Ek1(M1) = C1。</p><p>解密过程：将密文C1使用解密密钥K2通过解密算法D解密后得到原始的明文，记作Dk2（C1）= M1。</p><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p>对称加密：加密密钥和解密密钥相同密钥的加密解密系统，称为对称加密，也称单密钥加密。</p><ul><li>加密、解密使用同一组密钥</li><li>算法公开、计算量小、加密速度快、加密效率高，适合大量数据的场合</li><li>加密、解密双方，如果一方密钥泄露，数据就不安全了</li><li>常见加密算法：DES、AES</li></ul><p>对称加密算法有两种类型：分组密钥（Block Cipher）和流密码（Stream Cipher）。</p><p>流密码：对输入元素进行连续处理，同时产生连续单个输出元素。</p><p>分组密码：将明文分成固定长度的分组，各个分组在密钥控制下使用算法变换成等长的密文分组。常见的算法有DES、3DES、AES、Blowfish等。</p><h4 id="DES"><a href="#DES" class="headerlink" title="DES"></a>DES</h4><p>DES（Data Encryption Standard）数据加密标准，是目前最流行的加密算法之一。</p><p>DES分组密码算法</p><ul><li>用户提供64位初始密钥，经过一系列处理获得k1、k2、…、k16总共16个48位子密钥，分别用在</li><li>1~16轮运算中将明文分组（Block），每组64位，每组使用16个子密钥通过加密函数处理得到64位密文</li><li>加密解密过程相同，但密钥应用次序和加密时相反</li></ul><p>DES工作模式</p><ol><li>ECB（Electornic Codebook电子密码本）模式：64位的明文使用加密得到64位密文，将各组密文按顺序连接得到最终密文</li><li>CBC（Cipher Block Chaining分组链接）模式：每一组明文先和前一组密文计算后，再加密后得到密文。也就是说前一组的结果需代入下一组的计算，这看起来就是一个链。需提供一个初始向量IV和第一组明文计算。</li><li>CFB（Cipher Feed Back密文反馈）模式：增加移位寄存器。假设n为32，每组明文、密文都是n位。将上一组的n位密文分组，加入到移位寄存器中，使用移位寄存器中最右端64位加密得到64位结果，取结果中n位和n位明文计算得到n位密文</li><li>OFB（Output Feed Back输出反馈）模式：和CFB不同，前一组加密后的64位结果的前n位加入到下一组的移位寄存器中块填充</li></ol><h4 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h4><p>AES（Advanced Encryption Standard）高级加密标准，主要是为了取代DES算法。</p><ul><li>分组大小为128位</li><li>密钥长度也为128位</li><li>采用Rijndael加密算法，允许128、192、256位分组加密</li></ul><p>相较于DES</p><ul><li>计算对内存要求极低，适用于资源受限的硬件环境</li><li>计算更加快速，在各种处理器平台都能实现更快速的计算</li><li>安全性更高，具有很好的抵抗差分密码分析及线性密码分析的能力</li><li>分组长度和密钥长度可变，都可以是32位的任意倍数，最小为128位，最大为256位</li></ul><h4 id="块填充"><a href="#块填充" class="headerlink" title="块填充"></a>块填充</h4><p>分组加密时，要求分组（块）大小必须是固定大小，例如为16字节，如果明文长度正好不是16字节的倍数，就需要补齐为16字节。</p><ul><li>待填充字节数n = 块大小 - 数据长度 % 块大小<ul><li>r的范围是[1, n]</li><li>n等于块大小，明文正好对齐</li><li>r的值在[1, n-1]，说明要补齐</li></ul></li><li>Zero：待填充字节的每个字节都补零0x00</li><li>PKCS7是当下各大加密算法都遵循的填充算法<ul><li>如果需要补齐，待填充字节的每个字节都填充为待填充字节数n</li><li>如果不需要补齐，需要追加一个块大小的数据，每个字节填充为块大小</li></ul></li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">AES128，数据块为16Byte（数据长度需要为16Byte的倍数）。</span><br><span class="line"></span><br><span class="line">假设数据为0x11223344556677889900AA，共11个Byte,缺了5个Byte,采用PKCS7Padding方式填充</span><br><span class="line">之后的数据为0x11223344556677889900AA0505050505。</span><br><span class="line"></span><br><span class="line">如果是数据刚好满足数据块长度，也需要在数据后面按PKCS7规则填充一个数据块数据，这样做的目的是</span><br><span class="line">为了区分有效数据和补齐数据。</span><br><span class="line">假设数据为0x11223344556677889900AABBCCDDEEFF,共16个Byte，采用PKCS7Padding方式，仍</span><br><span class="line">需要在数据后面补充一个16个Byte的块，填充之后的数据为</span><br><span class="line">0x11223344556677889900AABBCCDDEEFF10101010101010101010101010101010</span><br></pre></td></tr></tbody></table></figure><h4 id="库"><a href="#库" class="headerlink" title="库"></a>库</h4><p>Go语言提供了标准库 <a href="https://pkg.go.dev/crypto，包含了DES、AES、MD5、SHA1等常用加密解密算法库。" target="_blank" rel="noopener">https://pkg.go.dev/crypto，包含了DES、AES、MD5、SHA1等常用加密解密算法库。</a></p><p>CBC例子参考 <a href="https://pkg.go.dev/crypto/cipher#example-NewCBCEncrypter" target="_blank" rel="noopener">https://pkg.go.dev/crypto/cipher#example-NewCBCEncrypter</a></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bytes"</span></span><br><span class="line"><span class="string">"crypto/aes"</span></span><br><span class="line"><span class="string">"crypto/cipher"</span></span><br><span class="line"><span class="string">"encoding/hex"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line"><span class="comment">// 为了理解算法，就没有封装成函数</span></span><br><span class="line">password := <span class="string">"6368616e676520746869732070617373"</span> <span class="comment">// 密码,32个字符</span></span><br><span class="line">plainText := []<span class="keyword">byte</span>(<span class="string">"exampleplaintext"</span>)        <span class="comment">// 明文，16</span></span><br><span class="line">fmt.Println(password, <span class="built_in">len</span>(password))</span><br><span class="line"><span class="comment">// key密钥，自定义，可以是16、24、32字节</span></span><br><span class="line">key, _ := hex.DecodeString(password) <span class="comment">// 按照16进制理解password</span></span><br><span class="line">fmt.Println(key, <span class="built_in">len</span>(key))</span><br><span class="line">fmt.Printf(<span class="string">"明文长度=%d字节，密钥长度%d字节\n"</span>, <span class="built_in">len</span>(plainText), <span class="built_in">len</span>(key)) <span class="comment">// 16 16</span></span><br><span class="line"><span class="comment">// 块必须为指定大小，不够就补齐</span></span><br><span class="line"><span class="comment">// 本次采用PKCS7Padding方式</span></span><br><span class="line">blockSize := aes.BlockSize</span><br><span class="line">fmt.Printf(<span class="string">"默认分组大小为 %d字节\n"</span>, blockSize)</span><br><span class="line">r := <span class="built_in">len</span>(plainText) % blockSize <span class="comment">// 余数</span></span><br><span class="line">n := blockSize - r              <span class="comment">// 待填充字节数</span></span><br><span class="line"><span class="keyword">if</span> n == blockSize {</span><br><span class="line"><span class="comment">// 正好满足分组字节要求，追加一个块，每个字节填充块大小</span></span><br><span class="line">fmt.Printf(<span class="string">"正好满足分组块大小要求，追加一个块（%d个字节)\n"</span>, n)</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">fmt.Printf(<span class="string">"不满足块大小要求，需要补充%d字节\n"</span>, n)</span><br><span class="line">}</span><br><span class="line">padding := bytes.Repeat([]<span class="keyword">byte</span>{<span class="keyword">byte</span>(n)}, n)</span><br><span class="line">fmt.Printf(<span class="string">"%d, %v\n"</span>, <span class="built_in">len</span>(padding), padding)</span><br><span class="line">paddingText := <span class="built_in">append</span>(plainText, padding...) <span class="comment">// 补完后去加密</span></span><br><span class="line">fmt.Printf(<span class="string">"%d, %v\n"</span>, <span class="built_in">len</span>(paddingText), paddingText)</span><br><span class="line">block, err := aes.NewCipher(key)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 加密</span></span><br><span class="line"><span class="comment">// CBC模式需要提供一个与第一分组计算的初始向量iv, iv字节数为块大小，这里取16字节</span></span><br><span class="line">iv := []<span class="keyword">byte</span>(<span class="string">"abcdef0123456789"</span>)</span><br><span class="line">enMode := cipher.NewCBCEncrypter(block, iv)</span><br><span class="line">cipherText := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="built_in">len</span>(paddingText))</span><br><span class="line">enMode.CryptBlocks(cipherText, paddingText)</span><br><span class="line">fmt.Printf(<span class="string">"密文：%x\n"</span>, cipherText)</span><br><span class="line"><span class="comment">// 解密，使用密文cipherText解密</span></span><br><span class="line">deMode := cipher.NewCBCDecrypter(block, iv)</span><br><span class="line">text := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="built_in">len</span>(cipherText))</span><br><span class="line">deMode.CryptBlocks(text, cipherText)</span><br><span class="line">padding1 := text[<span class="built_in">len</span>(text)<span class="number">-1</span>] <span class="comment">// text中最后一个字节一定是补充的字节数</span></span><br><span class="line">fmt.Printf(<span class="string">"明文：%x, %[1]s\n"</span>, text[:<span class="built_in">len</span>(text)-<span class="keyword">int</span>(padding1)])</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>国人写的库 <a href="https://github.com/golang-module/dongle/blob/main/README.cn.md" target="_blank" rel="noopener">https://github.com/golang-module/dongle/blob/main/README.cn.md</a></p><h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><p>非对称加密：加密和解密密钥不同且其中一个密钥不能通过另一个密钥推算出来。这种算法需要2个密钥，公开密钥和私有密钥。如果公钥对数据加密，就只能使用私钥才能解密；如果使用私钥对数据加密，也只能使用公钥解密。这就是非对称加密方式。</p><h4 id="RSA密码系统"><a href="#RSA密码系统" class="headerlink" title="RSA密码系统"></a>RSA密码系统</h4><p>1977年提出了RSA加密算法，名字是三位作者姓氏首字母的组合。</p><p>RAS密钥系统的安全性基于大数分解的困难性。计算一对大素数的乘积很容易，但是要对这个乘积进行因式分解则非常困难。因此，把一对大素数的乘积公开作为公钥，把素数作为私钥，那么从公钥和密文中恢复出（暴力破解）明文的难度等价于大素数乘积的质因数分解。</p><blockquote><p>对极大整数做因数分解的难度决定了RSA算法的可靠性。换言之，对一极大整数做因数分解愈困难，RSA算法愈可靠。假如有人找到一种快速因数分解的算法，那么RSA的可靠性就会极度下降。但找到这样的算法的可能性是非常小的。今天只有短的RSA密钥才可能被暴力破解。到2008年为止，世界上还没有任何可靠的攻击RSA算法的方式。 <strong>只要密钥长度足够长，用RSA加密的信息实际上是不能被破解的</strong>。</p><p>维基百科</p></blockquote><p>RSA目前推荐长度至少2048位，相对安全，据称目前使用超级计算机破解也需要80年。但是，有研究表示使用了量子计算机破解2048位只需要数小时。</p><h4 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h4><p>在计算机系统中，当接收者接收到一个消息时，往往需要验证消息在传输过程中是否有被篡改过，也要确定消息发送者的身份，这就需要数字签名技术来实现。</p><h5 id="RSA签名方案"><a href="#RSA签名方案" class="headerlink" title="RSA签名方案"></a>RSA签名方案</h5><p>1、签名</p><p>消息是公开的，使用哈希函数对消息哈希后得到哈希值，再使用私钥对哈希值进行加密得到签名。</p><p>2、校验</p><p>对消息再次哈希得到哈希值h1。使用公钥对签名解密得到哈希值h2。比对h1、h2是否相同，如果不同，则被篡改过，否则没被篡改过，是可信的。</p><p>可以看出，整个方案都是以RSA算法为基础，是以RSA算法难以破解为前提的。</p><!-- rebuild by neat --><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;加密解密系统&quot;&gt;&lt;a href=&quot;#加密解密系统&quot; class=&quot;headerlink&quot; title=&quot;加密解密系统&quot;&gt;&lt;/a&gt;加密解密系统&lt;/h3&gt;&lt;p&gt;通常一个密钥加密解密系统应该包括以下部分&lt;/p&gt;&lt;ul&gt;&lt;li&gt;消息空间M（Message），就是未加密的数
      
    
    </summary>
    
    
      <category term="Go" scheme="http://chenzhonzhou.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="http://chenzhonzhou.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go 反射</title>
    <link href="http://chenzhonzhou.github.io/2023/04/11/go-fan-she/"/>
    <id>http://chenzhonzhou.github.io/2023/04/11/go-fan-she/</id>
    <published>2023-04-11T03:12:01.000Z</published>
    <updated>2023-12-02T03:13:57.607Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go-反射"><a href="#Go-反射" class="headerlink" title="Go 反射"></a>Go 反射</h2><p>Go语言提供了一种机制在运行时更新和检查变量的值、调用变量的方法和变量支持的内在操作，但是在编译时并不知道这些变量的具体类型，这种机制被称为反射。反射也可以让我们将类型本身作为第一类的值类型处理。</p><p>反射是指在程序运行期对程序本身进行访问和修改的能力，程序在编译时变量被转换为内存地址，变量名不会被编译器写入到可执行部分，在运行程序时程序无法获取自身的信息。</p><p>支持反射的语言可以在程序编译期将变量的反射信息，如字段名称、类型信息、结构体信息等整合到可执行文件中，并给程序提供接口访问反射信息，这样就可以在程序运行期获取类型的反射信息，并且有能力修改它们。</p><p>C/<a href="http://c.biancheng.net/cplus/" target="_blank" rel="noopener">C++</a>语言没有支持反射功能，只能通过 typeid 提供非常弱化的程序运行时类型信息；Java、<a href="http://c.biancheng.net/csharp/" target="_blank" rel="noopener">C#</a> 等语言都支持完整的反射功能；Lua、<a href="http://c.biancheng.net/js/" target="_blank" rel="noopener">JavaScript</a> 类动态语言，由于其本身的语法特性就可以让代码在运行期访问程序自身的值和类型信息，因此不需要反射系统。</p><p>Go语言程序的反射系统无法获取到一个可执行文件空间中或者是一个包中的所有类型信息，需要配合使用标准库中对应的词法、语法解析器和抽象语法树（AST）对源码进行扫描后获得这些信息。</p><p>Go语言提供了 reflect 包来访问程序的反射信息。</p><h2 id="Type和Value方法"><a href="#Type和Value方法" class="headerlink" title="Type和Value方法"></a>Type和Value方法</h2><h3 id="Type和Value拥有的同名方法"><a href="#Type和Value拥有的同名方法" class="headerlink" title="Type和Value拥有的同名方法"></a>Type和Value拥有的同名方法</h3><table><thead><tr><th align="left">Method</th><th align="left">Type返回类型</th><th align="left">Value返回类型</th><th align="left">备注</th></tr></thead><tbody><tr><td align="left">Kind</td><td align="left">Kind</td><td align="left">Kind</td><td align="left">返回指定对象的Kind类型</td></tr><tr><td align="left">NumMethod</td><td align="left">int</td><td align="left">int</td><td align="left">返回struct拥有的方法总数，包括unexported方法</td></tr><tr><td align="left">MethodByName</td><td align="left">Method</td><td align="left">Value</td><td align="left">根据方法名找方法</td></tr><tr><td align="left">Method</td><td align="left">Method</td><td align="left">Value</td><td align="left">返回第i个方法</td></tr><tr><td align="left">NumField</td><td align="left">int</td><td align="left">int</td><td align="left">返回struct所包含的field数量</td></tr><tr><td align="left">Field</td><td align="left">StructField</td><td align="left">Value</td><td align="left">取struct结构的第n个field</td></tr><tr><td align="left">FieldByIndex</td><td align="left">StructField</td><td align="left">Value</td><td align="left">嵌套的方式取struct的field，比如v.FieldByIndex([]int{1,2})等价于 v.field(1).field(2)</td></tr><tr><td align="left">FieldByName</td><td align="left">StructFiel,bool</td><td align="left">Value</td><td align="left">返回名称匹配match函数的field</td></tr><tr><td align="left">FieldByNameFunc</td><td align="left">StructField,bool</td><td align="left">Value</td><td align="left">返回名称匹配match函数的field</td></tr></tbody></table><h3 id="Type独有的方法"><a href="#Type独有的方法" class="headerlink" title="Type独有的方法"></a>Type独有的方法</h3><table><thead><tr><th align="left">Method</th><th align="left">备注</th></tr></thead><tbody><tr><td align="left">Align</td><td align="left">分配内存时的内存对齐字节数</td></tr><tr><td align="left">FieldAlign</td><td align="left">作为struct的field时内存对齐字节数</td></tr><tr><td align="left">Name</td><td align="left">type名 string类型</td></tr><tr><td align="left">PkgPath</td><td align="left">包路径， “encoding/base64”， 内置类型返回empty string</td></tr><tr><td align="left">Size</td><td align="left">该类型变量占用字节数</td></tr><tr><td align="left">String</td><td align="left">type的string表示方式</td></tr><tr><td align="left">Implements</td><td align="left">判断该类型是否实现了某个接口</td></tr><tr><td align="left">AssignableTo</td><td align="left">判断该类型能否赋值给某个类型</td></tr><tr><td align="left">ConvertibleTo</td><td align="left">判断该类型能否转换为另外一种类型</td></tr><tr><td align="left">Comparable</td><td align="left">判断该类型变量是否可以比较</td></tr><tr><td align="left">ChanDir</td><td align="left">返回channel的方向 recv/send/double</td></tr><tr><td align="left">IsVariadic</td><td align="left">判断函数是否接受可变参数</td></tr><tr><td align="left">Elem</td><td align="left">取该类型的元素</td></tr><tr><td align="left">In</td><td align="left">函数第n个入参</td></tr><tr><td align="left">Out</td><td align="left">函数第n个出参</td></tr><tr><td align="left">NumIn</td><td align="left">函数的入参数个数</td></tr><tr><td align="left">NumOut</td><td align="left">函数的出参个数</td></tr><tr><td align="left">Key</td><td align="left">返回map结构的key类型Type</td></tr><tr><td align="left">Len</td><td align="left">返回array的长度</td></tr></tbody></table><h3 id="Value独有的方法"><a href="#Value独有的方法" class="headerlink" title="Value独有的方法"></a>Value独有的方法</h3><table><thead><tr><th align="left">Method</th><th align="left">备注</th></tr></thead><tbody><tr><td align="left">Addr</td><td align="left">v的指针，前提时CanAddr()返回true</td></tr><tr><td align="left">Bool</td><td align="left">取值，布尔类型</td></tr><tr><td align="left">Bytes</td><td align="left">取值，字节流</td></tr><tr><td align="left">Call</td><td align="left">调用函数</td></tr><tr><td align="left">CallSlice</td><td align="left">调用具有可变参的函数</td></tr><tr><td align="left">CanAddr</td><td align="left">判断能否取址</td></tr><tr><td align="left">CanInterface</td><td align="left">判断Interface方法能否使用</td></tr><tr><td align="left">CanSet</td><td align="left">判断v的值能否改变</td></tr><tr><td align="left">Cap</td><td align="left">判断容量 Array/Chan/Slice</td></tr><tr><td align="left">Close</td><td align="left">关闭Chan</td></tr><tr><td align="left">Complex</td><td align="left">取值，复数</td></tr><tr><td align="left">Convert</td><td align="left">返回将v转换位type t的结果</td></tr><tr><td align="left">Elem</td><td align="left">返回interface包含或者Ptr指针的实际值</td></tr><tr><td align="left">Float</td><td align="left">取值，浮点型</td></tr><tr><td align="left">Index 索引操作</td><td align="left">Array/Slice/String</td></tr><tr><td align="left">Int</td><td align="left">取值，整型</td></tr><tr><td align="left">Interface</td><td align="left">将当前value以interface{}形式返回</td></tr><tr><td align="left">IsNil</td><td align="left">判断是否为nil，chan, func, interface, map, pointer, or slice value</td></tr><tr><td align="left">IsValid</td><td align="left">是否是可操作的Value，返回false表示为zero Value</td></tr><tr><td align="left">Len</td><td align="left">适用于Array, Chan, Map, Slice, or String</td></tr><tr><td align="left">MapIndex</td><td align="left">对map类型按key取值</td></tr><tr><td align="left">MapKeys</td><td align="left">map类型的所有key的列表</td></tr><tr><td align="left">OverflowComplex</td><td align="left">溢出判断</td></tr><tr><td align="left">OverflowFloat</td><td align="left">溢出判断</td></tr><tr><td align="left">OverflowInt</td><td align="left">溢出判断</td></tr><tr><td align="left">OverflowUint</td><td align="left">溢出判断</td></tr><tr><td align="left">Pointer</td><td align="left">返回uintptr 适用于slice</td></tr><tr><td align="left">Recv</td><td align="left">chan接收</td></tr><tr><td align="left">Send</td><td align="left">chan发送</td></tr><tr><td align="left">Set</td><td align="left">将x赋值给v，类型要匹配</td></tr><tr><td align="left">SetBool</td><td align="left">Bool赋值，需要先判断CanSet()为true</td></tr><tr><td align="left">SetBytes</td><td align="left">Bytes赋值</td></tr><tr><td align="left">SetCap</td><td align="left">slice调整切片容量</td></tr><tr><td align="left">SetMapIndex</td><td align="left">map索引赋值</td></tr><tr><td align="left">SetUint</td><td align="left">Unit赋值</td></tr><tr><td align="left">SetPointer</td><td align="left">unsafe.Pointer赋值</td></tr><tr><td align="left">SetString</td><td align="left">String赋值</td></tr><tr><td align="left">Slice</td><td align="left">return v[i:j] 适用于Array/Slict/String</td></tr><tr><td align="left">String</td><td align="left">return value的string表示方法</td></tr><tr><td align="left">TryRecv</td><td align="left">chan非阻塞接收</td></tr><tr><td align="left">TrySend</td><td align="left">chan非阻塞发送</td></tr><tr><td align="left">Type</td><td align="left">返回value的Type</td></tr><tr><td align="left">UnsafeAddr</td><td align="left">返回指向value的data的指针</td></tr></tbody></table><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="结构体Type"><a href="#结构体Type" class="headerlink" title="结构体Type"></a>结构体Type</h3><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> {</span><br><span class="line">Name <span class="keyword">string</span> <span class="string">`json:"name"`</span></span><br><span class="line">age  <span class="keyword">int</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">GetName</span><span class="params">()</span> <span class="title">string</span></span> {</span><br><span class="line"><span class="keyword">return</span> p.Name</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">getAge</span><span class="params">()</span> <span class="title">int</span></span> {</span><br><span class="line"><span class="keyword">return</span> p.age</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line"><span class="comment">// 结构体</span></span><br><span class="line">tom := Person{Name: <span class="string">"tom"</span>, age: <span class="number">20</span>}</span><br><span class="line">t := reflect.TypeOf(tom)</span><br><span class="line">fmt.Println(t, t.Kind(), t.Size()) <span class="comment">// 类型是Person，种类是struct，占据内存字节数</span></span><br><span class="line">fmt.Println(<span class="string">"~~~~~~~~~~~~~~~~~~~~~~~~~~~"</span>)</span><br><span class="line"><span class="comment">// 字段</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; t.NumField(); i++ {</span><br><span class="line">f := t.Field(i)</span><br><span class="line">fmt.Println(i, f)</span><br><span class="line">fmt.Println(</span><br><span class="line">f.Name,            <span class="comment">// 字段名</span></span><br><span class="line">f.Index,           <span class="comment">// 字段索引</span></span><br><span class="line">f.Type,            <span class="comment">// 字段类型</span></span><br><span class="line">f.Type.Kind(),     <span class="comment">// 字段类型的种类</span></span><br><span class="line">f.Offset,          <span class="comment">// 相当于结构体首地址该字段值的偏移，string占16字节</span></span><br><span class="line">f.Anonymous,       <span class="comment">// 是否匿名成员，就是没有名字。注意不要和可见性混淆</span></span><br><span class="line">f.IsExported(),    <span class="comment">// 是否导出，包外可见否</span></span><br><span class="line">f.Tag,             <span class="comment">// 本质上就是string类型</span></span><br><span class="line">f.Tag.Get(<span class="string">"json"</span>), <span class="comment">// 获取结构体字段定义后面反引号部分的tag</span></span><br><span class="line">)</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 方法，只包括导出的方法，也不包括receiver是该结构体指针的方法</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; t.NumMethod(); i++ {</span><br><span class="line">m := t.Method(i)</span><br><span class="line">fmt.Println(i, m)</span><br><span class="line">fmt.Println(</span><br><span class="line">m.Name,         <span class="comment">// 方法名</span></span><br><span class="line">m.Index,        <span class="comment">// 方法索引</span></span><br><span class="line">m.Type,         <span class="comment">// 方法类型，函数签名</span></span><br><span class="line">m.Type.Kind(),  <span class="comment">// 方法类型的种类</span></span><br><span class="line">m.IsExported(), <span class="comment">// 是否导出。当然未导出的看不到</span></span><br><span class="line">m.Func,         <span class="comment">// reflect.Value</span></span><br><span class="line">)</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="指针类型"><a href="#指针类型" class="headerlink" title="指针类型"></a>指针类型</h3><p>指针类型不能调用NumField()方法，这是结构体才能调用的，这时候就要使用Elem()方法来解析指针，相当于对指针类型变量做了*操作获取元素。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> {</span><br><span class="line">Name <span class="keyword">string</span> <span class="string">`json:"name"`</span></span><br><span class="line">age  <span class="keyword">int</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">GetName</span><span class="params">()</span> <span class="title">string</span></span> {</span><br><span class="line"><span class="keyword">return</span> p.Name</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">getAge</span><span class="params">()</span> <span class="title">int</span></span> {</span><br><span class="line"><span class="keyword">return</span> p.age</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line"><span class="comment">// 结构体</span></span><br><span class="line">tom := &amp;Person{Name: <span class="string">"tom"</span>, age: <span class="number">20</span>}</span><br><span class="line">t := reflect.TypeOf(tom)</span><br><span class="line">fmt.Println(t, t.Kind()) <span class="comment">// 类型是Person，种类是struct</span></span><br><span class="line">fmt.Println(<span class="string">"~~~~~~~~~~~~~~~~~~~~~~~~~~~"</span>)</span><br><span class="line"><span class="comment">// 字段</span></span><br><span class="line"><span class="comment">// fmt.Println(t.NumField()) //reflect: NumField of non-struct type*main.Person</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; t.Elem().NumField(); i++ {</span><br><span class="line">f := t.Elem().Field(i)</span><br><span class="line">fmt.Println(i, f)</span><br><span class="line">fmt.Println(</span><br><span class="line">f.Name,            <span class="comment">// 字段名</span></span><br><span class="line">f.Index,           <span class="comment">// 字段索引</span></span><br><span class="line">f.Type,            <span class="comment">// 字段类型</span></span><br><span class="line">f.Type.Kind(),     <span class="comment">// 字段类型的种类</span></span><br><span class="line">f.Offset,          <span class="comment">// 相当于结构体首地址该字段值的偏移，string占16字节</span></span><br><span class="line">f.Anonymous,       <span class="comment">// 是否匿名成员，就是没有名字。注意不要和可见性混淆</span></span><br><span class="line">f.IsExported(),    <span class="comment">// 是否导出，包外可见否</span></span><br><span class="line">f.Tag,             <span class="comment">// 本质上就是string类型</span></span><br><span class="line">f.Tag.Get(<span class="string">"json"</span>), <span class="comment">// 获取结构体字段定义后面反引号部分的tag</span></span><br><span class="line">)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法，只包括导出的方法，也不包括receiver是该结构体指针的方法</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; t.Elem().NumMethod(); i++ {</span><br><span class="line">m := t.Method(i)</span><br><span class="line">fmt.Println(i, m)</span><br><span class="line">fmt.Println(</span><br><span class="line">m.Name,         <span class="comment">// 方法名</span></span><br><span class="line">m.Index,        <span class="comment">// 方法索引</span></span><br><span class="line">m.Type,         <span class="comment">// 方法类型，函数签名</span></span><br><span class="line">m.Type.Kind(),  <span class="comment">// 方法类型的种类</span></span><br><span class="line">m.IsExported(), <span class="comment">// 是否导出。当然未导出的看不到</span></span><br><span class="line">m.Func,         <span class="comment">// reflect.Value</span></span><br><span class="line">)</span><br><span class="line">}</span><br><span class="line">fmt.Println(<span class="string">"~~~~~~~~~~~~~~~~~~~~~~~~~~~"</span>)</span><br><span class="line"><span class="comment">// 方法，使用指针访问，可以访问所有receiver的导出的方法</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; t.NumMethod(); i++ {</span><br><span class="line">m := t.Method(i)</span><br><span class="line">fmt.Println(i, m)</span><br><span class="line">fmt.Println(</span><br><span class="line">m.Name,         <span class="comment">// 方法名</span></span><br><span class="line">m.Index,        <span class="comment">// 方法索引</span></span><br><span class="line">m.Type,         <span class="comment">// 方法类型，函数签名</span></span><br><span class="line">m.Type.Kind(),  <span class="comment">// 方法类型的种类</span></span><br><span class="line">m.IsExported(), <span class="comment">// 是否导出。当然未导出的看不到</span></span><br><span class="line">m.Func,         <span class="comment">// reflect.Value</span></span><br><span class="line">)</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="接口类型"><a href="#接口类型" class="headerlink" title="接口类型"></a>接口类型</h3><p>对于接口类型可以判断是否实现了某个接口。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Runner <span class="keyword">interface</span> {</span><br><span class="line">run()</span><br><span class="line">}</span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> {</span><br><span class="line">Name <span class="keyword">string</span> <span class="string">`json:"name"`</span></span><br><span class="line">Age  <span class="keyword">int</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">// func (Person) run() {</span></span><br><span class="line"><span class="comment">// }</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">tom := Person{<span class="string">"Tom"</span>, <span class="number">20</span>}</span><br><span class="line">t1 := reflect.TypeOf(tom)</span><br><span class="line">t2 := reflect.TypeOf((*Runner)(<span class="literal">nil</span>)) <span class="comment">// *Runner的类型</span></span><br><span class="line">fmt.Println(t2, t2.Kind())</span><br><span class="line">t3 := t2.Elem() <span class="comment">// 解析指针获得实例的类型</span></span><br><span class="line">fmt.Println(t3, t3.Kind())</span><br><span class="line"><span class="keyword">if</span> t1.Implements(t3) {</span><br><span class="line">fmt.Println(<span class="string">"实现了"</span>)</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">fmt.Println(<span class="string">"未实现"</span>)</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>(*Runner)(nil) 说明：</p><blockquote><p>nil是指针的零值，也就是空指针<br><em>Runner把空指针强制类型转换为</em>Runner类型空指针</p></blockquote><h3 id="Value和原始值"><a href="#Value和原始值" class="headerlink" title="Value和原始值"></a>Value和原始值</h3><p>reflect.Value 与原始值之间可以通过 值包装 和 值获取 相互转化。</p><table><thead><tr><th>方法签名</th><th>说明</th></tr></thead><tbody><tr><td>Interface() interface {}</td><td>将值以 interface{} 类型返回，可以通过<strong>类型断言</strong>转换为指定类型</td></tr><tr><td>Int() int64</td><td>将值以 int64 类型返回，所有有符号整型均可以此方式返回，如果需要的是int类型，则需要强制类型转换</td></tr><tr><td>Uint() uint64</td><td>将值以 uint64 类型返回，所有无符号整型均可以此方式返回</td></tr><tr><td>Float() float64</td><td>将值以双精度（float64）类型返回，所有浮点数（float32、float64）均可以此方式返回</td></tr><tr><td>Bool() bool</td><td>将值以 bool 类型返回</td></tr><tr><td>Bytes() []bytes</td><td>将值以字节数组 []bytes 类型返回</td></tr><tr><td>String() string</td><td>将值以字符串类型返回</td></tr></tbody></table><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">100</span></span><br><span class="line">v := reflect.ValueOf(a) <span class="comment">// 原始值 =&gt; Value，原始值包装</span></span><br><span class="line">i := v.Interface() <span class="comment">// 等价于 var i interface{} = (v's underlying value)，Value =&gt; 原始值，值获取</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">100</span></span><br><span class="line">v := reflect.ValueOf(a)</span><br><span class="line">i := v.Interface() <span class="comment">// 等价于 var i interface{} = (v's underlying value)</span></span><br><span class="line"><span class="comment">// 1 接口类型断言</span></span><br><span class="line">j := i.(<span class="keyword">int</span>) <span class="comment">// 获得int类型原始值，断言失败panic</span></span><br><span class="line">fmt.Printf(<span class="string">"%T %[1]d\n"</span>, j)</span><br><span class="line">j1, isStr := i.(<span class="keyword">string</span>) <span class="comment">// 断言失败与否看isStr，失败不panic</span></span><br><span class="line">fmt.Println(j1, isStr)</span><br><span class="line"><span class="comment">// 2 值获取</span></span><br><span class="line">k := v.Int() <span class="comment">// 返回的是int64</span></span><br><span class="line">fmt.Printf(<span class="string">"%T %[1]d\n"</span>, k)</span><br><span class="line">fmt.Println(<span class="keyword">int</span>(k)) <span class="comment">// 强制类型转换为int获得原始值</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="空值和有效性判断"><a href="#空值和有效性判断" class="headerlink" title="空值和有效性判断"></a>空值和有效性判断</h3><table><thead><tr><th>方法签名</th><th>说明</th></tr></thead><tbody><tr><td>IsValid() bool</td><td>判断值是否有效。当值本身非法时，返回 false，例如 reflect.ValueOf(nil).IsValid()就是false常用来判断返回值是否有效</td></tr><tr><td>IsZero() bool</td><td>值是否是零值。如果值无效则panic</td></tr><tr><td>IsNil() bool</td><td>值是否为 nil。必须是chan、func、interface、map、pointer、slice，否则panic。类似于语言层的 v== nil 操作常用来判断指针是否为空</td></tr></tbody></table><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">100</span></span><br><span class="line">v := reflect.ValueOf(a)</span><br><span class="line">fmt.Println(</span><br><span class="line">v.IsValid(), <span class="comment">// true</span></span><br><span class="line"><span class="comment">// v.IsNil(), // 必须是chan、func、interface、map、pointer、slice，否则panic</span></span><br><span class="line">v.IsZero(), <span class="comment">// false</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> b *<span class="keyword">int</span></span><br><span class="line">v = reflect.ValueOf(b)</span><br><span class="line">fmt.Println(</span><br><span class="line">v.IsValid(), <span class="comment">// true</span></span><br><span class="line">v.IsNil(),   <span class="comment">// true</span></span><br><span class="line">v.IsZero(),  <span class="comment">// true</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">v = reflect.ValueOf(<span class="literal">nil</span>)</span><br><span class="line">fmt.Println(</span><br><span class="line">v.IsValid(), <span class="comment">// false，因为nil是用来给某种类型做零值，直接用nil不知道其类型，所以无效</span></span><br><span class="line">)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>注意，上例中reflect.ValueOf(nil).IsValid()为false，而reflect.ValueOf(b).IsValid()为true，因为b是有类型的，它是*int不过是空指针罢了，所以有效，而nil不是。</p><h3 id="反射和结构体"><a href="#反射和结构体" class="headerlink" title="反射和结构体"></a>反射和结构体</h3><table><thead><tr><th>方法签名</th><th>说明</th></tr></thead><tbody><tr><td>Field(i int) Value</td><td>根据索引，返回索引对应的结构体成员字段的反射值对象。当值不是结构体或索引超界时panic</td></tr><tr><td>NumField() int</td><td>返回结构体成员字段数量。当值不是结构体或索引超界时发生宕机</td></tr><tr><td>FieldByName(name string) Value</td><td>根据给定字符串返回字符串对应的结构体字段。没有找到时返回零值，当值不是结构体panic</td></tr><tr><td>FieldByIndex(index []int) Value</td><td>多层成员访问时，根据 []int 提供的每个结构体的字段索引，返回字段的值。 没有找到时返回零值，当值不是结构体panic</td></tr><tr><td>Method(i int) Value</td><td>根据索引，返回索引对应的结构体成员方法的反射值对象。当值不是结构体或索引超界时panic</td></tr><tr><td>MethodByName(name string) Value</td><td>根据给定字符串返回字符串对应的结构体方法。没有找到时返回零值，当值不是结构体panic</td></tr></tbody></table><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> {</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">age  <span class="keyword">int</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p person)</span> <span class="title">GetName</span><span class="params">()</span> <span class="title">string</span></span> {</span><br><span class="line"><span class="keyword">return</span> p.name</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line"><span class="keyword">var</span> a = person{}</span><br><span class="line">a.name = <span class="string">"tom"</span></span><br><span class="line"><span class="comment">// a.age = 100</span></span><br><span class="line">v := reflect.ValueOf(a)</span><br><span class="line">t := v.Type()</span><br><span class="line">fmt.Println(v, t, t.Kind())</span><br><span class="line">fmt.Println(<span class="string">"~~~~~~~~~~~~~~~~~~~~~~~~~~~"</span>)</span><br><span class="line"><span class="comment">// 下面使用Type和Value遍历字段的区别</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; t.NumField(); i++ {</span><br><span class="line">f := t.Field(i)</span><br><span class="line">fmt.Println(</span><br><span class="line">f.Name, f.Index, f.Offset,</span><br><span class="line">f.Anonymous, f.IsExported(), <span class="comment">// Type字段类型信息</span></span><br><span class="line">)</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; v.NumField(); i++ {</span><br><span class="line">f := v.Field(i)</span><br><span class="line">fmt.Println(i, f.IsValid(), f.IsZero()) <span class="comment">// Value关注字段的值</span></span><br><span class="line">}</span><br><span class="line">fmt.Println(<span class="string">"~~~~~~~~~~~~~~~~~~~~~~~~~~~"</span>)</span><br><span class="line">fmt.Println(</span><br><span class="line">v.FieldByName(<span class="string">"name"</span>).IsZero(),            <span class="comment">// 通过v找底层结构体的name字段</span></span><br><span class="line">v.Field(<span class="number">1</span>).IsValid(), v.Field(<span class="number">1</span>).IsZero(), <span class="comment">// 字段age</span></span><br><span class="line">v.FieldByIndex([]<span class="keyword">int</span>{<span class="number">1</span>}).IsValid(),  <span class="comment">// 字段age</span></span><br><span class="line">v.FieldByName(<span class="string">"score"</span>).IsValid(),    <span class="comment">// score字段不存在，无效</span></span><br><span class="line">v.MethodByName(<span class="string">"GetName"</span>).IsValid(), <span class="comment">// GetName方法不存在，无效</span></span><br><span class="line">)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>反射调用函数</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> {</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">age  <span class="keyword">int</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p person)</span> <span class="title">GetName</span><span class="params">(prefix, suffix <span class="keyword">string</span>)</span> <span class="title">string</span></span> {</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">"%s %s %s"</span>, prefix, p.name, suffix)</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line"><span class="keyword">var</span> a = person{}</span><br><span class="line">a.name = <span class="string">"tom"</span></span><br><span class="line"><span class="comment">// a.age = 100</span></span><br><span class="line">v := reflect.ValueOf(a)         <span class="comment">// 结构体的Value</span></span><br><span class="line">vf := v.MethodByName(<span class="string">"GetName"</span>) <span class="comment">// 函数的Value</span></span><br><span class="line">fmt.Println(v, vf)</span><br><span class="line"><span class="comment">// 构建参数列表，需要2个入参</span></span><br><span class="line">p1 := reflect.ValueOf(<span class="string">"!!"</span>)</span><br><span class="line">p2 := reflect.ValueOf(<span class="string">"##"</span>)</span><br><span class="line">inParams := []reflect.Value{p1, p2}</span><br><span class="line">outParams := vf.Call(inParams) <span class="comment">// Call调用需要[]reflect.Value的参数列表</span></span><br><span class="line">fmt.Println(outParams)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="反射修改值"><a href="#反射修改值" class="headerlink" title="反射修改值"></a>反射修改值</h3><table><thead><tr><th>方法签名</th><th>说明</th></tr></thead><tbody><tr><td>Elem() Value</td><td>取值指向的元素值，类似于语言层 * 操作。当值类型不是指针或接口时panic，空指针时返回 nil 的 Value</td></tr><tr><td>Addr() Value</td><td>对可寻址的值返回其地址，类似于语言层 &amp; 操作。当值不可寻址时panic</td></tr><tr><td>CanAddr() bool</td><td>表示值是否可寻址</td></tr><tr><td>CanSet() bool</td><td>返回值能否被修改。要求值可寻址且是导出的字段</td></tr><tr><td>Set(x Value)</td><td>将值设置为传入的反射值对象的值</td></tr><tr><td>Setlnt(x int64)</td><td>使用 int64 设置值。当值的类型不是 int、int8、int16、 int32、int64 时会发生宕机</td></tr><tr><td>SetUint(x uint64)</td><td>使用 uint64 设置值。当值的类型不是 uint、uint8、uint16、uint32、uint64时分发生宕机</td></tr><tr><td>SetFloat(x float64)</td><td>使用 float64 设置值。当值的类型不是 float32、float64 时会发生宕机</td></tr><tr><td>SetBool(x bool)</td><td>使用 bool 设置值。当值的类型不是 bod 时会发生宕机</td></tr><tr><td>SetBytes(x []byte)</td><td>设置字节数组 []bytes值。当值的类型不是 []byte 时会发生宕机</td></tr><tr><td>SetString(x string)</td><td>设置字符串值。当值的类型不是 string 时会发生宕机</td></tr></tbody></table><p>如果CanSet() 返回false，调用以上Set*方法都会panic</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可被寻址</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">100</span></span><br><span class="line">v := reflect.ValueOf(&amp;a).Elem()      <span class="comment">// a指针指向的元素的Value</span></span><br><span class="line">fmt.Println(v.CanAddr(), v.CanSet()) <span class="comment">// true true</span></span><br><span class="line">v.SetInt(<span class="number">200</span>)</span><br><span class="line">fmt.Println(v, <span class="keyword">int</span>(v.Int()))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可被导出</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> {</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">age  <span class="keyword">int</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">v := reflect.ValueOf(&amp;person{Name: <span class="string">"Tom"</span>, age: <span class="number">20</span>})</span><br><span class="line">vf1 := v.Elem().FieldByName(<span class="string">"Name"</span>)           <span class="comment">// 导出字段</span></span><br><span class="line">fmt.Println(vf1, vf1.CanAddr(), vf1.CanSet()) <span class="comment">// true true</span></span><br><span class="line">vf1.SetString(<span class="string">"Jerry"</span>)                        <span class="comment">// 成功修改</span></span><br><span class="line">vf2 := v.Elem().FieldByName(<span class="string">"age"</span>)            <span class="comment">// 未导出字段</span></span><br><span class="line">fmt.Println(vf2, vf2.CanAddr(), vf2.CanSet()) <span class="comment">// true false</span></span><br><span class="line"><span class="comment">// vf2.SetInt(30) // reflect.Value.SetInt using value obtained using unexported</span></span><br><span class="line">fmt.Println(v) <span class="comment">// 名字已经变成了Jerry了</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="反射创建实例"><a href="#反射创建实例" class="headerlink" title="反射创建实例"></a>反射创建实例</h3><p>需要用到 <code>reflect.New(typ reflect.Type) reflect.Value</code> ，简单讲就是将<code>Type New</code>成<code>Value</code>。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">100</span></span><br><span class="line">t := reflect.TypeOf(a)                       <span class="comment">// 提取类型信息</span></span><br><span class="line">v := reflect.New(t)                          <span class="comment">// 创建一个该类型的新的零值返回指针的Value，相当于new(int)</span></span><br><span class="line">fmt.Println(v, v.Elem(), v.Type(), v.Kind()) <span class="comment">// 内存地址 0 *int ptr</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><!-- rebuild by neat --><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go-反射&quot;&gt;&lt;a href=&quot;#Go-反射&quot; class=&quot;headerlink&quot; title=&quot;Go 反射&quot;&gt;&lt;/a&gt;Go 反射&lt;/h2&gt;&lt;p&gt;Go语言提供了一种机制在运行时更新和检查变量的值、调用变量的方法和变量支持的内在操作，但是在编译时并不知道这些变量的
      
    
    </summary>
    
    
      <category term="Go" scheme="http://chenzhonzhou.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="http://chenzhonzhou.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go 标准库时间处理</title>
    <link href="http://chenzhonzhou.github.io/2023/04/05/go-biao-zhun-ku-shi-jian-chu-li/"/>
    <id>http://chenzhonzhou.github.io/2023/04/05/go-biao-zhun-ku-shi-jian-chu-li/</id>
    <published>2023-04-05T03:10:26.000Z</published>
    <updated>2023-12-02T03:11:45.353Z</updated>
    
    <content type="html"><![CDATA[<p>平时开发过程中，时间相关的操作用的还是很多的。接下来就与大家一起总结下与时间有关的操作，主要涉及到 time 包，核心数据结构是 time.Time，如下：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Time <span class="keyword">struct</span> {</span><br><span class="line">    wall <span class="keyword">uint64</span></span><br><span class="line">    ext  <span class="keyword">int64</span></span><br><span class="line">    loc *Location</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="1-获取时间相关函数"><a href="#1-获取时间相关函数" class="headerlink" title="1. 获取时间相关函数"></a>1. 获取时间相关函数</h3><h4 id="1-1-获取当前时间"><a href="#1-1-获取当前时间" class="headerlink" title="1.1 获取当前时间"></a>1.1 获取当前时间</h4><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回当前时间，注意此时返回的是 time.Time 类型</span></span><br><span class="line">now := time.Now()</span><br><span class="line">fmt.Println(now)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前时间戳</span></span><br><span class="line">fmt.Println(now.Unix())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 纳秒级时间戳</span></span><br><span class="line">fmt.Println(now.UnixNano())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 时间戳小数部分 单位：纳秒</span></span><br><span class="line">fmt.Println(now.Nanosecond())</span><br></pre></td></tr></tbody></table></figure><p>输出：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-25</span> <span class="number">09</span>:<span class="number">19</span>:<span class="number">37.135465</span> +<span class="number">0800</span> CST m=+<span class="number">0.004033001</span></span><br><span class="line"><span class="number">1671931177</span></span><br><span class="line"><span class="number">1671931177135465000</span></span><br><span class="line"><span class="number">135465000</span></span><br></pre></td></tr></tbody></table></figure><p><strong>返回当前年月日时分秒、星期几、一年中的第几天等操作</strong></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">now := time.Now()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回日期</span></span><br><span class="line">year, month, day := now.Date()</span><br><span class="line">fmt.Printf(<span class="string">"year:%d, month:%d, day:%d\n"</span>, year, month, day)</span><br><span class="line"><span class="comment">//输出:year:2021, month:1, day:22</span></span><br><span class="line"><span class="comment">// 年</span></span><br><span class="line">fmt.Println(now.Year())</span><br><span class="line"><span class="comment">// 月</span></span><br><span class="line">fmt.Println(now.Month())</span><br><span class="line"><span class="comment">// 日</span></span><br><span class="line">fmt.Println(now.Day())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 时分秒</span></span><br><span class="line"><span class="comment">//Clock：返回由t指定的一天内的 时 分 秒</span></span><br><span class="line">hour, minute, second := now.Clock()</span><br><span class="line">fmt.Printf(<span class="string">"hour:%d, minute:%d, second:%d\n"</span>, hour, minute, second)</span><br><span class="line"><span class="comment">//输出:hour:10, minute:3, second:9</span></span><br><span class="line"><span class="comment">// 时</span></span><br><span class="line">fmt.Println(now.Hour())</span><br><span class="line"><span class="comment">// 分</span></span><br><span class="line">fmt.Println(now.Minute())</span><br><span class="line"><span class="comment">// 秒</span></span><br><span class="line">fmt.Println(now.Second())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回星期</span></span><br><span class="line"><span class="comment">//Weekday：返回由t指定的星期几</span></span><br><span class="line">fmt.Println(now.Weekday())</span><br><span class="line">spr := fmt.Sprintf(<span class="string">"%d"</span>, now.Weekday()) <span class="comment">//根据格式化说明符进行格式化并返回结果字符串</span></span><br><span class="line">fmt.Println(<span class="string">"spr"</span>, spr)</span><br><span class="line">fmt.Printf(<span class="string">"%d\n"</span>, now.Weekday())</span><br><span class="line"><span class="comment">//返回一年中对应的第几天</span></span><br><span class="line">fmt.Println(now.YearDay())</span><br><span class="line"><span class="comment">//返回时区</span></span><br><span class="line">fmt.Println(now.Location())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一年中第几天</span></span><br><span class="line">fmt.Println(now.YearDay())</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="1-2-格式化时间"><a href="#1-2-格式化时间" class="headerlink" title="1.2 格式化时间"></a>1.2 格式化时间</h4><p>Go 语言提供了时间类型格式化函数 Format()，需要注意的是 Go 语言格式化时间模板不是常见的 Y-m-d H:i:s，而是 2006-01-02 15:04:05，也很好记忆(2006 1 2 3 4 5)</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">now := time.Now()</span><br><span class="line"></span><br><span class="line">fmt.Println(now.Format(<span class="string">"0102 030405 06 pm -0700"</span>)) <span class="comment">//12小时制，加入时区</span></span><br><span class="line">fmt.Println(now.Format(<span class="string">"2006-01-02 15:04:05"</span>))</span><br><span class="line">fmt.Println(now.Format(<span class="string">"2006-01-02 15:04:05 -0700"</span>)) <span class="comment">//24小时制，加入时区</span></span><br><span class="line">fmt.Println(now.Format(<span class="string">"2006-01-02"</span>))</span><br><span class="line">fmt.Println(now.Format(<span class="string">"15:03:04"</span>))</span><br><span class="line">fmt.Println(now.Format(<span class="string">"2006/01/02 15:04"</span>))</span><br><span class="line">fmt.Println(now.Format(<span class="string">"15:04 2006/01/02"</span>))</span><br></pre></td></tr></tbody></table></figure><h3 id="2-时间戳与日期字符串相互转化"><a href="#2-时间戳与日期字符串相互转化" class="headerlink" title="2. 时间戳与日期字符串相互转化"></a>2. 时间戳与日期字符串相互转化</h3><p>时间戳怎么转成日期格式呢？需要先转成将时间戳转成 time.Time 类型再格式化成日期格式。</p><h4 id="2-1-根据秒数、纳秒数返回-time-Time-类型"><a href="#2-1-根据秒数、纳秒数返回-time-Time-类型" class="headerlink" title="2.1 根据秒数、纳秒数返回 time.Time 类型"></a>2.1 根据秒数、纳秒数返回 time.Time 类型</h4><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">now := time.Now()</span><br><span class="line">layout := <span class="string">"2006-01-02 15:04:05"</span></span><br><span class="line">t := time.Unix(now.Unix(),<span class="number">0</span>) <span class="comment">// 参数分别是：秒数,纳秒数</span></span><br><span class="line">fmt.Println(t)</span><br><span class="line">fmt.Println(t.Format(layout))</span><br><span class="line"><span class="comment">//2022-12-25 09:41:37 +0800 CST</span></span><br><span class="line"><span class="comment">//2022-12-25 09:41:37</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="2-2-根据指定时间返回-time-Time-类型"><a href="#2-2-根据指定时间返回-time-Time-类型" class="headerlink" title="2.2 根据指定时间返回 time.Time 类型"></a>2.2 根据指定时间返回 time.Time 类型</h4><p>使用函数 time.Date()</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">now := time.Now()</span><br><span class="line">layout := <span class="string">"2006-01-02 15:04:05"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//根据指定时间返回 time.Time 类型</span></span><br><span class="line"><span class="comment">//分别指定年，月，日，时，分，秒，纳秒，时区</span></span><br><span class="line">t := time.Date(<span class="number">2022</span>, time.Month(<span class="number">12</span>), <span class="number">25</span>, <span class="number">09</span>, <span class="number">41</span>, <span class="number">37</span>, <span class="number">0</span>, now.Location())</span><br><span class="line">fmt.Println(t.Format(layout))</span><br><span class="line"><span class="comment">//2022-12-25 09:41:37</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="2-3-日期字符串解析成-time-Time-类型"><a href="#2-3-日期字符串解析成-time-Time-类型" class="headerlink" title="2.3 日期字符串解析成 time.Time 类型"></a>2.3 日期字符串解析成 time.Time 类型</h4><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">t, _ := time.ParseInLocation(<span class="string">"2006-01-02 15:04:05"</span>, time.Now().Format(<span class="string">"2006-01-02 15:04:05"</span>), time.Local)</span><br><span class="line">fmt.Println(<span class="string">"t"</span>, t)</span><br><span class="line"><span class="comment">// 输出 t 2022-12-25 09:41:37 +0800 CST(北京时间)</span></span><br><span class="line"><span class="comment">//time.Local 指定本地时间</span></span><br><span class="line"><span class="comment">//time.Now:返回当前本地时间</span></span><br><span class="line">tt, _ := time.Parse(<span class="string">"2006-01-02 15:04:05"</span>, time.Now().Format(<span class="string">"2006-01-02 15:04:05"</span>))</span><br><span class="line">fmt.Println(<span class="string">"tt"</span>, tt)</span><br><span class="line"><span class="comment">// 输出 tt 2022-12-25 09:41:37 +0000 UTC(世界协调时间)</span></span><br><span class="line"><span class="comment">//ParselnLocation功能与parse类似，但两个重要的不同之处：</span></span><br><span class="line"><span class="comment">//1.当缺少时区信息时，Parse将时间解释为UTC时间，而ParselnLocation将返回值得Location设置为loc(正在使用的区域)</span></span><br><span class="line"><span class="comment">//2.当时间字符串提供了时区偏移量信息时，Parse会尝试去匹配本地时区，而ParselnLocation会去匹配loc</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="2-4-时间戳转日期"><a href="#2-4-时间戳转日期" class="headerlink" title="2.4 时间戳转日期"></a>2.4 时间戳转日期</h4><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> startTime, endTime <span class="keyword">int64</span></span><br><span class="line">startTime = <span class="number">1671897600</span></span><br><span class="line">endTime = <span class="number">1671984000</span></span><br><span class="line">eTime := time.Unix(endTime, <span class="number">0</span>)</span><br><span class="line">sTime := time.Unix(startTime, <span class="number">0</span>)</span><br><span class="line">startTimeday := sTime.Format(<span class="string">"2006-01-02"</span>)</span><br><span class="line">endTimeday := eTime.Format(<span class="string">"2006-01-02"</span>)</span><br><span class="line">fmt.Printf(<span class="string">"%s\n%s"</span>, startTimeday, endTimeday)</span><br><span class="line"><span class="comment">//输出:startTimeday: 2022-12-25</span></span><br><span class="line"><span class="comment">//输出:endTimeday: 2022-12-26</span></span><br></pre></td></tr></tbody></table></figure><h4 id="2-5-日期转时间戳"><a href="#2-5-日期转时间戳" class="headerlink" title="2.5 日期转时间戳"></a>2.5 日期转时间戳</h4><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TimeStr2Time</span><span class="params">(Format, valueStr, locStr <span class="keyword">string</span>)</span> <span class="title">int64</span></span> {</span><br><span class="line">loc := time.Local</span><br><span class="line"><span class="keyword">if</span> locStr != <span class="string">""</span> {</span><br><span class="line">loc, _ = time.LoadLocation(locStr) <span class="comment">// 设置时区</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> Format == <span class="string">""</span> {</span><br><span class="line">Format = <span class="string">"2006-01-02"</span></span><br><span class="line">}</span><br><span class="line">t, _ := time.ParseInLocation(Format, valueStr, loc)</span><br><span class="line"><span class="keyword">return</span> t.Unix()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">fmt.Println(TimeStr2Time(<span class="string">""</span>, <span class="string">"2022-12-25"</span>, <span class="string">""</span>))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="3-计算、比较日期"><a href="#3-计算、比较日期" class="headerlink" title="3. 计算、比较日期"></a>3. 计算、比较日期</h3><h4 id="3-1-24小时之内的时间计算"><a href="#3-1-24小时之内的时间计算" class="headerlink" title="3.1 24小时之内的时间计算"></a>3.1 24小时之内的时间计算</h4><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">now := time.Now()</span><br><span class="line">fmt.Println(now)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1小时1分1s之后</span></span><br><span class="line">t1, _ := time.ParseDuration(<span class="string">"1h1m1s"</span>)</span><br><span class="line">fmt.Println(t1)</span><br><span class="line">m1 := now.Add(t1)</span><br><span class="line">fmt.Println(m1)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1小时1分1s之前</span></span><br><span class="line">t2, _ := time.ParseDuration(<span class="string">"-1h1m1s"</span>)</span><br><span class="line">m2 := now.Add(t2)</span><br><span class="line">fmt.Println(m2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3小时之前</span></span><br><span class="line">t3, _ := time.ParseDuration(<span class="string">"-1h"</span>)</span><br><span class="line">m3 := now.Add(t3 * <span class="number">3</span>)</span><br><span class="line">fmt.Println(m3)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 10 分钟之后</span></span><br><span class="line">t4, _ := time.ParseDuration(<span class="string">"10m"</span>)</span><br><span class="line">m4 := now.Add(t4)</span><br><span class="line">fmt.Println(m4)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sub 计算两个时间差</span></span><br><span class="line">sub1 := now.Sub(m3)</span><br><span class="line">fmt.Println(sub1.Hours())   <span class="comment">// 相差小时数</span></span><br><span class="line">fmt.Println(sub1.Minutes()) <span class="comment">// 相差分钟数</span></span><br></pre></td></tr></tbody></table></figure><h4 id="3-2-24小时之外的时间计算"><a href="#3-2-24小时之外的时间计算" class="headerlink" title="3.2 24小时之外的时间计算"></a>3.2 24小时之外的时间计算</h4><p>及到一天以外的时间计算，就需要用到 time.AddDate()，函数原型：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">AddDate</span><span class="params">(years <span class="keyword">int</span>, months <span class="keyword">int</span>, days <span class="keyword">int</span>)</span> <span class="title">Time</span></span></span><br></pre></td></tr></tbody></table></figure><p>比如我们想知道 一年一个月零一天 之后的时间，就可以这样：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">now := time.Now()</span><br><span class="line">fmt.Println(now)</span><br><span class="line">m1 := now.AddDate(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">fmt.Println(m1)</span><br></pre></td></tr></tbody></table></figure><p>再比如，我们想获得 2 天之前时间：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">now := time.Now()</span><br><span class="line">fmt.Println(now)</span><br><span class="line">m1 := now.AddDate(<span class="number">0</span>,<span class="number">0</span>,<span class="number">-2</span>)</span><br><span class="line">fmt.Println(m1)</span><br></pre></td></tr></tbody></table></figure><h4 id="3-3-日期比较"><a href="#3-3-日期比较" class="headerlink" title="3.3 日期比较"></a>3.3 日期比较</h4><p>日期的比较总共有三种：之前、之后和相等。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果 t 代表的时间点在 u 之前，返回真；否则返回假。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Before</span><span class="params">(u Time)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 如果 <span class="title">t</span> 代表的时间点在 <span class="title">u</span> 之后，返回真；否则返回假。</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(t Time)</span> <span class="title">After</span><span class="params">(u Time)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 比较时间是否相等，相等返回真；否则返回假。</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(t Time)</span> <span class="title">Equal</span><span class="params">(u Time)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="title">now</span> := <span class="title">time</span>.<span class="title">Now</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">fmt</span>.<span class="title">Println</span><span class="params">(now)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 1小时之后</span></span><br><span class="line">t1, _ := time.ParseDuration("1h")</span><br><span class="line">m1 := now.Add(t1)</span><br><span class="line">fmt.Println(m1)</span><br><span class="line"></span><br><span class="line">fmt.Println(m1.After(now))</span><br><span class="line">fmt.Println(now.Before(m1))</span><br><span class="line">fmt.Println(now.Equal(m1))</span><br></pre></td></tr></tbody></table></figure><h4 id="3-4-计算函数运行的时间"><a href="#3-4-计算函数运行的时间" class="headerlink" title="3.4 计算函数运行的时间"></a>3.4 计算函数运行的时间</h4><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">compute</span><span class="params">()</span></span> {</span><br><span class="line">    start := time.Now()</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++ {</span><br><span class="line">sum++</span><br><span class="line">}</span><br><span class="line">        cost := time.Since(start)</span><br><span class="line">        fmt.Println(<span class="string">"cost="</span>, cost)</span><br><span class="line">    }()</span><br><span class="line">    <span class="comment">// some computation</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><!-- rebuild by neat --><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;平时开发过程中，时间相关的操作用的还是很多的。接下来就与大家一起总结下与时间有关的操作，主要涉及到 time 包，核心数据结构是 time.Time，如下：&lt;/p&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td clas
      
    
    </summary>
    
    
      <category term="Go" scheme="http://chenzhonzhou.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="http://chenzhonzhou.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go 日志处理</title>
    <link href="http://chenzhonzhou.github.io/2023/03/18/go-ri-zhi-chu-li/"/>
    <id>http://chenzhonzhou.github.io/2023/03/18/go-ri-zhi-chu-li/</id>
    <published>2023-03-18T03:09:10.000Z</published>
    <updated>2023-12-02T03:10:00.087Z</updated>
    
    <content type="html"><![CDATA[<h2 id="标准日志库-log"><a href="#标准日志库-log" class="headerlink" title="标准日志库 log"></a>标准日志库 log</h2><p>Go标准库中有log包，提供了简单的日志功能。</p><table><thead><tr><th>输出</th><th>格式输出</th><th>换行输出</th><th></th></tr></thead><tbody><tr><td>log.Print()</td><td>log.Printf()</td><td>log.Println()</td><td>类似fmt.Print*</td></tr><tr><td>log.Fatal()</td><td>log.Fatalf()</td><td>log.Fatalln()</td><td>相当于log.Print* + os.Exit(1)</td></tr><tr><td>log.Panic()</td><td>log.Panicf()</td><td>log.Panicln</td><td>相当于log.Print* + panic()</td></tr></tbody></table><p>日志输出需要使用日志记录器Logger。</p><p>log包提供了一个缺省的Logger即std。std是小写的，包外不可见，所以提供了Default()方法返回std给包外使用。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 大约在源码log.go第90行</span></span><br><span class="line"><span class="keyword">var</span> std = New(os.Stderr, <span class="string">""</span>, LstdFlags)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Default</span><span class="params">()</span> *<span class="title">Logger</span></span> { <span class="keyword">return</span> std }</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">Ldate         = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span> <span class="comment">// 1 当前时区日期: 2009/01/23</span></span><br><span class="line">Ltime                     <span class="comment">// 2 当前时区时间: 01:23:23</span></span><br><span class="line">Lmicroseconds             <span class="comment">// 4 微秒: 01:23:23.123123. assumes Ltime.</span></span><br><span class="line">Llongfile                 <span class="comment">// 8 绝对路径和行号: /a/b/c/d.go:23</span></span><br><span class="line">Lshortfile                <span class="comment">// 16 文件名和行号: d.go:23. overrides Llongfile</span></span><br><span class="line">LUTC                      <span class="comment">// 32 使用UTC (GMT),而不是本地时区</span></span><br><span class="line">Lmsgprefix                <span class="comment">// 64 默认前缀放行首,这个标记把前缀prefix放到消息</span></span><br><span class="line">message之前</span><br><span class="line">LstdFlags = Ldate | Ltime <span class="comment">// 3 initial values for the standard</span></span><br><span class="line">logger</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><p>上表列出的方法底层都使用std.Output输出日志内容。而std本质上是使用了<strong>标准错误输出</strong>、无前缀、<strong>LstdFlags</strong>标准标记的记录器Logger实例。</p><h3 id="std使用"><a href="#std使用" class="headerlink" title="std使用"></a>std使用</h3><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line"><span class="comment">// 使用缺省Logger</span></span><br><span class="line">log.Print(<span class="string">"abcde\n"</span>)</span><br><span class="line">log.Printf(<span class="string">"%s\n"</span>, <span class="string">"abcd"</span>)</span><br><span class="line">log.Println(<span class="string">"abc"</span>)</span><br><span class="line">log.Fatal(<span class="string">"xyz"</span>)      <span class="comment">// 等价于 log.Print("xyz");os.Exit(1)</span></span><br><span class="line">log.Panicln(<span class="string">"Failed"</span>) <span class="comment">// 等价于 log.Println("Failed");panic()</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="自定义Logger"><a href="#自定义Logger" class="headerlink" title="自定义Logger"></a>自定义Logger</h3><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Logger <span class="keyword">struct</span> {</span><br><span class="line">mu        sync.Mutex <span class="comment">// ensures atomic writes; protects the following fields</span></span><br><span class="line">prefix    <span class="keyword">string</span>     <span class="comment">// prefix on each line to identify the logger (but see Lmsgprefix)</span></span><br><span class="line">flag      <span class="keyword">int</span>        <span class="comment">// properties</span></span><br><span class="line">out       io.Writer  <span class="comment">// destination for output</span></span><br><span class="line">buf       []<span class="keyword">byte</span>     <span class="comment">// for accumulating text to write</span></span><br><span class="line">isDiscard <span class="keyword">int32</span>      <span class="comment">// atomic boolean: whether out == io.Discard</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(out io.Writer, prefix <span class="keyword">string</span>, flag <span class="keyword">int</span>)</span> *<span class="title">Logger</span></span> {</span><br><span class="line">l := &amp;Logger{out: out, prefix: prefix, flag: flag}</span><br><span class="line"><span class="keyword">if</span> out == io.Discard {</span><br><span class="line">l.isDiscard = <span class="number">1</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> l</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果觉得缺省Logger std不满意，可以New构建一个自定义Logger并指定前缀、Flags。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line"><span class="comment">// 自定义Logger</span></span><br><span class="line">infoLogger := log.New(os.Stdout, <span class="string">"Info: "</span>, log.LstdFlags|log.Lmsgprefix)</span><br><span class="line">infoLogger.Println(<span class="string">"这是一个普通消息"</span>) <span class="comment">// 使用stdout输出</span></span><br><span class="line">errLogger := log.New(os.Stderr, <span class="string">"Error: "</span>, log.LstdFlags)</span><br><span class="line">errLogger.Fatal(<span class="string">"这是一个错误消息"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="写日志文件"><a href="#写日志文件" class="headerlink" title="写日志文件"></a>写日志文件</h3><p>New方法签名 New(out io.Writer, prefix string, flag int) *Logger 中out参数提供Writer接口即可，那么就可以提供一个可写文件对象。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">f, err := os.OpenFile(</span><br><span class="line"><span class="string">"o:/my.log"</span>,</span><br><span class="line">os.O_WRONLY|os.O_CREATE|os.O_APPEND, <span class="comment">// 追加写，文件不存在创建</span></span><br><span class="line">os.ModePerm,</span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">log.Panicln(err)</span><br><span class="line">}</span><br><span class="line"><span class="keyword">defer</span> f.Close()</span><br><span class="line">l := log.New(f, <span class="string">"Info: "</span>, log.LstdFlags)</span><br><span class="line">l.Println(<span class="string">"这是一个写入文件的消息"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="第三方日志库-zerolog"><a href="#第三方日志库-zerolog" class="headerlink" title="第三方日志库 zerolog"></a>第三方日志库 zerolog</h2><p>log模块太简陋了，实际使用并不方便。</p><blockquote><p>logrus有日志级别、Hook机制、日志格式输出，很好用；<br>zap是Uber的开源高性能日志库；<br>zerolog更注重开发体验，高性能、有日志级别、链式API，json格式日志记录，号称0内存分配。</p></blockquote><p>官网 <a href="https://zerolog.io/" target="_blank" rel="noopener">https://zerolog.io/</a></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">安装 go get -u github.com/rs/zerolog/log</span><br></pre></td></tr></tbody></table></figure><h3 id="缺省Logger"><a href="#缺省Logger" class="headerlink" title="缺省Logger"></a>缺省Logger</h3><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/rs/zerolog"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">log.Print(<span class="string">"hello"</span>) <span class="comment">// 使用全局缺省logger</span></span><br><span class="line"><span class="comment">// {"level":"debug","time":"2008-10-14T09:17:50+08:00","message":"hello"} JSON格式输出</span></span><br><span class="line"><span class="comment">// log.Print产生debug级别消息</span></span><br><span class="line"><span class="comment">// Logger is the global logger.源码第14行，定义了一个全局导出的缺省Logger</span></span><br><span class="line"><span class="keyword">var</span> Logger = zerolog.New(os.Stderr).With().Timestamp().Logger() <span class="comment">// 链式调用</span></span><br><span class="line"><span class="comment">// 缺省Logger使用标准错误输出</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>log.Print()、log.Printf()方法使用方式和标准库log模块类似。</p><h3 id="日志级别"><a href="#日志级别" class="headerlink" title="日志级别"></a>日志级别</h3><p>zerolog提供以下级别（从高到底）</p><blockquote><p>panic (zerolog.PanicLevel, 5)<br>fatal (zerolog.FatalLevel, 4)<br>error (zerolog.ErrorLevel, 3)<br>warn (zerolog.WarnLevel, 2)<br>info (zerolog.InfoLevel, 1)<br>debug (zerolog.DebugLevel, 0)<br>trace (zerolog.TraceLevel, -1)</p></blockquote><p>级别有</p><blockquote><p>gLevel全局级别</p><ul><li>zerolog.SetGlobalLevel(级别数字或常量) 来设置全局级别</li><li>zerolog.GlobalLevel() 获取当前全局级别</li></ul><p>每个Logger的级别<br>消息的级别</p></blockquote><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/rs/zerolog"</span></span><br><span class="line"><span class="string">"github.com/rs/zerolog/log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">fmt.Println(<span class="string">"全局级别gLevel为"</span>, zerolog.GlobalLevel())</span><br><span class="line">fmt.Println(<span class="string">"缺省logger的级别为"</span>, log.Logger.GetLevel())</span><br><span class="line">log1 := log.Level(zerolog.WarnLevel) <span class="comment">// 创建一个子logger</span></span><br><span class="line">fmt.Println(<span class="string">"log1级别为"</span>, log1.GetLevel())</span><br><span class="line">fmt.Println(<span class="string">"~~~~~~~~~~~~~~~~~~~~~~~~~~~"</span>)</span><br><span class="line">log.Trace().Msg(<span class="string">"缺省logger输出trace级别消息"</span>) <span class="comment">// 输出</span></span><br><span class="line">log.Info().Msg(<span class="string">"缺省logger输出info级别消息"</span>)   <span class="comment">// 输出</span></span><br><span class="line">log.Warn().Msg(<span class="string">"缺省logger输出warn级别消息"</span>)   <span class="comment">// 输出</span></span><br><span class="line">log.Error().Msg(<span class="string">"缺省logger输出error级别消息"</span>) <span class="comment">// 输出</span></span><br><span class="line">log1.Debug().Msg(<span class="string">"log1的Debug级别消息"</span>)     <span class="comment">// 不能输出</span></span><br><span class="line">log1.Warn().Msg(<span class="string">"log1的Warn级别消息"</span>)       <span class="comment">// 输出</span></span><br><span class="line">log1.Error().Msg(<span class="string">"log1的Error级别消息"</span>)     <span class="comment">// 输出</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可以看到，使用缺省logger，全部可以输出日志消息，而log1使22行、23行输出了日志，为什么？</p><p>因为，有<strong>消息级别</strong>和<strong>Logger级别</strong>。</p><p>log1的级别为warn 2，而log1.Debug()输出的消息级别为debug级别0，消息级别 &lt; log1级别，所以消息不能输出。log1.Warn()、log1.Error()产生warn、error消息消息，消息级别 ≥ log1级别，因此可以输出。</p><p>而缺省Logger的级别是trace，任何消息级别都大于等于log1的级别，因此都可以输出。</p><p>下面调高全局级别，试试看。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/rs/zerolog"</span></span><br><span class="line"><span class="string">"github.com/rs/zerolog/log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">zerolog.SetGlobalLevel(zerolog.ErrorLevel) <span class="comment">// 调高全局级别</span></span><br><span class="line">fmt.Println(<span class="string">"全局级别gLevel为"</span>, zerolog.GlobalLevel())</span><br><span class="line">fmt.Println(<span class="string">"缺省logger的级别为"</span>, log.Logger.GetLevel())</span><br><span class="line">log1 := log.Level(zerolog.WarnLevel) <span class="comment">// 创建一个子logger</span></span><br><span class="line">fmt.Println(<span class="string">"log1级别为"</span>, log1.GetLevel())</span><br><span class="line">fmt.Println(<span class="string">"~~~~~~~~~~~~~~~~~~~~~~~~~~~"</span>)</span><br><span class="line">log.Trace().Msg(<span class="string">"缺省logger输出trace级别消息"</span>) <span class="comment">// 不能输出</span></span><br><span class="line">log.Info().Msg(<span class="string">"缺省logger输出info级别消息"</span>)   <span class="comment">// 不能输出</span></span><br><span class="line">log.Warn().Msg(<span class="string">"缺省logger输出warn级别消息"</span>)   <span class="comment">// 不能输出</span></span><br><span class="line">log.Error().Msg(<span class="string">"缺省logger输出error级别消息"</span>) <span class="comment">// 输出</span></span><br><span class="line">log1.Debug().Msg(<span class="string">"log1的Debug级别消息"</span>)     <span class="comment">// 不能输出</span></span><br><span class="line">log1.Warn().Msg(<span class="string">"log1的Warn级别消息"</span>)       <span class="comment">// 不能输出</span></span><br><span class="line">log1.Error().Msg(<span class="string">"log1的Error级别消息"</span>)     <span class="comment">// 输出</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>缺省logger和log1都只有error级别的输出，说明将gLevel调整到error级别后，所有logger输出消息都必须大于等于gLevel。</p><p><strong>特别注意</strong>，<code>zerolog.SetGlobalLevel()</code>设置的是全局变量<strong>gLevel</strong>，它影响所有<strong>Logger</strong>。</p><p>日志消息是否能够输出，应当满足下面的要求 消息级别 ≥ max(gLevel, 当前logger级别)</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zerolog.SetGlobalLevel(zerolog.Disabled)</span><br><span class="line"><span class="comment">// zerolog.Disabled 为7，没有消息级别可以大于等于7，相当于禁用所有Logger，自然不能输出日志了</span></span><br></pre></td></tr></tbody></table></figure><h3 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h3><p>zerolog是以Json对象格式输出的，还可以自定义一些键值对字段增加到上下文中以输出。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">zerolog.SetGlobalLevel(zerolog.InfoLevel)</span><br><span class="line">log.Info().Bool(<span class="string">"Success"</span>, <span class="literal">false</span>).Str(<span class="string">"Rea son"</span>, <span class="string">"File Not Found"</span>).Msg(<span class="string">"文件</span></span><br><span class="line"><span class="string">没找到"</span>)</span><br><span class="line">log.Info().Str(<span class="string">"Name"</span>, <span class="string">"Tom"</span>).Floats32(<span class="string">"Scores"</span>, []<span class="keyword">float32</span>{<span class="number">87.5</span>, <span class="number">90</span>, </span><br><span class="line"><span class="number">59</span>}).Send()</span><br><span class="line"><span class="comment">// Send is equivalent to calling Msg("")</span></span><br></pre></td></tr></tbody></table></figure><h3 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h3><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"errors"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/rs/zerolog"</span></span><br><span class="line"><span class="string">"github.com/rs/zerolog/log"</span> <span class="comment">// 全局logger</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">zerolog.TimeFieldFormat = zerolog.TimeFormatUnix <span class="comment">// 自定义time字段时间的格式，TimeFormatUnix时间戳</span></span><br><span class="line"><span class="comment">// zerolog.ErrorFieldName = "err" // 修改日志Json中的缺省字段名error</span></span><br><span class="line"><span class="comment">// 错误日志</span></span><br><span class="line">err := errors.New(<span class="string">"自定义的错误"</span>)</span><br><span class="line">log.Error(). <span class="comment">// 错误级别消息</span></span><br><span class="line">Err(err). <span class="comment">// err字段，错误消息内容</span></span><br><span class="line">Send()    <span class="comment">// 有错误消息了，message可以省略</span></span><br><span class="line">log.Fatal(). <span class="comment">// fatal级别</span></span><br><span class="line">Err(err).Send()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="全局Logger"><a href="#全局Logger" class="headerlink" title="全局Logger"></a>全局Logger</h3><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局Logger定义如下，可以覆盖全局Logger</span></span><br><span class="line"><span class="keyword">var</span> Logger = zerolog.New(os.Stderr).With().Timestamp().Logger()</span><br><span class="line"></span><br><span class="line">zerolog.TimeFieldFormat = zerolog.TimeFormatUnix</span><br><span class="line"><span class="comment">// With()创建一个全局Logger的子logger</span></span><br><span class="line">log.Logger = log.With().Str(<span class="string">"School"</span>, <span class="string">"学习"</span>).Logger() <span class="comment">// 覆盖了全局Logger</span></span><br><span class="line">log.Info().Send() <span class="comment">// {"level":"info","School":"学习","time":1223947070}</span></span><br></pre></td></tr></tbody></table></figure><h3 id="自定义Logger-1"><a href="#自定义Logger-1" class="headerlink" title="自定义Logger"></a>自定义Logger</h3><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/rs/zerolog"</span></span><br><span class="line"><span class="string">"github.com/rs/zerolog/log"</span> <span class="comment">// 全局logger</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">zerolog.TimeFieldFormat = zerolog.TimeFormatUnix</span><br><span class="line">logger := log.With(). <span class="comment">// With()返回基于全局Logger的子logger</span></span><br><span class="line">Str(<span class="string">"School"</span>, <span class="string">"学习"</span>).</span><br><span class="line">Caller(). <span class="comment">// 增加日志调用的位置信息字段</span></span><br><span class="line">Logger()  <span class="comment">// 返回Logger</span></span><br><span class="line">logger.Info().Send() <span class="comment">// {"level":"info","School":"学习","time":1223947070}</span></span><br><span class="line">log.Info().Send()    <span class="comment">// {"level":"info","time":1223947070} 全局Logger</span></span><br><span class="line">zerolog.TimeFieldFormat = zerolog.TimeFormatUnix</span><br><span class="line">    </span><br><span class="line">logger = zerolog.New(os.Stdout). <span class="comment">// 不基于全局Logger，重新构造了一个Logger</span></span><br><span class="line">With().Str(<span class="string">"School"</span>, <span class="string">"学习"</span>).</span><br><span class="line">Caller().                 <span class="comment">// 调用者信息：增加日志函数调用的位置信息字段</span></span><br><span class="line">Logger().                 <span class="comment">// 返回Logger</span></span><br><span class="line">Level(zerolog.ErrorLevel) <span class="comment">// 重新定义Logger级别为3 error，返回Logger</span></span><br><span class="line">fmt.Println(logger.GetLevel())</span><br><span class="line">logger.Info().Send() <span class="comment">// {"level":"info","School":"学习","time":1223947070} 看颜色区别</span></span><br><span class="line">logger.Error().Send()</span><br><span class="line">log.Info().Send() <span class="comment">// {"level":"info","time":1223947070} 全局Logger</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="写日志文件-1"><a href="#写日志文件-1" class="headerlink" title="写日志文件"></a>写日志文件</h3><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/rs/zerolog"</span></span><br><span class="line"><span class="string">"github.com/rs/zerolog/log"</span> <span class="comment">// 全局logger</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">zerolog.TimeFieldFormat = zerolog.TimeFormatUnix</span><br><span class="line">f, err := os.OpenFile(<span class="string">"o:/my.log"</span>, os.O_CREATE|os.O_APPEND, os.ModePerm)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">log.Panic().Err(err).Send() <span class="comment">// 内部调用panic</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">defer</span> f.Close()</span><br><span class="line"></span><br><span class="line">multi := zerolog.MultiLevelWriter(f, os.Stdout) <span class="comment">// 多分支写</span></span><br><span class="line"><span class="comment">// Timestamp()为这个全新的Logger增加时间戳输出</span></span><br><span class="line">logger := zerolog.New(multi).With().Timestamp().Logger()</span><br><span class="line">logger.Info().Msg(<span class="string">"日志兵分两路，去控制台stdout，还去日志文件"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//日志一分为二，一路去控制台，一路进文件</span></span><br><span class="line">lw := zerolog.MultiLevelWriter(f, os.Stdout) <span class="comment">//f 写文件,os.Stdout 控制台输出</span></span><br><span class="line">log4 := zerolog.New(lw).With().Timestamp().</span><br><span class="line">Str(<span class="string">"school"</span>, <span class="string">"学习"</span>).Logger().Level(zerolog.InfoLevel)</span><br><span class="line">log4.Info().Send()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果只输出到文件可以使用 zerolog.New(f).With().Timestamp().Logger()</p><!-- rebuild by neat --><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;标准日志库-log&quot;&gt;&lt;a href=&quot;#标准日志库-log&quot; class=&quot;headerlink&quot; title=&quot;标准日志库 log&quot;&gt;&lt;/a&gt;标准日志库 log&lt;/h2&gt;&lt;p&gt;Go标准库中有log包，提供了简单的日志功能。&lt;/p&gt;&lt;table&gt;&lt;thead&gt;&lt;
      
    
    </summary>
    
    
      <category term="Go" scheme="http://chenzhonzhou.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="http://chenzhonzhou.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go 链接表和栈</title>
    <link href="http://chenzhonzhou.github.io/2023/03/12/go-lian-jie-biao-he-zhan/"/>
    <id>http://chenzhonzhou.github.io/2023/03/12/go-lian-jie-biao-he-zhan/</id>
    <published>2023-03-12T03:07:40.000Z</published>
    <updated>2023-12-02T03:08:53.745Z</updated>
    
    <content type="html"><![CDATA[<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>链表和数组、切片一样，都是容器，也就是它就是个盒子，盒子里面装着各种元素的节点。</p><p>所以在设计时，需要设计容器和元素。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"errors"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"strconv"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> {</span><br><span class="line">item <span class="keyword">int</span></span><br><span class="line">next *Node</span><br><span class="line">prev *Node</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Node)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> {</span><br><span class="line"><span class="keyword">var</span> next, prev <span class="keyword">string</span></span><br><span class="line"><span class="keyword">if</span> n.next == <span class="literal">nil</span> {</span><br><span class="line">next = <span class="string">"null"</span></span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">next = strconv.Itoa(n.next.item)</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> n.prev == <span class="literal">nil</span> {</span><br><span class="line">prev = <span class="string">"null"</span></span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">prev = fmt.Sprintf(<span class="string">"%d"</span>, n.prev.item)</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(</span><br><span class="line"><span class="string">"%s &lt;== %d ==&gt; %s"</span>,</span><br><span class="line">prev,</span><br><span class="line">n.item,</span><br><span class="line">next,</span><br><span class="line">)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LinkedList <span class="keyword">struct</span> {</span><br><span class="line">head *Node</span><br><span class="line">tail *Node</span><br><span class="line"><span class="built_in">len</span>  <span class="keyword">int</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewList</span><span class="params">()</span> *<span class="title">LinkedList</span></span> {</span><br><span class="line"><span class="keyword">return</span> &amp;LinkedList{}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *LinkedList)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> {</span><br><span class="line"><span class="keyword">return</span> l.<span class="built_in">len</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *LinkedList)</span> <span class="title">Append</span><span class="params">(item <span class="keyword">int</span>)</span></span> {</span><br><span class="line">node := <span class="built_in">new</span>(Node)</span><br><span class="line">node.item = item</span><br><span class="line"><span class="comment">// node.prev = nil 默认</span></span><br><span class="line"><span class="comment">// node.next = nil 默认</span></span><br><span class="line"><span class="keyword">if</span> l.head == <span class="literal">nil</span> {</span><br><span class="line"><span class="comment">// 没有元素，头尾都是nil，但凡有一个元素，头尾都不是nil</span></span><br><span class="line">l.head = node</span><br><span class="line">l.tail = node</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line"><span class="comment">// 哪怕是有一个元素，append都是动尾巴</span></span><br><span class="line">l.tail.next = node <span class="comment">// 手拉手1，修改当前尾巴的下一个</span></span><br><span class="line">node.prev = l.tail <span class="comment">// 手拉手2，新节点拉尾巴</span></span><br><span class="line">l.tail = node      <span class="comment">// 修改尾巴</span></span><br><span class="line">}</span><br><span class="line">l.<span class="built_in">len</span>++ <span class="comment">// 新增成功长度加1</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *LinkedList)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">error</span></span> {</span><br><span class="line"><span class="comment">// 尾部弹出</span></span><br><span class="line"><span class="keyword">if</span> l.tail == <span class="literal">nil</span> { <span class="comment">// 空链表</span></span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">"Empty"</span>)</span><br><span class="line">} <span class="keyword">else</span> <span class="keyword">if</span> l.head == l.tail {</span><br><span class="line"><span class="comment">// 仅有一个元素</span></span><br><span class="line">l.head = <span class="literal">nil</span></span><br><span class="line">l.tail = <span class="literal">nil</span></span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">tail := l.tail    <span class="comment">// 当前尾巴</span></span><br><span class="line">prev := tail.prev <span class="comment">// 当前倒数第二个</span></span><br><span class="line">prev.next = <span class="literal">nil</span></span><br><span class="line">l.tail = prev</span><br><span class="line">}</span><br><span class="line">l.<span class="built_in">len</span>-- <span class="comment">// 弹出一个，长度减1</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *LinkedList)</span> <span class="title">Insert</span><span class="params">(index <span class="keyword">int</span>, value <span class="keyword">int</span>)</span> <span class="title">error</span></span> {</span><br><span class="line"><span class="comment">// 使用索引插入。同学们自行实现按照值插入</span></span><br><span class="line"><span class="keyword">if</span> index &lt; <span class="number">0</span> {</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">"Not negative"</span>)</span><br><span class="line">}</span><br><span class="line"><span class="keyword">var</span> current *Node</span><br><span class="line"><span class="keyword">var</span> flag <span class="keyword">bool</span></span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> l.IterNodes(<span class="literal">false</span>) {</span><br><span class="line"><span class="keyword">if</span> i == index {</span><br><span class="line">current = v</span><br><span class="line">flag = <span class="literal">true</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> !flag {</span><br><span class="line"><span class="comment">// 遍历完了没找到，则追加</span></span><br><span class="line"><span class="comment">// 思考一下，如果一个元素都没有，insert会怎么样</span></span><br><span class="line">l.Append(value)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">// 走到这里说明一定有元素，把这个元素往后挤</span></span><br><span class="line">node := <span class="built_in">new</span>(Node)</span><br><span class="line">node.item = value</span><br><span class="line">prev := current.prev</span><br><span class="line"><span class="keyword">if</span> index == <span class="number">0</span> { <span class="comment">// 开头插入，换头</span></span><br><span class="line">l.head = node</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">prev.next = node <span class="comment">// 手拉手</span></span><br><span class="line">node.prev = prev <span class="comment">// 手拉手</span></span><br><span class="line">}</span><br><span class="line">node.next = current <span class="comment">// 手拉手1</span></span><br><span class="line">current.prev = node <span class="comment">// 手拉手2</span></span><br><span class="line">l.<span class="built_in">len</span>++</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *LinkedList)</span> <span class="title">Remove</span><span class="params">(index <span class="keyword">int</span>)</span> <span class="title">error</span></span> {</span><br><span class="line"><span class="keyword">if</span> l.tail == <span class="literal">nil</span> { <span class="comment">// 空链表</span></span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">"Empty"</span>)</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 使用索引移除。同学们自行实现按照值移除</span></span><br><span class="line"><span class="keyword">if</span> index &lt; <span class="number">0</span> {</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">"Not negative"</span>)</span><br><span class="line">}</span><br><span class="line"><span class="keyword">var</span> current *Node</span><br><span class="line"><span class="keyword">var</span> flag <span class="keyword">bool</span></span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> l.IterNodes(<span class="literal">false</span>) {</span><br><span class="line"><span class="keyword">if</span> i == index {</span><br><span class="line">current = v</span><br><span class="line">flag = <span class="literal">true</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> !flag {</span><br><span class="line"><span class="comment">// 遍历完了没找到，则报错</span></span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">"Out"</span>)</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 走到这里说明一定有元素且找到了这个元素</span></span><br><span class="line">prev := current.prev</span><br><span class="line">next := current.next</span><br><span class="line"><span class="comment">// 4种情况</span></span><br><span class="line"><span class="keyword">if</span> prev == <span class="literal">nil</span> &amp;&amp; next == <span class="literal">nil</span> {</span><br><span class="line"><span class="comment">// 仅仅只有一个元素，想想还有什么等价的条件？</span></span><br><span class="line">l.head = <span class="literal">nil</span></span><br><span class="line">l.tail = <span class="literal">nil</span></span><br><span class="line">} <span class="keyword">else</span> <span class="keyword">if</span> prev == <span class="literal">nil</span> { <span class="comment">// 是开头，且多于一个元素</span></span><br><span class="line">l.head = next</span><br><span class="line">next.prev = <span class="literal">nil</span></span><br><span class="line">} <span class="keyword">else</span> <span class="keyword">if</span> next == <span class="literal">nil</span> { <span class="comment">// 是尾巴，且多于一个元素</span></span><br><span class="line">prev.next = <span class="literal">nil</span></span><br><span class="line">l.tail = prev</span><br><span class="line">} <span class="keyword">else</span> { <span class="comment">// 既不是开头也不是尾巴，且多于一个元素</span></span><br><span class="line">prev.next = next</span><br><span class="line">next.prev = prev</span><br><span class="line">}</span><br><span class="line">l.<span class="built_in">len</span>--</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *LinkedList)</span> <span class="title">IterNodes</span><span class="params">(reversed <span class="keyword">bool</span>)</span> []*<span class="title">Node</span></span> {</span><br><span class="line"><span class="keyword">var</span> p *Node</span><br><span class="line">r := <span class="built_in">make</span>([]*Node, <span class="number">0</span>, l.<span class="built_in">len</span>)</span><br><span class="line"><span class="keyword">if</span> reversed {</span><br><span class="line">p = l.tail</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">p = l.head</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span> p != <span class="literal">nil</span> {</span><br><span class="line"><span class="comment">// fmt.Println(p)</span></span><br><span class="line">r = <span class="built_in">append</span>(r, p)</span><br><span class="line"><span class="keyword">if</span> reversed {</span><br><span class="line">p = p.prev</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">p = p.next</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> r</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line"><span class="comment">// 构造一个链表</span></span><br><span class="line">ll := NewList()</span><br><span class="line">ll.Append(<span class="number">2</span>)</span><br><span class="line">ll.Append(<span class="number">3</span>)</span><br><span class="line">ll.Insert(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">ll.Insert(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">ll.Append(<span class="number">5</span>)</span><br><span class="line">ll.Insert(<span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line">fmt.Println(ll.IterNodes(<span class="literal">false</span>))</span><br><span class="line">ll.Remove(<span class="number">1</span>)</span><br><span class="line">fmt.Println(ll.IterNodes(<span class="literal">false</span>))</span><br><span class="line">ll.Pop()</span><br><span class="line">fmt.Println(ll.IterNodes(<span class="literal">false</span>))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>Go语言标准库”container/list”中的List实现了双向链表。</p><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>栈stack，一种仅在表尾进行插入、删除的线性表。先压入的数据被压在栈底，最后进入的数据压在栈顶。弹出数据时，要从栈顶弹出数据。插入数据称为进栈、压栈、入栈，弹出数据称为退栈、出栈。</p><p>栈的特点就是后进先出LIFO。</p><p>“container/list”中的List实现了双向链表，可以用链表作为底层数据结构来实现实现栈。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"container/list"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">stack := list.New() <span class="comment">// 创建链表</span></span><br><span class="line">stack.PushBack(<span class="number">1</span>)   <span class="comment">// 尾部追加，返回元素对象</span></span><br><span class="line">stack.PushBack(<span class="number">2</span>)</span><br><span class="line">stack.PushBack(<span class="number">3</span>)</span><br><span class="line">stack.PushBack(<span class="number">4</span>)</span><br><span class="line">fmt.Println(stack.Front())</span><br><span class="line">fmt.Println(stack.Back())</span><br><span class="line">fmt.Println(stack.Len())</span><br><span class="line"><span class="keyword">for</span> r := stack.Front(); r != <span class="literal">nil</span>; r = r.Next() {</span><br><span class="line">fmt.Println(r.Value)</span><br><span class="line">}</span><br><span class="line">stack.Remove(stack.Back()) <span class="comment">// 移除尾巴</span></span><br><span class="line">fmt.Println(<span class="string">"~~~~~~~~~~~~~~~~~~~~~~~~~~~"</span>)</span><br><span class="line"><span class="keyword">for</span> r := stack.Front(); r != <span class="literal">nil</span>; r = r.Next() {</span><br><span class="line">fmt.Println(r.Value)</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><!-- rebuild by neat --><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;链表&quot;&gt;&lt;a href=&quot;#链表&quot; class=&quot;headerlink&quot; title=&quot;链表&quot;&gt;&lt;/a&gt;链表&lt;/h2&gt;&lt;p&gt;链表和数组、切片一样，都是容器，也就是它就是个盒子，盒子里面装着各种元素的节点。&lt;/p&gt;&lt;p&gt;所以在设计时，需要设计容器和元素。&lt;/p&gt;&lt;f
      
    
    </summary>
    
    
      <category term="Go" scheme="http://chenzhonzhou.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="http://chenzhonzhou.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go work工作区使用</title>
    <link href="http://chenzhonzhou.github.io/2023/03/09/go-work-gong-zuo-qu-shi-yong/"/>
    <id>http://chenzhonzhou.github.io/2023/03/09/go-work-gong-zuo-qu-shi-yong/</id>
    <published>2023-03-09T03:05:31.000Z</published>
    <updated>2023-12-02T03:07:07.547Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go-work工作区模式"><a href="#Go-work工作区模式" class="headerlink" title="Go work工作区模式"></a>Go work工作区模式</h2><p>Go 1.18引入的工作区模式，可以让你不用修改每个Go Module的go.mod，就能同时跨多个Go Module进行开发。</p><p>工作区里的每个Go Module在解析依赖的时候都被当做根Module。</p><p>在Go 1.18以前，如果遇到以下场景：Module A新增了一个feature，Module B需要使用Module A的这个新feature，你有2种方案：</p><p>发布Module A的修改到代码仓库，Module B更新依赖的Module A的版本即可修改Module B的go.mod，使用replace指令把对Module A的依赖指向你本地未发布的Module A所在目录。等Module A发布后，在发布Module B的时候，再删除Module B的go.mod文件里的replace指令。</p><p>有了Go工作区模式之后，针对上述场景，我们有了更为简单的方案：你可以在工作区目录维护一个go.work文件来管理你的所有依赖。go.work里的use和replace指令会覆盖工作区目录下的每个Go Module的go.mod文件，因此没有必要去修改Go Module的go.mod文件了。</p><h2 id="Go-work用法"><a href="#Go-work用法" class="headerlink" title="Go work用法"></a>Go work用法</h2><h3 id="go-work-init"><a href="#go-work-init" class="headerlink" title="go work init"></a>go work init</h3><p>使用go work init来创建一个workspace，go work init 的语法如下所示：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go work init [moddirs]</span><br></pre></td></tr></tbody></table></figure><p>moddirs是Go Module所在的本地目录。如果有多个Go Module，就用空格分开。如果go work init后面没有参数，会创建一个空的workspace。</p><p>执行go work init后会生成一个go.work文件，go.work里列出了该workspace需要用到的Go Module所在的目录，workspace目录不需要包含你当前正在开发的Go Module代码。</p><h3 id="go-work-use"><a href="#go-work-use" class="headerlink" title="go work use"></a>go work use</h3><p>如果要给workspace新增Go Module，可以使用如下命令：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go work use [-r] moddir</span><br></pre></td></tr></tbody></table></figure><p>或者手动编辑go work文件。</p><p>如果带有-r参数，会递归查找-r后面的路径参数下的所有子目录，把所有包含go.mod文件的子目录都添加到go work文件中。</p><p>如果某个Go Module的目录已经被加到go.work里了，后面该目录没有go.mod文件了或者该目录被删除了，那对该目录再次执行go work use命令，该目录的use指令会从go.work文件里自动移除。(注意：自动移除要从Go 1.18正式版本才会生效，Go 1.18beta1版本有bug，自动删除不会生效)</p><h3 id="go-work"><a href="#go-work" class="headerlink" title="go.work"></a>go.work</h3><p>go.work的语法和go.mod类似，包含如下3个指令：</p><ul><li>go: go的版本，例如 go 1.18</li><li>use: 添加一个本地磁盘上的Go Module到workspace的主Module集合里。use后面的参数是go.mod文件所在目录相对于workspace目录的相对路径，例如use ./main。use指令不会添加指定目录的子目录下的Go Module到workspace的主Module集合里。</li><li>replace: 和go.mod里的 replace指令类似。go.work里的 replace指令可以替换某个Go Module的特定版本或者所有版本的内容。</li></ul><h3 id="go-work-其他命令"><a href="#go-work-其他命令" class="headerlink" title="go work 其他命令"></a>go work 其他命令</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">edit        edit go.work from tools or scripts</span><br><span class="line">init        initialize workspace file</span><br><span class="line">sync        sync workspace build list to modules</span><br><span class="line">use         add modules to workspace file</span><br></pre></td></tr></tbody></table></figure><h2 id="使用场景和最佳实践"><a href="#使用场景和最佳实践" class="headerlink" title="使用场景和最佳实践"></a>使用场景和最佳实践</h2><p>Workspace使用起来很灵活，接下来会介绍最常见的几种使用场景及其最佳实践。</p><h3 id="使用场景1"><a href="#使用场景1" class="headerlink" title="使用场景1"></a>使用场景1</h3><p><strong>给上游模块新增feature，然后在你的Module里使用这个新feature</strong></p><p>为你的workspace(工作区)创建一个目录。Clone一份你要修改的上游模块的代码到本地。本地修改上游模块的代码，增加新的feature。<br>在workspace目录运行命令<code>go work init [path-to-upstream-mod-dir]</code>。为了使用上游模块的新feature，修改你自己的Go Module代码。<br>在workspace目录运行命令 <code>go work use [path-to-your-module]</code>。go work use 命令会添加你的Go Module的路径到 go.work 文件里：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="number">1.18</span></span><br><span class="line"></span><br><span class="line">use (</span><br><span class="line">./path-to-upstream-mod-dir</span><br><span class="line">./path-to-your-module</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><p>运行和测试你的Go Module。发布上游模块的新feature。发布你自己的Go Module代码。</p><h3 id="使用场景2"><a href="#使用场景2" class="headerlink" title="使用场景2"></a>使用场景2</h3><p><strong>同一个代码仓库里有多个互相依赖的Go Module</strong></p><p>当我们在同一个代码仓库里开发多个互相依赖的Go Module时，我们可以使用go.work，而不是在go.mod里使用replace指令。</p><p>为你的workspace(工作区)创建一个目录。</p><p>Clone仓库里的代码到你本地。代码存放的位置不一定要放在工作区目录下，因为你可以在go.work里使用use指令来指定Module的相对路径。在工作区目录运行 <code>go work init [path-to-module-one] [path-to-module-two]</code> 命令。</p><p>示例: 你正在开发 example.com/x/tools/groundhog 这个Module，该Module依赖 example.com/x/tools 下的其它Module。你Clone仓库里的代码到你本地，然后在工作区目录运行命令 <code>go work init tools tools/groundhog</code> 。<br>go.work 文件里的内容如下所示：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">go 1.18</span><br><span class="line"></span><br><span class="line">use (</span><br><span class="line">./tools</span><br><span class="line">./tools/groundhog</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><p>tools路径下其它Module的本地代码修改都会被 tools/groundhog 直接使用到。</p><h3 id="使用场景3"><a href="#使用场景3" class="headerlink" title="使用场景3"></a>使用场景3</h3><p><strong>切换依赖配置</strong></p><p>如果要测试你开发的代码在不同的本地依赖配置下的场景，你有2种选择：</p><p>创建多个workspace，每个workspace使用各自的go.work文件，每个go.work里指定一个版本的路径。</p><p>创建一个workspace，在go.work里注释掉你不想要的use指令。</p><p>对于创建多个workspace的方案：</p><p>为每个workspace创建独立的目录。比如你开发的代码依赖了example.com/util这个Go Module，但是想测试example.com/util2个版本的区别，你可以创建2个workspace目录。<br>在各自的workspace目录运行 go work init 来初始化workspace。在各自的workspace目录运行 go work use [path-to-dependency]来添加依赖的Go Module特定版本的目录。在各自的workspace目录运行 go run [path-to-your-module] 来测试go.work里指定的依赖版本。</p><p>对于使用同一个workspace的方案，可以直接编辑go.work文件，修改use指令后面的目录地址即可。</p><!-- rebuild by neat --><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go-work工作区模式&quot;&gt;&lt;a href=&quot;#Go-work工作区模式&quot; class=&quot;headerlink&quot; title=&quot;Go work工作区模式&quot;&gt;&lt;/a&gt;Go work工作区模式&lt;/h2&gt;&lt;p&gt;Go 1.18引入的工作区模式，可以让你不用修改每个Go M
      
    
    </summary>
    
    
      <category term="Go" scheme="http://chenzhonzhou.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="http://chenzhonzhou.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go 包管理</title>
    <link href="http://chenzhonzhou.github.io/2023/03/05/go-bao-guan-li/"/>
    <id>http://chenzhonzhou.github.io/2023/03/05/go-bao-guan-li/</id>
    <published>2023-03-05T03:03:41.000Z</published>
    <updated>2023-12-02T03:04:34.520Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p>用任何语言来开发，如果软件规模扩大，会编写大量的函数、结构体、接口等代码。这些代码不可能写在一个文件中，这就会产生大量的文件。如果这些文件杂乱无章，就会造成名称冲突、重复定义、难以检索、无法引用、共享不便、版本管理等一系列问题。有一些功能模块如何复用，如何共享方便其他项目使用。所以，一定要有模块化管理，解决以上诸多问题。</p><h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><ul><li><p>包由多个文件和目录组成</p></li><li><p>使用 package &lt;包名&gt; 来定义包名</p></li><li><p>包名一般都采用小写，符合标识符要求</p></li><li><p>当前目录名和 package &lt;包名&gt; 中的包名不需要一致，但最好保持一致</p></li><li><p><strong>同级文件归属一个包</strong>，就是说每个包目录的当前目录中，只能统一使用同一个package的包名，否则编译出错</p></li></ul><p>一般来说，开发项目时，可以把相关功能的代码集中放在某个包里面。例如在main包目录中新建一个calc包，将所有计算函数都放在其中，以供别的代码调用。同一个目录就是同一个包，该包内go文件里的变量、函数、结构体互相可见，可以直接使用。</p><p>跨目录就是跨包，使用时需要导入别的包，导入需要指定该包的路径。</p><h3 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h3><h4 id="GOPATH"><a href="#GOPATH" class="headerlink" title="GOPATH"></a>GOPATH</h4><p>Go 1.11版本之前，项目依赖包存于GOPATH。GOPATH是一个环境变量，指向一个目录，其中存放项目依赖包的源码。</p><p>GOPATH默认值是 <code>家目录</code>/go 。</p><p>开发的代码放在 GOPATH/src 目录中，编译这个目录的代码，生成的二进制文件放到 GOPATH/bin 目录下。</p><p>这会有以下问题：</p><ul><li>GOPATH不区分项目，代码中任何import的路径均从GOPATH作为根目录开始。如果有多个项目，不同项目依赖不同库的不同版本，这就很难解决了</li><li>所有项目的依赖都放在GOPATH中，很难知道当前项目的依赖项是哪些</li></ul><h4 id="GOPATH-vendor机制"><a href="#GOPATH-vendor机制" class="headerlink" title="GOPATH + vendor机制"></a>GOPATH + vendor机制</h4><p>Go 1.5引入vendor机制。</p><p>vendor：将项目依赖包复制到项目下的vendor目录，在编译时使用项目下的vendor目录的包进行编译。</p><p>依然不能解决不同项目依赖不同包版本问题</p><p>包搜索顺序</p><ul><li>在当前包vendor目录查找</li><li>向上级目录查找，直到GOPATH/src/vendor目录</li><li>在GOPATH目录查找</li><li>在GOROOT目录查找标准库</li></ul><h4 id="Go-Modules"><a href="#Go-Modules" class="headerlink" title="Go Modules"></a>Go Modules</h4><p>Go Modules是从Go 1.11版本引入，到1.13版本之后已经成熟，Go Modules成为官方的依赖包管理解决方案。</p><p>优势：</p><ul><li>不受GOPATH限制，代码可放在任意目录</li><li>自动管理和<strong>下载</strong>依赖，且可以控制使用版本</li><li>不允许使用相对导入</li></ul><h4 id="GO111MODULE配置"><a href="#GO111MODULE配置" class="headerlink" title="GO111MODULE配置"></a>GO111MODULE配置</h4><p>GO111MODULE控制Go Module模式是否开启，有off、on、auto（默认）三个值，auto是默认值。</p><ul><li>GO111MODULE=on ，支持模块，Go会忽略GOPATH和vendor目录，只根据go.mod下载依赖，在<strong>$GOPATH/pkg/mod</strong>目录搜索依赖包。<ul><li>Go 1.13后默认开启</li><li>目前开发已经使用了1.17+版本，可以不配置，默认直接开启</li></ul></li><li>GO111MODULE=off ，不支持模块，Go会从GOPATH和vendor目录寻找包</li><li>GO111MODULE=auto ，在 $GOPATH/src 外面构建项目且根目录有go.mod文件时，开启模块支持。否则使用GOPATH和vendor机制</li></ul><p>GOPROXY环境变量可以指定包下载镜像</p><ul><li>GOPROXY=<a href="https://goproxy.cn,direct" target="_blank" rel="noopener">https://goproxy.cn,direct</a></li><li>GOPROXY=<a href="https://mirrors.aliyun.com/goproxy/" target="_blank" rel="noopener">https://mirrors.aliyun.com/goproxy/</a></li><li>GOPROXY=<a href="https://mirrors.cloud.tencent.com/go/" target="_blank" rel="noopener">https://mirrors.cloud.tencent.com/go/</a></li><li>GOPROXY=<a href="https://repo.huaweicloud.com/repository/goproxy/" target="_blank" rel="noopener">https://repo.huaweicloud.com/repository/goproxy/</a></li></ul><h3 id="Module模式"><a href="#Module模式" class="headerlink" title="Module模式"></a>Module模式</h3><h4 id="go-mod命令"><a href="#go-mod命令" class="headerlink" title="go mod命令"></a>go mod命令</h4><p>在Go 1.11开始引入，可以在任何目录使用go.mod创建项目</p><ul><li>init 当前文件夹下初始化一个新的module, 创建go.mod文件</li><li>tidy 自动分析依赖，下载缺失的模块，移除未使用的模块，并更新go.mod文件</li></ul><h4 id="构建Module模式项目"><a href="#构建Module模式项目" class="headerlink" title="构建Module模式项目"></a>构建Module模式项目</h4><p>构建项目根目录magtools，并初始化模块 go mod init gitee.com/tools ，会产生go.mod文件，内容如下</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">module gitee.com/tools</span><br><span class="line"><span class="keyword">go</span> <span class="number">1.19</span></span><br></pre></td></tr></tbody></table></figure><ul><li>module 指定模块名称</li><li>go 指定当前模块使用的Go版本</li></ul><p>根目录下新建main.go，内容如下</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">     fmt.Println(<span class="string">"hello gitee.com"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>package 指定包名，同一个目录包名必须相同</li><li>import 导入包。这里是绝对导入，且fmt是标准库中的包<ul><li>标准库搜索 $GOROOT/src</li></ul></li><li>main函数，必须在main包中，且只能有一个main函数。如果要编译成可执行文件，必须要有main函数</li></ul><h4 id="导入子包"><a href="#导入子包" class="headerlink" title="导入子包"></a>导入子包</h4><p>构建本地子包calc，其下创建calc.go</p><p>初始化新包/子包，可以不初始化</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> work init ./mod</span><br></pre></td></tr></tbody></table></figure><p>使用子包</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> calc</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Add首字母大写导出</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> {</span><br><span class="line">fmt.Printf(<span class="string">"x and y in calc.Add: %d, %d\n"</span>, x, y)</span><br><span class="line"><span class="keyword">return</span> x + y</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如何在main.go中使用子包的函数Add呢？</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"./calc"</span> <span class="comment">// 相对导入，不推荐，会发生错误</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"gitee.com/go-study/xuexi/06mode/calc"</span> <span class="comment">// 正确，Local Package本地包需要使用Module名/子包路径</span></span><br><span class="line"><span class="comment">// 在VSCode中，代码中输入calc会有导入提示</span></span><br></pre></td></tr></tbody></table></figure><p>如果在calc下再创建minus/minus.go</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Minus</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Minus</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> {</span><br><span class="line">fmt.Printf(<span class="string">"x and y in minus.Minus: %d, %d\n"</span>, x, y)</span><br><span class="line"><span class="keyword">return</span> x - y</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>那么main.go中就要如下导入</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"gitee.com/go-study/xuexi/06mode/minus"</span></span><br><span class="line"><span class="string">"gitee.com/go-study/xuexi/06mode/calc"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">fmt.Println(calc.Add(<span class="number">1</span>, <span class="number">100</span>))</span><br><span class="line">fmt.Println(minus.Minus(<span class="number">22</span>, <span class="number">33</span>))</span><br><span class="line"><span class="comment">// fmt.Println(m.Minus(22, 33))</span></span><br><span class="line">fmt.Println(<span class="string">"hello gitee.com"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>项目目录结构</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">📦xuexi</span><br><span class="line">┣ 📂calc</span><br><span class="line">┃┗ 📜calc.go</span><br><span class="line">┃ 📂minus</span><br><span class="line">┃   ┗ 📜Minus.go</span><br><span class="line">┣ 📜go.mod</span><br><span class="line">┗ 📜main.go</span><br></pre></td></tr></tbody></table></figure><h4 id="import关键字"><a href="#import关键字" class="headerlink" title="import关键字"></a>import关键字</h4><p>1.绝对导入</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"gitee.com/go-study/xuexi/06mode/minus"</span></span><br><span class="line"><span class="string">"gitee.com/go-study/xuexi/06mode/calc"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line"><span class="comment">// 使用举例</span></span><br><span class="line">calc.Add(<span class="number">4</span>, <span class="number">10</span>)</span><br><span class="line">minus.Minus(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>2.别名导入</p><p>如果有两个导入的包冲突时，可以重命名包来避免冲突</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> m <span class="string">"gitee.com/go-study/xuexi/06mode/minus"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用举例</span></span><br><span class="line">m.Minus()</span><br></pre></td></tr></tbody></table></figure><p>3.相对导入</p><p>不建议使用</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"./calc"</span></span><br></pre></td></tr></tbody></table></figure><p>4.点导入</p><p>不推荐使用。</p><p>把包内所有导出成员直接导入到本地。很少使用，很有可能导入的标识符导致冲突。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> . <span class="string">"gitee.com/go-study/xuexi/06mode/minus"</span></span><br><span class="line"><span class="comment">// 使用举例</span></span><br><span class="line">Minus()</span><br></pre></td></tr></tbody></table></figure><p>go-staticcheck对于点导入会有警告， should not use dot imports (ST1001)go-staticcheck 。参看 should not use dot imports (ST1001)go-staticcheck。</p><p>5.匿名导入</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="string">"gitee.com/go-study/xuexi/06mode/minus"</span></span><br></pre></td></tr></tbody></table></figure><p>使用下划线作为别名，就意味着无法使用了，那其目的何在？</p><p>这种情况下，只能执行导入的包内的所有init函数了。主要作用是做包的初始化用。</p><p><strong>导入本地其它项目</strong></p><p>把calc包挪到本地其它目录中，如何导入呢？例如把calc包挪到o:/calc，同时在calc目录使用 go mod</p><p>init ccc ，打开<strong>增加的go.mod</strong>，内容如下</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">module ccc</span><br><span class="line"><span class="keyword">go</span> <span class="number">1.19</span></span><br></pre></td></tr></tbody></table></figure><p>main.go中的导入和使用，如下</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">"fmt"</span><br><span class="line">c "tools/ttt" // 故意随便写了一个包路径</span><br><span class="line"></span><br><span class="line">// 由于包路径的最后一段是ttt，而calc/calc.go里面是package calc，路径和包名不一样，所以要用别名</span><br><span class="line">"tools/ttt/minus" // 上面的子包</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">fmt.Println(c.Add(111, 1000))</span><br><span class="line">fmt.Println(minus.Minus(200, 300))</span><br><span class="line">fmt.Println("hello gitee.com")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>还需要手动在go.mod中增加</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">module gitee.com/tools</span><br><span class="line"><span class="keyword">go</span> <span class="number">1.19</span></span><br><span class="line">require (</span><br><span class="line"> &nbsp; &nbsp;tools/ttt v0<span class="number">.0</span><span class="number">.0</span> <span class="comment">// 指定伪版本号，满足格式要求</span></span><br><span class="line">)</span><br><span class="line">replace &nbsp;tools/ttt =&gt; <span class="string">"o:/calc"</span> <span class="comment">// replace指令指定包搜索路径，而不是去GOPATH/pkg/mod</span></span><br></pre></td></tr></tbody></table></figure><p>参考 <a href="https://golang.google.cn/ref/mod#go-mod-file-require" target="_blank" rel="noopener">https://golang.google.cn/ref/mod#go-mod-file-require</a></p><p>require：用于设置一个特定的模块版本<br>indirect：该注释表示该模块为间接依赖，也就是在当前应用程序中的 import 语句中，并没有发现这个模块的明确引用，有可能是你先手动 go get 拉取下来的，也有可能是你所依赖的模块所依赖的<br>exclue：用于从使用中排除一个特定的模块版本<br>replace：用于将一个模块版本替换为另外一个模块版本</p><h4 id="导入第三方包"><a href="#导入第三方包" class="headerlink" title="导入第三方包"></a>导入第三方包</h4><p>在 <a href="https://pkg.go.dev/" target="_blank" rel="noopener">https://pkg.go.dev/</a> 查找包Beego</p><p>下载</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> get -u github.com/astaxie/beego</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> mod tidy</span><br></pre></td></tr></tbody></table></figure><p>main.go</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">c <span class="string">"tools/ttt"</span> <span class="comment">// 故意随便写了一个包路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于包路径的最后一段是ttt，而calc/calc.go里面是package calc，这里要用别名</span></span><br><span class="line"><span class="string">"tools/ttt/minus"</span> <span class="comment">// 上面的子包</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/astaxie/beego"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">fmt.Println(c.Add(<span class="number">111</span>, <span class="number">1000</span>))</span><br><span class="line">fmt.Println(minus.Minus(<span class="number">200</span>, <span class="number">300</span>))</span><br><span class="line">fmt.Println(<span class="string">"hello gitee.com"</span>)</span><br><span class="line">beego.Run()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>第三方依赖包搜索 $GOPATH/pkg/mod</p><p>go.mod中</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">require github.com/astaxie/beego v1<span class="number">.12</span><span class="number">.3</span></span><br><span class="line">省略很多的间接依赖</span><br></pre></td></tr></tbody></table></figure><p>拉取模块依赖后，会发现多出了一个 go.sum 文件，其详细罗列了当前项目直接或间接依赖的所有模块版本，并写明了那些模块版本的 SHA-256 哈希值以备 Go 在今后的操作中保证项目所依赖的那些模块版本不会被篡改。</p><p>go.mod 加载外部包</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">require (</span><br><span class="line">github.com/mattn/<span class="keyword">go</span>-colorable v0<span class="number">.1</span><span class="number">.13</span> <span class="comment">// indirect</span></span><br><span class="line">github.com/mattn/<span class="keyword">go</span>-isatty v0<span class="number">.0</span><span class="number">.17</span> <span class="comment">// indirect</span></span><br><span class="line">github.com/rs/zerolog v1<span class="number">.29</span><span class="number">.0</span> <span class="comment">// indirect</span></span><br><span class="line">golang.org/x/sys v0<span class="number">.5</span><span class="number">.0</span> <span class="comment">// indirect</span></span><br><span class="line">    mode v0<span class="number">.0</span><span class="number">.0</span></span><br><span class="line">)</span><br><span class="line">replace mode =&gt; <span class="string">"E:/aaa/Go/GO学习/学习代码/mode/Minus"</span></span><br></pre></td></tr></tbody></table></figure><h3 id="int函数"><a href="#int函数" class="headerlink" title="int函数"></a>int函数</h3><ul><li>init函数，无参无返回值，不能被其他函数调用</li><li>包中的init函数将在main函数之前自动执行</li><li>每个包中init函数可以有多个，且可以位于不同的文件中</li><li>一个文件中至多有一个init函数</li><li>同一个包中的init函数没有明确的执行顺序，不可预期</li><li>不同包的init函数的执行顺序由导入顺序决定</li></ul><p>init函数主要是做一些初始化工作。但是由于同一个包里面init函数执行顺序不可预期，所以，除非有必要，不要在同一个包里面定义多个init。init和main函数不一定在同一个文件中。</p><p>import _ “xxx” 作用是什么？只执行该包的init函数，无法使用包内资源。</p><p>import “xxx” 作用是什么？也会执行该包的init函数，也可以使用包内资源。</p><!-- rebuild by neat --><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;模块化&quot;&gt;&lt;a href=&quot;#模块化&quot; class=&quot;headerlink&quot; title=&quot;模块化&quot;&gt;&lt;/a&gt;模块化&lt;/h2&gt;&lt;p&gt;用任何语言来开发，如果软件规模扩大，会编写大量的函数、结构体、接口等代码。这些代码不可能写在一个文件中，这就会产生大量的文件。如果这
      
    
    </summary>
    
    
      <category term="Go" scheme="http://chenzhonzhou.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="http://chenzhonzhou.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go 语言中常用的占位符</title>
    <link href="http://chenzhonzhou.github.io/2023/03/02/go-yu-yan-zhong-chang-yong-de-zhan-wei-fu/"/>
    <id>http://chenzhonzhou.github.io/2023/03/02/go-yu-yan-zhong-chang-yong-de-zhan-wei-fu/</id>
    <published>2023-03-02T03:01:27.000Z</published>
    <updated>2023-12-02T03:02:12.282Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>什么是占位符？你就从表面意思理解，就是占位置，只不过有很多不同种类的位置，而且这个位置不是谁都能坐，是有要求的，在程序层面用于格式化数据。</p><h3 id="哪些函数支持"><a href="#哪些函数支持" class="headerlink" title="哪些函数支持"></a>哪些函数支持</h3><p>在 Go 语言中，标准包 fmt 有好多格式化的工具函数，函数名末尾通常以 f 结尾，列举如下：</p><ul><li>fmt.Printf 格式化字符串并打印到终端（标准输出）。</li><li>fmt.Sprintf 格式化字符串并返回。</li><li>fmt.Sscanf 从字符串中解析占位符的对应位置数据。</li><li>fmt.Fscanf 从 io.Reader 类型中读取数据并解析占位符的对应位置数据，用于读取文件、终端（标准输入）。</li><li>fmt.Fprintf 将格式化的字符串数据输出到 io.Writer 类型中，用于输出到文件。</li><li>fmt.Errorf 格式化方式创建一个错误类型消息。</li></ul><p>这块没有重点展开讲解各个函数，只是简单罗列下，如果还不明白自行查一下。</p><p>下来看看本篇的重点…</p><h3 id="占位符使用"><a href="#占位符使用" class="headerlink" title="占位符使用"></a>占位符使用</h3><p>占位符需要使用 % 符号表示，简单展示一个。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s := fmt.Sprintf(<span class="string">"%s学习"</span>, <span class="string">"努力"</span>)</span><br><span class="line">fmt.Println(s)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">努力学习</span><br></pre></td></tr></tbody></table></figure><p>%s 标示字符串，将”努力”字符串填充到%s 位置。下来看看到底有哪些占位符？</p><h4 id="普通占位符"><a href="#普通占位符" class="headerlink" title="普通占位符"></a>普通占位符</h4><p>先创建一个数据，作为打印的对象。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Example <span class="keyword">struct</span> {</span><br><span class="line">    Content <span class="keyword">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> data = Example{Content: <span class="string">"例子"</span>}</span><br></pre></td></tr></tbody></table></figure><p>1、%v、%+v、%#v<br>%v：获取数据的值，如果实现了error 接口，仅表示错误消息。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"%v"</span>, data) </span><br><span class="line"><span class="comment">// 输出 </span></span><br><span class="line">{例子}</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"%v"</span>, errors.New(<span class="string">"我错了"</span>))</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">我错了</span><br></pre></td></tr></tbody></table></figure><p>%+v：获取数据的值，如果结构体，会携带字段名。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"%+v"</span>, data)</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">{Content:例子}</span><br></pre></td></tr></tbody></table></figure><p>%#v：获取数据的值，如果是结构体，会携带结构体名和字段名。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"%#v"</span>, data)</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">main.Example{Content:<span class="string">"例子"</span>}</span><br></pre></td></tr></tbody></table></figure><p>2、%T<br>获取数据类型。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"%T"</span>, data)</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">main.Example</span><br></pre></td></tr></tbody></table></figure><p>3、%%<br>字面上的一个百分号。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"%%"</span>)</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">%</span><br></pre></td></tr></tbody></table></figure><p>布尔占位符<br>%t<br>true 或 false。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"%t"</span>, <span class="literal">true</span>)</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></tbody></table></figure><h4 id="整数占位符"><a href="#整数占位符" class="headerlink" title="整数占位符"></a>整数占位符</h4><p>1、%b<br>二进制。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"%b"</span>, <span class="number">4</span>)</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></tbody></table></figure><p>2、%c</p><p>Unicode 码转字符。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"%c"</span>, <span class="number">0x82d7</span>)</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">苗</span><br></pre></td></tr></tbody></table></figure><p>3、%d、%5d、%-5d、%05d<br>十进制整数表示。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"%d,%d,%d"</span>, <span class="number">10</span>, <span class="number">010</span>, <span class="number">0x10</span>)</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="number">10</span>,<span class="number">8</span>,<span class="number">16</span></span><br></pre></td></tr></tbody></table></figure><p>三个数据： 10 十进制，010 八进制，0x10 十六进制</p><p>占位符还可以指定最小宽度，格式如下：</p><ul><li>%5d：最小宽度为 5，右对齐，左边留白。</li><li>%-5d：左对齐，右边留白。</li><li>%05d：数字位数不足 5 位时，左边补零。</li></ul><p>例：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"|%5d|%-5d|%05d|"</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">|    <span class="number">1</span>|<span class="number">1</span>    |<span class="number">00001</span>|</span><br></pre></td></tr></tbody></table></figure><p>4、%o、%#o<br>八进制表示。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"%o,%o,%o"</span>, <span class="number">10</span>, <span class="number">010</span>, <span class="number">0x10</span>)</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="number">12</span>,<span class="number">10</span>,<span class="number">20</span></span><br></pre></td></tr></tbody></table></figure><p>在很多开发语言中，0 打头的数字都表示八进制。通过 %#o 输出带 0 开头。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"\n%#o\n"</span>, <span class="number">10</span>)</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="number">012</span></span><br></pre></td></tr></tbody></table></figure><p>5、%q<br>同 %c 类似，都是Unicode 码转字符，只是结果多了单引号。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"%q"</span>, <span class="number">0x82d7</span>)</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="string">'苗'</span></span><br></pre></td></tr></tbody></table></figure><p>汉字对应表：<a href="http://www.chi2ko.com/tool/CJK.htm" target="_blank" rel="noopener">字体编辑用中日韩汉字Unicode编码表 - 编著：中韩翻译网 金圣镇</a></p><p>6、%x、%#x<br>十六进制表示，字母形式为小写 a-f，%#x 输出带 0x 开头。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"%x, %#x"</span>, <span class="number">13</span>, <span class="number">13</span>)</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">d, <span class="number">0xd</span></span><br></pre></td></tr></tbody></table></figure><p>7、%X、%#X<br>十六进制表示，字母形式为小写 A-F，%#X 输出带 0X 开头。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"%X, %#X"</span>, <span class="number">13</span>, <span class="number">13</span>)</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">D, <span class="number">0XD</span></span><br></pre></td></tr></tbody></table></figure><p>8、%U、%#U<br>%U：转化为 Unicode 格式规范。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"%U"</span>, <span class="number">0x82d7</span>)</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">U+<span class="number">82</span>D7</span><br></pre></td></tr></tbody></table></figure><p>%#U：转化为 Unicode 格式并带上对应的字符。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"%#U"</span>, <span class="number">0x82d7</span>)</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">U+<span class="number">82</span>D7 <span class="string">'苗'</span></span><br></pre></td></tr></tbody></table></figure><h4 id="浮点数与复数"><a href="#浮点数与复数" class="headerlink" title="浮点数与复数"></a>浮点数与复数</h4><p>1、%b<br>浮点数转化为 2 的幂的科学计数法。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"%b"</span>, <span class="number">0.1</span>)</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="number">7205759403792794</span>p<span class="number">-56</span></span><br></pre></td></tr></tbody></table></figure><p>2、%e、%E<br>10 的幂的科学计数法。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"%e"</span>, <span class="number">10.2</span>)</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="number">1.020000e+01</span></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"%E"</span>, <span class="number">10.2</span>)</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="number">1.020000E+01</span></span><br></pre></td></tr></tbody></table></figure><p>区别：%e 与 %E 输出时的大小写之分。</p><p>3、%f、%.2f 等等<br>浮点数，%.2f 表示保留 2 位小数，%f 默认保留 6 位，%f 与 %F 等价。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"%f"</span>, <span class="number">10.2</span>)</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="number">10.200000</span></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"%.2f|%.2f"</span>, <span class="number">10.232</span>, <span class="number">10.235</span>)</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="number">10.23</span>|<span class="number">10.23</span></span><br></pre></td></tr></tbody></table></figure><p>也可以加入最小宽度，如下：</p><ul><li>%9.2f 宽度最小为 9，包含小数位在内，精度为 2。</li><li>%9.f 或 %9f 宽度最小为 9。</li></ul><p>4、%g、%.3g<br>根据情况选择 %e 或 %f ，但末尾去除 0。</p><p>%f 情况如下：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"%g|%g"</span>, <span class="number">10.20</span>, <span class="number">1.200000</span>+<span class="number">3.400000i</span>)</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="number">10.2</span>|(<span class="number">1.2</span>+<span class="number">3.4i</span>)</span><br></pre></td></tr></tbody></table></figure><p>%e 情况如下：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"%g|%g"</span>, <span class="number">2e2</span>, <span class="number">2E2</span>)</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="number">200</span>|<span class="number">200</span></span><br></pre></td></tr></tbody></table></figure><p>%.3g 表示的不是小数保留 3 位，而是只保留 3 个数字。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"%.3g"</span>, <span class="number">12.34</span>)</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="number">12.3</span></span><br></pre></td></tr></tbody></table></figure><p>思考：官网中 %g 和 %G 是有区别的，但我测试下来是等价的，可能我的测试有问题，我给出官网文档，如下：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%g    %e <span class="keyword">for</span> large exponents, %f otherwise. Precision is discussed below.</span><br><span class="line">%G    %E <span class="keyword">for</span> large exponents, %F otherwise</span><br></pre></td></tr></tbody></table></figure><h4 id="字符串与字节切片"><a href="#字符串与字节切片" class="headerlink" title="字符串与字节切片"></a>字符串与字节切片</h4><p>1、%s<br>字符串或字节切片。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"%s|%s"</span>, <span class="string">"好好"</span>, []<span class="keyword">byte</span>(<span class="string">"学习"</span>))</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">好好|学习</span><br></pre></td></tr></tbody></table></figure><p>2、%q<br>有 Go 语言安全转义，双引号包裹。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"%q"</span>, <span class="string">"学习"</span>)</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="string">"学习"</span></span><br></pre></td></tr></tbody></table></figure><p>3、%x、%X<br>十六进制，%x 小写字母 a - f，%X 大写字母 A - F。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"%x|%X"</span>, <span class="string">"苗"</span>, <span class="string">"苗"</span>)</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">e88b97|E88B97</span><br></pre></td></tr></tbody></table></figure><h4 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h4><p>%p、%#p<br>地址，使用十六进制表示，%p 带 0x，%#p 不带。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">num := <span class="number">2</span></span><br><span class="line">s := []<span class="keyword">int</span>{<span class="number">1</span>, <span class="number">2</span>}</span><br><span class="line">fmt.Printf(<span class="string">"%p|%p"</span>, &amp;num, s)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="number">0xc00000a1d0</span>|<span class="number">0xc00000a1e0</span></span><br></pre></td></tr></tbody></table></figure><h4 id="其它标记"><a href="#其它标记" class="headerlink" title="其它标记"></a>其它标记</h4><p>1、+<br>打印数值的正负号，对于 %+q，只输出 ASCII 编码的字符，如果非 ASCII 编码，则转成 Unicode 编码输出。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"%+d|%+d"</span>, <span class="number">2</span>, <span class="number">-2</span>)</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">+<span class="number">2</span>|<span class="number">-2</span></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"%+q|%+q"</span>, <span class="string">"miao"</span>,<span class="string">"苗"</span>)</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="string">"miao"</span>|<span class="string">"\u82d7"</span></span><br></pre></td></tr></tbody></table></figure><p>2、-<br>在右侧填充空格，这块就不举例了，使用如 %-5d ，浮点%-9.2f 也支持，其它占位符大家可以有兴趣自行实验。</p><p>3、</p><ul><li>为八进制添加前导 0，上面已举例。</li><li>为十六进制添加前导 0x 或 0X，上面已举例。</li><li>为 %#p去掉 0x。</li><li>%+q 打印字符串时使用反引号包裹。</li></ul><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"%#q"</span>, <span class="string">"苗"</span>)</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="string">`苗`</span></span><br></pre></td></tr></tbody></table></figure><ul><li>%#U 打印编码时，带上字符，上面已举例。</li></ul><p>4、’ ‘ 空格<br>为正负号留出空白位置。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"|% d|"</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">| <span class="number">2</span>|</span><br></pre></td></tr></tbody></table></figure><p>5、0<br>填充前导的 0，对于数字会移到正负号之后，非数字也可使用。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"%05s"</span>, <span class="string">"a"</span>)</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="number">0000</span>a</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"%+05d"</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">+<span class="number">0001</span></span><br></pre></td></tr></tbody></table></figure><p>精度截断字符串<br>给字符串使用精度，用来截断字符串。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"%.2s"</span>, <span class="string">"abc"</span>)</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">ab</span><br></pre></td></tr></tbody></table></figure><p>总结<br>占位符区分大小写，总共讲了 20 个，但占位符相关的知识点其实还有，我暂时也不想研究了，因为在项目中也很难使用到。</p><!-- rebuild by neat --><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;什么是占位符？你就从表面意思理解，就是占位置，只不过有很多不同种类的位置，而且这个位置不是谁都能坐，是有要求的，在程序层面用于格式化数据。&lt;
      
    
    </summary>
    
    
      <category term="Go" scheme="http://chenzhonzhou.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="http://chenzhonzhou.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go init函数执行顺序</title>
    <link href="http://chenzhonzhou.github.io/2023/02/26/go-init-han-shu-zhi-xing-shun-xu/"/>
    <id>http://chenzhonzhou.github.io/2023/02/26/go-init-han-shu-zhi-xing-shun-xu/</id>
    <published>2023-02-26T13:05:45.000Z</published>
    <updated>2023-12-03T05:30:31.531Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、init-函数简介"><a href="#一、init-函数简介" class="headerlink" title="一、init 函数简介"></a>一、init 函数简介</h3><p>Golang init 函数是一种特殊的函数，主要用于完成程序的初始化工作，如初始化数据库的连接、载入本地配置文件、根据命令行参数初始化全局变量等。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"flag"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gopath <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> {</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"init a"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> {</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"init b"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> {</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"init c"</span>)</span><br><span class="line"><span class="comment">// gopath may be overridden by --gopath flag on command line.</span></span><br><span class="line">flag.StringVar(&amp;gopath, <span class="string">"gopath"</span>, <span class="string">"/root/go"</span>, <span class="string">"override default GOPATH"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"main"</span>)</span><br><span class="line">flag.Parse()</span><br><span class="line"><span class="built_in">println</span>(gopath)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行输出：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> run main.<span class="keyword">go</span> --gopath=<span class="string">"/home/alice/go"</span></span><br><span class="line">init a</span><br><span class="line">init b</span><br><span class="line">init c</span><br><span class="line">main</span><br><span class="line">/home/alice/<span class="keyword">go</span></span><br></pre></td></tr></tbody></table></figure><p>之所以特殊，是因为 init 函数有如下特点：</p><ul><li>init 函数是可选的，可以没有；</li><li>与 main 函数一样，不能有入参与返回值；</li><li>与 main 函数一样，init 会自动执行，不能被其他函数调用；</li><li>一个包内可以有多个 init 函数，即可以在包的多个源文件中定义多个 init 函数。一般建议在与包同名源文件中写一个 init 函数，这样可读性好且便于维护；</li><li>一个源文件可以有多个 init 函数。</li></ul><h3 id="二、执行顺序"><a href="#二、执行顺序" class="headerlink" title="二、执行顺序"></a>二、执行顺序</h3><p>既然一个程序可以有多个 init 函数，那么对于位于不同包、不同源文件中的多个 init 函数，其执行顺序是怎样的呢？</p><p>不同包的 init 函数与包级变量的初始化顺序如下图所示。</p><p><img src="/2023/02/26/go-init-han-shu-zhi-xing-shun-xu/%E5%9B%BE%E7%89%871.png" alt="图片"></p><p>下面从多个方面去考察。</p><h4 id="2-1-单个源文件的-init-执行顺序"><a href="#2-1-单个源文件的-init-执行顺序" class="headerlink" title="2.1 单个源文件的 init 执行顺序"></a>2.1 单个源文件的 init 执行顺序</h4><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> {</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"init a"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> {</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"init b"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> {</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"init c"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"main"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行输出：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go run main.go</span></span><br><span class="line">init a</span><br><span class="line">init b</span><br><span class="line">init c</span><br><span class="line">main</span><br></pre></td></tr></tbody></table></figure><p>结论： 同一个源文件的 init 函数执行顺序与其定义顺序一致，从上到下。</p><h4 id="2-2-单个包的-init-执行顺序"><a href="#2-2-单个包的-init-执行顺序" class="headerlink" title="2.2 单个包的 init 执行顺序"></a>2.2 单个包的 init 执行顺序</h4><p>假设 main 包有三个源文件 a.go，b.go 和 c.go。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> {</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"init a"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> {</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"init b"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// c.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> {</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"init c"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> {</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"init main"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"main"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>编译运行输出：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go build &amp;&amp; ./main</span></span><br><span class="line">init a</span><br><span class="line">init b</span><br><span class="line">init c</span><br><span class="line">init main</span><br><span class="line">main</span><br></pre></td></tr></tbody></table></figure><p>结论： 同一个包中不同源文件 init 函数的执行顺序，是根据文件名的字典序来确定。</p><h4 id="2-3-main-包导入多个包时-init-执行顺序"><a href="#2-3-main-包导入多个包时-init-执行顺序" class="headerlink" title="2.3 main 包导入多个包时 init 执行顺序"></a>2.3 main 包导入多个包时 init 执行顺序</h4><h5 id="2-3-1-不存在依赖"><a href="#2-3-1-不存在依赖" class="headerlink" title="2.3.1 不存在依赖"></a>2.3.1 不存在依赖</h5><p>对于不同的包，如果不相互依赖的话，在 main 包中被 import，那么这种情况下，各个包的 init 执行顺序是怎样的呢？</p><p>假设有包 a，b 和 c，在 main.go 中被 import。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a 包</span></span><br><span class="line"><span class="comment">// a.go</span></span><br><span class="line"><span class="keyword">package</span> a</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> {</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"init a"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// b 包</span></span><br><span class="line"><span class="comment">// b.go</span></span><br><span class="line"><span class="keyword">package</span> b</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> {</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"init b"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// c 包</span></span><br><span class="line"><span class="comment">// c.go</span></span><br><span class="line"><span class="keyword">package</span> c</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> {</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"init c"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// main 包</span></span><br><span class="line"><span class="comment">// main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">_ <span class="string">"main/a"</span></span><br><span class="line">_ <span class="string">"main/b"</span></span><br><span class="line">_ <span class="string">"main/c"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> {</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"init main"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"main"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>编译运行输出：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go build &amp;&amp; ./main</span></span><br><span class="line">init a</span><br><span class="line">init b</span><br><span class="line">init c</span><br><span class="line">init main</span><br><span class="line">main</span><br></pre></td></tr></tbody></table></figure><p>结论： 对于不同的包，如果不相互依赖的话，按照 main 包中导入顺序调用包的 init 函数，最后再调用 main 包的 init 函数。</p><h5 id="2-3-2-存在依赖"><a href="#2-3-2-存在依赖" class="headerlink" title="2.3.2 存在依赖"></a>2.3.2 存在依赖</h5><p>对于不同的包，如果存在依赖关系的话，在 main 包中被 import，那么这种情况下，各个包的 init 执行顺序是怎样的呢？</p><p>假设有包 a，b 和 c，main 包 import a 包，a import b，b import c，即依赖关系为 main &gt; a &gt; b &gt; c。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a 包</span></span><br><span class="line"><span class="comment">// a.go</span></span><br><span class="line"><span class="keyword">package</span> a</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> _ <span class="string">"main/b"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> {</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"init a"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// b 包</span></span><br><span class="line"><span class="comment">// b.go</span></span><br><span class="line"><span class="keyword">package</span> b</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> _ <span class="string">"main/c"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> {</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"init b"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// c 包</span></span><br><span class="line"><span class="comment">// c.go</span></span><br><span class="line"><span class="keyword">package</span> c</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> {</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"init c"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// main 包</span></span><br><span class="line"><span class="comment">// main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">_ <span class="string">"main/a"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> {</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"init main"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"main"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>编译运行输出：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go build &amp;&amp; ./main</span></span><br><span class="line">init c</span><br><span class="line">init b</span><br><span class="line">init a</span><br><span class="line">init main</span><br><span class="line">main</span><br></pre></td></tr></tbody></table></figure><p>结论: 如果 package 存在依赖，不同包的 init 函数按照包导入的依赖关系决定执行顺序。 调用顺序为最后被依赖的最先被初始化，如导入顺序 main &gt; a &gt; b &gt; c，则初始化顺序为 c &gt; b &gt; a &gt; main，依次执行对应的 init 方法。</p><h4 id="2-4-包级变量初始化与-init-函数执行顺序"><a href="#2-4-包级变量初始化与-init-函数执行顺序" class="headerlink" title="2.4 包级变量初始化与 init 函数执行顺序"></a>2.4 包级变量初始化与 init 函数执行顺序</h4><p>如果包中存在包级变量，那么其初始化与 init 函数执行先后顺序如何呢？</p><p>还是假设有包 a，b 和 c，main 包 import a 包，a import b，b import c，即依赖关系为 main &gt; a &gt; b &gt; c。且每个包都有一个包级变量，并通过函数完成其初始化。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a 包</span></span><br><span class="line"><span class="comment">// a.go</span></span><br><span class="line"><span class="keyword">package</span> a</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> _ <span class="string">"main/b"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> A = <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">string</span></span> {</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"init var A"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="string">"A"</span></span><br><span class="line">}()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> {</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"init a"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// b 包</span></span><br><span class="line"><span class="comment">// b.go</span></span><br><span class="line"><span class="keyword">package</span> b</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> _ <span class="string">"main/c"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> B = <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">string</span></span> {</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"init var B"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="string">"B"</span></span><br><span class="line">}()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> {</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"init b"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// c 包</span></span><br><span class="line"><span class="comment">// c.go</span></span><br><span class="line"><span class="keyword">package</span> c</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> C = <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">string</span></span> {</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"init var C"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="string">"C"</span></span><br><span class="line">}()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> {</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"init c"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// main 包</span></span><br><span class="line"><span class="comment">// main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">_ <span class="string">"main/a"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m = <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">string</span></span> {</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"init var m"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="string">"m"</span></span><br><span class="line">}()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> {</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"init main"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"main"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>编译运行输出：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go build &amp;&amp; ./main</span></span><br><span class="line">init var C</span><br><span class="line">init c</span><br><span class="line">init var B</span><br><span class="line">init b</span><br><span class="line">init var A</span><br><span class="line">init a</span><br><span class="line">init var m</span><br><span class="line">init main</span><br><span class="line">main</span><br></pre></td></tr></tbody></table></figure><p>结论: 可见包级变量是在 init 函数之前完成初始化。</p><h3 id="三、小结"><a href="#三、小结" class="headerlink" title="三、小结"></a>三、小结</h3><p>Golang 中的 init 是一种特殊的函数，主要用于完成程序的初始化工作。其特点有：</p><ul><li>init 函数是可选的，可以没有；</li><li>与 main 函数一样，不能有入参与返回值；</li><li>与 main 函数一样，init 会自动执行，不能被其他函数调用；</li><li>一个包内可以有多个 init 函数，即可以在包的多个源文件中定义多个 init 函数。一般建议在与包同名源文件中写一个 init 函数，这样可读性好且便于维护；</li><li>一个源文件可以有多个 init 函数。</li></ul><p>程序中如果在不同包的不同源文件有多个 init 函数时，其执行顺序可概述为：</p><ul><li>同一个源文件的 init 函数执行顺序与其定义顺序一致，从上到下；</li><li>同一个包中不同文件的 init 函数的执行顺序按照文件名的字典序；</li><li>对于不同的包，如果不相互依赖的话，按照 main 包中 import 的顺序调用其包中的 init 函数；</li><li>如果包存在依赖，不同包的 init 函数按照包导入的依赖关系决定执行顺序。 调用顺序为最后被依赖的最先被初始化，如导入顺序 main &gt; a &gt; b &gt; c，则初始化顺序为 c &gt; b &gt; a &gt; main，依次执行对应的 init 方法；</li><li>如果包存在包级变量，则先于包的 init 函数完成初始化。</li></ul><p>程序的初始化和执行都起始于 main 包。如果 main 包还导入了其它的包，那么就会在编译时将它们依次导入。有时一个包会被多个包同时导入，那么它只会被导入一次（例如很多包可能都会用到 fmt 包，但它只会被导入一次，因为没有必要导入多次）。</p><p>当一个包被导入时，如果该包还导入了其它的包，那么会先将其它包导入进来，然后再对这些包中的包级常量和变量进行初始化，接着执行 init 函数，依次类推。</p><p>请务必铭记于心，虽然 init() 顺序是明确的，但代码可以更改，init() 函数之间的关系可能会使代码变得脆弱和容易出错，因此在编码时避免依赖 init() 函数的执行顺序。</p><!-- rebuild by neat --><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、init-函数简介&quot;&gt;&lt;a href=&quot;#一、init-函数简介&quot; class=&quot;headerlink&quot; title=&quot;一、init 函数简介&quot;&gt;&lt;/a&gt;一、init 函数简介&lt;/h3&gt;&lt;p&gt;Golang init 函数是一种特殊的函数，主要用于完成程序的初始
      
    
    </summary>
    
    
      <category term="Go" scheme="http://chenzhonzhou.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="http://chenzhonzhou.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go 文件和目录操作</title>
    <link href="http://chenzhonzhou.github.io/2023/02/23/go-wen-jian-he-mu-lu-cao-zuo/"/>
    <id>http://chenzhonzhou.github.io/2023/02/23/go-wen-jian-he-mu-lu-cao-zuo/</id>
    <published>2023-02-23T02:59:44.000Z</published>
    <updated>2023-12-02T03:00:42.441Z</updated>
    
    <content type="html"><![CDATA[<h3 id="打开和关闭文件"><a href="#打开和关闭文件" class="headerlink" title="打开和关闭文件"></a>打开和关闭文件</h3><p><code>os.Open()</code>函数能够打开一个文件，返回一个<code>*File</code>文件指针和一个<code>err</code>。操作完成文件对象以后一定要记得关闭文件。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="comment">// 只读方式打开当前目录下的main.go文件</span></span><br><span class="line">file,err := os.Open(<span class="string">"./main.go"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">fmt.Println(<span class="string">"open file failed, err: "</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">}</span><br><span class="line">fmt.Println(file)<span class="comment">// &amp;{0xc000078780}</span></span><br><span class="line"><span class="keyword">defer</span> file.Close()<span class="comment">// 关闭文件</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>为了防止文件忘记关闭，我们通常使用defer注册文件关闭语句。</p><h3 id="file-Read-读取文件"><a href="#file-Read-读取文件" class="headerlink" title="file.Read() 读取文件"></a>file.Read() 读取文件</h3><p>基本使用<br>Read方法定义如下：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Read</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br></pre></td></tr></tbody></table></figure><p>它接收一个字节切片，返回读取的字节数和可能的具体错误，读到文件末尾时会返回0和io.EOF。举个例子：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"io"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="comment">// 只读方式打开当前目录下的main.go文件</span></span><br><span class="line">file,err := os.Open(<span class="string">"./main.go"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">fmt.Println(<span class="string">"open file failed!, err: "</span>,err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line"><span class="comment">// 使用Read方法读取数据，注意一次只会读取128个字节</span></span><br><span class="line"><span class="keyword">var</span> tmp = <span class="built_in">make</span>([]<span class="keyword">byte</span>,<span class="number">128</span>)</span><br><span class="line">n,err := file.Read(tmp)</span><br><span class="line"><span class="keyword">if</span> err == io.EOF {</span><br><span class="line">fmt.Println(<span class="string">"文件读完了"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">fmt.Println(<span class="string">"read file failed,err: "</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">}</span><br><span class="line">fmt.Printf(<span class="string">"读取了%d字节数据 \n"</span>, n)</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(tmp[:n]))读取数据从头切到n</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="循环读取"><a href="#循环读取" class="headerlink" title="循环读取"></a>循环读取</h3><p>使用for循环读取文件中的所有数据</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="comment">// 只读方式打开当前目录下的main.go文件</span></span><br><span class="line">file,err := os.Open(<span class="string">"./main.go"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">fmt.Println(<span class="string">"open file failed!, err: "</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line"><span class="comment">// 循环读取文件</span></span><br><span class="line"><span class="keyword">var</span> content []<span class="keyword">byte</span></span><br><span class="line"><span class="keyword">var</span> tmp = <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">128</span>)</span><br><span class="line"><span class="keyword">for</span> {</span><br><span class="line">n,err := file.Read(tmp)</span><br><span class="line"><span class="keyword">if</span> err == io.EOF {</span><br><span class="line">fmt.Println(<span class="string">"文件读完了"</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">fmt.Println(<span class="string">"read file failed, err: "</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">}</span><br><span class="line">content = <span class="built_in">append</span>(content, tmp[:n]...)</span><br><span class="line">}</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(content))</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="bufio读取文件"><a href="#bufio读取文件" class="headerlink" title="bufio读取文件"></a>bufio读取文件</h3><p>bufio是在file的基础上封装了一层API，支持更多的功能。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bufio"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"io"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// bufio 按行读取示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">file, err := os.Open(<span class="string">"C:/test.txt"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">fmt.Println(<span class="string">"open file failed, err: "</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line">reader := bufio.NewReader(file)</span><br><span class="line"><span class="keyword">for</span> {</span><br><span class="line">line, err := reader.ReadString(<span class="string">"\n"</span>)<span class="comment">// 注意是字符</span></span><br><span class="line"><span class="keyword">if</span> err == io.EOF {</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(line) != <span class="number">0</span> {</span><br><span class="line">fmt.Println(<span class="string">"还没有读完"</span>, line)</span><br><span class="line">}</span><br><span class="line">fmt.Println(<span class="string">"文件读完了"</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">fmt.Println(<span class="string">"read file failed, err: "</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">}</span><br><span class="line">fmt.Print(line)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="ioutil读取整个文件"><a href="#ioutil读取整个文件" class="headerlink" title="ioutil读取整个文件"></a>ioutil读取整个文件</h3><p>io/ioutil包的ReadFile方法能够读取完整的文件，只需要将文件名作为参数传入。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"io/ioutil"</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// ioutil.ReadFile 读取整个文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">content,err := ioutil.ReadFile(<span class="string">"./main.go"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">fmt.Println(<span class="string">"read file failed, err: "</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">}</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(content))<span class="comment">// 内容转换为字符串格式进行输出</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="文件写入操作"><a href="#文件写入操作" class="headerlink" title="文件写入操作"></a>文件写入操作</h3><p>os.OpenFile()函数能够以指定模式打开文件，从而实现文件写入相关功能。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OpenFile</span><span class="params">(name <span class="keyword">string</span>,flag <span class="keyword">int</span>, perm FileMode)</span> <span class="params">(*File, error)</span></span>{</span><br><span class="line">...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>其中：<br>name: 要打开的文件名<br>flag：打开文件的模式<br>模式有以下几种：<br>os.O_WRONLY 只写<br>os.O_CREATE 创建文件<br>os.O_RDONLY 只读<br>os.O_RDWR 读写<br>os.O_TRUNC 清空<br>os.O_APPEND 追加</p><p>perm：文件权限，一个八进制数。r 读 04, w 写 02, x 执行 01</p><h4 id="Write和WriteString"><a href="#Write和WriteString" class="headerlink" title="Write和WriteString"></a>Write和WriteString</h4><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">file, err := os.OpenFile(<span class="string">"C:/test.txt"</span>, os.O_CERATE|os.O_RDWR, <span class="number">0666</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">fmt.Println(<span class="string">"open file failed, err: "</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line">str := <span class="string">"你好golang"</span></span><br><span class="line">file.Write([]<span class="keyword">byte</span>(str))<span class="comment">// 写入字节切片数据</span></span><br><span class="line">file.WriteString(<span class="string">"直接写入的字符串数据"</span>)<span class="comment">// 直接写入字符串数据</span></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="bufio-NewWriter"><a href="#bufio-NewWriter" class="headerlink" title="bufio.NewWriter"></a>bufio.NewWriter</h4><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bufio"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">file,err := os.OpenFile(<span class="string">"C:/test.txt"</span>, os.O_CREATE|os.O_TRUNC|os.O_WRONLY,<span class="number">0666</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">fmt.Println(<span class="string">"open file failed, err: "</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line">writer := bufio.NewWriter(file)</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++ {</span><br><span class="line">writer.WriteString(<span class="string">"你好golang \r\n"</span>)<span class="comment">// 将数据先写入缓存</span></span><br><span class="line">}</span><br><span class="line">writer.Flush()<span class="comment">// 将缓存中的内容写入文件（注意）</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="ioutil-WriteFile"><a href="#ioutil-WriteFile" class="headerlink" title="ioutil.WriteFile"></a>ioutil.WriteFile</h4><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"io/ioutil"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">str := <span class="string">"hello golang"</span></span><br><span class="line">err := ioutil.WriteFile(<span class="string">"C:/test.txt"</span>, []<span class="keyword">byte</span>(str), <span class="number">0666</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">fmt.Println(<span class="string">"write file failed, err: "</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="文件重命名"><a href="#文件重命名" class="headerlink" title="文件重命名"></a>文件重命名</h3><p>注意：os.Rename()重命名操作，只能在同盘中进行使用</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">err := os.Rename(<span class="string">"C:/test.txt"</span>, <span class="string">"C:/test001.txt"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">fmt.Println(err)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="复制文件"><a href="#复制文件" class="headerlink" title="复制文件"></a>复制文件</h3><p>第一种复制文件的方法：通过 ioutil 进行复制</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"io/ioutil"</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 自己编写一个函数，接收两个文件路径 srcFileName 源文件名称dstFileName 目标文件名称</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CopyFile</span><span class="params">(dstFileName <span class="keyword">string</span>, srcFileName <span class="keyword">string</span>)</span> <span class="params">(err error)</span></span>{</span><br><span class="line">srcinput, err := ioutil.ReadFile(srcFileName)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span>  {</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span>err</span><br><span class="line">}</span><br><span class="line">err = ioutil.WriteFile(dstFileName, srcinput, <span class="number">0644</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">fmt.Println(<span class="string">"Error creating"</span>, dstFileName)</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">srcFile := <span class="string">"C:/test1.zip"</span></span><br><span class="line">dstFile := <span class="string">"D:/test.gz"</span></span><br><span class="line">err := CopyFile(dstFile, srcFile)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> {</span><br><span class="line">fmt.Printf(<span class="string">"拷贝完成 \n"</span>)</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">fmt.Printf(<span class="string">"拷贝错误 err=%v \n"</span>, err)</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>第二种复制文件方法流的方式复制：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"io"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 自己编写一个函数，接收两个文件路径 srcFileName 源文件名称dstFileName 目标文件名称</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CopyFile</span><span class="params">(dstFileName <span class="keyword">string</span>, srcFileName <span class="keyword">string</span>)</span><span class="params">(err error)</span></span>{</span><br><span class="line">source,_ := os.Open(srcFileName)</span><br><span class="line">destination,_ := os.OpenFile(dstFileName, os.O_CREATE|os.O_WRONLY, <span class="number">0666</span>)</span><br><span class="line">buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">128</span>)</span><br><span class="line"><span class="keyword">for</span> {</span><br><span class="line">n, err := source.Read(buf)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; err != io.EOF {</span><br><span class="line">fmt.Println(<span class="string">"文件没有读完"</span>)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> n == <span class="number">0</span> {</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> _,err := destination.Write(buf[:n]); err != <span class="literal">nil</span> {</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="comment">// 调用CopyFile完成文件拷贝</span></span><br><span class="line">srcFile := <span class="string">"C:/000.avi"</span></span><br><span class="line">dstFile := <span class="string">"D:/000111.avi"</span></span><br><span class="line">err := CopyFile(dstFile, srcFile)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> {</span><br><span class="line">fmt.Printf(<span class="string">"拷贝完成 \n"</span>)</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">fmt.Printf(<span class="string">"拷贝错误 err=%v \n"</span>, err)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h3><p>一次创建一个目录</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">err := os.Mkdir(<span class="string">"./adb"</span>,<span class="number">0666</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">fmt.Println(err)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>一次创建多个目录</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">err := os.MkdirAll(<span class="string">"dir1/dir2/dir3"</span>, <span class="number">0666</span>)<span class="comment">// 创建多级目录</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">fmt.Println(err)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="删除目录和文件"><a href="#删除目录和文件" class="headerlink" title="删除目录和文件"></a>删除目录和文件</h3><p>删除一个目录或者文件</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">err := os.Remove(<span class="string">"./main.go"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">fmt.Println(err)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>一次删除多个目录或者文件</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">err := os.RemoveAll(<span class="string">"aaa"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">fmt.Println(err)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><!-- rebuild by neat --><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;打开和关闭文件&quot;&gt;&lt;a href=&quot;#打开和关闭文件&quot; class=&quot;headerlink&quot; title=&quot;打开和关闭文件&quot;&gt;&lt;/a&gt;打开和关闭文件&lt;/h3&gt;&lt;p&gt;&lt;code&gt;os.Open()&lt;/code&gt;函数能够打开一个文件，返回一个&lt;code&gt;*File&lt;/
      
    
    </summary>
    
    
      <category term="Go" scheme="http://chenzhonzhou.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="http://chenzhonzhou.github.io/tags/Go/"/>
    
  </entry>
  
</feed>
