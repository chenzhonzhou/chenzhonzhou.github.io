<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>凡间的精灵</title>
  
  <subtitle>凡尘落素一精灵</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://chenzhonzhou.github.io/"/>
  <updated>2022-11-08T14:14:08.497Z</updated>
  <id>http://chenzhonzhou.github.io/</id>
  
  <author>
    <name>Zhongzhou Chen</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Go 结构体和流程控制</title>
    <link href="http://chenzhonzhou.github.io/2022/11/30/go-jie-gou-ti-he-liu-cheng-kong-zhi/"/>
    <id>http://chenzhonzhou.github.io/2022/11/30/go-jie-gou-ti-he-liu-cheng-kong-zhi/</id>
    <published>2022-11-30T14:13:09.000Z</published>
    <updated>2022-11-08T14:14:08.497Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Nov 08 2022 22:51:10 GMT+0800 (GMT+08:00) --><h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><p>和 Go 函数一样，if 语句的分支代码块的左大括号与 if 关键字在同一行上，这也是 Go 代码风格的统一要求，gofmt 工具会帮助我们实现这一点；</p><p>if 语句的布尔表达式整体不需要用括号包裹，一定程度上减少了开发人员敲击键盘的次数。而且，if 关键字后面的条件判断表达式的求值结果必须是布尔类型，即要么是 true，要么是 false。</p><h3 id="if-语句形式"><a href="#if-语句形式" class="headerlink" title="if 语句形式"></a>if 语句形式</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断两个数字大小</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="number">10</span></span><br><span class="line">b := <span class="number">15</span></span><br><span class="line"><span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">fmt.Printf(<span class="string">"a: %v\n"</span>, a)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"b: %v\n"</span>, b)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输入一个数，判断一个数是奇偶数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f2</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> num <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"请输入一个数字："</span>)</span><br><span class="line">fmt.Scan(&amp;num)</span><br><span class="line"><span class="keyword">if</span> num%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"num: %v%s\n"</span>, num, <span class="string">"偶数"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"num: %v%s\n"</span>, num, <span class="string">"奇数"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输入年龄判断是否未成年</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f3</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> age <span class="keyword">int</span></span><br><span class="line">fmt.Println(<span class="string">"请输入年龄："</span>)</span><br><span class="line">fmt.Scan(&amp;age)</span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"成年人"</span>)</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"未成年人"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">f1()</span><br><span class="line">f3()</span><br><span class="line">f2()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="if-自用变量"><a href="#if-自用变量" class="headerlink" title="if 自用变量"></a>if 自用变量</h3><p>在 <strong>if 语句中声明自用变量</strong>是 Go 语言的一个惯用法，这种使用方式直观上可以让开发者有一种代码行数减少的感觉，提高可读性。</p><p>同时，由于这些变量是 if 语句自用变量，它的<strong>作用域仅限于 if 语句的各层隐式代码块中</strong>，if 语句外部无法访问和更改这些变量，这就让这些变量具有一定隔离性，这样你在阅读和理解 if 语句的代码时也可以更聚焦。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> c, d, e := <span class="number">5</span>, <span class="number">9</span>, <span class="number">3</span>; c &lt; d &amp;&amp; (c &gt; e || c &gt; <span class="number">3</span>) &#123;</span><br><span class="line">fmt.Println(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>逻辑表达式中可以含有变量变量或常量；<br>if句子中允许包含1个（仅1个分号），在分号初始化一些局部变量（即只在if块内可见）；</p></blockquote><h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><p>Go语言的 switch 要比C语言的更加通用，表达式不需要为常量，甚至不需要为整数，case 按照从上到下的顺序进行求值，直到找到匹配的项，如果 switch 没有表达式，则对 true 进行匹配，因此，可以将 if else-if else 改写成一个 switch。</p><p>相对于C语言和 <a href="http://c.biancheng.net/java/" target="_blank" rel="noopener">Java</a> 等其它语言来说，Go语言中的 switch 结构使用上更加灵活，语法设计尽量以使用方便为主。</p><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">color := <span class="string">"black"</span></span><br><span class="line"><span class="keyword">switch</span> color &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"green"</span>: <span class="comment">//相当于 if color=="green"</span></span><br><span class="line"><span class="built_in">println</span>(<span class="string">"green"</span>)</span><br><span class="line"><span class="comment">//当出现多个 case 要放在一起的时候，可以写成下面这样</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">"red"</span>, <span class="string">"yellow"</span>: <span class="comment">//相当于else if color == "red" || color == "yellow"</span></span><br><span class="line">fmt.Println(<span class="string">"red or yellow"</span>)</span><br><span class="line"><span class="keyword">default</span>:      <span class="comment">//相当于else</span></span><br><span class="line">fmt.Printf(<span class="string">"invalid traffic signal: %s\n"</span>, strings.ToUpper(color))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> n + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">19</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="number">20</span></span><br><span class="line"><span class="keyword">switch</span> add(a) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">fmt.Println(<span class="string">"sum is 5"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">7</span>, <span class="number">8</span>, b:</span><br><span class="line">fmt.Println(<span class="string">"sum is 7 or 8 or b"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">"no"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="空-switch"><a href="#空-switch" class="headerlink" title="空 switch"></a>空 switch</h3><p>switch后带表达式时，switch-case只能模拟相等的情况；如果switch后不带表达式，case后就可以跟任意的条件表达式。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span> &gt; <span class="number">7</span> &amp;&amp; <span class="number">5</span> &lt; <span class="number">8</span>:</span><br><span class="line">fmt.Println(<span class="string">"right"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">"wrong"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="fallthrough"><a href="#fallthrough" class="headerlink" title="fallthrough"></a>fallthrough</h3><blockquote><p>switch中从上往下，只要找到成立的case，就不再执行后面的case了，所以为了提高性能，把大概率会匹配的case放在前面；<br>case里如果带了fallthrough，则执行完本case还会去判断下一个case是否满足；<br>在switch type语句的case子句中不能使用fallthrough。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> s = <span class="string">"hello"</span></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> s == <span class="string">"hello"</span>:</span><br><span class="line">fmt.Println(<span class="string">"hello"</span>)</span><br><span class="line"><span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">case</span> s != <span class="string">"world"</span>:</span><br><span class="line">fmt.Println(<span class="string">"world"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">world</span><br></pre></td></tr></table></figure><h3 id="switch-type"><a href="#switch-type" class="headerlink" title="switch type"></a>switch type</h3><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Nov 08 2022 22:51:10 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;if&quot;&gt;&lt;a href=&quot;#if&quot; class=&quot;headerlink&quot; title=&quot;if&quot;&gt;&lt;/a&gt;if&lt;/h2&gt;&lt;p&gt;和 Go 
      
    
    </summary>
    
    
      <category term="Go" scheme="http://chenzhonzhou.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="http://chenzhonzhou.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go 数据类型</title>
    <link href="http://chenzhonzhou.github.io/2022/10/15/go-shu-ju-lei-xing/"/>
    <id>http://chenzhonzhou.github.io/2022/10/15/go-shu-ju-lei-xing/</id>
    <published>2022-10-15T14:05:14.000Z</published>
    <updated>2022-11-08T14:10:41.274Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Nov 08 2022 22:51:10 GMT+0800 (GMT+08:00) --><h2 id="一、基础数据类型"><a href="#一、基础数据类型" class="headerlink" title="一、基础数据类型"></a>一、基础数据类型</h2><h3 id="1-1-基础数据类型"><a href="#1-1-基础数据类型" class="headerlink" title="1.1 基础数据类型"></a>1.1 基础数据类型</h3><table><thead><tr><th>类型</th><th>长度(字节)</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td>bool</td><td>1</td><td>false</td><td></td></tr><tr><td>byte</td><td>1</td><td>0</td><td>uint8，取值范围[0,255]</td></tr><tr><td>rune</td><td>4</td><td>0</td><td>Unicode Code Point，int32</td></tr><tr><td>int，uint</td><td>4或8</td><td>0</td><td>32或64位，取决于操作系统</td></tr><tr><td>int8，uint8</td><td>1</td><td>0</td><td>-128~127，0~255</td></tr><tr><td>int16，uint16</td><td>2</td><td>0</td><td>-32768~32767，0-65535</td></tr><tr><td>int32，uint32</td><td>4</td><td>0</td><td>-21亿~21亿，0~42亿，rune是int32的别名</td></tr><tr><td>int64，uint64</td><td>8</td><td>0</td><td></td></tr><tr><td>float32</td><td>4</td><td>0.0</td><td></td></tr><tr><td>float64</td><td>8</td><td>0.0</td><td></td></tr><tr><td>complex64</td><td>8</td><td></td><td></td></tr><tr><td>complex128</td><td>16</td><td></td><td></td></tr><tr><td>uintptr</td><td>4或8</td><td></td><td>以存储指针的uint32或uint64整数</td></tr></tbody></table><h3 id="1-2-复合数据类型"><a href="#1-2-复合数据类型" class="headerlink" title="1.2 复合数据类型"></a>1.2 复合数据类型</h3><table><thead><tr><th>类型</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td>array</td><td></td><td>值类型</td></tr><tr><td>struct</td><td></td><td>值类型</td></tr><tr><td>string</td><td>“”</td><td>UTF-8 字符串</td></tr><tr><td>slice</td><td>nil</td><td>引用类型</td></tr><tr><td>map</td><td>nil</td><td>引用类型</td></tr><tr><td>channel</td><td>nil</td><td>引用类型</td></tr><tr><td>interface</td><td>nil</td><td>接口</td></tr><tr><td>function</td><td>nil</td><td>函数</td></tr></tbody></table><h2 id="二、自定义类型"><a href="#二、自定义类型" class="headerlink" title="二、自定义类型"></a>二、自定义类型</h2><h3 id="2-1-自定义类型"><a href="#2-1-自定义类型" class="headerlink" title="2.1 自定义类型"></a>2.1 自定义类型</h3><p>在Go语言中有一些基本的数据类型，如string、整型、浮点型、布尔等数据类型，Go语言中可以使用 type 关键字来定义自定义类型。</p><p>自定义类型是 定义了一个全新的类型 。我们可以基于内置的基本类型定义，也可以通过 struct 定义。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将MyInt定义为int类型</span></span><br><span class="line"><span class="keyword">type</span> MyInt <span class="keyword">int</span></span><br></pre></td></tr></table></figure><p>通过Type关键字的定义，MyInt就是一种新的类型，它具有 int 的特性。</p><p>思考：<br>实际上，Go语言中的结构体类型就是一种自定义类型。<br>看看结构体的定义格式就知道了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> 结构体类型名 <span class="keyword">struct</span> &#123;</span><br><span class="line">字段名<span class="number">1</span> 字段类型<span class="number">1</span></span><br><span class="line">    字段名<span class="number">2</span> 字段类型<span class="number">2</span></span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是和上述自定义类型的格式一模一样呢？</p><h3 id="2-2-类型别名"><a href="#2-2-类型别名" class="headerlink" title="2.2 类型别名"></a>2.2 类型别名</h3><p>类型别名是Go1.9版本添加的新功能。</p><p>类型别名规定：TypeAlias只是Type的别名，本质上TypeAlias与Type是同一个类型。就像一个孩子小时候有小名、乳名，上学后用学名，英语老师又会给他起英文名，但这些名字都指的是他本人。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TypeAlias = Type</span><br></pre></td></tr></table></figure><p>我们之前见过的rune和byte就是类型别名，他们的定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="keyword">byte</span> = <span class="keyword">uint8</span></span><br><span class="line"><span class="keyword">type</span> <span class="keyword">rune</span> = <span class="keyword">int32</span></span><br></pre></td></tr></table></figure><h3 id="2-3-类型定义和类型别名的区别"><a href="#2-3-类型定义和类型别名的区别" class="headerlink" title="2.3 类型定义和类型别名的区别"></a>2.3 类型定义和类型别名的区别</h3><p>类型别名与类型定义表面上看只有一个等号的差异，我们通过下面的这段代码来理解它们之间的区别。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型定义</span></span><br><span class="line"><span class="keyword">type</span> NewInt <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型别名</span></span><br><span class="line"><span class="keyword">type</span> MyInt = <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a NewInt</span><br><span class="line"><span class="keyword">var</span> b MyInt</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"type of a:%T\n"</span>, a) <span class="comment">//type of a:main.NewInt</span></span><br><span class="line">fmt.Printf(<span class="string">"type of b:%T\n"</span>, b) <span class="comment">//type of b:int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> of a:main.NewInt</span><br><span class="line"><span class="keyword">type</span> of b:<span class="keyword">int</span></span><br></pre></td></tr></table></figure><p>结果显示a的类型是main.NewInt，表示main包下定义的NewInt类型。这是一个新的数据类型。</p><p>b的类型是int。MyInt类型别名只会在代码中存在，编译完成时并不会有MyInt类型。</p><h2 id="三、字符串"><a href="#三、字符串" class="headerlink" title="三、字符串"></a>三、字符串</h2><p>Go语言将字符串作为一种原生的基本数据类型。字符串是一个不可修改的数据类型。它的底层结构如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> stringStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">str unsafe.Pointer <span class="comment">// 指向底层字节数组的指针</span></span><br><span class="line"><span class="built_in">len</span> <span class="keyword">int</span>            <span class="comment">// 字节数组长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-字符串赋值"><a href="#3-1-字符串赋值" class="headerlink" title="3.1 字符串赋值"></a>3.1 字符串赋值</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s1 :=<span class="string">"MY name is zhangsan \u4f17"</span> <span class="comment">//字符串里可以包含任意Unicode字符</span></span><br><span class="line">s2 := <span class="string">"He say:\"I'm file.\"\nThank\tyou."</span> <span class="comment">//包含转文字符</span></span><br><span class="line">s3 := <span class="string">`here is first \nline.`</span> <span class="comment">//反引号里的转文字符无效，原样输出包括空白符和换行符等</span></span><br></pre></td></tr></table></figure><h3 id="3-2-字符串常用操作"><a href="#3-2-字符串常用操作" class="headerlink" title="3.2 字符串常用操作"></a>3.2 字符串常用操作</h3><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>len(str)</td><td>求长度</td></tr><tr><td>strings.Split</td><td>分割</td></tr><tr><td>strings.Contains</td><td>判断是否包含</td></tr><tr><td>Strings.HasPrefix，strings.HasSuffix</td><td>前缀/后缀判断</td></tr><tr><td>Strings.Index()，Strings.LastIndex()</td><td>子串出现的位置</td></tr></tbody></table><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求长度</span></span><br><span class="line">s := <span class="string">"123 张三"</span></span><br><span class="line">fmt.Printf(<span class="string">"s len %d"</span>, <span class="built_in">len</span>(s))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分割</span></span><br><span class="line">s := <span class="string">"hello, how are you"</span></span><br><span class="line">fmt.Printf(<span class="string">"%t\n"</span>, strings.HasSuffix(s, <span class="string">"are"</span>))</span><br><span class="line">a := strings.Split(s, <span class="string">"l"</span>)</span><br><span class="line">fmt.Printf(<span class="string">"%s"</span>, a)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否包含</span></span><br><span class="line">s := <span class="string">"hello, how are you"</span></span><br><span class="line">fmt.Println(strings.Contains(s, <span class="string">"how"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前缀/后缀判断</span></span><br><span class="line">s := <span class="string">"hello, how are you"</span></span><br><span class="line">fmt.Println(strings.HasPrefix(s, <span class="string">"hello"</span>))</span><br><span class="line">fmt.Println(strings.HasSuffix(s, <span class="string">"hello"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子串出现的位置</span></span><br><span class="line">s := <span class="string">"hello, how are you"</span></span><br><span class="line">fmt.Println(strings.Index(s, <span class="string">"o"</span>))</span><br><span class="line">fmt.Println(strings.LastIndex(s, <span class="string">"o"</span>))</span><br></pre></td></tr></table></figure><h3 id="3-3-字符串拼接"><a href="#3-3-字符串拼接" class="headerlink" title="3.3 字符串拼接"></a>3.3 字符串拼接</h3><h4 id="3-3-1-加号拼接"><a href="#3-3-1-加号拼接" class="headerlink" title="3.3.1 加号拼接"></a>3.3.1 加号拼接</h4><p>最常用的方法肯定是 + 连接两个字符串。这与python类似，不过由于golang中的字符串是不可变的类型，因此用 + 连接会产生一个新的字符串对效率有影响。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s1 := <span class="string">"字符串"</span></span><br><span class="line">s2 := <span class="string">"拼接"</span></span><br><span class="line">s3 := s1 + s2</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印s3字符串</span></span><br><span class="line">fmt.Print(s3)</span><br></pre></td></tr></table></figure><h4 id="3-3-2-sprintf-函数"><a href="#3-3-2-sprintf-函数" class="headerlink" title="3.3.2 sprintf 函数"></a>3.3.2 sprintf 函数</h4><p>第二种方法使用sprintf函数，虽然不会像直接使用 + 那样产生临时字符串。但是效率也不高</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s1 := <span class="string">"字符串"</span></span><br><span class="line">s2 := <span class="string">"拼接"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印s3字符串</span></span><br><span class="line">s3 := fmt.Sprintf(<span class="string">"%s%s"</span>, s1, s2)</span><br></pre></td></tr></table></figure><h4 id="3-3-3-Join-函数"><a href="#3-3-3-Join-函数" class="headerlink" title="3.3.3 Join 函数"></a>3.3.3 Join 函数</h4><p>第三种方法是用Join函数，这里我们需要先引入strings包才能调用Join函数。Join函数会先根据字符串数组的内容，计算出一个拼接之后的长度，然后申请对应大小的内存，一个一个字符串填入，在已有一个数组的情况下，这种效率会很高，如果没有的话效率也不高。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要先导入strings包</span></span><br><span class="line">s1 := <span class="string">"字符串"</span></span><br><span class="line">s2 := <span class="string">"拼接"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个字符串数组包含上述的字符串</span></span><br><span class="line"><span class="keyword">var</span> str []<span class="keyword">string</span> = []<span class="keyword">string</span>&#123;s1, s2&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用Join函数</span></span><br><span class="line">s3 := strings.Join(str, <span class="string">""</span>)</span><br><span class="line">fmt.Print(s3)</span><br></pre></td></tr></table></figure><h4 id="3-3-4-buffer-函数"><a href="#3-3-4-buffer-函数" class="headerlink" title="3.3.4 buffer 函数"></a>3.3.4 buffer 函数</h4><p>第四个方法是调用buffer.WriteString函数，这种方法的性能就要大大优于上面的了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要先导入bytes包</span></span><br><span class="line">s1 := <span class="string">"字符串"</span></span><br><span class="line">s2 := <span class="string">"拼接"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义Buffer类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bt bytes.Buffer</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向bt中写入字符串</span></span><br><span class="line">bt.WriteString(s1)</span><br><span class="line">bt.WriteString(s2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得拼接后的字符串</span></span><br><span class="line">s3 := bt.String()</span><br><span class="line">fmt.Print(s3)</span><br></pre></td></tr></table></figure><h4 id="3-3-5-Builder-函数"><a href="#3-3-5-Builder-函数" class="headerlink" title="3.3.5 Builder 函数"></a>3.3.5 Builder 函数</h4><p>第5个方法是用buffer.Builder，这个方法和上面的差不多，不过官方建议用这个，使用方法和上面基本一样</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要先导入Strings包 </span></span><br><span class="line">s1 := <span class="string">"字符串"</span></span><br><span class="line">s2 := <span class="string">"拼接"</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> build strings.Builder </span><br><span class="line">build.WriteString(s1)</span><br><span class="line">build.WriteString(s2)</span><br><span class="line"></span><br><span class="line">s3 := build.String()</span><br><span class="line">fmt.Print(s3)</span><br></pre></td></tr></table></figure><h3 id="3-4-byte-和-rune"><a href="#3-4-byte-和-rune" class="headerlink" title="3.4 byte 和 rune"></a>3.4 byte 和 rune</h3><p>Go内置两种字符类型：一种是byte的字节类型（byte也是uint8的别名），另一种是表示Unicode编码的字符rune。</p><blockquote><p>string中每个元素叫”字符”，字符有两种：</p><ul><li>byte：1个字节，代表ASCII码的一个字符；</li><li>rune：4个字节，代码UTF-8字符，一个汉字可以用一个rune表示；</li></ul><p>string底层是byte数组，string的长度就是该byte数组的长度，UFT-8编码下一个汉字占3个byte，即一个汉字占3个长度；<br>string可以转换为[]byte或[]rune类型；<br>string是常量，不能修改其中的字符；</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">"123 张三"</span></span><br><span class="line"><span class="comment">// arr := []byte(s) //byte类型</span></span><br><span class="line">arr := []<span class="keyword">rune</span>(s) <span class="comment">//rune类型</span></span><br><span class="line"><span class="keyword">for</span> _, ele := <span class="keyword">range</span> arr &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%c "</span>, ele)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println()</span><br><span class="line">fmt.Printf(<span class="string">"arr len %d,s len %d"</span>, <span class="built_in">len</span>(arr), <span class="built_in">len</span>(s)) <span class="comment">//byte和rune中的中文字符长度不一样</span></span><br></pre></td></tr></table></figure><h2 id="四、强制类型转换"><a href="#四、强制类型转换" class="headerlink" title="四、强制类型转换"></a>四、强制类型转换</h2><p><strong>golang语言不支持类型自动转换（隐式转换），只支持强制类型转换（显示转换）</strong></p><p>即不同类型变量之间赋值需要用到强制类型转换语法</p><p>基本语法如下：</p><blockquote><p>表达式T(v)，表示将变量v的值转换为T类型，把转换后的值赋值给接收变量</p></blockquote><p>PS：存储范围更大的类型转换成存储范围更小的类型时，如果值超过了后者的取值范围，不会报错但是会直接截断字节，得到很奇怪的值（二进制数被从高位截断导致的）</p><ul><li>byte和int可以互相转换</li><li>float和int可以互相转换，小数位会丢失</li><li>bool和int不能相互转换</li><li>不同长度的int或float之间可以相互转换</li><li>string可以转换为[]byte或[]rune类型，byte或rune可以转换为string</li><li>低精度向高精度转换没问题，高精度向低精度转换会丢失位数</li><li>无符号向有符号转换，最高位是符号位</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例子：</span></span><br><span class="line"><span class="keyword">var</span> i1 <span class="keyword">int64</span></span><br><span class="line"><span class="keyword">var</span> i2 <span class="keyword">int32</span></span><br><span class="line"><span class="keyword">var</span> i3 <span class="keyword">int8</span></span><br><span class="line">i1 = <span class="number">123</span></span><br><span class="line">i2 = <span class="keyword">int32</span>(i1)</span><br><span class="line">i3 = <span class="keyword">int8</span>(i1)</span><br><span class="line">fmt.Printf(<span class="string">"i1 类型为 %T ，值= %v\n"</span>, i1, i1) <span class="comment">// i1 类型为 int64 ，值= 123</span></span><br><span class="line">fmt.Printf(<span class="string">"i2 类型为 %T ，值= %v\n"</span>, i2, i2) <span class="comment">// i2 类型为 int32 ，值= 123</span></span><br><span class="line">fmt.Printf(<span class="string">"i3 类型为 %T ，值= %v\n"</span>, i3, i3) <span class="comment">// i3 类型为 int8 ，值= 123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储范围更大的类型转换成存储范围更小的类型时，如果值超过了后者的取值范围，不会报错但是会直接截断字节，得到很奇怪的值（二进制数被从高位截断导致的）</span></span><br><span class="line"><span class="comment">// 例子：</span></span><br><span class="line"><span class="keyword">var</span> i4 <span class="keyword">int</span> = <span class="number">1000</span></span><br><span class="line"><span class="keyword">var</span> i5 <span class="keyword">int8</span></span><br><span class="line">fmt.Println(i4) <span class="comment">// 1000</span></span><br><span class="line">i5 = <span class="keyword">int8</span>(i4)</span><br><span class="line">fmt.Println(i5) <span class="comment">// -24</span></span><br></pre></td></tr></table></figure><h2 id="五、数组"><a href="#五、数组" class="headerlink" title="五、数组"></a>五、数组</h2><p>数组是同一种数据类型元素的集合，是块连续的内存空间，在声明的时候必须指定长度，使用时可以修改数组成员，且长度不能改变。所以数组在声明的时候就可以把内存空间分配好，并赋上默认值，即完成了初始化。</p><p><img src="/2022/10/15/go-shu-ju-lei-xing/E:%5Caaa%5CGo%5CGO%E5%AD%A6%E4%B9%A0%5C%E7%AC%94%E8%AE%B0%5C%E5%9B%BE%E7%89%87%5C%E6%95%B0%E7%BB%841.png" alt="数组"></p><h3 id="5-1-数组初始化"><a href="#5-1-数组初始化" class="headerlink" title="5.1 数组初始化"></a>5.1 数组初始化</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 [<span class="number">5</span>]<span class="keyword">int</span> = [<span class="number">5</span>]<span class="keyword">int</span>&#123;&#125;         <span class="comment">//数组必须指定长度和类型，且长度和类型指定后不可改变</span></span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">5</span>]<span class="keyword">int</span>&#123;&#125;                <span class="comment">//推断长度是5的数组</span></span><br><span class="line"><span class="keyword">var</span> arr3 = [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">3</span>, <span class="number">2</span>&#125;            <span class="comment">//给前2个元素赋值</span></span><br><span class="line"><span class="keyword">var</span> arr4 = [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">2</span>: <span class="number">15</span>, <span class="number">4</span>: <span class="number">22</span>&#125;    <span class="comment">//给第2,4个元素赋值</span></span><br><span class="line"><span class="keyword">var</span> arr5 = [...]<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>&#125; <span class="comment">//根据值的数量去推断数组长度</span></span><br><span class="line"><span class="keyword">var</span> arr6 = [...]<span class="keyword">struct</span> &#123;           <span class="comment">//结构体赋值数组</span></span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age  <span class="keyword">int</span></span><br><span class="line">&#125;&#123;&#123;<span class="string">"Tom"</span>, <span class="number">19</span>&#125;, &#123;<span class="string">"Jin"</span>, <span class="number">22</span>&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-二维数组初始化"><a href="#5-2-二维数组初始化" class="headerlink" title="5.2 二维数组初始化"></a>5.2 二维数组初始化</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//5行3列，只给前2行赋值，且前2行的所有列还没有赋满</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">5</span>][<span class="number">3</span>]<span class="keyword">int</span>&#123;&#123;<span class="number">1</span>&#125;, &#123;<span class="number">2</span>, <span class="number">3</span>&#125;&#125;</span><br><span class="line"><span class="comment">//第1维可以用...推测，第2维不能用...</span></span><br><span class="line"><span class="keyword">var</span> arr2 = [...][<span class="number">3</span>]<span class="keyword">int</span>&#123;&#123;<span class="number">1</span>&#125;, &#123;<span class="number">2</span>, <span class="number">3</span>&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-访问数组元素"><a href="#5-3-访问数组元素" class="headerlink" title="5.3 访问数组元素"></a>5.3 访问数组元素</h3><p>通过index访问</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">访问首元素arr[0]</span><br><span class="line">访问末元素arr[len(arr)-1]</span><br></pre></td></tr></table></figure><p>访问二维数组元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">访问位于第三行第四列的元素arr[2][3]</span><br></pre></td></tr></table></figure><h3 id="5-4-遍历数组"><a href="#5-4-遍历数组" class="headerlink" title="5.4 遍历数组"></a>5.4 遍历数组</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//for range 遍历数组</span></span><br><span class="line"><span class="keyword">for</span> i, ele := <span class="keyword">range</span> arr4 &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"index=%d,element=%d\n"</span>, i, ele)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//或 for 循环遍历数组</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= <span class="built_in">len</span>(arr4); i++ &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"index=%d,element=%d\n"</span>, i, arr4[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>冒泡排序</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    arr01 := [...]<span class="keyword">int</span>&#123;<span class="number">54</span>,<span class="number">123</span>,<span class="number">11</span>,<span class="number">22</span>,<span class="number">875</span>,<span class="number">124</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> i :=<span class="number">1</span>;i&lt;<span class="built_in">len</span>(arr01);i++&#123;</span><br><span class="line">        <span class="comment">//fmt.Println(arr01[i])</span></span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">0</span>;j&lt;<span class="built_in">len</span>(arr01)-i;j++&#123;</span><br><span class="line">            <span class="keyword">if</span> arr01[j] &gt; arr01[j+<span class="number">1</span>]&#123;</span><br><span class="line">                arr01[j],arr01[j+<span class="number">1</span>] = arr01[j+<span class="number">1</span>],arr01[j]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(arr01)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>遍历二维数组</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历二维数组</span></span><br><span class="line"><span class="keyword">for</span> row, array := <span class="keyword">range</span> arr1 &#123; <span class="comment">//再遍历行</span></span><br><span class="line">    <span class="keyword">for</span> col, ele := <span class="keyword">range</span> array &#123; <span class="comment">//再遍历列</span></span><br><span class="line">        fmt.Printf(<span class="string">"arr[%d] [%d]=%d\n"</span>, row, col, ele)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-5-数组中的-cap-和-len"><a href="#5-5-数组中的-cap-和-len" class="headerlink" title="5.5 数组中的 cap 和 len"></a>5.5 数组中的 cap 和 len</h3><ul><li>cap代表capacity容量；</li><li>len代表length长度；</li><li>len代表目前数组里的几个元素，cap代表给数组分配的内存空间可以容纳多少个元素；</li><li>由于数组初始化之后长度不会改变，不需要给它预留内存空间所以<code>len(arr)==cap(arr)</code>；</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr [<span class="number">5</span>]<span class="keyword">int</span> = [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">6</span>&#125;</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(arr))</span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(arr))</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果：</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><h3 id="5-6-数组传参"><a href="#5-6-数组传参" class="headerlink" title="5.6 数组传参"></a>5.6 数组传参</h3><ul><li>数组的长度和类型都是数组类型的一部分，函数传递数组类型时这两部分都必须吻合；</li><li>go语言没有按引用传参，全部是按值传参，即传递数组实际上传的是数组的拷贝，当数组的长度很大时，仅传参开销都很大；</li><li>如果想修改函数外部的数组，就把它的指针（数组在内存里的地址）传进来；</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不使用指针传递数组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">arrPoint</span><span class="params">(arr [5]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%p\n"</span>, &amp;arr)</span><br><span class="line">    fmt.Printf(<span class="string">"%d\n"</span>, arr[<span class="number">0</span>])</span><br><span class="line">arr[<span class="number">0</span>] += <span class="number">10</span></span><br><span class="line">    fmt.Printf(<span class="string">"%d\n"</span>, arr[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> crr [<span class="number">5</span>]<span class="keyword">int</span> = [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">6</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%p\n"</span>, &amp;crr)</span><br><span class="line">arrPoint(crr)</span><br><span class="line">    fmt.Printf(<span class="string">"%d\n"</span>, crr[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果：</span></span><br><span class="line"><span class="number">0xc00000e330</span></span><br><span class="line"><span class="number">0xc00000e360</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="comment">//实际上是将外部的数组拷贝了一份，arrPoint函数修改的是拷贝后的数组</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 现在使用指针传递数组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">arrPoint</span><span class="params">(arr *[5]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%p\n"</span>, arr)</span><br><span class="line">fmt.Printf(<span class="string">"%p\n"</span>, &amp;arr[<span class="number">0</span>])</span><br><span class="line">fmt.Printf(<span class="string">"%d\n"</span>, arr[<span class="number">0</span>])</span><br><span class="line">arr[<span class="number">0</span>] += <span class="number">10</span></span><br><span class="line">fmt.Printf(<span class="string">"%d\n"</span>, arr[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> crr [<span class="number">5</span>]<span class="keyword">int</span> = [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">6</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%p\n"</span>, &amp;crr)</span><br><span class="line">arrPoint(&amp;crr)</span><br><span class="line">fmt.Printf(<span class="string">"%d\n"</span>, crr[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果：</span></span><br><span class="line"><span class="number">0xc00000e330</span></span><br><span class="line"><span class="number">0xc00000e330</span></span><br><span class="line"><span class="number">0xc00000e330</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">15</span></span><br></pre></td></tr></table></figure><h2 id="六、切片"><a href="#六、切片" class="headerlink" title="六、切片"></a>六、切片</h2><p>Go 语言切片是对数组的一种抽象。</p><p>Go 数组的长度不可改变，在特定场景中就不太适用，Go 中提供了一种灵活，功能强悍的内置类型：切片(“动态数组”)，与数组相比切片的长度是不固定的，可以追加元素，在追加时可能使切片的容量增大。</p><p>需要说明，slice 并不是数组或数组指针。它通过内部指针和相关属性 引用数组片段 ，以实现变长方案。</p><ul><li>切片：切片是数组的一个引用，因此切片是引用类型。但自身是结构体，值拷贝传递。</li><li>切片的长度可以改变，因此，切片相当于一个可变的数组。</li><li>切片遍历方式和数组一样，可以用 len() 求长度。表示可用元素数量，读写操作不能超过该限制。</li><li>cap 可以求出 slice 最大扩张容量，不能超出数组限制。<code>0 &lt;= len(slice) &lt;= len(array)</code>，其中array是slice引用的数组。</li><li>切片的定义：var 切片变量名 []类型，比如 <code>var str []string</code> 、 <code>var arr []int</code>。</li><li>如果 <code>slice == nil</code>，那么 len、cap 结果都等于 0。</li></ul><p>Go 语言中的切片类型是从数组类型基础上发展出来的新类型，当声明一个数组时，不指定该数组长度，则该类型为切片(“动态数组”)，切片有自己独立的内部结构字段(len, cap, array pointer)，并于其引用的底层数组共用存储空间。</p><h3 id="6-1-切片初始化"><a href="#6-1-切片初始化" class="headerlink" title="6.1 切片初始化"></a>6.1 切片初始化</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常规声明</span></span><br><span class="line"><span class="keyword">var</span> s, e, f []<span class="keyword">int</span>           <span class="comment">//切片声明，len=cap=0</span></span><br><span class="line">s = []<span class="keyword">int</span>&#123;&#125;                 <span class="comment">//初始化，len=cap=0</span></span><br><span class="line">s = []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125; <span class="comment">//初始化，len=cap=6</span></span><br><span class="line">e = s[<span class="number">0</span>:<span class="number">2</span>:<span class="built_in">cap</span>(s)]           <span class="comment">//有2个元素的切片, len为2, cap为6，2个元素是s中的前两位也就是1,2</span></span><br><span class="line">f = s[:<span class="number">0</span>]                   <span class="comment">//有0个元素的切片, len为0, cap为6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// make() 函数创建</span></span><br><span class="line"><span class="keyword">var</span> s []<span class="keyword">int</span></span><br><span class="line">s = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">3</span>)          <span class="comment">//初始化，len=cap=3</span></span><br><span class="line">s = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">3</span>, <span class="number">5</span>)       <span class="comment">//初始化，len=3,cap=5</span></span><br><span class="line">fmt.Printf(<span class="string">"%d\n"</span>, s)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值符 := 创建</span></span><br><span class="line">s2d := [][]<span class="keyword">int</span>&#123;</span><br><span class="line">    &#123;<span class="number">1</span>&#125;, &#123;<span class="number">2</span>, <span class="number">3</span>&#125;, <span class="comment">//二维数组各行的列数相等，但二维切片各行的列数可以不相等</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%d\n"</span>, s2d)</span><br></pre></td></tr></table></figure><h3 id="6-2-append"><a href="#6-2-append" class="headerlink" title="6.2 append"></a>6.2 append</h3><ul><li>切片相对于数组最大的特点就是可以追加元素，可以自动扩容；</li><li>追加的元素放到预留的内存空间里，同时len加1；</li><li>如果预留空间已用完，则会重新申请一块更大的内存空间，capacity变成之前的2倍(cap&lt;1024)或1.25倍(cat&gt;1024)。把原内存空间的数据拷贝过来，在新内存空间上执行append操作；</li></ul><p><strong>末尾添加</strong> 预留空间不足时，append会重新分配内存</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a []<span class="keyword">int</span></span><br><span class="line">a = <span class="built_in">append</span>(a, <span class="number">1</span>)               <span class="comment">// 追加1个元素</span></span><br><span class="line">a = <span class="built_in">append</span>(a, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)         <span class="comment">// 追加多个元素, 手写解包方式</span></span><br><span class="line">a = <span class="built_in">append</span>(a, []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;...) <span class="comment">// 追加一个切片, 切片需要解包</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 预留空间不足时，append会重新分配内存</span></span><br><span class="line">s1 := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;     <span class="comment">//初始化，len=2,cap=2</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s1), <span class="built_in">cap</span>(s1))</span><br><span class="line">s1 = <span class="built_in">append</span>(s1, <span class="number">10</span>)</span><br><span class="line">fmt.Println(s1)</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s1), <span class="built_in">cap</span>(s1)) <span class="comment">//预留空间已用完，申请了一个长度cap为4的内存空间</span></span><br><span class="line"><span class="comment">//输出结果：</span></span><br><span class="line"><span class="number">2</span> <span class="number">2</span></span><br><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">10</span>]</span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>开头添加</strong> 一般都会重新分配内存</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开头添加（一般都会重新分配内存）</span></span><br><span class="line"><span class="keyword">var</span> a = []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">a = <span class="built_in">append</span>([]<span class="keyword">int</span>&#123;<span class="number">0</span>&#125;, a...)        <span class="comment">// 在开头添加1个元素</span></span><br><span class="line">a = <span class="built_in">append</span>([]<span class="keyword">int</span>&#123;<span class="number">-3</span>, <span class="number">-2</span>, <span class="number">-1</span>&#125;, a...) <span class="comment">// 在开头添加1个切片</span></span><br></pre></td></tr></table></figure><p><strong>中间添加</strong> (append和copy组合实现)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// append实现，第二个append调用会创建一个临时的切片</span></span><br><span class="line"><span class="keyword">var</span> a []<span class="keyword">int</span></span><br><span class="line">a = <span class="built_in">append</span>(a[:i], <span class="built_in">append</span>([]<span class="keyword">int</span>&#123;x&#125;, a[i:]...)...)     <span class="comment">// 在第i个位置插入x</span></span><br><span class="line">a = <span class="built_in">append</span>(a[:i], <span class="built_in">append</span>([]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;, a[i:]...)...) <span class="comment">// 在第i个位置插入切片</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// append和copy组合实现，避免创建中间的临时切片</span></span><br><span class="line">a = <span class="built_in">append</span>(a, <span class="number">0</span>) <span class="comment">// 先扩容</span></span><br><span class="line"><span class="built_in">copy</span>(a[i+<span class="number">1</span>:], a[i:]) <span class="comment">// a[i:]向后移动1个位置</span></span><br><span class="line">a[i] = x             <span class="comment">// 设置新添加的元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// append和copy组合，在指定位置插入切片（多个元素）</span></span><br><span class="line">a = <span class="built_in">append</span>(a, x...) <span class="comment">// 没有专门的函数来扩容，只有使用append</span></span><br><span class="line"><span class="built_in">copy</span>(a[i+<span class="built_in">len</span>(x):], a[i:])</span><br><span class="line"><span class="built_in">copy</span>(a[i:], x)</span><br></pre></td></tr></table></figure><h3 id="6-3-截取子切片"><a href="#6-3-截取子切片" class="headerlink" title="6.3 截取子切片"></a>6.3 截取子切片</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s := make([]int,4,5)  //len=4,cap=5</span><br><span class="line">sub_slice = s[1:3]    //len=2,cap=4</span><br></pre></td></tr></table></figure><p>刚开始，子切片和母切片共享底层的内存空间，修改子切片会反映到母切片上，在子切片上执行append会把新元素放到母切片预留的内存空间上；</p><p>当子切片不断执行append，耗完了母切片预留的内存空间，子切片跟母切片就会发生内存分享，此后两个切片相互独立没有任何关系。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">arr := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">crr := arr[<span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line">crr[<span class="number">0</span>] = <span class="number">8</span></span><br><span class="line">fmt.Println(crr, arr)</span><br><span class="line">crr = <span class="built_in">append</span>(crr, <span class="number">9</span>)</span><br><span class="line">crr = <span class="built_in">append</span>(crr, <span class="number">10</span>)</span><br><span class="line">fmt.Println(crr, arr)</span><br><span class="line">fmt.Printf(<span class="string">"%p %p\n"</span>, &amp;crr[<span class="number">0</span>], &amp;arr[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">//内存分离</span></span><br><span class="line">crr = <span class="built_in">append</span>(crr, <span class="number">12</span>)</span><br><span class="line">fmt.Println(crr, arr)</span><br><span class="line">fmt.Printf(<span class="string">"%p %p\n"</span>, &amp;crr[<span class="number">0</span>], &amp;arr[<span class="number">0</span>])</span><br><span class="line"><span class="comment">//输出结果：</span></span><br><span class="line">[<span class="number">8</span> <span class="number">0</span> <span class="number">0</span>] [<span class="number">8</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"><span class="number">0xc00000e330</span> <span class="number">0xc00000e330</span></span><br><span class="line">[<span class="number">8</span> <span class="number">0</span> <span class="number">0</span> <span class="number">9</span> <span class="number">10</span>] [<span class="number">8</span> <span class="number">0</span> <span class="number">0</span> <span class="number">9</span>]</span><br><span class="line">[<span class="number">8</span> <span class="number">0</span> <span class="number">0</span> <span class="number">9</span> <span class="number">10</span> <span class="number">12</span>] [<span class="number">8</span> <span class="number">0</span> <span class="number">0</span> <span class="number">9</span>]</span><br><span class="line"><span class="number">0xc000012320</span> <span class="number">0xc00000e330</span></span><br></pre></td></tr></table></figure><h2 id="七、map"><a href="#七、map" class="headerlink" title="七、map"></a>七、map</h2><p>Map 是高级语言中一种重要的数据结构，能够很方便的进行数据组织，主要都是&lt;k,v&gt;结构。<strong>除了slice,map,function的内建类型都可以作为key进行使用</strong>。因此，struct类型在不包含上述字段的时候，也可以作为key进行使用。</p><h3 id="7-1-Map的定义"><a href="#7-1-Map的定义" class="headerlink" title="7.1 Map的定义"></a>7.1 Map的定义</h3><p>Go语言中，可以通过自己手工使用基础语法进行map定义，也可以使用内置的<code>make</code>方法进行定义。</p><p><strong>基础定义方式</strong></p><p>Go语言中，定义map的基本语法格式是：<code>map[k类型] v类型 {k值，v值}</code>一个典型的Map定义实例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span> &#123;</span><br><span class="line">    <span class="string">"name"</span>:<span class="string">"ccmouse"</span>,</span><br><span class="line">    <span class="string">"course"</span>:<span class="string">"golang"</span>,</span><br><span class="line">    <span class="string">"site"</span>:<span class="string">"imooc"</span>,</span><br><span class="line">    <span class="string">"quality"</span>:<span class="string">"notbad"</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"Map value is %v"</span>, m)</span><br></pre></td></tr></table></figure><p><strong>使用内置make方法</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// k为string类型，v为int类型</span></span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基础声明方法</span></span><br><span class="line"><span class="keyword">var</span> m2 <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">m2 = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)    <span class="comment">//初始化，容量为0</span></span><br><span class="line">m2 = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>, <span class="number">5</span>) <span class="comment">//初始化 容量为5，如果能确定使用容量强烈建议在初始化时给一个合适的容量，减少扩容的概率</span></span><br><span class="line">m2 = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;         <span class="comment">//初始化时直接赋值</span></span><br><span class="line">    <span class="string">"语文"</span>: <span class="number">10</span>,</span><br><span class="line">    <span class="string">"数学"</span>: <span class="number">15</span>,</span><br><span class="line">    <span class="string">"化学"</span>: <span class="number">20</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>map 在使用前一定要 make；<br>map 的 key 不能重复，如果重复了，则以最后这个 key-value 为准；<br>map 的 value 是可以相同的；<br>map 的 key-value 是无序；</p><h3 id="7-2-添加和删除key"><a href="#7-2-添加和删除key" class="headerlink" title="7.2 添加和删除key"></a>7.2 添加和删除key</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加和删除key</span></span><br><span class="line">m2[<span class="string">"化学"</span>] = <span class="number">67</span></span><br><span class="line"><span class="built_in">delete</span>(m2, <span class="string">"化学"</span>)</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(m2), m2)</span><br></pre></td></tr></table></figure><h3 id="7-3-根据key查找value"><a href="#7-3-根据key查找value" class="headerlink" title="7.3 根据key查找value"></a>7.3 根据key查找value</h3><p>读取key对应的value，如果key不存在，则返回value类型的默认值</p><p>取key对应的value建议使用 if</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据key查找value</span></span><br><span class="line"><span class="keyword">if</span> value, exists := m2[<span class="string">"化学"</span>]; exists &#123;</span><br><span class="line">fmt.Println(value)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"map里不存在查找的value"</span>, exists)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-4-遍历map"><a href="#7-4-遍历map" class="headerlink" title="7.4 遍历map"></a>7.4 遍历map</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历map</span></span><br><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> m2 &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%s=%d\n"</span>, key, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="八、channel"><a href="#八、channel" class="headerlink" title="八、channel"></a>八、channel</h2><p>Go语言中的通道（channel）是一种特殊的类型。<br>在任何时候，<strong>同时只能有一个</strong> goroutine 访问通道进行发送和获取数据。goroutine 间通过通道就可以通信。</p><p>通道像一个传送带或者队列，总是遵循先入先出（First In First Out）的规则，保证收发数据的顺序。</p><p>（1）channel本身是一个队列，先进先出<br>（2）线程安全，不需要加锁<br>（3）本身是有类型的，string, int 等，如果要存多种类型，则定义成 interface类型<br>（4）channel是引用类型，必须make之后才能使用，一旦 make，它的容量就确定了，不会动态增加！！它和map，slice不一样</p><p><strong>channel 的特点</strong>：<br>（1）一旦初始化容量，就不会改变了。<br>（2）当写满时，不可以写，取空时，不可以取。<br>（3）发送将持续阻塞直到数据被接收<br>把数据往通道中发送时，如果接收方一直都没有接收，那么发送操作将持续阻塞。Go 程序运行时能智能地发现一些永远无法发送成功的语句并做出提示<br>（4）接收将持续阻塞直到发送方发送数据。<br>如果接收方接收时，通道中没有发送方发送数据，接收方也会发生阻塞，直到发送方发送数据为止。<br>（5）每次接收一个元素。<br>通道一次只能接收一个数据元素。</p><h3 id="8-1-channel-的声明和使用"><a href="#8-1-channel-的声明和使用" class="headerlink" title="8.1 channel 的声明和使用"></a>8.1 channel 的声明和使用</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 创建一个可以存放3个int类型的管道</span></span><br><span class="line"><span class="keyword">var</span> intChan <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">intChan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 看看intChan是什么</span></span><br><span class="line"><span class="comment">//channel其实和指针一样，本身存放在一个内存单元中，有它的地址</span></span><br><span class="line">fmt.Printf(<span class="string">"intChan 的值=%v intChan本身的地址=%p\n"</span>, intChan, &amp;intChan)</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 向管道写入数据</span></span><br><span class="line">intChan&lt;- <span class="number">10</span></span><br><span class="line">num := <span class="number">211</span></span><br><span class="line">intChan&lt;- num</span><br><span class="line">intChan&lt;- <span class="number">50</span></span><br><span class="line"><span class="comment">// //如果从channel取出数据后，可以继续放入</span></span><br><span class="line">&lt;-intChan</span><br><span class="line">intChan&lt;- <span class="number">98</span><span class="comment">//注意点, 当我们给管写入数据时，不能超过其容量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 看看管道的长度和cap(容量)</span></span><br><span class="line">fmt.Printf(<span class="string">"channel len= %v cap=%v \n"</span>, <span class="built_in">len</span>(intChan), <span class="built_in">cap</span>(intChan)) <span class="comment">// 3, 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//5. 从管道中读取数据</span></span><br><span class="line"><span class="keyword">var</span> num2 <span class="keyword">int</span></span><br><span class="line">num2 = &lt;-intChan </span><br><span class="line">fmt.Println(<span class="string">"num2="</span>, num2)</span><br><span class="line">fmt.Printf(<span class="string">"channel len= %v cap=%v \n"</span>, <span class="built_in">len</span>(intChan), <span class="built_in">cap</span>(intChan))  <span class="comment">// 2, 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//6. 在没有使用协程的情况下，如果我们的管道数据已经全部取出，再取就会报告 deadlock</span></span><br><span class="line">num3 := &lt;-intChan</span><br><span class="line">num4 := &lt;-intChan</span><br><span class="line"></span><br><span class="line"><span class="comment">//num5 := &lt;-intChan</span></span><br><span class="line">fmt.Println(<span class="string">"num3="</span>, num3, <span class="string">"num4="</span>, num4<span class="comment">/*, "num5=", num5*/</span>)</span><br></pre></td></tr></table></figure><h3 id="8-2-空接口类型的-channel"><a href="#8-2-空接口类型的-channel" class="headerlink" title="8.2 空接口类型的 channel"></a>8.2 空接口类型的 channel</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">Age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个存放任意数据类型的管道 3个数据</span></span><br><span class="line"><span class="comment">//var allChan chan interface&#123;&#125;</span></span><br><span class="line">allChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">allChan&lt;- <span class="number">10</span></span><br><span class="line">allChan&lt;- <span class="string">"tom jack"</span></span><br><span class="line">cat := Cat&#123;<span class="string">"小花猫"</span>, <span class="number">4</span>&#125;</span><br><span class="line">allChan&lt;- cat</span><br><span class="line"></span><br><span class="line"><span class="comment">//我们希望获得到管道中的第三个元素，则先将前2个推出</span></span><br><span class="line">&lt;-allChan</span><br><span class="line">&lt;-allChan</span><br><span class="line"></span><br><span class="line">newCat := &lt;-allChan <span class="comment">//从管道中取出的Cat是什么?</span></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"newCat=%T , newCat=%v\n"</span>, newCat, newCat)</span><br><span class="line"><span class="comment">//下面的写法是错误的!编译不通过</span></span><br><span class="line"><span class="comment">//fmt.Printf("newCat.Name=%v", newCat.Name)</span></span><br><span class="line"><span class="comment">//使用类型断言</span></span><br><span class="line">a := newCat.(Cat) </span><br><span class="line">fmt.Printf(<span class="string">"newCat.Name=%v"</span>, a.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>定义 interface类型的空接口，可以接收任意类型的数据，但是在取出来的时候，必须断言！<br>a := newCat.(Cat)</p></blockquote><h3 id="8-3-channel-的遍历"><a href="#8-3-channel-的遍历" class="headerlink" title="8.3 channel 的遍历"></a>8.3 channel 的遍历</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明chan类型，初始化可存放10个int</span></span><br><span class="line"><span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环写入</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    ch &lt;- i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//for ++遍历不需要close</span></span><br><span class="line"><span class="comment">// for j := 0; j &lt; 10; j++ &#123;</span></span><br><span class="line"><span class="comment">// v := &lt;-ch</span></span><br><span class="line"><span class="comment">// fmt.Println(v)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//for range 遍历需要close</span></span><br><span class="line"><span class="built_in">close</span>(ch)</span><br><span class="line"><span class="keyword">for</span> ele := <span class="keyword">range</span> ch &#123;</span><br><span class="line">    fmt.Println(ele)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="九、引用类型"><a href="#九、引用类型" class="headerlink" title="九、引用类型"></a>九、引用类型</h2><ul><li>slice、map和channel是go语言里的3种引用类型，都可以通过make函数来进行初始化（申请内存分配）；</li><li>因为他们都包含一个指向底层数据结构的指针，所以称之后“引用”类型；</li><li>引用类型未初始化时都是nil，可以对它们执行len()函数，返回0；</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Nov 08 2022 22:51:10 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;一、基础数据类型&quot;&gt;&lt;a href=&quot;#一、基础数据类型&quot; class=&quot;headerlink&quot; title=&quot;一、基础数据类型&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="Go" scheme="http://chenzhonzhou.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="http://chenzhonzhou.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go 语言基础</title>
    <link href="http://chenzhonzhou.github.io/2022/10/11/go-yu-yan-ji-chu/"/>
    <id>http://chenzhonzhou.github.io/2022/10/11/go-yu-yan-ji-chu/</id>
    <published>2022-10-11T14:00:03.000Z</published>
    <updated>2022-11-08T14:04:28.640Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Nov 08 2022 22:51:10 GMT+0800 (GMT+08:00) --><h2 id="一、标识符与关键字"><a href="#一、标识符与关键字" class="headerlink" title="一、标识符与关键字"></a>一、标识符与关键字</h2><p>go变量、常量、自定义类型、包、函数的命名方式必须遵循以下规则：</p><ol><li>首字符可以是任意Unicode字符或下划线；</li><li>首字符之外的部分可以是Unicode字符、下划线或数字；</li><li>名字的长度无限制；</li></ol><p>理论上名字里可以有汉字，甚至可以全是汉字，但实际中不要这么做</p><h3 id="1-1-关键字"><a href="#1-1-关键字" class="headerlink" title="1.1 关键字"></a>1.1 关键字</h3><p>break，default，func，interface，select，case，defer，go，map，struct，chan，else，goto，package，switch，const，if，range，type，continue，for，import，return，fallthrough，var</p><h3 id="1-2-常量"><a href="#1-2-常量" class="headerlink" title="1.2 常量"></a>1.2 常量</h3><p>true，false，iota，nil</p><h3 id="1-3-数据类型"><a href="#1-3-数据类型" class="headerlink" title="1.3 数据类型"></a>1.3 数据类型</h3><p>int，int8，int16，int32，int64，uint，uint8，uint16，uint32，uint64，uintptr，float32，float64，complex128，complex64，bool，byte，rune，string，error</p><h3 id="1-4-函数"><a href="#1-4-函数" class="headerlink" title="1.4 函数"></a>1.4 函数</h3><p>make，len，cap，new，append，copy，close，delete，complex，real，imag，panic，recover</p><h2 id="二、运算符与表达式"><a href="#二、运算符与表达式" class="headerlink" title="二、运算符与表达式"></a>二、运算符与表达式</h2><h3 id="2-1-算数运算符"><a href="#2-1-算数运算符" class="headerlink" title="2.1 算数运算符"></a>2.1 算数运算符</h3><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>+</td><td>相加</td></tr><tr><td>-</td><td>相减</td></tr><tr><td>*</td><td>相乘</td></tr><tr><td>/</td><td>相除取商</td></tr><tr><td>%</td><td>求余</td></tr></tbody></table><h3 id="2-2-关系运算符"><a href="#2-2-关系运算符" class="headerlink" title="2.2 关系运算符"></a>2.2 关系运算符</h3><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>==</td><td>检查两个值是否相等，如果相等返回True否则返回False</td></tr><tr><td>!=</td><td>检查两个值是否不相等，如果不相等返回True否则返回False</td></tr><tr><td>&gt;</td><td>检查左边值是否大于右边值，如果是返回True否则返回False</td></tr><tr><td>&gt;=</td><td>检查左边值是否大于或等于右边值，如果是返回True否则返回False</td></tr><tr><td>&lt;</td><td>检查左边值是否小于右边值，如果是返回True否则返回False</td></tr><tr><td>&lt;=</td><td>检查左边值是否小于或等于右边值，如果是返回True否则返回False</td></tr></tbody></table><h3 id="2-3-逻辑运算符"><a href="#2-3-逻辑运算符" class="headerlink" title="2.3 逻辑运算符"></a>2.3 逻辑运算符</h3><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>&amp;&amp;</td><td>逻辑AND运算符；如果两边的操作数都是True，则为True，否则为False</td></tr><tr><td>||</td><td>逻辑OR运算符；如果两边的操作数有一个是True，则为True，否则为False</td></tr><tr><td>!</td><td>逻辑NOT运算符；如果条件为False，则为True，否则为True</td></tr></tbody></table><h3 id="2-4-位运算符"><a href="#2-4-位运算符" class="headerlink" title="2.4 位运算符"></a>2.4 位运算符</h3><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>&amp;</td><td>参与运算的两数各对应的二进位相与（两位均为1才为1）</td></tr><tr><td>|</td><td>参与运算的两数各对应的二进位相或（两位有一个为1就为1）</td></tr><tr><td>^</td><td>参与运算的两数各对应的二进位相异或，当两对应的二进位相同时为0，不同是为1。作为一元运算符时表示按位取反，符号位也跟着变</td></tr><tr><td>&lt;&lt;</td><td>左移n位就是乘以2的n次方。a&lt;&lt;b是把a的各二进位全部左移b位，高位丢弃，低位补0。通过左移，符号位可能会变</td></tr><tr><td>&gt;&gt;</td><td>右移n位就是除以2的n次方。a&gt;&gt;b是把a的各二进位全部右移b位，正数高位补0，负数高位补1</td></tr></tbody></table><h3 id="2-5-赋值运算符"><a href="#2-5-赋值运算符" class="headerlink" title="2.5 赋值运算符"></a>2.5 赋值运算符</h3><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>=</td><td>简单的赋值运算符，将一个表达式的值赋给一个左值</td></tr><tr><td>+=</td><td>相加后再赋值</td></tr><tr><td>-+</td><td>相减后再赋值</td></tr><tr><td>*=</td><td>相乘后再赋值</td></tr><tr><td>/=</td><td>相除后再赋值</td></tr><tr><td>%=</td><td>求余后再赋值</td></tr><tr><td>&lt;&lt;=</td><td>左移后再赋值</td></tr><tr><td>&gt;&gt;=</td><td>右移后再赋值</td></tr><tr><td>&amp;=</td><td>按位与后赋值</td></tr><tr><td>!=</td><td>按位或后赋值</td></tr><tr><td>^=</td><td>按位异或后赋值</td></tr></tbody></table><h2 id="三、变量、常量、字面量"><a href="#三、变量、常量、字面量" class="headerlink" title="三、变量、常量、字面量"></a>三、变量、常量、字面量</h2><h3 id="3-1-变量类型"><a href="#3-1-变量类型" class="headerlink" title="3.1 变量类型"></a>3.1 变量类型</h3><table><thead><tr><th>类型</th><th>go变量类型</th><th>fmt输出</th></tr></thead><tbody><tr><td>整形</td><td>int，int8，int16，int32，int64，uint，uint8，uint16，uint32，uint64</td><td>%d</td></tr><tr><td>浮点型</td><td>float32，float64</td><td>%f，%e，%g</td></tr><tr><td>复数</td><td>complex128，complex64</td><td>%v</td></tr><tr><td>布尔型</td><td>bool</td><td>%t</td></tr><tr><td>指针</td><td>uintptr</td><td>%p</td></tr><tr><td>引用</td><td>map slice channel</td><td>%v</td></tr><tr><td>字节</td><td>byte</td><td>%c</td></tr><tr><td>任意字符</td><td>rune</td><td>%c</td></tr><tr><td>字符串</td><td>string</td><td>%s</td></tr><tr><td>错误</td><td>error</td><td>%v</td></tr></tbody></table><h4 id="3-1-1-变量声明"><a href="#3-1-1-变量声明" class="headerlink" title="3.1.1 变量声明"></a>3.1.1 变量声明</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//标准声明</span></span><br><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> age <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> isOK <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//批量声明</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">age <span class="keyword">int</span></span><br><span class="line">isOK <span class="keyword">bool</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="3-1-2-变量初始化"><a href="#3-1-2-变量初始化" class="headerlink" title="3.1.2 变量初始化"></a>3.1.2 变量初始化</h4><ul><li><p>如果声明后未显式初始化，数值型初始化0，字符串初始化为空字符串，布尔型初始化为false，引用类型、函数、指针、接口初始化为nil</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比如以下几种变量初始化方式</span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">string</span>=<span class="string">"china"</span></span><br><span class="line"><span class="keyword">var</span> a,b <span class="keyword">int</span>=<span class="number">3</span>,<span class="number">7</span></span><br><span class="line"><span class="keyword">var</span> a=<span class="string">"china"</span> <span class="comment">//类型推断，通过赋值数据类型反推变量类型</span></span><br><span class="line"><span class="keyword">var</span> a,b=<span class="string">"china"</span>,<span class="number">7</span></span><br></pre></td></tr></table></figure></li><li><p>函数内部的变量（非全局变量）可以通过<code>:=</code>声明并初始化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a:=<span class="number">3</span></span><br></pre></td></tr></table></figure></li><li><p>下划线表示匿名变量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_=<span class="number">2</span>+<span class="number">4</span></span><br></pre></td></tr></table></figure><p>匿名变量不占命名空间，不会分配内存，因此可以重复使用</p></li></ul><h3 id="3-2-常量"><a href="#3-2-常量" class="headerlink" title="3.2 常量"></a>3.2 常量</h3><p>常量在定义时必须赋值，且程序运行期间其值不能改变</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常量的几种常见赋值方式</span></span><br><span class="line"><span class="keyword">const</span> PI <span class="keyword">float32</span>=<span class="number">3.14</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    PI = <span class="number">3.14</span></span><br><span class="line">    E  = <span class="number">2.7</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    a = <span class="number">100</span></span><br><span class="line">    b  <span class="comment">//值是100，跟上一行的值相同</span></span><br><span class="line">    c  <span class="comment">//值是100，跟上一行的值相同</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>常量中的<code>iota</code>，<code>iota</code>是go语言的常量计数器，只能在常量的表达式中使用</p><p>使用<code>iota</code>时只需要记住以下两点</p><p>1.<code>iota</code>在<code>const</code>关键字出现时将被重置为0。<br>2.<code>const</code>中每新增一行常量声明将使<code>iota</code>计数一次(iota可理解为<code>const</code>语句块中的行索引)。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常量的几种iota常见赋值方式</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    a = <span class="literal">iota</span> <span class="comment">//值是0</span></span><br><span class="line">    b        <span class="comment">//值是1</span></span><br><span class="line">    c        <span class="comment">//值是2</span></span><br><span class="line">    d        <span class="comment">//值是3</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    a = <span class="literal">iota</span> <span class="comment">//值是0</span></span><br><span class="line">    b        <span class="comment">//值是1</span></span><br><span class="line">    _        <span class="comment">//值是2，不想要这个值可以使用匿名变量</span></span><br><span class="line">    d        <span class="comment">//值是3</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    a = <span class="literal">iota</span> <span class="comment">//值是0</span></span><br><span class="line">    b = <span class="number">20</span>   <span class="comment">//值是20</span></span><br><span class="line">    c = <span class="literal">iota</span> <span class="comment">//值是2</span></span><br><span class="line">    d        <span class="comment">//值是3</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ( <span class="comment">//计算KB，MB，GB，TB</span></span><br><span class="line">    _  = <span class="literal">iota</span></span><br><span class="line">    KB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>) <span class="comment">//iota=0 //&lt;&lt;移位操作，速度比乘除法快 </span></span><br><span class="line">    MB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>) <span class="comment">//iota=1 //1&lt;&lt;3 相当于1*2*2*2     0001 -&gt; 1000</span></span><br><span class="line">    GB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>) <span class="comment">//iota=2</span></span><br><span class="line">    TB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>) <span class="comment">//iota=3</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ( <span class="comment">//赋值多个变量</span></span><br><span class="line">    a, b = <span class="literal">iota</span> + <span class="number">1</span>, <span class="literal">iota</span> + <span class="number">2</span> <span class="comment">//值是1,2 iota=0</span></span><br><span class="line">    c, d                      <span class="comment">//值是2,3 iota=1</span></span><br><span class="line">    e, f                      <span class="comment">//值是3,4 iota=2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="3-3-字面量"><a href="#3-3-字面量" class="headerlink" title="3.3 字面量"></a>3.3 字面量</h3><p>字面量：没有出现变量名，直接出现了值。基础类型的字面量相当于是常量</p><h4 id="3-3-1-整型字面量"><a href="#3-3-1-整型字面量" class="headerlink" title="3.3.1 整型字面量"></a>3.3.1 整型字面量</h4><p>整型字面量使用特定的字符序列表示具体的整型数值。常用于整型变量或常量的初始化。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"%d\n"</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><h4 id="3-3-2-浮点型字面量"><a href="#3-3-2-浮点型字面量" class="headerlink" title="3.3.2 浮点型字面量"></a>3.3.2 浮点型字面量</h4><p>浮点型字面量使用特定字符序列来表示一个浮点数值。它支持两种格式：一种是标准的数学小数形式，例如0.23；另一种是科学计数法，例如1E6。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"%d\n"</span>, <span class="number">0.23</span>)</span><br></pre></td></tr></table></figure><h4 id="3-3-3-复数类型字面量"><a href="#3-3-3-复数类型字面量" class="headerlink" title="3.3.3 复数类型字面量"></a>3.3.3 复数类型字面量</h4><p>复数类型字面量使用特定的字符序列来表示复数类型的常量值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"%v\n"</span>, <span class="number">.4i</span>) <span class="comment">//0.4i</span></span><br></pre></td></tr></table></figure><h4 id="3-3-4-字符型字面量"><a href="#3-3-4-字符型字面量" class="headerlink" title="3.3.4 字符型字面量"></a>3.3.4 字符型字面量</h4><p>Go的源码采用UTF-8的编码方式，UTF-8字符占用1～4个字节。Go的字符采用一对单引号包裹。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"%d %d\n"</span>, <span class="string">'\u4f17'</span>, <span class="string">'众'</span>)</span><br></pre></td></tr></table></figure><h4 id="3-3-5-字符串字面量"><a href="#3-3-5-字符串字面量" class="headerlink" title="3.3.5 字符串字面量"></a>3.3.5 字符串字面量</h4><p>Go中的字符串字面量表现形式是采用一对双引号或一对”`”包裹的字符字面量或其编码值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"Hello\nWorld\n!\n"</span>)</span><br></pre></td></tr></table></figure><h2 id="四、变量作用域"><a href="#四、变量作用域" class="headerlink" title="四、变量作用域"></a>四、变量作用域</h2><p>Go 语言 中的一个 变量（常量、类型或 函数）在程序中都有一定的作用范围，我们称之为作用域。Go 语言变量作用域分为<strong>局部</strong>作用域和<strong>全局</strong>作用域</p><h3 id="4-1-局部变量"><a href="#4-1-局部变量" class="headerlink" title="4.1 局部变量"></a>4.1 局部变量</h3><p>在函数内部声明/定义的变量叫局部变量，局部变量的作用域仅限于函数内部。在函数内部定义的变量，函数的 参数 和 返回值，if 和 for 结构内部使用的变量等都是局部变量。</p><p>下面的 main() 函数中使用到了局部变量 a、b、c</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//声明局部变量 a 和 b 并赋值</span></span><br><span class="line">    <span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">3</span></span><br><span class="line">    <span class="keyword">var</span> b <span class="keyword">int</span> = <span class="number">4</span></span><br><span class="line">    <span class="comment">//声明局部变量 c 并计算 a 和 b 的和</span></span><br><span class="line">    c := a + b</span><br><span class="line">    fmt.Printf(<span class="string">"a = %d, b = %d, c = %d\n"</span>, a, b, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">3</span>, b = <span class="number">4</span>, c = <span class="number">7</span></span><br></pre></td></tr></table></figure><h3 id="4-2-全局变量"><a href="#4-2-全局变量" class="headerlink" title="4.2 全局变量"></a>4.2 全局变量</h3><p>在函数外部声明/定义的变量叫全局变量。<strong>如果首字母为大写，则作用域在整个程序有效，如果不为大小，作用域在整个包中有效</strong>。</p><p>下面代码中，第 3 行定义了全局变量 c</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">int</span> <span class="comment">//声明全局变量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a, b <span class="keyword">int</span> <span class="comment">//声明局部变量</span></span><br><span class="line">    <span class="comment">//初始化参数</span></span><br><span class="line">    a = <span class="number">3</span></span><br><span class="line">    b = <span class="number">4</span></span><br><span class="line">    c = a + b</span><br><span class="line">    fmt.Printf(<span class="string">"a = %d, b = %d, c = %d\n"</span>, a, b, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">3</span>, b = <span class="number">4</span>, c = <span class="number">7</span></span><br></pre></td></tr></table></figure><p>全局变量与局部变量名称可以相同，但是函数体内的局部变量会被优先考虑</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="comment">//声明全局变量</span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">float32</span> = <span class="number">3.14</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//声明局部变量</span></span><br><span class="line">    <span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">3</span></span><br><span class="line">    fmt.Printf(<span class="string">"a = %d\n"</span>, a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">3</span></span><br></pre></td></tr></table></figure><h2 id="五、注释与godoc"><a href="#五、注释与godoc" class="headerlink" title="五、注释与godoc"></a>五、注释与godoc</h2><h3 id="5-1-注释的形式"><a href="#5-1-注释的形式" class="headerlink" title="5.1 注释的形式"></a>5.1 注释的形式</h3><ul><li>单行注释，以//开头</li><li>多行注释，连续多行以//开头 或者在段前使用/* 段尾使用*/</li><li>多行注释之间不能出现空行</li><li>NOTE：引人注意，TODO：将来需要优化，Deprecated：变量或函数强烈建议不要使用</li><li>注释行前加缩进即可写go代码</li><li>包注释，在package xxx的上方。一个包只需要在一个地方写包注释，通常会专门写一个doc.go，里面只有一行package xxx和关于包的注释</li><li>结构休注释，在type xxx struct上方</li><li>函数注释，在func xxx()</li><li>行注释，在行上方或右侧</li></ul><h3 id="5-2-go-doc"><a href="#5-2-go-doc" class="headerlink" title="5.2 go doc"></a>5.2 go doc</h3><p>go doc是go自带命令，可以打印附于Go语言程序实体上的文档</p><blockquote><p>go doc package</p></blockquote><p>例如：获取某个函数在某个包中的文档注释</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> doc fmt Printf <span class="comment">//会显示有关 fmt.Printf() 的使用说明。</span></span><br></pre></td></tr></table></figure><h3 id="5-3-godoc"><a href="#5-3-godoc" class="headerlink" title="5.3 godoc"></a>5.3 godoc</h3><p>godoc可以为项目代码导出网页版的注释文档</p><ol><li>需要先安装：go install golang.org/x/tools/cmd/godoc@latest</li><li>本机启动http端口：godoc -http=:6060</li><li>用浏览器访问：<a href="http://127.0.0.1:6060" target="_blank" rel="noopener">http://127.0.0.1:6060</a> 查看go标准库的文档</li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Nov 08 2022 22:51:10 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;一、标识符与关键字&quot;&gt;&lt;a href=&quot;#一、标识符与关键字&quot; class=&quot;headerlink&quot; title=&quot;一、标识符与关键字
      
    
    </summary>
    
    
      <category term="Go" scheme="http://chenzhonzhou.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="http://chenzhonzhou.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go 不同平台下交叉编译方式</title>
    <link href="http://chenzhonzhou.github.io/2022/10/05/go-bu-tong-ping-tai-xia-jiao-cha-bian-yi-fang-shi/"/>
    <id>http://chenzhonzhou.github.io/2022/10/05/go-bu-tong-ping-tai-xia-jiao-cha-bian-yi-fang-shi/</id>
    <published>2022-10-05T13:54:18.000Z</published>
    <updated>2022-11-08T13:59:00.364Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Nov 08 2022 22:51:10 GMT+0800 (GMT+08:00) --><p>golang的一大特性就是<strong>跨平台编译</strong>。<br>有时候我们会遇到在windows里写代码，然后把程序拿到linux里运行的情况。跨平台编译的便利性会使你喜欢上golang这个语言。</p><p>所谓跨平台编译，就是在一个操作系统下生成另一个操作系统下可执行的文件。<br>你只需要在编写代码的操作系统下设置一些参数即可达到这个目的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Windows下编译linux的64位可执行文件</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> SET  CGO_ENABLED=0</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> SET GOOS=linux</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> SET GOARCH=amd64</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> go build hello.go</span></span><br></pre></td></tr></table></figure><h3 id="以helloworld作为示例"><a href="#以helloworld作为示例" class="headerlink" title="以helloworld作为示例"></a>以helloworld作为示例</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"hello world."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>go代码编写完成后，执行<code>go build hello.go</code>，会在目录下生成hello.exe，执行上述命令后，会生成linux下的可执行文件。</p><p><img src="/2022/10/05/go-bu-tong-ping-tai-xia-jiao-cha-bian-yi-fang-shi/%E5%9B%BE%E7%89%871.png" alt="图片1"></p><p>红框内是linux下的可执行文件.png</p><p><img src="/2022/10/05/go-bu-tong-ping-tai-xia-jiao-cha-bian-yi-fang-shi/%E5%9B%BE%E7%89%872.png" alt="图片2"></p><h3 id="记录不同平台下交叉编译的命令"><a href="#记录不同平台下交叉编译的命令" class="headerlink" title="记录不同平台下交叉编译的命令"></a>记录不同平台下交叉编译的命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Windows下编译Mac平台64位可执行程序：</span></span><br><span class="line">SET CGO_ENABLED=0</span><br><span class="line">SET GOOS=darwin</span><br><span class="line">SET GOARCH=amd64</span><br><span class="line">go build xxx.go</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Linux下编译 Mac 和 Windows 平台64位可执行程序：</span></span><br><span class="line">CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build xxx.go</span><br><span class="line">CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build xxx.go</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Mac 下编译 Linux 和 Windows 平台 64位 可执行程序</span></span><br><span class="line">CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build xxx.go</span><br><span class="line">CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build xxx.go</span><br></pre></td></tr></table></figure><blockquote><p>GOOS：目标可执行程序运行操作系统，支持darwin、freebsd、linux、windows<br>GOARCH：目标可执行程序操作系统构架，包括386、amd64、arm</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Nov 08 2022 22:51:10 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;golang的一大特性就是&lt;strong&gt;跨平台编译&lt;/strong&gt;。&lt;br&gt;有时候我们会遇到在windows里写代码，然后把程序拿到linu
      
    
    </summary>
    
    
      <category term="Go" scheme="http://chenzhonzhou.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="http://chenzhonzhou.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go 常用命令</title>
    <link href="http://chenzhonzhou.github.io/2022/09/29/go-chang-yong-ming-ling/"/>
    <id>http://chenzhonzhou.github.io/2022/09/29/go-chang-yong-ming-ling/</id>
    <published>2022-09-29T13:42:44.000Z</published>
    <updated>2022-11-08T13:50:35.445Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Nov 08 2022 22:51:10 GMT+0800 (GMT+08:00) --><h4 id="go-help"><a href="#go-help" class="headerlink" title="go help"></a>go help</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go help build</span><br></pre></td></tr></table></figure><p>查看帮助文档</p><h4 id="go-build"><a href="#go-build" class="headerlink" title="go build"></a>go build</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go build -o my_first_go_exe entrance_class/demo.go</span><br></pre></td></tr></table></figure><p>对源代码和依赖的文件进行打包，生成可执行文件</p><h4 id="go-install"><a href="#go-install" class="headerlink" title="go install"></a>go install</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go install entrance_class/demo.go</span><br></pre></td></tr></table></figure><p>编译并安装包或依赖，安装到<code>$GOPATH/bin</code>目录下</p><h4 id="go-get"><a href="#go-get" class="headerlink" title="go get"></a>go get</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/ginylib/msgp 会在$GOPATH/pkg/mod目录下生成github.com/tinylib/msgp目录</span><br><span class="line">go install github.com/tinylib/msgp@latest 会在$GOPATH/bin下生成msgp可执行文件</span><br></pre></td></tr></table></figure><p>把依赖库添加到当前module中，如果本机之前从未下载过则先下载</p><h4 id="go-mod"><a href="#go-mod" class="headerlink" title="go mod"></a>go mod</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go mod init module_name 初始化一个go项目</span><br><span class="line">go mod tidy 通过扫描当前项目中的所有代码来添加未被记录的依赖至go.mod文件或从go.mod文件中删除不再被使用的依赖</span><br></pre></td></tr></table></figure><h4 id="go-run"><a href="#go-run" class="headerlink" title="go run"></a>go run</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run demo.go</span><br></pre></td></tr></table></figure><p>编译并运行程序</p><h4 id="go-test"><a href="#go-test" class="headerlink" title="go test"></a>go test</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go test</span><br></pre></td></tr></table></figure><p>执行测试代码</p><h4 id="go-tool"><a href="#go-tool" class="headerlink" title="go tool"></a>go tool</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go tool pprof 对cpu、内存和协程进行监控</span><br><span class="line">go tool trace 跟踪协程的执行过程</span><br></pre></td></tr></table></figure><h4 id="go-vet"><a href="#go-vet" class="headerlink" title="go vet"></a>go vet</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go vet demo.go</span><br></pre></td></tr></table></figure><p>检查代码中的静态错误</p><h4 id="go-fmt"><a href="#go-fmt" class="headerlink" title="go fmt"></a>go fmt</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go fmt entrance_class/demo.go</span><br></pre></td></tr></table></figure><p>对代码文件进行格式化，如果用了IDE这个命令就不需要了</p><h4 id="go-doc"><a href="#go-doc" class="headerlink" title="go doc"></a>go doc</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go doc fmt</span><br><span class="line">go doc gonum.org/v1/gonum/stat</span><br></pre></td></tr></table></figure><p>查看go标准库或第三方库的帮助文档</p><h4 id="go-version"><a href="#go-version" class="headerlink" title="go version"></a>go version</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go version</span><br></pre></td></tr></table></figure><p>查看go版本号</p><h4 id="go-env"><a href="#go-env" class="headerlink" title="go env"></a>go env</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go env</span><br></pre></td></tr></table></figure><p>查看go环境信息</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Nov 08 2022 22:51:10 GMT+0800 (GMT+08:00) --&gt;&lt;h4 id=&quot;go-help&quot;&gt;&lt;a href=&quot;#go-help&quot; class=&quot;headerlink&quot; title=&quot;go help&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="Go" scheme="http://chenzhonzhou.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="http://chenzhonzhou.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go 环境安装</title>
    <link href="http://chenzhonzhou.github.io/2022/09/28/go-huan-jing-an-zhuang/"/>
    <id>http://chenzhonzhou.github.io/2022/09/28/go-huan-jing-an-zhuang/</id>
    <published>2022-09-28T13:42:44.000Z</published>
    <updated>2022-11-08T13:46:17.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Nov 08 2022 22:51:10 GMT+0800 (GMT+08:00) --><p>Go官网下载地址：<a href="https://golang.org/dl/" target="_blank" rel="noopener">https://golang.org/dl/</a></p><p>Go官方镜像站（推荐）：<a href="https://golang.google.cn/dl/" target="_blank" rel="noopener">https://golang.google.cn/dl/</a></p><h4 id="linux-安装"><a href="#linux-安装" class="headerlink" title="linux 安装"></a>linux 安装</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[czz@czz downloads]$ wget https://golang.google.cn/dl/go1.19.1.linux-amd64.tar.gz</span><br><span class="line">[czz@czz downloads]$ tar xf go1.19.1.linux-amd64.tar.gz</span><br><span class="line">[czz@czz ~]$ mv -f downloads/go .</span><br><span class="line">[czz@czz ~]$ vim .bashrc</span><br><span class="line">export GOROOT=/home/czz/go</span><br><span class="line">export GOPATH=/home/czz/go_path</span><br><span class="line">export GOPROXY=https://goproxy.cn</span><br><span class="line">export PATH=$PATH:$GOROOT/bin:$GOPATH/bin</span><br><span class="line"></span><br><span class="line">[czz@czz ~]$ source .bashrc</span><br><span class="line">[czz@czz ~]$ mkdir -p go_path/&#123;src,bin,pkg&#125;</span><br></pre></td></tr></table></figure><p>环境变量含义</p><blockquote><p>GOROOT：是go的安装目录，go原生的工具在该目录下；<br>GOPATH：通常用于存放第三方依赖库；<br>GOPROXY：下载依赖库时走哪个镜像代理，可以是公司内部自寻镜像库，比如export ；GOPRIVATE=git.my.com/my/private；<br>PATH：下的二进制文件可以在任意目录下直接运行；<br>在$GOPATH目录有3个子目录：src、bin、pkg，其中src、pkg是第三方库存储目录 src已经被弃用 只有少量库在使用，bin是第三方可执行文件；</p></blockquote><h4 id="win-安装"><a href="#win-安装" class="headerlink" title="win 安装"></a>win 安装</h4><ul><li><p>二进制安装原理和 linux 的安装一样，都需要手动设置环境变量</p></li><li><p>安装包方式则直接双击安装即可</p></li></ul><h4 id="Go-Modules依赖包查找机制"><a href="#Go-Modules依赖包查找机制" class="headerlink" title="Go Modules依赖包查找机制"></a>Go Modules依赖包查找机制</h4><blockquote><p>下载的第三方依赖存储在$GOPATH/pkg/mod下<br>go install生成的可执行文件存储在$GOPATH/bin下<br>依赖包的想找顺序：工作目录，$GOPATH/pkg/mod，$GOROOT/src</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Nov 08 2022 22:51:10 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;Go官网下载地址：&lt;a href=&quot;https://golang.org/dl/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;
      
    
    </summary>
    
    
      <category term="Go" scheme="http://chenzhonzhou.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="http://chenzhonzhou.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch 集成 OpenLDAP</title>
    <link href="http://chenzhonzhou.github.io/2022/08/26/elasticsearch-ji-cheng-openldap/"/>
    <id>http://chenzhonzhou.github.io/2022/08/26/elasticsearch-ji-cheng-openldap/</id>
    <published>2022-08-26T08:47:46.000Z</published>
    <updated>2022-09-06T09:46:50.862Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Nov 08 2022 22:51:10 GMT+0800 (GMT+08:00) --><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>Elasticsearch 集成 OpenLDAP的目地是为了统一管理账号，因为多人使用同一个账号密码会有密码泄露的风险，而且一但改了密码还得通知所有使用的人，为了管理方便索性接入OpenLDAP来管理账号。</p><h2 id="二、部署ES和kibana"><a href="#二、部署ES和kibana" class="headerlink" title="二、部署ES和kibana"></a>二、部署ES和kibana</h2><p>部署ES和kibana（需要依赖jdk环境），已有ES和kibana 可以跳过这一部分</p><h3 id="2-1-部署-ES"><a href="#2-1-部署-ES" class="headerlink" title="2.1 部署 ES"></a>2.1 部署 ES</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[czz@localhost ~]$ wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-6.8.0.tar.gz</span><br><span class="line">[czz@localhost ~]$ tar xf elasticsearch-6.8.0.tar.gz</span><br><span class="line">[czz@localhost ~]$ cd elasticsearch-6.8.0</span><br><span class="line">[czz@localhost elasticsearch-6.8.0]$ vim config/jvm.options</span><br><span class="line">-Xms4g</span><br><span class="line">-Xmx4g</span><br><span class="line"></span><br><span class="line">[czz@localhost elasticsearch-6.8.0]$ ./bin/elasticsearch</span><br></pre></td></tr></table></figure><p>实际使用，建议将jvm内存调大一些</p><h3 id="2-2-部署-kibana"><a href="#2-2-部署-kibana" class="headerlink" title="2.2 部署 kibana"></a>2.2 部署 kibana</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[czz@localhost ~]$ wget https://artifacts.elastic.co/downloads/kibana/kibana-6.8.0-linux-x86_64.tar.gz</span><br><span class="line">[czz@localhost ~]$ tar xf kibana-6.8.0-linux-x86_64.tar.gz</span><br><span class="line">[czz@localhost ~]$ cd kibana-6.8.0</span><br><span class="line">[czz@localhost kibana-6.8.0]$ vim config/kibana.yml</span><br><span class="line">server.port: 5601</span><br><span class="line">server.host: "0.0.0.0"</span><br><span class="line">elasticsearch.hosts: ["http://localhost:9200"]</span><br><span class="line"></span><br><span class="line">[czz@localhost kibana-6.8.0]$ ./bin/kibana</span><br></pre></td></tr></table></figure><p>启动后访问kibana页面，确保服务能正常访问</p><h2 id="三、ES-集成-OpenLDAP"><a href="#三、ES-集成-OpenLDAP" class="headerlink" title="三、ES 集成 OpenLDAP"></a>三、ES 集成 OpenLDAP</h2><p>Elasticsearch集群一但开启X-Pack，则需要为每一台ES和kibana都开启X-Pack插件支持，而且集群开启X-Pack后 Logstash 也要开启X-Pack</p><h3 id="3-1-ES-安装破解-x-pack"><a href="#3-1-ES-安装破解-x-pack" class="headerlink" title="3.1 ES 安装破解 x-pack"></a>3.1 ES 安装破解 x-pack</h3><p>强烈说明：本教程只供交流学习使用，切勿运用到商业用途。如有需要请购买官方正版授权<br>由于在elasticsearch在6.3版本之后x-pack是默认安装好的，这里就不需要自己去安装了<br>破解的x-pack和license的包下载地址：<a href="https://pan.baidu.com/s/1f9plvnhdbeSroOdW2G1YIg" target="_blank" rel="noopener">https://pan.baidu.com/s/1f9plvnhdbeSroOdW2G1YIg</a> 提取码：1v2g</p><p><strong>替换x-pack包，并重启elasticsearch服务</strong></p><p>将解压的x-pack-core-6.8.0.jar包，拷贝到ES 的 <code>modules/x-pack-core/</code>目录下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[czz@localhost elasticsearch-6.8.0]$ cd modules/x-pack-core/</span><br><span class="line">[czz@localhost x-pack-core]$ cp x-pack-core-6.8.0.jar x-pack-core-6.8.0.jar.bak</span><br><span class="line">[czz@localhost x-pack-core]$ cp /tmp/x-pack-core-6.8.0.jar ./</span><br></pre></td></tr></table></figure><p><strong>替换完毕之后需要新增elasticsearch.yml配置</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[czz@localhost elasticsearch-6.8.0]$ vim config/elasticsearch.yml</span><br><span class="line">xpack.security.enabled: false</span><br><span class="line">xpack.monitoring.collection.enabled: true</span><br></pre></td></tr></table></figure><p>配置完后重启ES服务</p><p><strong>导入license</strong>，密码为：change</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[czz@localhost ~]$ curl -XPUT -u elastic 'http://localhost:9200/_xpack/license' -H "Content-Type: application/json" -d @license.json</span><br><span class="line">Enter host password for user 'elastic':</span><br><span class="line">&#123;"acknowledged":true,"license_status":"valid"&#125;</span><br></pre></td></tr></table></figure><p><strong>在kibana上查看license</strong></p><p><img src="/2022/08/26/elasticsearch-ji-cheng-openldap/%E5%9B%BE%E7%89%871.png" alt="图片1"></p><p>Platinum表示白金版，过期时间为2099 年12月31日，如果是自建的Elasticsearch集群则暂时还不能使用x-pack，因为白金版的x-pack需要SSL进行数据传输，需要先配置SSL</p><h3 id="3-2-如何注册License"><a href="#3-2-如何注册License" class="headerlink" title="3.2 如何注册License"></a>3.2 如何注册License</h3><p>注册es产品：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fregister.elastic.co%2Fxpack_register" target="_blank" rel="noopener">https://register.elastic.co/xpack_register</a></p><p>更新license，Updating Your License 官方文档<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.elastic.co%2Fguide%2Fen%2Fx-pack%2Fcurrent%2Finstalling-license.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/x-pack/current/installing-license.html</a></p><p>注册用户获取基础license，有效期1年<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fregister.elastic.co%2Fxpack_register" target="_blank" rel="noopener">https://register.elastic.co/xpack_register</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XPUT -u elastic:password 'http://&lt;host&gt;:&lt;port&gt;/_xpack/license' -d @license.json</span><br></pre></td></tr></table></figure><p>@license.json 申请得到的json文件，复制文件中的所有内容，粘贴在此。</p><p>如果提示需要acknowledge，则设置为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">true curl -XPUT -u elastic:password 'http://&lt;host&gt;:&lt;port&gt;/_xpack/license?acknowledge=true' -d @license.json</span><br></pre></td></tr></table></figure><p>查看license：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET http://localhost:9200/_xpack/license</span><br></pre></td></tr></table></figure><h3 id="3-3-ES-使用-x-pack"><a href="#3-3-ES-使用-x-pack" class="headerlink" title="3.3 ES 使用 x-pack"></a>3.3 ES 使用 x-pack</h3><p><strong>配置启用 x-pack</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[czz@localhost elasticsearch-6.8.0]$ vim config/elasticsearch.yml</span><br><span class="line">xpack.security.enabled: true</span><br></pre></td></tr></table></figure><p>重启ES服务后，还需要配置kibana使用用户名密码登录</p><p><strong>创建 ES 用户</strong></p><p>如果是自建的ES集群最好是在master的es主机上去创建</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[czz@localhost elasticsearch-6.8.0]$ ./bin/elasticsearch-setup-passwords auto</span><br><span class="line">Initiating the setup of passwords for reserved users elastic,apm_system,kibana,logstash_system,beats_system,remote_monitoring_user.</span><br><span class="line">The passwords will be randomly generated and printed to the console.</span><br><span class="line">Please confirm that you would like to continue [y/N]y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Changed password for user apm_system</span><br><span class="line">PASSWORD apm_system = D3vWQiOiG3w1JZedeAFL</span><br><span class="line"></span><br><span class="line">Changed password for user kibana</span><br><span class="line">PASSWORD kibana = Z6LsfahTn2kY9g0V9YHP</span><br><span class="line"></span><br><span class="line">Changed password for user logstash_system</span><br><span class="line">PASSWORD logstash_system = W2q1XB3T5lFA7ANtebqn</span><br><span class="line"></span><br><span class="line">Changed password for user beats_system</span><br><span class="line">PASSWORD beats_system = MNuBiMk6iUpKHjlkFr0E</span><br><span class="line"></span><br><span class="line">Changed password for user remote_monitoring_user</span><br><span class="line">PASSWORD remote_monitoring_user = sg1wpAmFEKf0vU5YvyhE</span><br><span class="line"></span><br><span class="line">Changed password for user elastic</span><br><span class="line">PASSWORD elastic = bucpN7jkqUUFWr94gciV</span><br></pre></td></tr></table></figure><blockquote><p>elasticsearch-setup-passwords 支持2种选项</p><p>auto - Uses randomly generated passwords #主要命令选项，表示系统将使用随机字符串设置密码<br>interactive - Uses passwords entered by a user #主要命令选项，表示使用用户输入的字符串作为密码</p><p>这里使用auto系统自动创建密码</p></blockquote><p><strong>kibana添加ES用户认证</strong></p><p>将上一步创建的账号elastic和密码配置到kibana.yaml</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[czz@localhost kibana]$ vim config/kibana.yml</span><br><span class="line">xpack.security.enabled: true</span><br><span class="line">elasticsearch.username: "elastic"</span><br><span class="line">elasticsearch.password: "bucpN7jkqUUFWr94gciV"</span><br></pre></td></tr></table></figure><p><strong>重启kibana，重启后测试登录kibana</strong></p><p><img src="/2022/08/26/elasticsearch-ji-cheng-openldap/%E5%9B%BE%E7%89%872.png" alt="图片2"></p><p>使用之前创建用户和密码登录</p><h3 id="3-4-ES-接入-OpenLDAP"><a href="#3-4-ES-接入-OpenLDAP" class="headerlink" title="3.4 ES 接入 OpenLDAP"></a>3.4 ES 接入 OpenLDAP</h3><p>OpenLDAP用户和组，结构如下</p><p><img src="/2022/08/26/elasticsearch-ji-cheng-openldap/%E5%9B%BE%E7%89%873.png" alt="图片3"></p><p>修改 elasticsearch.yml 配置文件，接入OpenLDAP认证</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[czz@localhost</span> <span class="string">elasticsearch-6.8.0]$</span> <span class="string">vim</span> <span class="string">config/elasticsearch.yml</span></span><br><span class="line"><span class="string">xpack.security.enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="string">xpack.monitoring.collection.enabled:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="string">xpack.security.authc.realms.ldap1.type:</span> <span class="string">ldap</span></span><br><span class="line"><span class="string">xpack.security.authc.realms.ldap1.order:</span> <span class="number">0</span></span><br><span class="line"><span class="string">xpack.security.authc.realms.ldap1.url:</span> <span class="string">"ldap://192.168.126.145:389"</span></span><br><span class="line"><span class="string">xpack.security.authc.realms.ldap1.bind_dn:</span> <span class="string">"cn=admin,dc=sys,dc=com"</span></span><br><span class="line"><span class="string">xpack.security.authc.realms.ldap1.bind_password:</span> <span class="string">"Abc.123456"</span></span><br><span class="line"><span class="string">xpack.security.authc.realms.ldap1.user_search.base_dn:</span> <span class="string">"ou=sys,dc=sys,dc=com"</span></span><br><span class="line"><span class="string">xpack.security.authc.realms.ldap1.user_search.filter:</span> <span class="string">"(cn=&#123;0&#125;)"</span></span><br><span class="line"><span class="string">xpack.security.authc.realms.ldap1.group_search.base_dn:</span> <span class="string">"cn=Aliyun-UAT-Ops,ou=Aliyun-UAT,ou=elasticsearch,ou=groups,dc=sys,dc=com"</span></span><br><span class="line"><span class="string">xpack.security.authc.realms.ldap1.unmapped_groups_as_roles:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>修改完后需要重启ES服务</p><h3 id="3-5-ES-分配-LDAP-用户权限"><a href="#3-5-ES-分配-LDAP-用户权限" class="headerlink" title="3.5 ES 分配 LDAP 用户权限"></a>3.5 ES 分配 LDAP 用户权限</h3><p>配置 role-mapping 将LDAP的用户和ES 中的role 关联，从而给LDAP中的用户分配权限，更多配置可以参考<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.5/security-api-put-role-mapping.html#_role_templates" target="_blank" rel="noopener">官网</a></p><p><strong>普通用户权限</strong>，为role readuser配置权限，配置可以参考<a href="https://www.alibabacloud.com/help/zh/elasticsearch/latest/use-the-rbac-mechanism-provided-by-elasticsearch-x-pack-to-implement-access-control" target="_blank" rel="noopener">通过Elasticsearch X-Pack角色管理实现用户权限管控</a></p><p><img src="/2022/08/26/elasticsearch-ji-cheng-openldap/%E5%9B%BE%E7%89%874.png" alt="图片4"></p><p>普通用户分配到role</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">POST _xpack/security/role_mapping/ldap_read_user1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"roles"</span>: [ <span class="string">"readuser"</span>,<span class="string">"user"</span> ],</span><br><span class="line">  <span class="attr">"enabled"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"rules"</span>: &#123;</span><br><span class="line">    <span class="attr">"any"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="attr">"field"</span> : &#123; <span class="attr">"username"</span> : [<span class="string">"yu"</span>,<span class="string">"bin"</span>] &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>管理员权限</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">POST _xpack/security/role_mapping/ldap_super_user1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"roles"</span>: [ <span class="string">"superuser"</span> ],</span><br><span class="line">  <span class="attr">"enabled"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"rules"</span>: &#123;</span><br><span class="line">    <span class="attr">"any"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"field"</span>: &#123;</span><br><span class="line">          <span class="attr">"username"</span>: <span class="string">"zhongzhou.chen"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为这里分配权限遇到了问题，无法为ldap中的组分配权限，只能给用户分配权限，导致所有用户都可以登录ES，所以就直接将用户分配到了role，后期如果解决了会在这里更新</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Nov 08 2022 22:51:10 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;
      
    
    </summary>
    
    
      <category term="ElasticSearch" scheme="http://chenzhonzhou.github.io/categories/ElasticSearch/"/>
    
    
      <category term="OpenLDAP" scheme="http://chenzhonzhou.github.io/tags/OpenLDAP/"/>
    
      <category term="ElasticSearch" scheme="http://chenzhonzhou.github.io/tags/ElasticSearch/"/>
    
  </entry>
  
  <entry>
    <title>Grafana 使用SSL加密集成 OpenLDAP</title>
    <link href="http://chenzhonzhou.github.io/2022/08/22/grafana-shi-yong-ssl-jia-mi-ji-cheng-openldap/"/>
    <id>http://chenzhonzhou.github.io/2022/08/22/grafana-shi-yong-ssl-jia-mi-ji-cheng-openldap/</id>
    <published>2022-08-22T01:58:28.000Z</published>
    <updated>2022-08-22T02:57:51.708Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Nov 08 2022 22:51:10 GMT+0800 (GMT+08:00) --><h3 id="准备grafana相应的权限用户组"><a href="#准备grafana相应的权限用户组" class="headerlink" title="准备grafana相应的权限用户组"></a>准备grafana相应的权限用户组</h3><p><img src="/2022/08/22/grafana-shi-yong-ssl-jia-mi-ji-cheng-openldap/%E5%9B%BE%E7%89%871.png" alt="图片1"></p><h3 id="设置ldap配置文件"><a href="#设置ldap配置文件" class="headerlink" title="设置ldap配置文件"></a>设置ldap配置文件</h3><p>ldap使用的是自签发证书</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost grafana]# vim ldap.toml</span><br><span class="line">[log]</span><br><span class="line">mode = 'console'</span><br><span class="line"><span class="meta">#</span><span class="bash">filters = <span class="string">'ldap:debug'</span></span></span><br><span class="line"></span><br><span class="line">[[servers]]</span><br><span class="line">host = "ldap.sys.com"</span><br><span class="line">port = 10636</span><br><span class="line">use_ssl = true</span><br><span class="line">start_tls = false</span><br><span class="line">ssl_skip_verify = true</span><br><span class="line"></span><br><span class="line">bind_dn = "cn=admin,dc=sys,dc=com"</span><br><span class="line">bind_password = 'abc.abc'</span><br><span class="line">timeout = 10</span><br><span class="line"></span><br><span class="line">search_filter = "(cn=%s)"</span><br><span class="line">search_base_dns = ["ou=users,dc=sys,dc=com"]</span><br><span class="line"></span><br><span class="line">group_search_filter = "(&amp;(objectClass=posixGroup)(memberUid=%s))"</span><br><span class="line">group_search_base_dns = ["ou=AWS-UAT,ou=grafana,ou=groups,dc=sys,dc=com"]</span><br><span class="line">group_search_filter_user_attribute = "uid"</span><br><span class="line"></span><br><span class="line">[servers.attributes]</span><br><span class="line">name = "givenName"</span><br><span class="line">surname = "sn"</span><br><span class="line">username = "cn"</span><br><span class="line">member_of = "cn"</span><br><span class="line">email =  "mail"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">admins组的用户分配到Admin权限组</span></span><br><span class="line">[[servers.group_mappings]]</span><br><span class="line">group_dn = "AWS-UAT-Admins"</span><br><span class="line">org_role = "Admin"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">editors组的用户分配到Editor权限组</span></span><br><span class="line">[[servers.group_mappings]]</span><br><span class="line">group_dn = "grafana-editors"</span><br><span class="line">org_role = "Editor"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">viewers组的用户分配到viewer权限组</span></span><br><span class="line">[[servers.group_mappings]]</span><br><span class="line">group_dn = "grafana-viewers"</span><br><span class="line">org_role = "Viewer"</span><br></pre></td></tr></table></figure><p>配置完后重启grafana服务</p><h3 id="测试ldap账户登录"><a href="#测试ldap账户登录" class="headerlink" title="测试ldap账户登录"></a>测试ldap账户登录</h3><p><img src="/2022/08/22/grafana-shi-yong-ssl-jia-mi-ji-cheng-openldap/%E5%9B%BE%E7%89%872.png" alt="图片2"></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Nov 08 2022 22:51:10 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;准备grafana相应的权限用户组&quot;&gt;&lt;a href=&quot;#准备grafana相应的权限用户组&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
      <category term="Grafana" scheme="http://chenzhonzhou.github.io/categories/Grafana/"/>
    
    
      <category term="OpenLDAP" scheme="http://chenzhonzhou.github.io/tags/OpenLDAP/"/>
    
      <category term="Grafana" scheme="http://chenzhonzhou.github.io/tags/Grafana/"/>
    
  </entry>
  
  <entry>
    <title>OpenLDAP 开启SSL/TLS加密通信</title>
    <link href="http://chenzhonzhou.github.io/2022/08/17/openldap-kai-qi-ssl-tls-jia-mi-tong-xin/"/>
    <id>http://chenzhonzhou.github.io/2022/08/17/openldap-kai-qi-ssl-tls-jia-mi-tong-xin/</id>
    <published>2022-08-17T03:34:27.000Z</published>
    <updated>2022-08-25T07:45:59.826Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Nov 08 2022 22:51:11 GMT+0800 (GMT+08:00) --><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><h3 id="Openldap为啥要加密"><a href="#Openldap为啥要加密" class="headerlink" title="Openldap为啥要加密"></a>Openldap为啥要加密</h3><p>​ Openldap默认使用简单验证，对slapd的所有访问都使用明文密码通过未加密通道进行。为了确保信息安全，需要对信息进行加密传输，SSL(Secure Sockets Layer)是一个可靠的解决方案。</p><p>​ 它使用X.509证书，由可信任第三方（Certificate Authority(CA)）进行数字签名的一个标准格式的数据。有效的数字签名意味着已签名的数据没有被篡改。如果签名的数据被更改，将不会通过验证。</p><h3 id="SSL-TLS加密原理简介"><a href="#SSL-TLS加密原理简介" class="headerlink" title="SSL/TLS加密原理简介"></a>SSL/TLS加密原理简介</h3><p>​ SSL/TLS是基于PKI机制的加密方式，包括证书认证、密钥交换、非对称加密、对称加密。SSL/TLS采用CA作为服务端核客户端都信赖的具有权威性的组织，证书的颁发和认证都依赖于CA，并假定CA颁发的证书是可靠的、可信赖的，证书里面的内容是真实的、有效的，并可用于客户机和服务器进行安全的可靠的通信加密。</p><p>​ SSL/TLS证书用来认证服务器和客户机双方的身份，并用于密钥交换的非对称加密。密钥交换完毕之后，就可以用这个密钥做通信数据的对称加密了，具体的加密算法是由客户机和服务器相互协商得来的。服务器和客户机由于SSL/TLS库的不同以及用户的配置不同，双方支持的算法列表不完全相同，当双方做SSL/TLS握手的时候，就需要将自己支持的算法列表以及优先顺序告知对方，一旦对方按照优先顺序找到了第一个支持的算法，那么协商完成，否则双方协商失败，SSL/TLS连接断开。</p><h2 id="二、自生成证书"><a href="#二、自生成证书" class="headerlink" title="二、自生成证书"></a>二、自生成证书</h2><h2 id="2-1-自建-CA-中心"><a href="#2-1-自建-CA-中心" class="headerlink" title="2.1 自建 CA 中心"></a>2.1 自建 CA 中心</h2><h3 id="2-1-1-CA中心生成自身私钥"><a href="#2-1-1-CA中心生成自身私钥" class="headerlink" title="2.1.1 CA中心生成自身私钥"></a>2.1.1 CA中心生成自身私钥</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost openldap]# cd /etc/pki/CA</span><br><span class="line">[root@localhost CA]# openssl genrsa -out private/cakey.pem 2048</span><br><span class="line">Generating RSA private key, 2048 bit long modulus</span><br><span class="line">............+++</span><br><span class="line">....................+++</span><br><span class="line">e is 65537 (0x10001)</span><br></pre></td></tr></table></figure><h3 id="2-1-2-CA签发自身公钥"><a href="#2-1-2-CA签发自身公钥" class="headerlink" title="2.1.2 CA签发自身公钥"></a>2.1.2 CA签发自身公钥</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost CA]# openssl  req -new -x509 -key private/cakey.pem -out cacert.pem -days 3650</span><br><span class="line">You are about to be asked to enter information that will be incorporated</span><br><span class="line">into your certificate request.</span><br><span class="line">What you are about to enter is what is called a Distinguished Name or a DN.</span><br><span class="line">There are quite a few fields but you can leave some blank</span><br><span class="line">For some fields there will be a default value,</span><br><span class="line">If you enter '.', the field will be left blank.</span><br><span class="line">-----</span><br><span class="line">Country Name (2 letter code) [XX]:CN</span><br><span class="line">State or Province Name (full name) []:BeiJing</span><br><span class="line">Locality Name (eg, city) [Default City]:BeiJing</span><br><span class="line">Organization Name (eg, company) [Default Company Ltd]:sys.com</span><br><span class="line">Organizational Unit Name (eg, section) []:Devops</span><br><span class="line">Common Name (eg, your name or your server's hostname) []:ldap.sys.com</span><br><span class="line">Email Address []:ldap@sys.com</span><br></pre></td></tr></table></figure><p>信息可以随便填写，但后面生成LDAP证书的时候需要和这里的信息保持一致</p><h3 id="2-1-3-创建index-txt和serial文件"><a href="#2-1-3-创建index-txt和serial文件" class="headerlink" title="2.1.3 创建index.txt和serial文件"></a>2.1.3 创建index.txt和serial文件</h3><p>index.txt 文件用于存放客户端证书信息，serial 文件用于存放客户端证书编号，可以自定义，用于识别客户端证书</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost CA]# touch serial index.txt</span><br><span class="line">[root@localhost CA]# echo "01" &gt; serial</span><br></pre></td></tr></table></figure><h3 id="2-1-4-使用openssl命令获取证书信息"><a href="#2-1-4-使用openssl命令获取证书信息" class="headerlink" title="2.1.4 使用openssl命令获取证书信息"></a>2.1.4 使用openssl命令获取证书信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost CA]# openssl x509 -noout -text -in /etc/pki/CA/cacert.pem</span><br><span class="line">Certificate:</span><br><span class="line">    Data:</span><br><span class="line">        Version: 3 (0x2)</span><br><span class="line">        Serial Number:</span><br><span class="line">            99:9d:0e:5e:77:51:2c:38</span><br><span class="line">    Signature Algorithm: sha256WithRSAEncryption</span><br><span class="line">        Issuer: C=CN, ST=BeiJing, L=BeiJing, O=sys.com, OU=Devops, CN=ldap.sys.com/emailAddress=ldap@sys.com</span><br><span class="line">        Validity</span><br><span class="line">            Not Before: Aug 17 09:07:28 2022 GMT</span><br><span class="line">            Not After : Aug 14 09:07:28 2032 GMT</span><br><span class="line">        Subject: C=CN, ST=BeiJing, L=BeiJing, O=sys.com, OU=Devops, CN=ldap.sys.com/emailAddress=ldap@sys.com</span><br><span class="line">        Subject Public Key Info:</span><br><span class="line">            Public Key Algorithm: rsaEncryption</span><br><span class="line">                Public-Key: (2048 bit)</span><br><span class="line">                Modulus:</span><br><span class="line">                    00:a6:08:87:0e:0b:cb:85:8b:ef:03:1e:c9:5c:ed:</span><br><span class="line">                    eb:b3:02:77:dd:4d:ad:4b:b5:ca:b3:7c:8c:03:12:</span><br><span class="line">                    63:c5:8c:89:1e:a4:15:c9:4c:c1:68:e0:8c:74:3d:</span><br><span class="line">                    9b:2b:a2:8e:cf:ad:3c:40:42:e7:ff:e8:27:b7:98:</span><br><span class="line">                    73:99:2d:33:b6:c9:39:ce:62:07:cd:ae:65:ea:c2:</span><br><span class="line">                    7a:0a:eb:84:ff:42:db:56:da:e1:6a:ef:fb:fc:29:</span><br><span class="line">                    75:73:1d:00:15:e5:04:f2:fe:d4:4e:f5:00:08:29:</span><br><span class="line">                    b8:f9:89:41:7d:c8:a5:61:ef:10:8f:5d:29:ce:d3:</span><br><span class="line">                    d6:c2:d9:33:4c:ab:e1:d5:49:90:51:b7:3f:a4:6f:</span><br><span class="line">                    7b:6c:2d:1a:8e:8f:73:a6:af:c7:7d:c4:58:7d:36:</span><br><span class="line">                    d4:e7:eb:4c:1a:ba:23:9d:ac:6b:30:54:ba:0a:fb:</span><br><span class="line">                    13:1b:27:7a:a7:f5:ad:3f:e6:be:8b:f7:a3:52:a5:</span><br><span class="line">                    05:23:42:24:56:ba:7d:80:ce:81:fb:00:05:89:19:</span><br><span class="line">                    31:f1:19:66:a7:a8:57:98:5b:5d:b6:9e:4c:bf:a3:</span><br><span class="line">                    15:25:1c:e9:76:cd:84:48:50:0b:e8:f8:cf:df:cb:</span><br><span class="line">                    1e:69:aa:7e:51:73:f6:e8:59:3c:bb:d4:0d:a1:a7:</span><br><span class="line">                    22:3f:54:b2:ae:7c:ea:33:d3:75:64:94:52:aa:2e:</span><br><span class="line">                    b5:33</span><br><span class="line">                Exponent: 65537 (0x10001)</span><br><span class="line">        X509v3 extensions:</span><br><span class="line">            X509v3 Subject Key Identifier:</span><br><span class="line">                15:E1:DF:F5:24:B8:F2:AD:C2:93:0B:92:48:E6:EC:A8:D5:25:88:B8</span><br><span class="line">            X509v3 Authority Key Identifier:</span><br><span class="line">                keyid:15:E1:DF:F5:24:B8:F2:AD:C2:93:0B:92:48:E6:EC:A8:D5:25:88:B8</span><br><span class="line"></span><br><span class="line">            X509v3 Basic Constraints:</span><br><span class="line">                CA:TRUE</span><br><span class="line">    Signature Algorithm: sha256WithRSAEncryption</span><br><span class="line">         01:2e:84:f1:ee:ce:99:b1:77:1b:f3:b4:ab:21:80:8a:8a:04:</span><br><span class="line">         16:23:f9:48:85:d5:db:bf:d1:00:d8:2f:7f:2c:b8:e5:1e:6b:</span><br><span class="line">         0f:f7:10:41:b2:a4:75:84:bf:0b:b6:eb:97:3e:06:07:30:f6:</span><br><span class="line">         c7:f2:6f:9c:ed:9a:0e:70:fd:14:cc:a4:34:b9:ef:a8:69:a7:</span><br><span class="line">         c4:f3:ff:00:b2:2d:c6:ac:3a:35:86:58:25:2a:be:0c:4f:20:</span><br><span class="line">         52:91:98:f3:06:33:79:ce:c7:cb:8c:a2:a3:ca:6d:2a:60:94:</span><br><span class="line">         1d:97:38:d1:f5:55:f6:db:30:ff:67:85:c7:0e:7f:08:eb:88:</span><br><span class="line">         e0:30:b1:f9:6e:01:a8:fa:16:53:53:12:62:af:ca:35:cf:85:</span><br><span class="line">         e2:be:7c:39:70:57:7b:06:19:4a:aa:8a:12:8a:e7:3f:a9:dd:</span><br><span class="line">         11:f4:45:96:6f:1c:82:90:62:bb:24:57:a5:cc:a8:99:96:80:</span><br><span class="line">         8c:48:75:34:94:05:e2:42:9c:64:81:11:d9:f2:1c:c7:c2:4c:</span><br><span class="line">         fa:ad:16:23:7d:ba:a0:26:fc:b5:df:df:5d:34:6d:1c:39:61:</span><br><span class="line">         e2:45:e2:0d:00:22:a2:89:72:d2:25:e0:b0:c0:25:70:8f:bf:</span><br><span class="line">         e3:4c:a9:bd:a5:60:67:d6:d3:77:a2:aa:6e:92:2f:cb:17:fb:</span><br><span class="line">         a4:ef:b2:d3</span><br></pre></td></tr></table></figure><h2 id="2-2-生成-LDAP-证书"><a href="#2-2-生成-LDAP-证书" class="headerlink" title="2.2 生成 LDAP 证书"></a>2.2 生成 LDAP 证书</h2><h3 id="2-2-1-获取LDAP证书"><a href="#2-2-1-获取LDAP证书" class="headerlink" title="2.2.1 获取LDAP证书"></a>2.2.1 获取LDAP证书</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost CA]# mkdir /etc/openldap/ssl</span><br><span class="line">[root@localhost CA]# cd /etc/openldap/ssl</span><br></pre></td></tr></table></figure><p>生成服务端密钥</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ssl]# openssl genrsa -out ldapkey.pem 2048</span><br><span class="line">Generating RSA private key, 2048 bit long modulus</span><br><span class="line">....................................+++</span><br><span class="line">......................................................+++</span><br><span class="line">e is 65537 (0x10001)</span><br></pre></td></tr></table></figure><p>服务端向CA中心申请证书签署请求，相关信息必须和CA所填写一致才可以正常签发</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ssl]# openssl req -new -key ldapkey.pem -out ldap.csr -days 3650</span><br></pre></td></tr></table></figure><h3 id="2-2-2-生成LDAP证书"><a href="#2-2-2-生成LDAP证书" class="headerlink" title="2.2.2 生成LDAP证书"></a>2.2.2 生成LDAP证书</h3><p>CA检测用户请求，通过后生成证书</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ssl]# openssl ca -in ldap.csr -out ldapcert.pem -days 3650</span><br><span class="line">Using configuration from /etc/pki/tls/openssl.cnf</span><br><span class="line">Check that the request matches the signature</span><br><span class="line">Signature ok</span><br><span class="line">Certificate Details:</span><br><span class="line">        Serial Number: 1 (0x1)</span><br><span class="line">        Validity</span><br><span class="line">            Not Before: Aug 17 09:26:34 2022 GMT</span><br><span class="line">            Not After : Aug 14 09:26:34 2032 GMT</span><br><span class="line">        Subject:</span><br><span class="line">            countryName               = CN</span><br><span class="line">            stateOrProvinceName       = BeiJing</span><br><span class="line">            organizationName          = sys.com</span><br><span class="line">            organizationalUnitName    = Devops</span><br><span class="line">            commonName                = ldap.sys.com</span><br><span class="line">            emailAddress              = ldap@sys.com</span><br><span class="line">        X509v3 extensions:</span><br><span class="line">            X509v3 Basic Constraints:</span><br><span class="line">                CA:FALSE</span><br><span class="line">            Netscape Comment:</span><br><span class="line">                OpenSSL Generated Certificate</span><br><span class="line">            X509v3 Subject Key Identifier:</span><br><span class="line">                AD:14:68:D1:B3:1D:4E:34:5A:EA:B0:F5:78:74:C8:51:0B:D8:83:E7</span><br><span class="line">            X509v3 Authority Key Identifier:</span><br><span class="line">                keyid:15:E1:DF:F5:24:B8:F2:AD:C2:93:0B:92:48:E6:EC:A8:D5:25:88:B8</span><br><span class="line"></span><br><span class="line">Certificate is to be certified until Aug 14 09:26:34 2032 GMT (3650 days)</span><br><span class="line">Sign the certificate? [y/n]:y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1 out of 1 certificate requests certified, commit? [y/n]y</span><br><span class="line">Write out database with 1 new entries</span><br><span class="line">Data Base Updated</span><br></pre></td></tr></table></figure><h3 id="2-2-3-验证证书"><a href="#2-2-3-验证证书" class="headerlink" title="2.2.3 验证证书"></a>2.2.3 验证证书</h3><p>成功生成证书后，可以 openssl 验证服务端证书的合法性</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ssl]# openssl verify -CAfile /etc/pki/CA/cacert.pem /etc/openldap/ssl/ldapcert.pem</span><br><span class="line">/etc/openldap/ssl/ldapcert.pem: OK</span><br></pre></td></tr></table></figure><h3 id="2-2-4-准备证书文件"><a href="#2-2-4-准备证书文件" class="headerlink" title="2.2.4 准备证书文件"></a>2.2.4 准备证书文件</h3><p>后面ldap开启SSL需要使用到<code>cacert.pem</code>,<code>ldapcert.pem</code>,<code>ldapkey.pem</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ssl]# cp /etc/pki/CA/cacert.pem /etc/openldap/ssl/</span><br><span class="line">[root@localhost ssl]# ls /etc/openldap/ssl/</span><br><span class="line">cacert.pem  ldapcert.pem  ldap.csr  ldapkey.pem</span><br></pre></td></tr></table></figure><h2 id="三、OpenLDAP-开启-TLS"><a href="#三、OpenLDAP-开启-TLS" class="headerlink" title="三、OpenLDAP 开启 TLS"></a>三、OpenLDAP 开启 TLS</h2><h3 id="3-1-自建-OpenLDAP"><a href="#3-1-自建-OpenLDAP" class="headerlink" title="3.1 自建 OpenLDAP"></a>3.1 自建 OpenLDAP</h3><p>这里以我之前手动部署了一个openldap 2.4.44为例，开启TLS，不需要重新生成数据直接开启TLS认证就行</p><h4 id="3-1-1-创建TLS的ldif配置文件"><a href="#3-1-1-创建TLS的ldif配置文件" class="headerlink" title="3.1.1 创建TLS的ldif配置文件"></a>3.1.1 创建TLS的ldif配置文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost schema]# vim enable_tls.ldif</span><br><span class="line">dn: cn=config</span><br><span class="line">changetype: modify</span><br><span class="line">replace: olcTLSCACertificateFile</span><br><span class="line">olcTLSCACertificateFile: /etc/openldap/ssl/cacert.pem</span><br><span class="line">-</span><br><span class="line">replace: olcTLSCertificateFile</span><br><span class="line">olcTLSCertificateFile: /etc/openldap/ssl/ldapcert.pem</span><br><span class="line">-</span><br><span class="line">replace: olcTLSCertificateKeyFile</span><br><span class="line">olcTLSCertificateKeyFile: /etc/openldap/ssl/ldapkey.pem</span><br><span class="line">-</span><br><span class="line">add: olcTLSVerifyClient</span><br><span class="line">olcTLSVerifyClient: never</span><br></pre></td></tr></table></figure><h4 id="3-1-2-导入ssl配置"><a href="#3-1-2-导入ssl配置" class="headerlink" title="3.1.2 导入ssl配置"></a>3.1.2 导入ssl配置</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost schema]# ldapmodify -Y EXTERNAL -H ldapi:/// -D "cn=admin,dc=sys,dc=com" -w Abc.123456 -f enable_tls.ldif</span><br><span class="line">SASL/EXTERNAL authentication started</span><br><span class="line">SASL username: gidNumber=0+uidNumber=0,cn=peercred,cn=external,cn=auth</span><br><span class="line">SASL SSF: 0</span><br><span class="line">modifying entry "cn=config"</span><br></pre></td></tr></table></figure><h4 id="3-1-3-配置只开启ldaps安全端口"><a href="#3-1-3-配置只开启ldaps安全端口" class="headerlink" title="3.1.3 配置只开启ldaps安全端口"></a>3.1.3 配置只开启ldaps安全端口</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost schema]# vim /etc/sysconfig/slapd</span><br><span class="line">SLAPD_URLS="ldapi:/// ldaps:///"</span><br></pre></td></tr></table></figure><h4 id="3-1-4-重启slapd服务"><a href="#3-1-4-重启slapd服务" class="headerlink" title="3.1.4 重启slapd服务"></a>3.1.4 重启slapd服务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost schema]# systemctl restart slapd</span><br><span class="line">[root@localhost schema]# netstat -ntpl</span><br><span class="line">Active Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name</span><br><span class="line">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      957/sshd</span><br><span class="line">tcp        0      0 127.0.0.1:25            0.0.0.0:*               LISTEN      1152/master</span><br><span class="line">tcp        0      0 0.0.0.0:636             0.0.0.0:*               LISTEN      5650/slapd</span><br></pre></td></tr></table></figure><p>已经开启了636端口</p><h4 id="3-1-5-测试连接"><a href="#3-1-5-测试连接" class="headerlink" title="3.1.5 测试连接"></a>3.1.5 测试连接</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#命令行连接需要开启</span></span></span><br><span class="line">[root@localhost schema]# echo "TLS_REQCERT allow" &gt;&gt; /etc/openldap/ldap.conf</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#测试是否可以匿名访问，关闭匿名访问可以参考我的另一篇OpenLDAP 禁止匿名访问</span></span></span><br><span class="line">[root@localhost schema]# ldapwhoami -v -x -Z</span><br><span class="line">ldap_initialize( &lt;DEFAULT&gt; )</span><br><span class="line">anonymous</span><br><span class="line">Result: Success (0)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#测试连接</span></span></span><br><span class="line">[root@localhost schema]# ldapwhoami -D "cn=admin,dc=sys,dc=com" -w Abc.123456 -H ldaps://192.168.126.145:636 -v</span><br><span class="line">ldap_initialize( ldaps://192.168.126.145:636/??base )</span><br><span class="line">dn:cn=admin,dc=sys,dc=com</span><br><span class="line">Result: Success (0)</span><br><span class="line">[root@localhost schema]#</span><br></pre></td></tr></table></figure><p>可以正常连接ldap，说明配置成功了<br>同时也可以测试当前套接字是否能通过CA的验证</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost schema]# openssl s_client -connect 192.168.126.145:636 -showcerts -state -CAfile /etc/openldap/ssl/cacert.pem</span><br><span class="line">CONNECTED(00000003)</span><br><span class="line">SSL_connect:before/connect initialization</span><br><span class="line">SSL_connect:SSLv2/v3 write client hello A</span><br><span class="line">SSL_connect:SSLv3 read server hello A</span><br><span class="line">depth=1 C = CN, ST = BeiJing, L = BeiJing, O = sys.com, OU = Devops, CN = ldap.sys.com, emailAddress = ldap@sys.com</span><br><span class="line">verify return:1</span><br><span class="line">depth=0 C = CN, ST = BeiJing, O = sys.com, OU = Devops, CN = ldap.sys.com, emailAddress = ldap@sys.com</span><br><span class="line">verify return:1</span><br><span class="line">SSL_connect:SSLv3 read server certificate A</span><br><span class="line">SSL_connect:SSLv3 read server done A</span><br><span class="line">SSL_connect:SSLv3 write client key exchange A</span><br><span class="line">SSL_connect:SSLv3 write change cipher spec A</span><br><span class="line">SSL_connect:SSLv3 write finished A</span><br><span class="line">SSL_connect:SSLv3 flush data</span><br><span class="line">SSL_connect:SSLv3 read server session ticket A</span><br><span class="line">SSL_connect:SSLv3 read finished A</span><br><span class="line">---</span><br><span class="line">Certificate chain</span><br><span class="line"> 0 s:/C=CN/ST=BeiJing/O=sys.com/OU=Devops/CN=ldap.sys.com/emailAddress=ldap@sys.com</span><br><span class="line">   i:/C=CN/ST=BeiJing/L=BeiJing/O=sys.com/OU=Devops/CN=ldap.sys.com/emailAddress=ldap@sys.com</span><br><span class="line">-----BEGIN CERTIFICATE-----</span><br><span class="line">MIID9TCCAt2gAwIBAgIBATANBgkqhkiG9w0BAQsFADCBiDELMAkGA1UEBhMCQ04x</span><br><span class="line">EDAOBgNVBAgMB0JlaUppbmcxEDAOBgNVBAcMB0JlaUppbmcxEDAOBgNVBAoMB3N5</span><br><span class="line">cy5jb20xDzANBgNVBAsMBkRldm9wczEVMBMGA1UEAwwMbGRhcC5zeXMuY29tMRsw</span><br><span class="line">GQYJKoZIhvcNAQkBFgxsZGFwQHN5cy5jb20wHhcNMjIwODE3MDkyNjM0WhcNMzIw</span><br><span class="line">ODE0MDkyNjM0WjB2MQswCQYDVQQGEwJDTjEQMA4GA1UECAwHQmVpSmluZzEQMA4G</span><br><span class="line">A1UECgwHc3lzLmNvbTEPMA0GA1UECwwGRGV2b3BzMRUwEwYDVQQDDAxsZGFwLnN5</span><br><span class="line">cy5jb20xGzAZBgkqhkiG9w0BCQEWDGxkYXBAc3lzLmNvbTCCASIwDQYJKoZIhvcN</span><br><span class="line">AQEBBQADggEPADCCAQoCggEBANLIIW1esDMAfv/WVFMvHWjeOfkzHxj7U3Npi5o6</span><br><span class="line">m/TYY7tklQYVLl+qdXhVyqOFIxPqISDaIov/33ubgI+2QS6YAGUtaXiNLjrd4G5P</span><br><span class="line">yZ1eOMBR567OojiroF6ZX+ukwp/YK1qD/FjY1lhd2PXnqKmKRfD/6JXmx8fPFsXf</span><br><span class="line">OI2dlMzwE7R+A8O02QUkVtm3fPDKOV67wld2dlrr9F0pf7i3CVW8nQr7ys+487a8</span><br><span class="line">jXEI/AwIsLX1tmJxMZBuswJn+Q3If0n4R9agzfTOm+PuTCCOHbDvBQtSnhogLSRy</span><br><span class="line">OZnkEfAZpSVoo8qZ6rTkZdXbkfN10XJvT2E5f7dhZe+Kj9sCAwEAAaN7MHkwCQYD</span><br><span class="line">VR0TBAIwADAsBglghkgBhvhCAQ0EHxYdT3BlblNTTCBHZW5lcmF0ZWQgQ2VydGlm</span><br><span class="line">aWNhdGUwHQYDVR0OBBYEFK0UaNGzHU40Wuqw9Xh0yFEL2IPnMB8GA1UdIwQYMBaA</span><br><span class="line">FBXh3/UkuPKtwpMLkkjm7KjVJYi4MA0GCSqGSIb3DQEBCwUAA4IBAQB1jIRE0C4c</span><br><span class="line">RAsQTkGEr1p+xkhnkIcBm+ryIyLDRDSPBa6Knd00L//VhM0IcIQCWVRG2LwbfVAD</span><br><span class="line">b8EszOVXB5UHPNyOWUO5aO1jzfeCmMw+IIurYW4iLftMRAwKakwpUobdPmgfuDy9</span><br><span class="line">4SrGAbLEAS3nYt/scM6sGJnQ4cCM9E7kGwyM7a2HqB/XKl6bOESTZ2yhtjaOHT32</span><br><span class="line">vzsr5iQAzSf0Kytp63Y3nYewLO/nE5FlBT84c32nMsliBwN7Tl3CSu1844cnJAPE</span><br><span class="line">pZlBZoGKZGWRGDY4Dw1Tk6PxfrmpmGzVoU7NiyshyThBMx/89Mxx7xQgP4zWtWkA</span><br><span class="line">l0Fyzr3jF3z0</span><br><span class="line">-----END CERTIFICATE-----</span><br><span class="line"> 1 s:/C=CN/ST=BeiJing/L=BeiJing/O=sys.com/OU=Devops/CN=ldap.sys.com/emailAddress=ldap@sys.com</span><br><span class="line">   i:/C=CN/ST=BeiJing/L=BeiJing/O=sys.com/OU=Devops/CN=ldap.sys.com/emailAddress=ldap@sys.com</span><br><span class="line">-----BEGIN CERTIFICATE-----</span><br><span class="line">MIID5TCCAs2gAwIBAgIJAJmdDl53USw4MA0GCSqGSIb3DQEBCwUAMIGIMQswCQYD</span><br><span class="line">VQQGEwJDTjEQMA4GA1UECAwHQmVpSmluZzEQMA4GA1UEBwwHQmVpSmluZzEQMA4G</span><br><span class="line">A1UECgwHc3lzLmNvbTEPMA0GA1UECwwGRGV2b3BzMRUwEwYDVQQDDAxsZGFwLnN5</span><br><span class="line">cy5jb20xGzAZBgkqhkiG9w0BCQEWDGxkYXBAc3lzLmNvbTAeFw0yMjA4MTcwOTA3</span><br><span class="line">MjhaFw0zMjA4MTQwOTA3MjhaMIGIMQswCQYDVQQGEwJDTjEQMA4GA1UECAwHQmVp</span><br><span class="line">SmluZzEQMA4GA1UEBwwHQmVpSmluZzEQMA4GA1UECgwHc3lzLmNvbTEPMA0GA1UE</span><br><span class="line">CwwGRGV2b3BzMRUwEwYDVQQDDAxsZGFwLnN5cy5jb20xGzAZBgkqhkiG9w0BCQEW</span><br><span class="line">DGxkYXBAc3lzLmNvbTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAKYI</span><br><span class="line">hw4Ly4WL7wMeyVzt67MCd91NrUu1yrN8jAMSY8WMiR6kFclMwWjgjHQ9myuijs+t</span><br><span class="line">PEBC5//oJ7eYc5ktM7bJOc5iB82uZerCegrrhP9C21ba4Wrv+/wpdXMdABXlBPL+</span><br><span class="line">1E71AAgpuPmJQX3IpWHvEI9dKc7T1sLZM0yr4dVJkFG3P6Rve2wtGo6Pc6avx33E</span><br><span class="line">WH021OfrTBq6I52sazBUugr7Exsneqf1rT/mvov3o1KlBSNCJFa6fYDOgfsABYkZ</span><br><span class="line">MfEZZqeoV5hbXbaeTL+jFSUc6XbNhEhQC+j4z9/LHmmqflFz9uhZPLvUDaGnIj9U</span><br><span class="line">sq586jPTdWSUUqoutTMCAwEAAaNQME4wHQYDVR0OBBYEFBXh3/UkuPKtwpMLkkjm</span><br><span class="line">7KjVJYi4MB8GA1UdIwQYMBaAFBXh3/UkuPKtwpMLkkjm7KjVJYi4MAwGA1UdEwQF</span><br><span class="line">MAMBAf8wDQYJKoZIhvcNAQELBQADggEBAAEuhPHuzpmxdxvztKshgIqKBBYj+UiF</span><br><span class="line">1du/0QDYL38suOUeaw/3EEGypHWEvwu265c+Bgcw9sfyb5ztmg5w/RTMpDS576hp</span><br><span class="line">p8Tz/wCyLcasOjWGWCUqvgxPIFKRmPMGM3nOx8uMoqPKbSpglB2XONH1VfbbMP9n</span><br><span class="line">hccOfwjriOAwsfluAaj6FlNTEmKvyjXPheK+fDlwV3sGGUqqihKK5z+p3RH0RZZv</span><br><span class="line">HIKQYrskV6XMqJmWgIxIdTSUBeJCnGSBEdnyHMfCTPqtFiN9uqAm/LXf3100bRw5</span><br><span class="line">YeJF4g0AIqKJctIl4LDAJXCPv+NMqb2lYGfW03eiqm6SL8sX+6TvstM=</span><br><span class="line">-----END CERTIFICATE-----</span><br><span class="line">---</span><br><span class="line">Server certificate</span><br><span class="line">subject=/C=CN/ST=BeiJing/O=sys.com/OU=Devops/CN=ldap.sys.com/emailAddress=ldap@sys.com</span><br><span class="line">issuer=/C=CN/ST=BeiJing/L=BeiJing/O=sys.com/OU=Devops/CN=ldap.sys.com/emailAddress=ldap@sys.com</span><br><span class="line">---</span><br><span class="line">No client certificate CA names sent</span><br><span class="line">---</span><br><span class="line">SSL handshake has read 2334 bytes and written 607 bytes</span><br><span class="line">---</span><br><span class="line">New, TLSv1/SSLv3, Cipher is AES256-GCM-SHA384</span><br><span class="line">Server public key is 2048 bit</span><br><span class="line">Secure Renegotiation IS supported</span><br><span class="line">Compression: NONE</span><br><span class="line">Expansion: NONE</span><br><span class="line">No ALPN negotiated</span><br><span class="line">SSL-Session:</span><br><span class="line">    Protocol  : TLSv1.2</span><br><span class="line">    Cipher    : AES256-GCM-SHA384</span><br><span class="line">    Session-ID: 47754753CC89AABE4A33D4E89C6C382C3557F074D1F20EE69C5E07CE3284F7B2</span><br><span class="line">    Session-ID-ctx:</span><br><span class="line">    Master-Key: F115E963EF46F2C6608D0DF61CD676404B54B400E081A56E3C49CC2C8C73D74F59F6D524F5B96AD94F8497737848C71E</span><br><span class="line">    Key-Arg   : None</span><br><span class="line">    Krb5 Principal: None</span><br><span class="line">    PSK identity: None</span><br><span class="line">    PSK identity hint: None</span><br><span class="line">    TLS session ticket lifetime hint: 300 (seconds)</span><br><span class="line">    TLS session ticket:</span><br><span class="line">    0000 - e8 74 39 03 64 ab 5b 66-f8 bc 5c e6 1e cc 55 de   .t9.d.[f..\...U.</span><br><span class="line">    0010 - 99 de 08 3c da ef 99 3f-a9 52 13 e6 34 57 ec a5   ...&lt;...?.R..4W..</span><br><span class="line">    0020 - 4f 49 54 77 df 89 66 93-b1 d6 9f f0 76 39 1b 15   OITw..f.....v9..</span><br><span class="line">    0030 - fc 16 a3 fd 23 ad 7f 6d-a7 dc b4 01 89 3c 9e f4   ....#..m.....&lt;..</span><br><span class="line">    0040 - 0a cd d0 80 fe 90 b5 ff-42 03 31 f2 93 5a f7 af   ........B.1..Z..</span><br><span class="line">    0050 - 92 be 04 5e 22 16 3a 0d-36 46 7c 53 c1 6a f3 71   ...^".:.6F|S.j.q</span><br><span class="line">    0060 - e8 00 3c 01 0a d4 0f 23-6d 27 23 fd fc 91 25 a1   ..&lt;....#m'#...%.</span><br><span class="line">    0070 - 15 d5 da ce 95 f3 bb 74-e1 60 6a 3d 7e a9 81 e3   .......t.`j=~...</span><br><span class="line">    0080 - 5d 6c 2e 5d bb 9e 89 26-23 ab 08 99 66 ee 82 f7   ]l.]...&amp;#...f...</span><br><span class="line">    0090 - 37 2f 1c 0b b1 88 47 6f-45 2e ac ca 11 c2 7e 98   7/....GoE.....~.</span><br><span class="line"></span><br><span class="line">    Start Time: 1660732009</span><br><span class="line">    Timeout   : 300 (sec)</span><br><span class="line">    Verify return code: 0 (ok)</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h3 id="3-2-容器-OpenLDAP"><a href="#3-2-容器-OpenLDAP" class="headerlink" title="3.2 容器 OpenLDAP"></a>3.2 容器 OpenLDAP</h3><p>为了节省资源现在很多服务都采用容器方式部署，OpenLDAP也不例可以使用容器运行，这里以2.6.3为例，镜像使用的<code>bitnami/openldap</code> 目前只有这个OpenLDAP镜像在长期更新</p><p>OpenLDAP 2.5版本开始支持很多新功能，像<code>多重身份认证</code>,<code>密码过期提醒</code>等，更多信息可前往<a href="https://www.openldap.org/software/roadmap.html" target="_blank" rel="noopener">官网</a>查看</p><h4 id="3-2-1-创建-OpenLDAP-pvc"><a href="#3-2-1-创建-OpenLDAP-pvc" class="headerlink" title="3.2.1 创建 OpenLDAP pvc"></a>3.2.1 创建 OpenLDAP pvc</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[ec2-user@localhost</span> <span class="string">ldap2.6]$</span> <span class="string">vim</span> <span class="string">openldap-pvc.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">openldap-data-pvc</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">monitor</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  accessModes:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">ReadWriteOnce</span></span><br><span class="line"><span class="attr">  resources:</span></span><br><span class="line"><span class="attr">    requests:</span></span><br><span class="line"><span class="attr">      storage:</span> <span class="number">10</span><span class="string">Gi</span></span><br><span class="line"><span class="attr">  storageClassName:</span> <span class="string">nfs</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">openldap-config-pvc</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">monitor</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  accessModes:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">ReadWriteOnce</span></span><br><span class="line"><span class="attr">  resources:</span></span><br><span class="line"><span class="attr">    requests:</span></span><br><span class="line"><span class="attr">      storage:</span> <span class="number">10</span><span class="string">Gi</span></span><br><span class="line"><span class="attr">  storageClassName:</span> <span class="string">nfs</span></span><br><span class="line"></span><br><span class="line"><span class="string">[ec2-user@localhost</span> <span class="string">ldap2.6]$</span> <span class="string">kubectl</span> <span class="string">apply</span> <span class="bullet">-f</span> <span class="string">openldap-pvc.yaml</span></span><br></pre></td></tr></table></figure><p>注意：根据自己的环境修改<code>storageClassName:</code>存储类名称</p><h4 id="3-2-2-导入-OpenLDAP-证书"><a href="#3-2-2-导入-OpenLDAP-证书" class="headerlink" title="3.2.2 导入 OpenLDAP 证书"></a>3.2.2 导入 OpenLDAP 证书</h4><p>将生成的OpenLDAP证书导入到k8s的secret中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[ec2-user@localhost ssl]$ kubectl create secret generic openldap-certs -nmonitor --from-file=./cacert.pem --from-file=./ldapcert.pem --from-file=./ldapkey.pem</span><br><span class="line">secret/openldap-certs created</span><br><span class="line">[ec2-user@localhost ssl]$ kubectl get secret -nmonitor |grep openldap</span><br><span class="line">openldap-certs                      Opaque                                3      12s</span><br></pre></td></tr></table></figure><h4 id="3-2-3-创建-OpenLDAP-deployment"><a href="#3-2-3-创建-OpenLDAP-deployment" class="headerlink" title="3.2.3 创建 OpenLDAP deployment"></a>3.2.3 创建 OpenLDAP deployment</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[ec2-user@localhost</span> <span class="string">ldap2.6]$</span> <span class="string">vim</span> <span class="string">openldap-deployment.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  annotations:</span></span><br><span class="line">    <span class="string">app.kubernetes.io/alias-name:</span> <span class="string">LDAP</span></span><br><span class="line">    <span class="string">app.kubernetes.io/description:</span> <span class="string">认证中心</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">openldap</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">openldap</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">monitor</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  progressDeadlineSeconds:</span> <span class="number">600</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  revisionHistoryLimit:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      app:</span> <span class="string">openldap</span></span><br><span class="line"><span class="attr">  strategy:</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">Recreate</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">openldap</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - env:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">LDAP_ROOT</span></span><br><span class="line"><span class="attr">          value:</span> <span class="string">dc=sys,dc=com</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">LDAP_ADMIN_USERNAME</span></span><br><span class="line"><span class="attr">          value:</span> <span class="string">admin</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">LDAP_ADMIN_PASSWORD</span></span><br><span class="line"><span class="attr">          value:</span> <span class="number">6</span><span class="meta">&amp;g0hbSRZJovaqjsA</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">LDAP_TLS_CERT_FILE</span></span><br><span class="line"><span class="attr">          value:</span> <span class="string">/opt/bitnami/openldap/certs/ldapcert.pem</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">LDAP_TLS_KEY_FILE</span></span><br><span class="line"><span class="attr">          value:</span> <span class="string">/opt/bitnami/openldap/certs/ldapkey.pem</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">LDAP_TLS_CA_FILE</span></span><br><span class="line"><span class="attr">          value:</span> <span class="string">/opt/bitnami/openldap/certs/cacert.pem</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">LDAP_ENABLE_TLS</span></span><br><span class="line"><span class="attr">          value:</span> <span class="string">"yes"</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">BITNAMI_DEBUG</span></span><br><span class="line"><span class="attr">          value:</span> <span class="string">"true"</span></span><br><span class="line"><span class="attr">        image:</span> <span class="string">bitnami/openldap:2.6.3</span></span><br><span class="line"><span class="attr">        imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line"><span class="attr">        name:</span> <span class="string">openldap</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">1389</span></span><br><span class="line"><span class="attr">          name:</span> <span class="string">tcp-389</span></span><br><span class="line"><span class="attr">          protocol:</span> <span class="string">TCP</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">1636</span></span><br><span class="line"><span class="attr">          name:</span> <span class="string">tcp-636</span></span><br><span class="line"><span class="attr">          protocol:</span> <span class="string">TCP</span></span><br><span class="line"><span class="attr">        resources:</span></span><br><span class="line"><span class="attr">          limits:</span></span><br><span class="line"><span class="attr">            cpu:</span> <span class="number">500</span><span class="string">m</span></span><br><span class="line"><span class="attr">            memory:</span> <span class="number">500</span><span class="string">Mi</span></span><br><span class="line"><span class="attr">          requests:</span></span><br><span class="line"><span class="attr">            cpu:</span> <span class="number">100</span><span class="string">m</span></span><br><span class="line"><span class="attr">            memory:</span> <span class="number">64</span><span class="string">Mi</span></span><br><span class="line"><span class="attr">        terminationMessagePath:</span> <span class="string">/dev/termination-log</span></span><br><span class="line"><span class="attr">        terminationMessagePolicy:</span> <span class="string">File</span></span><br><span class="line"><span class="attr">        volumeMounts:</span></span><br><span class="line"><span class="attr">        - mountPath:</span> <span class="string">/bitnami/openldap/</span></span><br><span class="line"><span class="attr">          name:</span> <span class="string">ldap-data-pvc</span></span><br><span class="line"><span class="attr">        - mountPath:</span> <span class="string">/opt/bitnami/openldap/certs</span></span><br><span class="line"><span class="attr">          name:</span> <span class="string">ldap-certs</span></span><br><span class="line"><span class="attr">      dnsPolicy:</span> <span class="string">ClusterFirst</span></span><br><span class="line"><span class="attr">      restartPolicy:</span> <span class="string">Always</span></span><br><span class="line"><span class="attr">      schedulerName:</span> <span class="string">default-scheduler</span></span><br><span class="line"><span class="attr">      securityContext:</span> <span class="string">&#123;&#125;</span></span><br><span class="line"><span class="attr">      terminationGracePeriodSeconds:</span> <span class="number">30</span></span><br><span class="line"><span class="attr">      volumes:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">ldap-data-pvc</span></span><br><span class="line"><span class="attr">        persistentVolumeClaim:</span></span><br><span class="line"><span class="attr">          claimName:</span> <span class="string">openldap-data-pvc</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">ldap-certs</span></span><br><span class="line"><span class="attr">        secret:</span></span><br><span class="line"><span class="attr">          defaultMode:</span> <span class="number">420</span></span><br><span class="line"><span class="attr">          secretName:</span> <span class="string">openldap-certs</span></span><br><span class="line"></span><br><span class="line"><span class="string">[ec2-user@localhost</span> <span class="string">ldap2.6]$</span> <span class="string">kubectl</span> <span class="string">apply</span> <span class="bullet">-f</span> <span class="string">openldap-deployment.yaml</span></span><br></pre></td></tr></table></figure><h4 id="3-2-4-创建-OpenLDAP-service"><a href="#3-2-4-创建-OpenLDAP-service" class="headerlink" title="3.2.4 创建 OpenLDAP service"></a>3.2.4 创建 OpenLDAP service</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[ec2-user@localhost ldap2.6]$ cat openldap-svc.yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: openldap-svc</span><br><span class="line">  namespace: monitor</span><br><span class="line">  labels:</span><br><span class="line">    app: openldap-svc</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">  - name: tcp-389</span><br><span class="line">    nodePort: 30402</span><br><span class="line">    port: 1389</span><br><span class="line">    protocol: TCP</span><br><span class="line">    targetPort: 1389</span><br><span class="line">  - name: tcp-636</span><br><span class="line">    nodePort: 30381</span><br><span class="line">    port: 1636</span><br><span class="line">    protocol: TCP</span><br><span class="line">    targetPort: 1636</span><br><span class="line">  selector:</span><br><span class="line">    app: openldap</span><br><span class="line">  type: LoadBalancer</span><br><span class="line"></span><br><span class="line">[ec2-user@localhost ldap2.6]$ kubectl apply -f openldap-svc.yaml</span><br></pre></td></tr></table></figure><h4 id="3-2-5-测试连接"><a href="#3-2-5-测试连接" class="headerlink" title="3.2.5 测试连接"></a>3.2.5 测试连接</h4><p>这里使用ldapadmin连接</p><p><img src="/2022/08/17/openldap-kai-qi-ssl-tls-jia-mi-tong-xin/%E5%9B%BE%E7%89%871.png" alt="图片1"></p><p><img src="/2022/08/17/openldap-kai-qi-ssl-tls-jia-mi-tong-xin/%E5%9B%BE%E7%89%872.png" alt="图片2"></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Nov 08 2022 22:51:11 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;
      
    
    </summary>
    
    
      <category term="LDAP" scheme="http://chenzhonzhou.github.io/categories/LDAP/"/>
    
      <category term="OpenLDAP" scheme="http://chenzhonzhou.github.io/categories/LDAP/OpenLDAP/"/>
    
    
      <category term="OpenLDAP" scheme="http://chenzhonzhou.github.io/tags/OpenLDAP/"/>
    
      <category term="LDAP" scheme="http://chenzhonzhou.github.io/tags/LDAP/"/>
    
  </entry>
  
  <entry>
    <title>K8s 中运行OpenLDAP</title>
    <link href="http://chenzhonzhou.github.io/2022/08/03/k8s-zhong-yun-xing-openldap/"/>
    <id>http://chenzhonzhou.github.io/2022/08/03/k8s-zhong-yun-xing-openldap/</id>
    <published>2022-08-03T02:31:12.000Z</published>
    <updated>2022-08-25T07:38:53.930Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Nov 08 2022 22:51:10 GMT+0800 (GMT+08:00) --><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>通常我们会遵循专机专用的原则，单独使用一台服务器运行OpenLDAP，但实际使用到的资源只有几百兆甚至更少，存在一定的资源浪费，而且多出一台服务器也增加了一定的管理成本。这时如果在k8s容器中运行OpenLDAP的话，就能很好的解决这一问题。</p><h2 id="二、部署-OpenLDAP-容器服务"><a href="#二、部署-OpenLDAP-容器服务" class="headerlink" title="二、部署 OpenLDAP 容器服务"></a>二、部署 OpenLDAP 容器服务</h2><h3 id="2-1-创建-PVC"><a href="#2-1-创建-PVC" class="headerlink" title="2.1 创建 PVC"></a>2.1 创建 PVC</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[ec2-user@ip-</span> <span class="string">ldap]$</span> <span class="string">cat</span> <span class="string">openldap-pvc.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">openldap-data-pvc</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">ops</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  accessModes:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">ReadWriteOnce</span></span><br><span class="line"><span class="attr">  resources:</span></span><br><span class="line"><span class="attr">    requests:</span></span><br><span class="line"><span class="attr">      storage:</span> <span class="number">10</span><span class="string">Gi</span></span><br><span class="line"><span class="attr">  storageClassName:</span> <span class="string">nfs</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">openldap-config-pvc</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">ops</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  accessModes:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">ReadWriteOnce</span></span><br><span class="line"><span class="attr">  resources:</span></span><br><span class="line"><span class="attr">    requests:</span></span><br><span class="line"><span class="attr">      storage:</span> <span class="number">10</span><span class="string">Gi</span></span><br><span class="line"><span class="attr">  storageClassName:</span> <span class="string">nfs</span></span><br><span class="line"></span><br><span class="line"><span class="string">[ec2-user@ip-</span> <span class="string">ldap]$</span> <span class="string">kubectl</span> <span class="string">apply</span> <span class="bullet">-f</span> <span class="string">openldap-pvc.yaml</span></span><br></pre></td></tr></table></figure><p>这里使用到了 <code>storageClassName</code> 储存类，可以参照各云厂商创建或自建存储类</p><h3 id="2-2-创建-deployment"><a href="#2-2-创建-deployment" class="headerlink" title="2.2 创建 deployment"></a>2.2 创建 deployment</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[ec2-user@ip-</span> <span class="string">ldap]$</span> <span class="string">cat</span> <span class="string">openldap-deployment.yaml</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">openldap</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">ops</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">openldap</span></span><br><span class="line"><span class="attr">  annotations:</span></span><br><span class="line">    <span class="string">app.kubernetes.io/alias-name:</span> <span class="string">LDAP</span></span><br><span class="line">    <span class="string">app.kubernetes.io/description:</span> <span class="string">认证中心</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      app:</span> <span class="string">openldap</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">openldap</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">openldap</span></span><br><span class="line"><span class="attr">          image:</span> <span class="string">'osixia/openldap:1.5.0'</span></span><br><span class="line"><span class="attr">          ports:</span></span><br><span class="line"><span class="attr">            - name:</span> <span class="string">tcp-389</span></span><br><span class="line"><span class="attr">              containerPort:</span> <span class="number">389</span></span><br><span class="line"><span class="attr">              protocol:</span> <span class="string">TCP</span></span><br><span class="line"><span class="attr">            - name:</span> <span class="string">tcp-636</span></span><br><span class="line"><span class="attr">              containerPort:</span> <span class="number">636</span></span><br><span class="line"><span class="attr">              protocol:</span> <span class="string">TCP</span></span><br><span class="line"><span class="attr">          env:</span></span><br><span class="line"><span class="attr">            - name:</span> <span class="string">LDAP_ORGANISATION</span></span><br><span class="line"><span class="attr">              value:</span> <span class="string">admin</span></span><br><span class="line"><span class="attr">            - name:</span> <span class="string">LDAP_DOMAIN</span></span><br><span class="line"><span class="attr">              value:</span> <span class="string">default.com</span></span><br><span class="line"><span class="attr">            - name:</span> <span class="string">LDAP_ADMIN_PASSWORD</span></span><br><span class="line"><span class="attr">              value:</span> <span class="number">6</span><span class="meta">&amp;g0hbSRZJovaqjsA</span></span><br><span class="line"><span class="attr">            - name:</span> <span class="string">LDAP_CONFIG_PASSWORD</span></span><br><span class="line"><span class="attr">              value:</span> <span class="string">C!DUwyUFZqqQj2&amp;!</span></span><br><span class="line"><span class="attr">            - name:</span> <span class="string">LDAP_BACKEND</span></span><br><span class="line"><span class="attr">              value:</span> <span class="string">mdb</span></span><br><span class="line"><span class="attr">          resources:</span></span><br><span class="line"><span class="attr">            limits:</span></span><br><span class="line"><span class="attr">              cpu:</span> <span class="number">500</span><span class="string">m</span></span><br><span class="line"><span class="attr">              memory:</span> <span class="number">500</span><span class="string">Mi</span></span><br><span class="line"><span class="attr">            requests:</span></span><br><span class="line"><span class="attr">              cpu:</span> <span class="number">100</span><span class="string">m</span></span><br><span class="line"><span class="attr">              memory:</span> <span class="number">100</span><span class="string">Mi</span></span><br><span class="line"><span class="attr">          volumeMounts:</span></span><br><span class="line"><span class="attr">            - name:</span> <span class="string">ldap-config-pvc</span></span><br><span class="line"><span class="attr">              mountPath:</span> <span class="string">/etc/ldap/slapd.d</span></span><br><span class="line"><span class="attr">            - name:</span> <span class="string">ldap-data-pvc</span></span><br><span class="line"><span class="attr">              mountPath:</span> <span class="string">/var/lib/ldap</span></span><br><span class="line"><span class="attr">      volumes:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">ldap-config-pvc</span></span><br><span class="line"><span class="attr">          persistentVolumeClaim:</span></span><br><span class="line"><span class="attr">            claimName:</span> <span class="string">openldap-config-pvc</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">ldap-data-pvc</span></span><br><span class="line"><span class="attr">          persistentVolumeClaim:</span></span><br><span class="line"><span class="attr">            claimName:</span> <span class="string">openldap-data-pvc</span></span><br><span class="line"></span><br><span class="line"><span class="string">[ec2-user@ip-</span> <span class="string">ldap]$</span> <span class="string">kubectl</span> <span class="string">apply</span> <span class="bullet">-f</span> <span class="string">openldap-deployment.yaml</span></span><br></pre></td></tr></table></figure><blockquote><p>这里使用的镜像<code>osixia/openldap:1.5.0</code>对应 OpenLDAP: slapd 2.4.57 版本<br>另外需要注意<code>env</code> 里面配置的参数记得做修改</p></blockquote><h3 id="2-3-创建-svc"><a href="#2-3-创建-svc" class="headerlink" title="2.3 创建 svc"></a>2.3 创建 svc</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[ec2-user@ip-</span> <span class="string">ldap]$</span> <span class="string">cat</span> <span class="string">openldap-svc.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  annotations:</span></span><br><span class="line">    <span class="string">service.beta.kubernetes.io/load-balancer-source-ranges:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/0</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">openldap-svc</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">ops</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">openldap-svc</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">tcp-389</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">389</span></span><br><span class="line"><span class="attr">    protocol:</span> <span class="string">TCP</span></span><br><span class="line"><span class="attr">    targetPort:</span> <span class="number">389</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">tcp-636</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">636</span></span><br><span class="line"><span class="attr">    protocol:</span> <span class="string">TCP</span></span><br><span class="line"><span class="attr">    targetPort:</span> <span class="number">636</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">openldap</span></span><br><span class="line">    </span><br><span class="line"><span class="string">[ec2-user@ip-</span> <span class="string">ldap]$</span> <span class="string">kubectl</span> <span class="string">apply</span> <span class="bullet">-f</span> <span class="string">openldap-svc.yaml</span></span><br></pre></td></tr></table></figure><blockquote><p><code>service.beta.kubernetes.io/load-balancer-source-ranges：</code>是AWS中对Network Load Balancer资源的白名单配置，参见：<a href="https://kubernetes-sigs.github.io/aws-load-balancer-controller/v2.4/guide/service/annotations/#access-control" target="_blank" rel="noopener">https://kubernetes-sigs.github.io/aws-load-balancer-controller/v2.4/guide/service/annotations/#access-control</a></p></blockquote><p>至此，openldap服务就已经部署好了；接下来部署 phpldapadmin 页面用来管理openldap，使用客户端ldap管理工具的话可以跳过下面步骤</p><h2 id="三、部署-phpldap-管理-OpenLDAP"><a href="#三、部署-phpldap-管理-OpenLDAP" class="headerlink" title="三、部署 phpldap 管理 OpenLDAP"></a>三、部署 phpldap 管理 OpenLDAP</h2><h3 id="3-1-创建-phpldap-deploy-svc"><a href="#3-1-创建-phpldap-deploy-svc" class="headerlink" title="3.1 创建 phpldap deploy,svc"></a>3.1 创建 phpldap deploy,svc</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[ec2-user@ip-</span> <span class="string">ldap]$</span> <span class="string">cat</span> <span class="string">openldap-phpldapadmin.yaml</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">ldap-phpldapadmin</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">ops</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">ldap-phpldapadmin</span></span><br><span class="line"><span class="attr">  annotations:</span></span><br><span class="line">    <span class="string">app.kubernetes.io/alias-name:</span> <span class="string">LDAP</span></span><br><span class="line">    <span class="string">app.kubernetes.io/description:</span> <span class="string">LDAP在线工具</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      app:</span> <span class="string">ldap-phpldapadmin</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">ldap-phpldapadmin</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">phpldapadmin</span></span><br><span class="line"><span class="attr">          image:</span> <span class="string">'osixia/phpldapadmin:stable'</span></span><br><span class="line"><span class="attr">          ports:</span></span><br><span class="line"><span class="attr">            - name:</span> <span class="string">tcp-80</span></span><br><span class="line"><span class="attr">              containerPort:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">              protocol:</span> <span class="string">TCP</span></span><br><span class="line"><span class="attr">          env:</span></span><br><span class="line"><span class="attr">            - name:</span> <span class="string">PHPLDAPADMIN_HTTPS</span></span><br><span class="line"><span class="attr">              value:</span> <span class="string">'false'</span></span><br><span class="line"><span class="attr">            - name:</span> <span class="string">PHPLDAPADMIN_LDAP_HOSTS</span></span><br><span class="line"><span class="attr">              value:</span> <span class="string">openldap-svc</span></span><br><span class="line"><span class="attr">          resources:</span></span><br><span class="line"><span class="attr">            limits:</span></span><br><span class="line"><span class="attr">              cpu:</span> <span class="number">500</span><span class="string">m</span></span><br><span class="line"><span class="attr">              memory:</span> <span class="number">500</span><span class="string">Mi</span></span><br><span class="line"><span class="attr">            requests:</span></span><br><span class="line"><span class="attr">              cpu:</span> <span class="number">10</span><span class="string">m</span></span><br><span class="line"><span class="attr">              memory:</span> <span class="number">10</span><span class="string">Mi</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">ldap-phpldapadmin-svc</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">ops</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">ldap-phpldapadmin-svc</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">tcp-80</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">    protocol:</span> <span class="string">TCP</span></span><br><span class="line"><span class="attr">    targetPort:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">ldap-phpldapadmin</span></span><br><span class="line">    </span><br><span class="line"><span class="string">[ec2-user@ip-</span> <span class="string">ldap]$</span> <span class="string">kubectl</span> <span class="string">apply</span> <span class="bullet">-f</span> <span class="string">openldap-phpldapadmin.yaml</span></span><br></pre></td></tr></table></figure><h3 id="3-2-创建-ingress-代理"><a href="#3-2-创建-ingress-代理" class="headerlink" title="3.2 创建 ingress 代理"></a>3.2 创建 ingress 代理</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[ec2-user@ip-</span> <span class="string">ldap]$</span> <span class="string">cat</span> <span class="string">phpldapadmin-ingress.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  annotations:</span></span><br><span class="line">    <span class="string">nginx.ingress.kubernetes.io/whitelist-source-range:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/0</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">phpldap</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">ops</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  rules:</span></span><br><span class="line"><span class="attr">  - host:</span> <span class="string">phpldap.xxx.xxx</span></span><br><span class="line"><span class="attr">    http:</span></span><br><span class="line"><span class="attr">      paths:</span></span><br><span class="line"><span class="attr">      - backend:</span></span><br><span class="line"><span class="attr">          serviceName:</span> <span class="string">ldap-phpldapadmin-svc</span></span><br><span class="line"><span class="attr">          servicePort:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">        path:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">        pathType:</span> <span class="string">Prefix</span></span><br><span class="line"><span class="attr">  tls:</span></span><br><span class="line"><span class="attr">  - hosts:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">phpldap.xxx.xxx</span></span><br><span class="line"><span class="attr">    secretName:</span> <span class="string">xxx.xxx-20220322-20230322-https</span></span><br><span class="line"></span><br><span class="line"><span class="string">[ec2-user@ip-</span> <span class="string">ldap]$</span> <span class="string">kubectl</span> <span class="string">apply</span> <span class="bullet">-f</span> <span class="string">phpldapadmin-ingress.yaml</span></span><br></pre></td></tr></table></figure><h3 id="3-3-访问-phpldapadmin"><a href="#3-3-访问-phpldapadmin" class="headerlink" title="3.3 访问 phpldapadmin"></a>3.3 访问 phpldapadmin</h3><p><strong>login DN:</strong> cn=admin,dc=xxx,dc=com<br><strong>Password:</strong> 系统变量中的：LDAP_ADMIN_PASSWORD</p><p><img src="/2022/08/03/k8s-zhong-yun-xing-openldap/%E5%9B%BE%E7%89%872.png" alt="图片1"></p><p>顺利登录后就可以通过web页面对openldap进行管理了</p><p><img src="/2022/08/03/k8s-zhong-yun-xing-openldap/%E5%9B%BE%E7%89%873.png" alt="图片2"></p><p>这里在登录时还有个小插曲，上面我设置的ldap密码使用了特殊字符在web登录时认证失败，但我通过ldap客户端工具是可以登录的，后来把ldap密码中的特殊字符<code>&amp;</code>换掉就能顺利登录了</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Nov 08 2022 22:51:10 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;
      
    
    </summary>
    
    
      <category term="kubernetes" scheme="http://chenzhonzhou.github.io/categories/kubernetes/"/>
    
    
      <category term="OpenLDAP" scheme="http://chenzhonzhou.github.io/tags/OpenLDAP/"/>
    
      <category term="kubernetes" scheme="http://chenzhonzhou.github.io/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>K8s 容器PodDisruptionBudget 主动驱逐保护</title>
    <link href="http://chenzhonzhou.github.io/2022/06/28/k8s-rong-qi-poddisruptionbudget-zhu-dong-qu-zhu-bao-hu/"/>
    <id>http://chenzhonzhou.github.io/2022/06/28/k8s-rong-qi-poddisruptionbudget-zhu-dong-qu-zhu-bao-hu/</id>
    <published>2022-06-28T07:41:37.000Z</published>
    <updated>2022-06-29T03:14:02.289Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Nov 08 2022 22:51:10 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 Kubernetes 中，为了保证业务不中断或业务SLA不降级，需要将应用进行集群化部署。通过PodDisruptionBudget 控制器可以设置应用POD集群处于运行状态最低个数，也可以设置应用POD集群处于运行状态的最低百分比，这样可以保证在主动销毁应用POD的时候，不会一次性销毁太多的应用POD，从而保证业务不中断或业务SLA不降级。</p><h2 id="PodDisruptionBudget-简介"><a href="#PodDisruptionBudget-简介" class="headerlink" title="PodDisruptionBudget 简介"></a>PodDisruptionBudget 简介</h2><p><code>Pod Disruption Budget</code> (pod 中断 预算) 简称<code>PDB</code>，含义其实是终止pod前通过 <code>labelSelector</code> 机制获取正常运行的<code>pod</code>数目的限制，目的是对<strong><code>自愿中断</code></strong>的保护措施。</p><blockquote><p>Kubernetes version &gt;= 1.7 才支持 <code>PodDisruptionBudget</code></p></blockquote><h2 id="PDB-应用场景"><a href="#PDB-应用场景" class="headerlink" title="PDB 应用场景"></a>PDB 应用场景</h2><p>节点维护或升级时 ( kubectl drain )</p><blockquote><p>注意：如果 Node 状态处于 <code>not ready</code>，PDB 是不会生效，因为 PDB 只能针对<code>自愿中断</code>生效，什么叫 <strong><code>自愿中断</code></strong> 下文介绍。</p></blockquote><h2 id="自愿中断和非自愿中断"><a href="#自愿中断和非自愿中断" class="headerlink" title="自愿中断和非自愿中断"></a>自愿中断和非自愿中断</h2><h3 id="非自愿中断"><a href="#非自愿中断" class="headerlink" title="非自愿中断"></a>非自愿中断</h3><p>Pod 不会消失，直到有人（人类或控制器）将其销毁，或者当出现不可避免的硬件或系统软件错误。</p><p>我们把这些不可避免的情况称为应用的<code>非自愿性中断</code>，例如：</p><ul><li>后端节点物理机的硬件故障</li><li>集群管理员错误地删除虚拟机（实例）</li><li>云提供商或管理程序故障使虚拟机消失</li><li>内核恐慌（kernel panic）</li><li>节点由于集群网络分区而从集群中消失</li><li>由于节点资源不足而将容器逐出</li></ul><p>除资源不足的情况外，大多数用户应该都熟悉以下这些情况；它们不是特定于 Kubernetes 的。</p><h3 id="自愿中断"><a href="#自愿中断" class="headerlink" title="自愿中断"></a>自愿中断</h3><p>包括由应用程序所有者发起的操作和由集群管理员发起的操作，我们称这些情况为<code>自愿中断</code>。</p><p><strong>典型的应用程序所有者操作包括</strong>：</p><ul><li>删除管理该 pod 的 Deployment 或其他控制器</li><li>更新了 Deployment 的 pod 模板导致 pod 重启</li><li>直接删除 pod（意外删除）</li></ul><p><strong>集群管理员操作包括</strong>：</p><ul><li>排空（drain）节点进行修复或升级。</li><li>从集群中排空节点以缩小集群（了解集群自动调节）。</li><li>从节点中移除一个 pod，以允许其他 pod 使用该节点。</li></ul><p>这些操作可能由集群管理员直接执行，也可能由集群管理员或集群托管提供商自动执行。</p><h2 id="PDB-关键参数与注意事项"><a href="#PDB-关键参数与注意事项" class="headerlink" title="PDB 关键参数与注意事项"></a>PDB 关键参数与注意事项</h2><blockquote><p>spec.minAvailable：表示发生自愿中断的过程中，要保证至少可用的Pods数或者百分比<br>spec.maxUnavailable：表示发生自愿中断的过程中，要保证最大不可用的Pods数或者百分比</p></blockquote><p>上面配置只能用来对应 Deployment，RS，RC，StatefulSet的Pods，推荐优先使用 .spec.maxUnavailable。</p><p>在极端的情况下，比如将maxUnavailable设置成0，或者设置成100%，那么就表示不能进行kubectl drain操作。同理将minAvailable设置成100%，或者设置成应用POD集群最大副本数，也表示不能进行kubectl drain操作。</p><p><strong>注意：</strong></p><ul><li>同一个 PDB Object 中不能同时定义 .spec.minAvailable 和 .spec.maxUnavailable。</li><li>前面提到，应用滚动更新时Pod的delete和unavailable虽然也属于自愿中断，但是实际上滚动更新有自己的策略控制（marSurge 和 maxUnavailable），因此PDB不会干预这个过程。</li><li>PDB 只能保证自愿中断时的副本数，比如 evict pod过程中刚好满足 .spec.minAvailable 或 .spec.maxUnavailable，这时某个本来正常的Pod突然因为Node Down(非自愿中断)挂了，那么这个时候实际Pods数就比PDB中要求的少了，因此PDB不是万能的！</li></ul><p>在使用上，如果设置 .spec.minAvailable 为 100% 或者 .spec.maxUnavailable 为 0%，意味着会完全阻止 evict pods 的过程（ Deployment和StatefulSet的滚动更新除外 ）。</p><h2 id="PDB-例子"><a href="#PDB-例子" class="headerlink" title="PDB 例子"></a>PDB 例子</h2><h3 id="定义-minAvailable"><a href="#定义-minAvailable" class="headerlink" title="定义 minAvailable"></a>定义 minAvailable</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">policy/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PodDisruptionBudget</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr"> name:</span> <span class="string">zk-pdb</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr"> minAvailable:</span> <span class="number">2</span>  <span class="comment">#定义存活的zookeeper的pod最少为2个</span></span><br><span class="line"><span class="attr"> selector:</span></span><br><span class="line"><span class="attr">   matchLabels:</span></span><br><span class="line"><span class="attr">     app:</span> <span class="string">zookeeper</span></span><br></pre></td></tr></table></figure><h3 id="定义-maxUnavailable"><a href="#定义-maxUnavailable" class="headerlink" title="定义 maxUnavailable"></a>定义 maxUnavailable</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">policy/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PodDisruptionBudget</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr"> name:</span> <span class="string">zk-pdb</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr"> maxUnavailable:</span> <span class="number">1</span>  <span class="comment">#定义非存活的zookeeper的pod最多为1个</span></span><br><span class="line"><span class="attr"> selector:</span></span><br><span class="line"><span class="attr">   matchLabels:</span></span><br><span class="line"><span class="attr">     app:</span> <span class="string">zookeeper</span></span><br></pre></td></tr></table></figure><p>创建资源清单</p><p>对于PodDisruptionBudget对象，无法直接进行更新操作，只能通过删除和重新创建来完成对PodDisruptionBudget对象的更新。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># kubectl apply -f zk-pdb.yaml</span></span><br></pre></td></tr></table></figure><p>查看状态</p><p>对于PodDisruptionBudget对象，无法直接进行更新操作，只能通过删除和重新创建来完成对PodDisruptionBudget对象的更新。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># kubectl get pdb</span></span><br><span class="line">NAME     MIN-AVAILABLE   ALLOWED-DISRUPTIONS   AGE</span><br><span class="line">zk-pdb   2               1                     7s</span><br></pre></td></tr></table></figure><p>查看详细信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># kubectl describe pdb pdb-demo</span></span><br><span class="line">Name:           zk-pdb</span><br><span class="line">Namespace:      default</span><br><span class="line">Min available:  2</span><br><span class="line">Selector:       app=zookeeper</span><br><span class="line">Status:</span><br><span class="line">    Allowed disruptions:  0</span><br><span class="line">    Current:              0</span><br><span class="line">    Desired:              2</span><br><span class="line">    Total:                0</span><br><span class="line">Events:</span><br><span class="line">  Type    Reason  Age                   From               Message</span><br><span class="line">  ----    ------  ----                  ----               -------</span><br><span class="line">  Normal  NoPods  2m58s (x53 over 28m)  controllermanager  No matching pods found</span><br></pre></td></tr></table></figure><p>通过下面命令查看PodDisruptionBudget对象的详细信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># kubectl get poddisruptionbudgets zk-pdb-o yaml</span></span><br><span class="line"></span><br><span class="line">apiVersion: policy/v1beta1</span><br><span class="line">kind: PodDisruptionBudget</span><br><span class="line">metadata:</span><br><span class="line"> name: zk-pdb</span><br><span class="line">...</span><br><span class="line">status:</span><br><span class="line"> currentHealthy: 3</span><br><span class="line"> desiredHealthy: 3</span><br><span class="line"> disruptedPods: null</span><br><span class="line"> disruptionsAllowed: 1</span><br><span class="line"> expectedPods: 3</span><br><span class="line"> observedGeneration: 1</span><br></pre></td></tr></table></figure><p><strong>官方参考文档</strong>：<a href="https://kubernetes.io/docs/tasks/run-application/configure-pdb/" target="_blank" rel="noopener">https://kubernetes.io/docs/tasks/run-application/configure-pdb/</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Nov 08 2022 22:51:10 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在 Kub
      
    
    </summary>
    
    
      <category term="kubernetes" scheme="http://chenzhonzhou.github.io/categories/kubernetes/"/>
    
    
      <category term="kubernetes" scheme="http://chenzhonzhou.github.io/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>K8s 中运行Zookeeper</title>
    <link href="http://chenzhonzhou.github.io/2022/06/28/k8s-zhong-yun-xing-zookeeper/"/>
    <id>http://chenzhonzhou.github.io/2022/06/28/k8s-zhong-yun-xing-zookeeper/</id>
    <published>2022-06-28T07:38:05.000Z</published>
    <updated>2022-06-28T09:11:09.705Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Nov 08 2022 22:51:10 GMT+0800 (GMT+08:00) --><h3 id="1、zk-的yaml资源文件"><a href="#1、zk-的yaml资源文件" class="headerlink" title="1、zk 的yaml资源文件"></a>1、zk 的yaml资源文件</h3><p>这里使用statefulSet的方式来部署 Zookeeper，它会创建一个ConfigMap，一个Service，一个Headless Service，一个PodDisruptionBudget，一个StatefulSet</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建ConfigMap</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">zk-scripts</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line">    <span class="string">app.kubernetes.io/name:</span> <span class="string">zookeeper</span></span><br><span class="line">    <span class="string">app.kubernetes.io/component:</span> <span class="string">zookeeper</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="string">setup.sh:</span> <span class="string">|-</span></span><br><span class="line">    <span class="comment">#!/bin/bash</span></span><br><span class="line">    <span class="string">if</span> <span class="string">[[</span> <span class="bullet">-f</span> <span class="string">"/bitnami/zookeeper/data/myid"</span> <span class="string">]];</span> <span class="string">then</span></span><br><span class="line">        <span class="string">export</span> <span class="string">ZOO_SERVER_ID="$(cat</span> <span class="string">/bitnami/zookeeper/data/myid)"</span></span><br><span class="line">    <span class="string">else</span></span><br><span class="line">        <span class="string">HOSTNAME="$(hostname</span> <span class="bullet">-s)"</span></span><br><span class="line">        <span class="string">if</span> <span class="string">[[</span> <span class="string">$HOSTNAME</span> <span class="string">=~</span> <span class="string">(.*)-([0-9]+)$</span> <span class="string">]];</span> <span class="string">then</span></span><br><span class="line">            <span class="string">ORD=$&#123;BASH_REMATCH[2]&#125;</span></span><br><span class="line">            <span class="string">export</span> <span class="string">ZOO_SERVER_ID="$((ORD</span> <span class="string">+</span> <span class="number">1</span> <span class="string">))"</span></span><br><span class="line">        <span class="string">else</span></span><br><span class="line">            <span class="string">echo</span> <span class="string">"Failed to get index from hostname $HOST"</span></span><br><span class="line">            <span class="string">exit</span> <span class="number">1</span></span><br><span class="line">        <span class="string">fi</span></span><br><span class="line">    <span class="string">fi</span></span><br><span class="line">    <span class="string">exec</span> <span class="string">/entrypoint.sh</span> <span class="string">/run.sh</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># 创建headless服务</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">zk-headless</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line">    <span class="string">app.kubernetes.io/name:</span> <span class="string">zookeeper</span></span><br><span class="line">    <span class="string">app.kubernetes.io/component:</span> <span class="string">zookeeper</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">ClusterIP</span></span><br><span class="line"><span class="attr">  clusterIP:</span> <span class="string">None</span></span><br><span class="line"><span class="attr">  publishNotReadyAddresses:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">tcp-client</span></span><br><span class="line"><span class="attr">      port:</span> <span class="number">2181</span></span><br><span class="line"><span class="attr">      targetPort:</span> <span class="string">client</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">tcp-follower</span></span><br><span class="line"><span class="attr">      port:</span> <span class="number">2888</span></span><br><span class="line"><span class="attr">      targetPort:</span> <span class="string">follower</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">tcp-election</span></span><br><span class="line"><span class="attr">      port:</span> <span class="number">3888</span></span><br><span class="line"><span class="attr">      targetPort:</span> <span class="string">election</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line">    <span class="string">app.kubernetes.io/name:</span> <span class="string">zookeeper</span></span><br><span class="line">    <span class="string">app.kubernetes.io/component:</span> <span class="string">zookeeper</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># 创建service服务</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">zk</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line">    <span class="string">app.kubernetes.io/name:</span> <span class="string">zookeeper</span></span><br><span class="line">    <span class="string">app.kubernetes.io/component:</span> <span class="string">zookeeper</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">ClusterIP</span></span><br><span class="line"><span class="attr">  sessionAffinity:</span> <span class="string">None</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">tcp-client</span></span><br><span class="line"><span class="attr">      port:</span> <span class="number">2181</span></span><br><span class="line"><span class="attr">      targetPort:</span> <span class="string">client</span></span><br><span class="line"><span class="attr">      nodePort:</span> <span class="literal">null</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">tcp-follower</span></span><br><span class="line"><span class="attr">      port:</span> <span class="number">2888</span></span><br><span class="line"><span class="attr">      targetPort:</span> <span class="string">follower</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">tcp-election</span></span><br><span class="line"><span class="attr">      port:</span> <span class="number">3888</span></span><br><span class="line"><span class="attr">      targetPort:</span> <span class="string">election</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line">    <span class="string">app.kubernetes.io/name:</span> <span class="string">zookeeper</span></span><br><span class="line">    <span class="string">app.kubernetes.io/component:</span> <span class="string">zookeeper</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># 创建PodDisruptionBudget 控制器</span></span><br><span class="line"><span class="comment"># Pod Disruption Budget (pod 中断 预算) 简称PDB，含义其实是终止pod前通过 labelSelector 机制获取正常运行的pod数目的限制，目的是对自愿中断的保护措施</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">policy/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PodDisruptionBudget</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">zookeeper-pod-disruption-budget</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line">      <span class="string">app.kubernetes.io/name:</span> <span class="string">zookeeper</span></span><br><span class="line">      <span class="string">app.kubernetes.io/component:</span> <span class="string">zookeeper</span></span><br><span class="line"><span class="attr">  maxUnavailable:</span> <span class="number">1</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StatefulSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">zk</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line">    <span class="string">app.kubernetes.io/name:</span> <span class="string">zookeeper</span></span><br><span class="line">    <span class="string">app.kubernetes.io/component:</span> <span class="string">zookeeper</span></span><br><span class="line"><span class="attr">    role:</span> <span class="string">zookeeper</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">  podManagementPolicy:</span> <span class="string">Parallel</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line">      <span class="string">app.kubernetes.io/name:</span> <span class="string">zookeeper</span></span><br><span class="line">      <span class="string">app.kubernetes.io/component:</span> <span class="string">zookeeper</span></span><br><span class="line"><span class="attr">  serviceName:</span> <span class="string">zk-headless</span></span><br><span class="line"><span class="attr">  updateStrategy:</span></span><br><span class="line"><span class="attr">    rollingUpdate:</span> <span class="string">&#123;&#125;</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">RollingUpdate</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      annotations:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line">        <span class="string">app.kubernetes.io/name:</span> <span class="string">zookeeper</span></span><br><span class="line">        <span class="string">app.kubernetes.io/component:</span> <span class="string">zookeeper</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      serviceAccountName:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">      affinity:</span></span><br><span class="line"><span class="attr">        podAntiAffinity:</span></span><br><span class="line"><span class="attr">          preferredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line"><span class="attr">            - podAffinityTerm:</span></span><br><span class="line"><span class="attr">                labelSelector:</span></span><br><span class="line"><span class="attr">                  matchLabels:</span></span><br><span class="line">                    <span class="string">app.kubernetes.io/name:</span> <span class="string">zookeeper</span></span><br><span class="line">                    <span class="string">app.kubernetes.io/component:</span> <span class="string">zookeeper</span></span><br><span class="line"><span class="attr">                namespaces:</span></span><br><span class="line"><span class="bullet">                  -</span> <span class="string">"default"</span></span><br><span class="line"><span class="attr">                topologyKey:</span> <span class="string">kubernetes.io/hostname</span></span><br><span class="line"><span class="attr">              weight:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">      securityContext:</span></span><br><span class="line"><span class="attr">        fsGroup:</span> <span class="number">1001</span></span><br><span class="line"><span class="attr">      initContainers:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">zookeeper</span></span><br><span class="line"><span class="attr">          image:</span> <span class="string">bitnami/zookeeper:3.8.0</span></span><br><span class="line"><span class="attr">          imagePullPolicy:</span> <span class="string">"IfNotPresent"</span></span><br><span class="line"><span class="attr">          securityContext:</span></span><br><span class="line"><span class="attr">            runAsNonRoot:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">            runAsUser:</span> <span class="number">1001</span></span><br><span class="line"><span class="attr">          command:</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">/scripts/setup.sh</span></span><br><span class="line"><span class="attr">          resources:</span></span><br><span class="line"><span class="attr">            limits:</span></span><br><span class="line"><span class="attr">              cpu:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">              memory:</span> <span class="number">1</span><span class="string">Gi</span></span><br><span class="line"><span class="attr">            requests:</span></span><br><span class="line"><span class="attr">              cpu:</span> <span class="number">0.1</span></span><br><span class="line"><span class="attr">              memory:</span> <span class="number">128</span><span class="string">Mi</span></span><br><span class="line"><span class="attr">          env:</span></span><br><span class="line"><span class="attr">            - name:</span> <span class="string">BITNAMI_DEBUG</span></span><br><span class="line"><span class="attr">              value:</span> <span class="string">"false"</span></span><br><span class="line"><span class="attr">            - name:</span> <span class="string">ZOO_DATA_LOG_DIR</span></span><br><span class="line"><span class="attr">              value:</span> <span class="string">""</span></span><br><span class="line"><span class="attr">            - name:</span> <span class="string">ZOO_PORT_NUMBER</span></span><br><span class="line"><span class="attr">              value:</span> <span class="string">"2181"</span></span><br><span class="line"><span class="attr">            - name:</span> <span class="string">ZOO_TICK_TIME</span></span><br><span class="line"><span class="attr">              value:</span> <span class="string">"2000"</span></span><br><span class="line"><span class="attr">            - name:</span> <span class="string">ZOO_INIT_LIMIT</span></span><br><span class="line"><span class="attr">              value:</span> <span class="string">"10"</span></span><br><span class="line"><span class="attr">            - name:</span> <span class="string">ZOO_SYNC_LIMIT</span></span><br><span class="line"><span class="attr">              value:</span> <span class="string">"5"</span></span><br><span class="line"><span class="attr">            - name:</span> <span class="string">ZOO_PRE_ALLOC_SIZE</span></span><br><span class="line"><span class="attr">              value:</span> <span class="string">"65536"</span></span><br><span class="line"><span class="attr">            - name:</span> <span class="string">ZOO_SNAPCOUNT</span></span><br><span class="line"><span class="attr">              value:</span> <span class="string">"100000"</span></span><br><span class="line"><span class="attr">            - name:</span> <span class="string">ZOO_MAX_CLIENT_CNXNS</span></span><br><span class="line"><span class="attr">              value:</span> <span class="string">"60"</span></span><br><span class="line"><span class="attr">            - name:</span> <span class="string">ZOO_4LW_COMMANDS_WHITELIST</span></span><br><span class="line"><span class="attr">              value:</span> <span class="string">"srvr, mntr, ruok"</span></span><br><span class="line"><span class="attr">            - name:</span> <span class="string">ZOO_LISTEN_ALLIPS_ENABLED</span></span><br><span class="line"><span class="attr">              value:</span> <span class="string">"no"</span></span><br><span class="line"><span class="attr">            - name:</span> <span class="string">ZOO_AUTOPURGE_INTERVAL</span></span><br><span class="line"><span class="attr">              value:</span> <span class="string">"0"</span></span><br><span class="line"><span class="attr">            - name:</span> <span class="string">ZOO_AUTOPURGE_RETAIN_COUNT</span></span><br><span class="line"><span class="attr">              value:</span> <span class="string">"3"</span></span><br><span class="line"><span class="attr">            - name:</span> <span class="string">ZOO_MAX_SESSION_TIMEOUT</span></span><br><span class="line"><span class="attr">              value:</span> <span class="string">"40000"</span></span><br><span class="line"><span class="attr">            - name:</span> <span class="string">ZOO_SERVERS</span></span><br><span class="line"><span class="attr">              value:</span> <span class="string">zk-0.zk-headless.default.svc.cluster.local:2888:3888::1</span> <span class="string">zk-1.zk-headless.default.svc.cluster.local:2888:3888::2</span> <span class="string">zk-2.zk-headless.default.svc.cluster.local:2888:3888::3</span></span><br><span class="line"><span class="attr">            - name:</span> <span class="string">ZOO_ENABLE_AUTH</span></span><br><span class="line"><span class="attr">              value:</span> <span class="string">"no"</span></span><br><span class="line"><span class="attr">            - name:</span> <span class="string">ZOO_HEAP_SIZE</span></span><br><span class="line"><span class="attr">              value:</span> <span class="string">"1024"</span></span><br><span class="line"><span class="attr">            - name:</span> <span class="string">ZOO_LOG_LEVEL</span></span><br><span class="line"><span class="attr">              value:</span> <span class="string">"ERROR"</span></span><br><span class="line"><span class="attr">            - name:</span> <span class="string">ALLOW_ANONYMOUS_LOGIN</span></span><br><span class="line"><span class="attr">              value:</span> <span class="string">"yes"</span></span><br><span class="line"><span class="attr">            - name:</span> <span class="string">POD_NAME</span></span><br><span class="line"><span class="attr">              valueFrom:</span></span><br><span class="line"><span class="attr">                fieldRef:</span></span><br><span class="line"><span class="attr">                  apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">                  fieldPath:</span> <span class="string">metadata.name</span></span><br><span class="line"><span class="attr">          ports:</span></span><br><span class="line"><span class="attr">            - name:</span> <span class="string">client</span></span><br><span class="line"><span class="attr">              containerPort:</span> <span class="number">2181</span></span><br><span class="line"><span class="attr">            - name:</span> <span class="string">follower</span></span><br><span class="line"><span class="attr">              containerPort:</span> <span class="number">2888</span></span><br><span class="line"><span class="attr">            - name:</span> <span class="string">election</span></span><br><span class="line"><span class="attr">              containerPort:</span> <span class="number">3888</span></span><br><span class="line"><span class="attr">          livenessProbe:</span></span><br><span class="line"><span class="attr">            failureThreshold:</span> <span class="number">6</span></span><br><span class="line"><span class="attr">            initialDelaySeconds:</span> <span class="number">30</span></span><br><span class="line"><span class="attr">            periodSeconds:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">            successThreshold:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">            timeoutSeconds:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">            exec:</span></span><br><span class="line"><span class="attr">              command:</span> <span class="string">['/bin/bash',</span> <span class="string">'-c'</span><span class="string">,</span> <span class="string">'echo "ruok" | timeout 2 nc -w 2 localhost 2181 | grep imok'</span><span class="string">]</span></span><br><span class="line"><span class="attr">          readinessProbe:</span></span><br><span class="line"><span class="attr">            failureThreshold:</span> <span class="number">6</span></span><br><span class="line"><span class="attr">            initialDelaySeconds:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">            periodSeconds:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">            successThreshold:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">            timeoutSeconds:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">            exec:</span></span><br><span class="line"><span class="attr">              command:</span> <span class="string">['/bin/bash',</span> <span class="string">'-c'</span><span class="string">,</span> <span class="string">'echo "ruok" | timeout 2 nc -w 2 localhost 2181 | grep imok'</span><span class="string">]</span></span><br><span class="line"><span class="attr">          volumeMounts:</span></span><br><span class="line"><span class="attr">            - name:</span> <span class="string">scripts</span></span><br><span class="line"><span class="attr">              mountPath:</span> <span class="string">/scripts/setup.sh</span></span><br><span class="line"><span class="attr">              subPath:</span> <span class="string">setup.sh</span></span><br><span class="line"><span class="attr">            - name:</span> <span class="string">zookeeper-data</span></span><br><span class="line"><span class="attr">              mountPath:</span> <span class="string">/bitnami/zookeeper</span></span><br><span class="line"><span class="attr">      volumes:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">scripts</span></span><br><span class="line"><span class="attr">          configMap:</span></span><br><span class="line"><span class="attr">            name:</span> <span class="string">zk-scripts</span></span><br><span class="line"><span class="attr">            defaultMode:</span> <span class="number">0755</span></span><br><span class="line"><span class="attr">  volumeClaimTemplates:</span></span><br><span class="line"><span class="attr">  - metadata:</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">zookeeper-data</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      storageClassName:</span> <span class="string">nfs</span></span><br><span class="line"><span class="attr">      accessModes:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">ReadWriteOnce</span></span><br><span class="line"><span class="attr">      resources:</span></span><br><span class="line"><span class="attr">        requests:</span></span><br><span class="line"><span class="attr">          storage:</span> <span class="number">2</span><span class="string">Gi</span></span><br></pre></td></tr></table></figure><blockquote><p>因为这里使用的镜像<code>bitnami/zookeeper</code>是别人经过调整的，介意的话可以使用k8s 官网的zk yaml部署 <a href="https://kubernetes.io/docs/tutorials/stateful-application/zookeeper/" target="_blank" rel="noopener">https://kubernetes.io/docs/tutorials/stateful-application/zookeeper/</a></p></blockquote><h3 id="2、部署-zk"><a href="#2、部署-zk" class="headerlink" title="2、部署 zk"></a>2、部署 zk</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@001-new ~]$ kubectl apply -f zookeeper.yaml</span><br></pre></td></tr></table></figure><h3 id="3、查看-zk-服务状态"><a href="#3、查看-zk-服务状态" class="headerlink" title="3、查看 zk 服务状态"></a>3、查看 zk 服务状态</h3><p>查看资源清单</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@001-new ~]$ kubectl get po,svc,pdb,pvc|grep zk</span><br><span class="line">pod/zk-0                                      1/1     Running   0          72m</span><br><span class="line">pod/zk-1                                      1/1     Running   0          72m</span><br><span class="line">pod/zk-2                                      1/1     Running   1          72m</span><br><span class="line">service/zk                      ClusterIP   172.21.6.1      &lt;none&gt;        2181/TCP,2888/TCP,3888/TCP   72m</span><br><span class="line">service/zk-headless             ClusterIP   None            &lt;none&gt;        2181/TCP,2888/TCP,3888/TCP   72m</span><br><span class="line">persistentvolumeclaim/zookeeper-data-zk-0   Bound    pvc-beb9b6e9-f6b0-11ec-a9e9-d27996f947d5   2Gi        RWO            nfs   72m</span><br><span class="line">persistentvolumeclaim/zookeeper-data-zk-1   Bound    pvc-bebb5f58-f6b0-11ec-a9e9-d27996f947d5   2Gi        RWO            nfs   72m</span><br><span class="line">persistentvolumeclaim/zookeeper-data-zk-2   Bound    pvc-bebd09ee-f6b0-11ec-a9e9-d27996f947d5   2Gi        RWO            nfs   72m</span><br></pre></td></tr></table></figure><p>查看zk节点状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@001-new ~]$ <span class="keyword">for</span> i <span class="keyword">in</span> 0 1 2;<span class="keyword">do</span> kubectl <span class="built_in">exec</span> zk-<span class="variable">$i</span> -- /opt/bitnami/zookeeper/bin/zkServer.sh status;<span class="keyword">done</span></span><br><span class="line">/opt/bitnami/java/bin/java</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /opt/bitnami/zookeeper/bin/../conf/zoo.cfg</span><br><span class="line">Client port found: 2181. Client address: localhost. Client SSL: <span class="literal">false</span>.</span><br><span class="line">Mode: follower</span><br><span class="line">/opt/bitnami/java/bin/java</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /opt/bitnami/zookeeper/bin/../conf/zoo.cfg</span><br><span class="line">Client port found: 2181. Client address: localhost. Client SSL: <span class="literal">false</span>.</span><br><span class="line">Mode: leader</span><br><span class="line">/opt/bitnami/java/bin/java</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /opt/bitnami/zookeeper/bin/../conf/zoo.cfg</span><br><span class="line">Client port found: 2181. Client address: localhost. Client SSL: <span class="literal">false</span>.</span><br><span class="line">Mode: follower</span><br></pre></td></tr></table></figure><p>让zk节点重新选举</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 模拟当前的leader节点意外下线</span></span><br><span class="line">[root@001-new ~]$ kubectl <span class="built_in">exec</span> -it zk-1 bash</span><br><span class="line">kubectl <span class="built_in">exec</span> [POD] [COMMAND] is DEPRECATED and will be removed <span class="keyword">in</span> a future version. Use kubectl <span class="built_in">exec</span> [POD] -- [COMMAND] instead.</span><br><span class="line">I have no name!@zk-1:/$ /opt/bitnami/zookeeper/bin/zkServer.sh status</span><br><span class="line">/opt/bitnami/java/bin/java</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /opt/bitnami/zookeeper/bin/../conf/zoo.cfg</span><br><span class="line">Client port found: 2181. Client address: localhost. Client SSL: <span class="literal">false</span>.</span><br><span class="line">Mode: leader</span><br><span class="line">I have no name!@zk-1:/$ ps -ef</span><br><span class="line">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class="line">1001         1     0  0 07:06 ?        00:00:06 java -Dzookeeper.log.dir=/opt/bitnami/zookeeper/logs -Dzookeeper.log.file=/opt/bitnami</span><br><span class="line">1001      8877     0  0 08:24 pts/0    00:00:00 bash</span><br><span class="line">1001      8944  8877  0 08:25 pts/0    00:00:00 ps -ef</span><br><span class="line">I have no name!@zk-1:/$ <span class="built_in">kill</span> 1</span><br><span class="line">I have no name!@zk-1:/$ <span class="built_in">command</span> terminated with <span class="built_in">exit</span> code 137</span><br><span class="line">[root@001-new ~]$</span><br><span class="line">[root@001-new ~]$ kubectl get po |grep zk</span><br><span class="line">zk-0                                      1/1     Running   0          79m</span><br><span class="line">zk-1                                      1/1     Running   1          79m</span><br><span class="line">zk-2                                      1/1     Running   1          79m</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次查看zk节点状态</span></span><br><span class="line">[root@001-new ~]$ <span class="keyword">for</span> i <span class="keyword">in</span> 0 1 2;<span class="keyword">do</span> kubectl <span class="built_in">exec</span> zk-<span class="variable">$i</span> -- /opt/bitnami/zookeeper/bin/zkServer.sh status;<span class="keyword">done</span></span><br><span class="line">/opt/bitnami/java/bin/java</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /opt/bitnami/zookeeper/bin/../conf/zoo.cfg</span><br><span class="line">Client port found: 2181. Client address: localhost. Client SSL: <span class="literal">false</span>.</span><br><span class="line">Mode: follower</span><br><span class="line">/opt/bitnami/java/bin/java</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /opt/bitnami/zookeeper/bin/../conf/zoo.cfg</span><br><span class="line">Client port found: 2181. Client address: localhost. Client SSL: <span class="literal">false</span>.</span><br><span class="line">Mode: follower</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /opt/bitnami/zookeeper/bin/../conf/zoo.cfg</span><br><span class="line">/opt/bitnami/java/bin/java</span><br><span class="line">Client port found: 2181. Client address: localhost. Client SSL: <span class="literal">false</span>.</span><br><span class="line">Mode: leader</span><br></pre></td></tr></table></figure><p>获取zk StatefulSet 中每个 Pod 的FQDN域名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@001-new ~]$ <span class="keyword">for</span> i <span class="keyword">in</span> 0 1 2; <span class="keyword">do</span> kubectl <span class="built_in">exec</span> zk-<span class="variable">$i</span> -- hostname -f; <span class="keyword">done</span></span><br><span class="line">zk-0.zk-headless.default.svc.cluster.local</span><br><span class="line">zk-1.zk-headless.default.svc.cluster.local</span><br><span class="line">zk-2.zk-headless.default.svc.cluster.local</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Nov 08 2022 22:51:10 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;1、zk-的yaml资源文件&quot;&gt;&lt;a href=&quot;#1、zk-的yaml资源文件&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
      <category term="kubernetes" scheme="http://chenzhonzhou.github.io/categories/kubernetes/"/>
    
    
      <category term="kubernetes" scheme="http://chenzhonzhou.github.io/tags/kubernetes/"/>
    
      <category term="Zookeeper" scheme="http://chenzhonzhou.github.io/tags/Zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>Gitlab 版本升级</title>
    <link href="http://chenzhonzhou.github.io/2022/04/08/gitlab-ban-ben-sheng-ji/"/>
    <id>http://chenzhonzhou.github.io/2022/04/08/gitlab-ban-ben-sheng-ji/</id>
    <published>2022-04-08T06:19:18.000Z</published>
    <updated>2022-06-22T09:38:26.081Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Nov 08 2022 22:51:10 GMT+0800 (GMT+08:00) --><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>由于gitlab使用的 13.5.3版本有 CVE-2021-22205 漏洞，需要升级到稳定版本13.8.8</p><h2 id="二、升级流程"><a href="#二、升级流程" class="headerlink" title="二、升级流程"></a>二、升级流程</h2><p>先查看<a href="https://docs.gitlab.com/ee/update/#upgrade-paths" target="_blank" rel="noopener">官网</a>的版本升级路线，13.5.3可以直接升级13.8.8</p><h3 id="2-1-备份原gitlab数据"><a href="#2-1-备份原gitlab数据" class="headerlink" title="2.1 备份原gitlab数据"></a>2.1 备份原gitlab数据</h3><p>升级前备份原gitlab文件</p><blockquote><p>/etc/gitlab/gitlab.rb 该文件配置了gitlab的域名、邮件发送信息、白名单等相关信息。<br>/etc/gitlab/gitlab-secrets.json 该文件存储了gitlab的db secret信息。如果丢失，那么使用双重身份验证的GitLab用户将无法访问GitLab服务器，而存储在GitLab中的 <strong><code>安全变量</code></strong>将被丢失。</p></blockquote><p>使用 gitlab-rake 备份gitlab数据，可忽略因为升级过程中会自动进行备份</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># gitlab-rake gitlab:backup:create</span></span><br><span class="line"></span><br><span class="line">默认备份文件存储在/var/opt/gitlab/backups，若该目录下不存在，则需要查看/etc/gitlab/gitlab.rb配置中对应的gitlab_rails[<span class="string">'backup_path'</span>]选项所指定的目录。</span><br></pre></td></tr></table></figure><h3 id="2-2-部署新版本的gitlab服务"><a href="#2-2-部署新版本的gitlab服务" class="headerlink" title="2.2 部署新版本的gitlab服务"></a>2.2 部署新版本的gitlab服务</h3><p>关闭部分gitlab服务（不要全关，因为升级中可能需要部分服务）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> gitlab-ctl stop unicorn</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> gitlab-ctl stop sidekiq</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> gitlab-ctl stop nginx</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">升级</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> yum install -y gitlab-ee-13.8.8</span></span><br></pre></td></tr></table></figure><p>按升级路线版本进行部署，安装源可以使用<a href="https://packages.gitlab.com/gitlab/" target="_blank" rel="noopener">gitlab官方源</a></p><h3 id="2-3-重启gitlab服务"><a href="#2-3-重启gitlab服务" class="headerlink" title="2.3 重启gitlab服务"></a>2.3 重启gitlab服务</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">刷新配置</span><br><span class="line"><span class="meta">#</span><span class="bash"> gitlab-ctl reconfigure</span></span><br><span class="line"></span><br><span class="line">重启gitlab服务</span><br><span class="line"><span class="meta">#</span><span class="bash"> gitlab-ctl restart</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>如果跨多个大版本需要按版本升级路线中的版本，重复2.2、2.3步骤，升级到目标版本</strong></p></blockquote><h3 id="2-4-设置gitlab定时备份"><a href="#2-4-设置gitlab定时备份" class="headerlink" title="2.4 设置gitlab定时备份"></a>2.4 设置gitlab定时备份</h3><p>修改 <code>/etc/gitlab/gitlab.rb</code> 文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置备份存储位置</span></span><br><span class="line"><span class="string">gitlab_rails['backup_path']</span> <span class="string">=</span> <span class="string">"/mnt/udisk/gitlab/backups"</span></span><br><span class="line"><span class="comment"># 备份最近七天的数据，即 7*24*60*60 秒</span></span><br><span class="line"><span class="string">gitlab_rails['backup_keep_time']</span> <span class="string">=</span> <span class="number">604800</span></span><br></pre></td></tr></table></figure><p>保存后，刷新配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitlab-ctl reconfigure</span><br></pre></td></tr></table></figure><p>编辑定时任务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab -e</span><br></pre></td></tr></table></figure><p>加入以下内容后保存(每天中午 12 点和傍晚 18 点自动执行备份操作)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 12 * * * /opt/gitlab/bin/gitlab-rake gitlab:backup:create SKIP=uploads,builds,artifacts,lfs,registry,pages</span><br></pre></td></tr></table></figure><p>保存后需要重新启动定时器，执行如下语句</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重启定时任务</span></span><br><span class="line">systemctl restart crond.service</span><br><span class="line"><span class="comment"># 重装定时任务</span></span><br><span class="line">systemctl reload crond.service</span><br><span class="line"><span class="comment"># 查看定时任务是否开启（可选）</span></span><br><span class="line">systemctl is-enabled crond.service</span><br><span class="line"><span class="comment"># 查看所有用户下的定时任务（可选）</span></span><br><span class="line">cat /etc/passwd | cut -f 1 -d : |xargs -I &#123;&#125; crontab -l -u &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="三、迁移流程"><a href="#三、迁移流程" class="headerlink" title="三、迁移流程"></a>三、迁移流程</h2><p>迁移并非是升级gitlab服务的版本，而是将gitlab从一台服务器迁移到另一台服务器的过程，并且要保持迁移前后gitlab的版本一致否则在还原数据的时候会报错。</p><h3 id="3-1-备份原gitlab数据"><a href="#3-1-备份原gitlab数据" class="headerlink" title="3.1 备份原gitlab数据"></a>3.1 备份原gitlab数据</h3><p>迁移前备份原gitlab文件</p><blockquote><p>/etc/gitlab/gitlab.rb 该文件配置了gitlab的域名、邮件发送信息、白名单等相关信息。<br>/etc/gitlab/gitlab-secrets.json 该文件存储了gitlab的db secret信息。如果丢失，那么使用双重身份验证的GitLab用户将无法访问GitLab服务器，而存储在GitLab中的 <strong><code>安全变量</code></strong>将被丢失。</p></blockquote><p>使用 gitlab-rake 备份gitlab数据</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># gitlab-rake gitlab:backup:create</span></span><br></pre></td></tr></table></figure><h3 id="3-2-部署新版本的gitlab服务"><a href="#3-2-部署新版本的gitlab服务" class="headerlink" title="3.2 部署新版本的gitlab服务"></a>3.2 部署新版本的gitlab服务</h3><p>安装源可以使用<a href="https://packages.gitlab.com/gitlab/" target="_blank" rel="noopener">gitlab官方源</a></p><h3 id="3-3-还原gitlab数据"><a href="#3-3-还原gitlab数据" class="headerlink" title="3.3 还原gitlab数据"></a>3.3 还原gitlab数据</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">还原gitlab数据</span><br><span class="line"><span class="meta">#</span><span class="bash"> gitlab-rake gitlab:backup:restore BACKUP=1649181808_2022_04_06_13.5.3-ee</span></span><br><span class="line"></span><br><span class="line">将备份的gitlab-secrets.json、gitlab.rb文件拷贝回/etc/gitlab/ 目录下</span><br><span class="line"></span><br><span class="line">刷新配置</span><br><span class="line"><span class="meta">#</span><span class="bash"> gitlab-ctl reconfigure</span></span><br><span class="line"></span><br><span class="line">重启gitlab服务</span><br><span class="line"><span class="meta">#</span><span class="bash"> gitlab-ctl restart</span></span><br></pre></td></tr></table></figure><p>至此gitlab迁移就已完成，jenkins进行CI/CD的时候可能会出现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Host key verification failed.</span><br><span class="line">fatal: Could not read from remote repository.</span><br></pre></td></tr></table></figure><p>需要手动克隆一下代码，然后在gitlab对应项目的 Settings –&gt; Repository –&gt; Deploy Keys 中允许jenkins服务器，只需要手动克隆一个项目即可。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Nov 08 2022 22:51:10 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; title=&quot;一、简介&quot;&gt;&lt;/a&gt;一、简介&lt;/h2&gt;
      
    
    </summary>
    
    
      <category term="版本库服务" scheme="http://chenzhonzhou.github.io/categories/%E7%89%88%E6%9C%AC%E5%BA%93%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="Gitlab" scheme="http://chenzhonzhou.github.io/categories/%E7%89%88%E6%9C%AC%E5%BA%93%E6%9C%8D%E5%8A%A1/Gitlab/"/>
    
    
      <category term="Gitlab" scheme="http://chenzhonzhou.github.io/tags/Gitlab/"/>
    
      <category term="版本库服务" scheme="http://chenzhonzhou.github.io/tags/%E7%89%88%E6%9C%AC%E5%BA%93%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Linux 升级内核版本</title>
    <link href="http://chenzhonzhou.github.io/2022/03/09/linux-sheng-ji-nei-he-ban-ben/"/>
    <id>http://chenzhonzhou.github.io/2022/03/09/linux-sheng-ji-nei-he-ban-ben/</id>
    <published>2022-03-09T08:33:11.000Z</published>
    <updated>2022-03-16T10:08:44.873Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Nov 08 2022 22:51:11 GMT+0800 (GMT+08:00) --><h3 id="小版本升级"><a href="#小版本升级" class="headerlink" title="小版本升级"></a>小版本升级</h3><p>5.10.75 升级到 5.10.96，这里以AWS服务器为例</p><p>查看当前内核版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> uname -sr</span></span><br></pre></td></tr></table></figure><p>查看可以升级的内核版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> yum list kernel -q</span></span><br><span class="line">Installed Packages</span><br><span class="line">kernel.x86_64       5.10.75-79.358.amzn2        installed</span><br><span class="line">Available Packages</span><br><span class="line">kernel.x86_64       5.10.96-90.460.amzn2        @amzn2extra-kernel-5.10</span><br></pre></td></tr></table></figure><p>安装新版本内核</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> yum install kernel-5.10.96-90.460.amzn2</span></span><br></pre></td></tr></table></figure><p>查看系统可用内核，并设置启动顺序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> rpm -q kernel</span></span><br><span class="line"></span><br><span class="line">查看启动顺序</span><br><span class="line"><span class="meta">#</span><span class="bash"> awk -F\<span class="string">' '</span><span class="variable">$1</span>==<span class="string">"menuentry "</span> &#123;<span class="built_in">print</span> i++ <span class="string">" : "</span> <span class="variable">$2</span>&#125;<span class="string">' /boot/grub2/grub.cfg</span></span></span><br><span class="line">0 : Amazon Linux (5.10.96-90.460.amzn2.x86_64) 2</span><br><span class="line">1 : Amazon Linux (5.10.75-79.358.amzn2.x86_64) 2</span><br></pre></td></tr></table></figure><p>已经自动将新内核设置为默认启动项了</p><p>重启系统生效</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> reboot</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>手动设置内核启动项，例如设置 1为默认启动项</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> yum install grub2-pc</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> grub2-set-default 1</span></span><br></pre></td></tr></table></figure><p>生成 grub 配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> grub2-mkconfig -o /boot/grub2/grub.cfg </span></span><br></pre></td></tr></table></figure><p>重启系统</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> reboot</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="大版本升级"><a href="#大版本升级" class="headerlink" title="大版本升级"></a>大版本升级</h3><p>4.x 升级到 5.x</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">查看当前内核版本</span><br><span class="line"><span class="meta">#</span><span class="bash"> uname -sr</span></span><br><span class="line">Linux 4.14.248-189.473.el7.x86_64</span><br><span class="line"></span><br><span class="line">查看操作系统版本</span><br><span class="line"><span class="meta">#</span><span class="bash"> cat /etc/redhat-release</span></span><br><span class="line">CentOS Linux release 7.9.2009 (Core)</span><br><span class="line"></span><br><span class="line">导入 ELRepo 仓库的公共密钥</span><br><span class="line"><span class="meta">#</span><span class="bash"> rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org</span></span><br><span class="line"></span><br><span class="line">安装 ELRepo 仓库的 yum 源</span><br><span class="line"><span class="meta">#</span><span class="bash"> yum install -y https://www.elrepo.org/elrepo-release-7.el7.elrepo.noarch.rpm</span></span><br><span class="line"></span><br><span class="line">替换为清华 ELRepo 源</span><br><span class="line"><span class="meta">#</span><span class="bash"> sed -i <span class="string">"s/mirrorlist=/#mirrorlist=/g"</span> /etc/yum.repos.d/elrepo.repo</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> sed -i <span class="string">"s#elrepo.org/linux#mirrors.tuna.tsinghua.edu.cn/elrepo#g"</span> /etc/yum.repos.d/elrepo.repo</span></span><br><span class="line"></span><br><span class="line">更新 yum 缓存</span><br><span class="line"><span class="meta">#</span><span class="bash"> yum makecache</span></span><br><span class="line"></span><br><span class="line">查看可用的内核版本，kernel-ml（mainline stable）：稳定主线版本，kernel-lt（long term support）：长期支持版本</span><br><span class="line"><span class="meta">#</span><span class="bash"> yum --disablerepo=<span class="string">"*"</span> --enablerepo=<span class="string">"elrepo-kernel"</span> list available</span></span><br><span class="line">已加载插件：fastestmirror, langpacks</span><br><span class="line">Repository base is listed more than once in the configuration</span><br><span class="line">Repository updates is listed more than once in the configuration</span><br><span class="line">Repository extras is listed more than once in the configuration</span><br><span class="line">Repository centosplus is listed more than once in the configuration</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line"> * elrepo-kernel: linux-mirrors.fnal.gov</span><br><span class="line">可安装的软件包</span><br><span class="line">kernel-lt.x86_64                           5.4.127-1.el7.elrepo          elrepo-kernel</span><br><span class="line">kernel-lt-devel.x86_64                     5.4.127-1.el7.elrepo          elrepo-kernel</span><br><span class="line">kernel-lt-doc.noarch                       5.4.127-1.el7.elrepo          elrepo-kernel</span><br><span class="line">kernel-lt-headers.x86_64                   5.4.127-1.el7.elrepo          elrepo-kernel</span><br><span class="line">kernel-lt-tools.x86_64                     5.4.127-1.el7.elrepo          elrepo-kernel</span><br><span class="line">kernel-lt-tools-libs.x86_64                5.4.127-1.el7.elrepo          elrepo-kernel</span><br><span class="line">kernel-lt-tools-libs-devel.x86_64          5.4.127-1.el7.elrepo          elrepo-kernel</span><br><span class="line">kernel-ml.x86_64                           5.12.12-1.el7.elrepo          elrepo-kernel</span><br><span class="line">kernel-ml-devel.x86_64                     5.12.12-1.el7.elrepo          elrepo-kernel</span><br><span class="line">kernel-ml-doc.noarch                       5.12.12-1.el7.elrepo          elrepo-kernel</span><br><span class="line">kernel-ml-headers.x86_64                   5.12.12-1.el7.elrepo          elrepo-kernel</span><br><span class="line">kernel-ml-tools.x86_64                     5.12.12-1.el7.elrepo          elrepo-kernel</span><br><span class="line">kernel-ml-tools-libs.x86_64                5.12.12-1.el7.elrepo          elrepo-kernel</span><br><span class="line">kernel-ml-tools-libs-devel.x86_64          5.12.12-1.el7.elrepo          elrepo-kernel</span><br><span class="line">perf.x86_64                                5.12.12-1.el7.elrepo          elrepo-kernel</span><br><span class="line">python-perf.x86_64                         5.12.12-1.el7.elrepo          elrepo-kernel</span><br><span class="line"></span><br><span class="line">升级为主线版本</span><br><span class="line"><span class="meta">#</span><span class="bash"> yum --enablerepo=elrepo-kernel install kernel-ml -y</span></span><br></pre></td></tr></table></figure><p>配置开机加载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">查看可用内核版本及启动顺序</span><br><span class="line"><span class="meta">#</span><span class="bash"> awk -F\<span class="string">' '</span><span class="variable">$1</span>==<span class="string">"menuentry "</span> &#123;<span class="built_in">print</span> i++ <span class="string">" : "</span> <span class="variable">$2</span>&#125;<span class="string">' /boot/grub2/grub.cfg</span></span></span><br><span class="line"></span><br><span class="line">查看启动顺序</span><br><span class="line"><span class="meta">#</span><span class="bash"> yum install grub2-pc</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> grub2-editenv list</span></span><br><span class="line"></span><br><span class="line">设置开机启动</span><br><span class="line"><span class="meta">#</span><span class="bash"> grub2-set-default 0</span></span><br><span class="line">或者</span><br><span class="line"><span class="meta">#</span><span class="bash"> grub2-mkconfig -o /boot/grub2/grub.cfg</span></span><br><span class="line"></span><br><span class="line">重启生效</span><br><span class="line"><span class="meta">#</span><span class="bash"> reboot</span></span><br><span class="line"></span><br><span class="line">重启后查看内核版本</span><br><span class="line"><span class="meta">#</span><span class="bash"> uname -sr</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Nov 08 2022 22:51:11 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;小版本升级&quot;&gt;&lt;a href=&quot;#小版本升级&quot; class=&quot;headerlink&quot; title=&quot;小版本升级&quot;&gt;&lt;/a&gt;小版本升级&lt;
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://chenzhonzhou.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://chenzhonzhou.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>k8s Helm3部署和使用</title>
    <link href="http://chenzhonzhou.github.io/2022/02/16/k8s-helm-bu-shu-he-shi-yong/"/>
    <id>http://chenzhonzhou.github.io/2022/02/16/k8s-helm-bu-shu-he-shi-yong/</id>
    <published>2022-02-16T06:43:49.000Z</published>
    <updated>2022-03-22T07:00:32.149Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Nov 08 2022 22:51:11 GMT+0800 (GMT+08:00) --><h2 id="一、Helm-介绍"><a href="#一、Helm-介绍" class="headerlink" title="一、Helm 介绍"></a>一、Helm 介绍</h2><p>没有使用Helm之前，在Kubernetes部署应用，我们要依次部署deployment、service等，步骤比较繁琐。况且随着很多项目微服务化，复杂的应用在容器中部署以及管理显得较为复杂。</p><blockquote><p>helm通过打包的方式，支持发布的版本管理和控制，很大程度上简化了Kubernetes应用的部署和管理。</p></blockquote><p>Helm本质就是让k8s的应用管理（Deployment、Service等）可配置，能动态生成。通过动态生成K8S资源清单文件（deployment.yaml、service.yaml）。然后kubectl自动调用K8S资源部署。</p><blockquote><p>Helm是官方提供类似于YUM的包管理，是部署环境的流程封装，Helm有三个重要的概念：chart、release和Repository</p></blockquote><ul><li>chart是创建一个应用的信息集合，包括各种Kubernetes对象的配置模板、参数定义、依赖关系、文档说明等。可以将chart想象成apt、yum中的软件安装包。</li><li>release是chart的运行实例，代表一个正在运行的应用。当chart被安装到Kubernetes集群，就生成一个release。chart能多次安装到同一个集群，每次安装都是一个release【根据chart赋值不同，完全可以部署出多个release出来】。</li><li>Repository用于发布和存储 Chart 的存储库。</li></ul><blockquote><p><strong>Helm包含两个组件：Helm客户端和Tiller服务端，如下图所示：</strong></p></blockquote><p><img src="/2022/02/16/k8s-helm-bu-shu-he-shi-yong/%E5%9B%BE%E7%89%871.png" alt="图片1"></p><p><strong>Helm</strong> 客户端 负责 chart 和 release 的创建和管理以及和 Tiller 的交互。<br><strong>Tiller</strong> 服务端 运行在 Kubernetes 集群中，它会处理Helm客户端的请求，与 Kubernetes API Server 交互（在heml3中已弃用 Tiller）。<br><strong>KubeAPI</strong> 将数据、资源得生成写入到 etcd ，被 kubelet 接受并创建。</p><h2 id="二、Helm-部署"><a href="#二、Helm-部署" class="headerlink" title="二、Helm 部署"></a>二、Helm 部署</h2><p>Helm由客户端命令helm工具和服务端tiller组成。</p><p>部署前可以前往help官网查看 <a href="https://helm.sh/zh/docs/topics/version_skew/" target="_blank" rel="noopener">Helm支持的 <strong>Kubernetes</strong> 版本</a> （不推荐将Helm用于比编译它所依赖的版本更高的Kubernetes版本，因为Helm并没有做出任何向前兼容的保证）。</p><h3 id="2-1-安装-helm"><a href="#2-1-安装-helm" class="headerlink" title="2.1 安装 helm"></a>2.1 安装 helm</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@czz ~]# wget https://get.helm.sh/helm-v3.8.0-linux-amd64.tar.gz</span><br><span class="line">[root@czz ~]# tar xf helm-v3.8.1-linux-amd64.tar.gz</span><br><span class="line">[root@czz ~]# mv linux-amd64/helm /usr/local/bin/helm</span><br></pre></td></tr></table></figure><p>或使用脚本安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL -o get_helm.sh https://raw.githubusercontent.com/helm/helm/master/scripts/get-helm-3</span><br><span class="line">chmod 700 get_helm.sh</span><br><span class="line">./get_helm.sh</span><br></pre></td></tr></table></figure><h3 id="2-2-验证-helm"><a href="#2-2-验证-helm" class="headerlink" title="2.2 验证 helm"></a>2.2 验证 helm</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@czz ~]# helm version</span><br><span class="line">version.BuildInfo&#123;Version:"v3.8.1", GitCommit:"5cb9af4b1b271d11d7a97a71df3ac337dd94ad37", GitTreeState:"clean", GoVersion:"go1.17.5"&#125;</span><br></pre></td></tr></table></figure><h2 id="三、使用-helm-部署应用"><a href="#三、使用-helm-部署应用" class="headerlink" title="三、使用 helm 部署应用"></a>三、使用 helm 部署应用</h2><h3 id="3-1-使用-helm-源部署"><a href="#3-1-使用-helm-源部署" class="headerlink" title="3.1 使用 helm 源部署"></a>3.1 使用 helm 源部署</h3><h4 id="3-1-添加-chart-源"><a href="#3-1-添加-chart-源" class="headerlink" title="3.1 添加 chart 源"></a>3.1 添加 chart 源</h4><p>准备好 helm 后，需要添加 helm 源数据仓库。有以下几个常见的源库</p><blockquote><p><a href="https://kubernetes-charts.storage.googleapis.com/" target="_blank" rel="noopener">https://kubernetes-charts.storage.googleapis.com/</a> helm官网 chart 库，稳定<br><a href="https://apphub.aliyuncs.com" target="_blank" rel="noopener">https://apphub.aliyuncs.com</a> 阿里云chart 库，速度最快</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@czz ~]# helm repo add aliyun https://apphub.aliyuncs.com</span><br><span class="line">"aliyun" has been added to your repositories</span><br></pre></td></tr></table></figure><h4 id="3-2-安装一个-Helm-应用"><a href="#3-2-安装一个-Helm-应用" class="headerlink" title="3.2 安装一个 Helm 应用"></a>3.2 安装一个 Helm 应用</h4><p><strong>查看想要安装的服务</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@czz ~]# helm search repo nginx</span><br><span class="line">NAME                           CHART VERSIONAPP VERSION         DESCRIPTION</span><br><span class="line">aliyun/nginx                   5.1.5        1.16.1              Chart for the nginx server</span><br><span class="line">aliyun/nginx-ingress           1.30.3       0.28.0              An nginx Ingress controller that uses ConfigMap...</span><br><span class="line">aliyun/nginx-ingress-controller5.3.4        0.29.0              Chart for the nginx Ingress controller</span><br><span class="line">aliyun/nginx-lego              0.3.1                            Chart for nginx-ingress-controller and kube-lego</span><br><span class="line">aliyun/nginx-php               1.0.0        nginx-1.10.3_php-7.0Chart for the nginx php server</span><br></pre></td></tr></table></figure><p><strong>使用helm安装服务</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@czz ~]# helm install nginx aliyun/nginx</span><br><span class="line"></span><br><span class="line">[root@czz ~]# kubectl get pod,svc</span><br><span class="line">NAME                        READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod/nginx-99fcdd97b-g5xxz   1/1     Running   0          15m</span><br><span class="line"></span><br><span class="line">NAME                 TYPE           CLUSTER-IP    EXTERNAL-IP   PORT(S)                      AGE</span><br><span class="line">service/kubernetes   ClusterIP      10.10.0.1     &lt;none&gt;        443/TCP                      3d16h</span><br><span class="line">service/nginx        LoadBalancer   10.10.18.28   &lt;pending&gt;     80:30418/TCP,443:32580/TCP   15m</span><br></pre></td></tr></table></figure><p><strong>使用 helm status 跟踪发布状态或重新读取配置信息</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@czz ~]# helm status nginx</span><br><span class="line">NAME: nginx</span><br><span class="line">LAST DEPLOYED: Tue Mar 22 10:47:59 2022</span><br><span class="line">NAMESPACE: default</span><br><span class="line">STATUS: deployed</span><br><span class="line">REVISION: 1</span><br><span class="line">TEST SUITE: None</span><br><span class="line">NOTES:</span><br><span class="line">Get the NGINX URL:</span><br><span class="line"></span><br><span class="line">  NOTE: It may take a few minutes for the LoadBalancer IP to be available.</span><br><span class="line">        Watch the status with: 'kubectl get svc --namespace default -w nginx'</span><br><span class="line"></span><br><span class="line">  export SERVICE_IP=$(kubectl get svc --namespace default nginx --template "&#123;&#123; range (index .status.loadBalancer.ingress 0) &#125;&#125;&#123;&#123;.&#125;&#125;&#123;&#123;end &#125;&#125;")</span><br><span class="line">  echo "NGINX URL: http://$SERVICE_IP/"</span><br></pre></td></tr></table></figure><h4 id="3-3-升级一个-helm-应用"><a href="#3-3-升级一个-helm-应用" class="headerlink" title="3.3 升级一个 helm 应用"></a>3.3 升级一个 helm 应用</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@czz ~]# helm upgrade nginx aliyun/nginx</span><br><span class="line"></span><br><span class="line">也可以指定命名空间和它的taz包</span><br><span class="line">[root@czz ~]# helm upgrade --install --force hello-world ./hello.tgz --namespace default</span><br></pre></td></tr></table></figure><h4 id="3-4-回滚一个-Helm-应用"><a href="#3-4-回滚一个-Helm-应用" class="headerlink" title="3.4 回滚一个 Helm 应用"></a>3.4 回滚一个 Helm 应用</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">向上归滚一个版本</span><br><span class="line">[root@czz ~]# helm rollback nginx 1</span><br></pre></td></tr></table></figure><h4 id="3-5-卸载一个-Helm-应用"><a href="#3-5-卸载一个-Helm-应用" class="headerlink" title="3.5 卸载一个 Helm 应用"></a>3.5 卸载一个 Helm 应用</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@czz ~]# helm uninstall nginx -ndefault</span><br></pre></td></tr></table></figure><h3 id="3-2-使用-helm-构建应用"><a href="#3-2-使用-helm-构建应用" class="headerlink" title="3.2 使用 helm 构建应用"></a>3.2 使用 helm 构建应用</h3><h4 id="3-2-1-建立一个-helm-charts"><a href="#3-2-1-建立一个-helm-charts" class="headerlink" title="3.2.1 建立一个 helm charts"></a>3.2.1 建立一个 helm charts</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@czz ~]# helm create hello-world</span><br><span class="line"></span><br><span class="line">[root@czz ~]# ls hello-world/</span><br><span class="line">charts  Chart.yaml  templates  values.yaml</span><br></pre></td></tr></table></figure><ul><li>Chart.yaml 用于描述这个Chart的相关信息，包括名字、描述信息以及版本等。<br>仅仅是一些简单的文本描述</li><li>values.yaml 用于存储 templates 目录中模板文件中用到变量的值。</li><li>NOTES.txt 用于介绍 Chart 部署后的一些信息，例如：如何使用这个 Chart、列出缺省的设置等。</li><li>Templates 目录下是 YAML 文件的模板，该模板文件遵循 Go template 语法。</li></ul><blockquote><p>Templates 目录下 YAML 文件模板的值默认都是在 values.yaml 里定义的，比如在 deployment.yaml 中定义的容器镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image: &quot;&#123;&#123; .Values.image.repository &#125;&#125;:&#123;&#123; .Values.image.tag &#125;&#125;&quot;</span><br></pre></td></tr></table></figure><p>其中的 .Values.image.repository 的值就是在 <strong>values.yaml</strong> 里定义的 nginx，.Values.image.tag 的值就是 stable。<br>以上两个变量值是在 create chart 的时候就自动生成的默认值，你可以根据实际情况进行修改。实际上都是静态文本,只在是执行的时候才被解析.</p></blockquote><h4 id="3-2-2-构建一个-helm-应用"><a href="#3-2-2-构建一个-helm-应用" class="headerlink" title="3.2.2 构建一个 helm 应用"></a>3.2.2 构建一个 helm 应用</h4><p>打开 Chart.yaml，可以看到内容如下，配置名称和版本</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[root@czz</span> <span class="string">~]#</span>  <span class="string">cat</span> <span class="string">hello-world/Chart.yaml</span> <span class="string">|grep</span> <span class="bullet">-Ev</span> <span class="string">"^#|^$"</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v2</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">hello-world</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">A</span> <span class="string">Helm</span> <span class="string">chart</span> <span class="string">for</span> <span class="string">Kubernetes</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">application</span></span><br><span class="line"><span class="attr">version:</span> <span class="number">0.1</span><span class="number">.0</span></span><br><span class="line"><span class="attr">appVersion:</span> <span class="string">"1.16.0"</span></span><br></pre></td></tr></table></figure><p>编辑 values.yaml，它默认会在 Kubernetes 部署一个 Nginx。下面是 mychart 应用的 values.yaml 文件的内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[root@czz</span> <span class="string">~]#</span> <span class="string">cat</span> <span class="string">hello-world/values.yaml</span></span><br><span class="line"><span class="comment"># Default values for hello-world.</span></span><br><span class="line"><span class="comment"># This is a YAML-formatted file.</span></span><br><span class="line"><span class="comment"># Declare variables to be passed into your templates.</span></span><br><span class="line"></span><br><span class="line"><span class="attr">replicaCount:</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="attr">image:</span></span><br><span class="line"><span class="attr">  repository:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">  pullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">  <span class="comment"># Overrides the image tag whose default is the chart appVersion.</span></span><br><span class="line"><span class="attr">  tag:</span> <span class="string">""</span></span><br><span class="line"></span><br><span class="line"><span class="attr">imagePullSecrets:</span> <span class="string">[]</span></span><br><span class="line"><span class="attr">nameOverride:</span> <span class="string">""</span></span><br><span class="line"><span class="attr">fullnameOverride:</span> <span class="string">""</span></span><br><span class="line"></span><br><span class="line"><span class="attr">serviceAccount:</span></span><br><span class="line">  <span class="comment"># Specifies whether a service account should be created</span></span><br><span class="line"><span class="attr">  create:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Annotations to add to the service account</span></span><br><span class="line"><span class="attr">  annotations:</span> <span class="string">&#123;&#125;</span></span><br><span class="line">  <span class="comment"># The name of the service account to use.</span></span><br><span class="line">  <span class="comment"># If not set and create is true, a name is generated using the fullname template</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">""</span></span><br><span class="line"></span><br><span class="line"><span class="attr">podAnnotations:</span> <span class="string">&#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">podSecurityContext:</span> <span class="string">&#123;&#125;</span></span><br><span class="line">  <span class="comment"># fsGroup: 2000</span></span><br><span class="line"></span><br><span class="line"><span class="attr">securityContext:</span> <span class="string">&#123;&#125;</span></span><br><span class="line">  <span class="comment"># capabilities:</span></span><br><span class="line">  <span class="comment">#   drop:</span></span><br><span class="line">  <span class="comment">#   - ALL</span></span><br><span class="line">  <span class="comment"># readOnlyRootFilesystem: true</span></span><br><span class="line">  <span class="comment"># runAsNonRoot: true</span></span><br><span class="line">  <span class="comment"># runAsUser: 1000</span></span><br><span class="line"></span><br><span class="line"><span class="attr">service:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">ClusterIP</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="attr">ingress:</span></span><br><span class="line"><span class="attr">  enabled:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  className:</span> <span class="string">""</span></span><br><span class="line"><span class="attr">  annotations:</span> <span class="string">&#123;&#125;</span></span><br><span class="line">    <span class="comment"># kubernetes.io/ingress.class: nginx</span></span><br><span class="line">    <span class="comment"># kubernetes.io/tls-acme: "true"</span></span><br><span class="line"><span class="attr">  hosts:</span></span><br><span class="line"><span class="attr">    - host:</span> <span class="string">chart-example.local</span></span><br><span class="line"><span class="attr">      paths:</span></span><br><span class="line"><span class="attr">        - path:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">          pathType:</span> <span class="string">ImplementationSpecific</span></span><br><span class="line"><span class="attr">  tls:</span> <span class="string">[]</span></span><br><span class="line">  <span class="comment">#  - secretName: chart-example-tls</span></span><br><span class="line">  <span class="comment">#    hosts:</span></span><br><span class="line">  <span class="comment">#      - chart-example.local</span></span><br><span class="line"></span><br><span class="line"><span class="attr">resources:</span> <span class="string">&#123;&#125;</span></span><br><span class="line">  <span class="comment"># We usually recommend not to specify default resources and to leave this as a conscious</span></span><br><span class="line">  <span class="comment"># choice for the user. This also increases chances charts run on environments with little</span></span><br><span class="line">  <span class="comment"># resources, such as Minikube. If you do want to specify resources, uncomment the following</span></span><br><span class="line">  <span class="comment"># lines, adjust them as necessary, and remove the curly braces after 'resources:'.</span></span><br><span class="line">  <span class="comment"># limits:</span></span><br><span class="line">  <span class="comment">#   cpu: 100m</span></span><br><span class="line">  <span class="comment">#   memory: 128Mi</span></span><br><span class="line">  <span class="comment"># requests:</span></span><br><span class="line">  <span class="comment">#   cpu: 100m</span></span><br><span class="line">  <span class="comment">#   memory: 128Mi</span></span><br><span class="line"></span><br><span class="line"><span class="attr">autoscaling:</span></span><br><span class="line"><span class="attr">  enabled:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  minReplicas:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  maxReplicas:</span> <span class="number">100</span></span><br><span class="line"><span class="attr">  targetCPUUtilizationPercentage:</span> <span class="number">80</span></span><br><span class="line">  <span class="comment"># targetMemoryUtilizationPercentage: 80</span></span><br><span class="line"></span><br><span class="line"><span class="attr">nodeSelector:</span> <span class="string">&#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">tolerations:</span> <span class="string">[]</span></span><br><span class="line"></span><br><span class="line"><span class="attr">affinity:</span> <span class="string">&#123;&#125;</span></span><br></pre></td></tr></table></figure><h4 id="3-2-3-检查模块配置"><a href="#3-2-3-检查模块配置" class="headerlink" title="3.2.3 检查模块配置"></a>3.2.3 检查模块配置</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@czz ~]# helm lint hello-world/</span><br></pre></td></tr></table></figure><h4 id="3-2-4-部署-helm-本地应用"><a href="#3-2-4-部署-helm-本地应用" class="headerlink" title="3.2.4 部署 helm 本地应用"></a>3.2.4 部署 helm 本地应用</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@czz ~]# helm install hello ./hello-world</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Nov 08 2022 22:51:11 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;一、Helm-介绍&quot;&gt;&lt;a href=&quot;#一、Helm-介绍&quot; class=&quot;headerlink&quot; title=&quot;一、Helm 介绍
      
    
    </summary>
    
    
      <category term="kubernetes" scheme="http://chenzhonzhou.github.io/categories/kubernetes/"/>
    
    
      <category term="kubernetes - Helm" scheme="http://chenzhonzhou.github.io/tags/kubernetes-Helm/"/>
    
  </entry>
  
  <entry>
    <title>Alluxio 分布式内存虚拟文件系统</title>
    <link href="http://chenzhonzhou.github.io/2021/12/11/alluxio-fen-bu-shi-nei-cun-wen-jian-xi-tong/"/>
    <id>http://chenzhonzhou.github.io/2021/12/11/alluxio-fen-bu-shi-nei-cun-wen-jian-xi-tong/</id>
    <published>2021-12-11T06:56:08.000Z</published>
    <updated>2021-12-14T03:39:37.959Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Nov 08 2022 22:51:10 GMT+0800 (GMT+08:00) --><h2 id="一、Alluxio概览"><a href="#一、Alluxio概览" class="headerlink" title="一、Alluxio概览"></a>一、Alluxio概览</h2><h3 id="1-1-什么是-Alluxio"><a href="#1-1-什么是-Alluxio" class="headerlink" title="1.1 什么是 Alluxio"></a>1.1 什么是 Alluxio</h3><p><strong><a href="https://docs.alluxio.io/os/user/stable/cn/Overview.html" target="_blank" rel="noopener">Alluxio</a>（之前名为 Tachyon）是一个开源的具有内存级速度的虚拟分布式存储系统。</strong>它统一了数据访问的方式，为上层计算框架和底层存储系统构建了桥梁。应用只需要连接Alluxio即可访问存储在底层任意存储系统中的数据。此外，Alluxio的以内存为中心的架构使得数据的访问速度能比现有常规方案快几个数量级。</p><p>在大数据生态系统中，Alluxio 位于数据驱动框架或应用（如 Apache Spark、Presto、Tensorflow、Apache HBase、Apache Hive 或 Apache Flink）和各种持久化存储系统（如 Amazon S3、Google Cloud Storage、OpenStack Swift、HDFS、GlusterFS、IBM Cleversafe、EMC ECS、Ceph、NFS 、Minio和 Alibaba OSS）之间。 Alluxio 统一了存储在这些不同存储系统中的数据，为其上层数据驱动型应用提供统一的客户端 API 和全局命名空间。用户可以以独立集群方式(如Amazon EC2)运行Alluxio，也可以从Apache Mesos或Apache YARN上启动Alluxio。</p><p><img src="/2021/12/11/alluxio-fen-bu-shi-nei-cun-wen-jian-xi-tong/%E5%9B%BE%E7%89%871.png" alt="图片1"></p><blockquote><p>Alluxio作为一个内存级的虚拟分布式存储系统有几个常见的使用场景：</p><ul><li>计算层需要反复访问远程（比如在云端，或跨机房）的数据；</li><li>计算层需要同时访问多个独立的持久化数据源（比如同时访问S3和HDFS中的数据）；</li><li>多个独立的大数据应用（比如不同的Spark Job）需要高速有效的共享数据；</li><li>当计算层有着较为严重的内存资源、以及JVM GC压力，或者较高的任务失败率时，Alluxio作为输入输出数据的Off heap存储可以极大缓解这一压力，并使计算消耗的时间和资源更可控可预测。</li></ul><blockquote><p>Alluixo利用的是堆内内存，如果不符合典型场景，用起来就是鸡肋！<br>Ignite是堆外内存，真正加速任务</p></blockquote><p>以上引用原文：<a href="https://www.cnblogs.com/liugh/articles/7324488.html" target="_blank" rel="noopener">https://www.cnblogs.com/liugh/articles/7324488.html</a></p></blockquote><h3 id="1-2-Alluxio的优势"><a href="#1-2-Alluxio的优势" class="headerlink" title="1.2 Alluxio的优势"></a>1.2 Alluxio的优势</h3><p>通过简化应用程序访问其数据的方式（无论数据是什么格式或位置），Alluxio能够帮助克服从数据中提取信息所面临的困难。Alluxio的优势包括：</p><h4 id="1-2-1-内存速度-I-O"><a href="#1-2-1-内存速度-I-O" class="headerlink" title="1.2.1 内存速度 I/O"></a>1.2.1 内存速度 I/O</h4><p>Alluxio 能够用作分布式共享缓存服务，这样与 Alluxio 通信的计算应用程序可以透明地缓存频繁访问的数据（尤其是从远程位置），以提供内存级 I/O 吞吐率。此外，Alluxio的层次化存储机制能够充分利用内存、固态硬盘或者磁盘，降低具有弹性扩张特性的数据驱动型应用的成本开销。</p><h4 id="1-2-2-统一数据访问接口"><a href="#1-2-2-统一数据访问接口" class="headerlink" title="1.2.2 统一数据访问接口"></a>1.2.2 统一数据访问接口</h4><p>Alluxio 能够屏蔽底层持久化存储系统在API、客户端及版本方面的差异，从而使整个系统易于扩展和管理。</p><p><img src="/2021/12/11/alluxio-fen-bu-shi-nei-cun-wen-jian-xi-tong/%E5%9B%BE%E7%89%873.png" alt="图片3"></p><ul><li>能够将多个数据源中的数据挂载到Alluxio中</li><li>多个数据源使用统一的命名空间</li><li>用户使用统一的路径访问</li></ul><h4 id="1-2-3-提升远程存储读写性能"><a href="#1-2-3-提升远程存储读写性能" class="headerlink" title="1.2.3 提升远程存储读写性能"></a>1.2.3 提升远程存储读写性能</h4><p>以Hadoop为代表的存储计算紧耦合的传统架构具有优良的计算本地性。通过在邻近所需数据的节点上来部署运行计算任务，可以尽量减少通过网络传输数据，从而有效地提升性能。然而，维持这种紧耦合结构所需要付出的成本代价正逐渐让性能优势带来的意义变得微乎其微。</p><p>Alluxio通过在当前主流的存储计算分离解耦的架构中，提供与紧耦合架构相似甚至更优的性能，来解决解耦后性能降低的难题。推荐把Alluxio与集群的计算框架并置部署（co-locate），从而能够提供靠近计算的跨存储缓存来实现高效本地性。</p><p><img src="/2021/12/11/alluxio-fen-bu-shi-nei-cun-wen-jian-xi-tong/%E5%9B%BE%E7%89%874.png" alt="图片4">与传统的架构方案相比，用户需要注意采用Alluxio架构带来的两个关键区别。</p><blockquote><ol><li>Alluxio存储中<strong>不需要保存底层存储中的所有数据</strong>，它只需要保存工作集（WorkingSet）。即使全体数据的规模非常大，Alluxio也不需要大量存储空间来存储所有数据，而是可以在有限的存储空间中只缓存作业所需要的数据。</li><li>Alluxio<strong>存储采用了一种弹性的缓存机制来管理</strong>、使用存储资源。<strong>访问热度越高的数据</strong>（如被很多作业读取的数据表），<strong>会产生越多的副本</strong>，而请求很少甚至没有复用的数据则会被逐渐替换出Alluxio存储层（其在远端存储系统中的副本不会被清除）。而以HDFS为代表的存储系统通常是采用一个固定的副本数目（如3副本），很难根据具体的数据访问热度动态调节存储资源的使用。</li></ol></blockquote><h4 id="1-2-4-数据快速复用与共性"><a href="#1-2-4-数据快速复用与共性" class="headerlink" title="1.2.4 数据快速复用与共性"></a>1.2.4 数据快速复用与共性</h4><p>Alluxio可以帮助实现跨计算、作业间的数据快速复用和共享。</p><p>对于用户应用程序和大数据计算框架来说，Alluxio存储通常与计算框架并置。这种部署方式使Alluxio可以提供快速存储，促进作业之间的数据共享，无论它们是否在同一计算平台上运行。</p><p><img src="/2021/12/11/alluxio-fen-bu-shi-nei-cun-wen-jian-xi-tong/%E5%9B%BE%E7%89%875.png" alt="图片5"></p><h4 id="1-2-5-集成机器学习和深度学习"><a href="#1-2-5-集成机器学习和深度学习" class="headerlink" title="1.2.5 集成机器学习和深度学习"></a>1.2.5 集成机器学习和深度学习</h4><p><img src="/2021/12/11/alluxio-fen-bu-shi-nei-cun-wen-jian-xi-tong/%E5%9B%BE%E7%89%876.png" alt="图片6"></p><p>机器学习和深度学习框架往往需要从Hadoop或对象存储中提取大规模数据，这通常是手动且非常耗时的过程。通过Alluxio POSIX API克服该问题。</p><p>Alluxio的FUSE功能支持POSIX兼容的API，因此通过Alluxio，TensorFlow、 Caffe等框架以及其他基于Python的模型可以使用传统文件系统的访问方式直接访问任何存储系统中的数据。</p><h3 id="1-3-技术创新"><a href="#1-3-技术创新" class="headerlink" title="1.3 技术创新"></a>1.3 技术创新</h3><p>Alluxio将三个关键领域的创新结合在一起，提供了一套独特的功能。</p><ol><li><strong>全局命名空间</strong>: Alluxio 能够对多个独立存储系统提供单点访问，无论这些存储系统的物理位置在何处。这提供了所有数据源的统一视图和应用程序的标准接口。有关详细信息，请参阅命名空间管理。</li><li><strong>智能多层级缓存</strong>: Alluxio 集群能够充当底层存储系统中数据的读写缓存。可配置自动优化数据放置策略，以实现跨内存和磁盘（SSD/HDD）的性能和可靠性。缓存对用户是透明的，使用缓冲来保持与持久存储的一致性。有关详细信息，请参阅 Alluxio存储管理。</li><li><strong>服务器端 API 翻译转换</strong>: Alluxio支持工业界场景的API接口，例如HDFS API, S3 API, FUSE API, REST API。它能够透明地从标准客户端接口转换到任何存储接口。Alluxio 负责管理应用程序和文件或对象存储之间的通信，从而消除了对复杂系统进行配置和管理的需求。文件数据可以看起来像对象数据，反之亦然。</li></ol><h3 id="1-4-功能简介"><a href="#1-4-功能简介" class="headerlink" title="1.4 功能简介"></a>1.4 功能简介</h3><ul><li>灵活的API</li><li>兼容Haddop 的HDFS文件系统接口</li><li>分级存储，自定义分配和回收策略</li><li>统一命名空间</li><li>完整的命令行</li><li>Web UI</li></ul><h2 id="二、系统架构"><a href="#二、系统架构" class="headerlink" title="二、系统架构"></a>二、系统架构</h2><h3 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h3><p>Alluxio作为大数据和机器学习生态系统中的一个新的数据访问层，配置在任何持久性存储系统(如Amazon S3、Microsoft Azure对象存储、Apache HDFS或OpenStack Swift)和计算框架(如Apache Spark、Presto或Hadoop MapReduce)之间。<strong>请注意，Alluxio不是一个持久化存储系统。</strong>使用Alluxio作为数据访问层有如下好处：</p><ul><li>对于用户应用程序和计算框架，Alluxio提供了快速存储，促进了作业之间的数据共享和局部性，而不管使用的是哪种计算引擎。因此，当数据位于本地时，Alluxio可以以内存速度提供数据;当数据位于Alluxio时，Alluxio可以以计算集群网络的速度提供数据。第一次访问数据时，只从存储系统上读取一次数据。为了得到更好的性能，Alluxio推荐部署在计算集群上。</li><li>对于存储系统，Alluxio弥补了大数据应用与传统存储系统之间的差距，扩大了可用的数据工作负载集。当同时挂载多个数据源时，Alluxio可以作为任意数量的不同数据源的统一层。</li></ul><p><img src="/2021/12/11/alluxio-fen-bu-shi-nei-cun-wen-jian-xi-tong/%E5%9B%BE%E7%89%872.png" alt="图片2"></p><p>Alluxio可以分为三个组件：<strong>masters</strong>、<strong>worker</strong>和<strong>clients</strong>。一个典型的集群由一个单一的主要主节点<code>leading masters</code>、备用主节点<code>job master</code>、一个作业主节点<code>standby job masters</code>、备用作业主节点<code>standby job masters</code>、工作节点<code>workers</code>和作业工作节点<code>job workers</code>组成。master 和 worker 进程构成了 Alluxio 服务器，它们是系统管理员需要维护的组件。客户端用于通过 Spark 或 MapReduce 作业、Alluxio CLI 或 Alluxio FUSE 层等应用程序与 Alluxio 服务器通信。</p><p>Alluxio Job Masters 和 Job Workers 可以分离成一个单独的功能，称为 <strong>Job Service</strong>。Alluxio Job Service 是一个轻量级的任务调度框架，负责为 Job Workers 分配许多不同类型的操作。这些任务包括</p><ul><li>从 UFS 加载数据到 Alluxio</li><li>将数据持久化到 UFS</li><li>在 Alluxio 中复制文件</li><li>在 UFS 或 Alluxio 位置之间移动或复制数据</li></ul><p><strong>Job Service</strong>的设计使得所有与作业相关的进程不一定需要位于 Alluxio 集群的其余部分。但是，我们确实建议job worker 与相应的 Alluxio worker 位于同一位置，因为它为 RPC 和数据传输提供了更低的延迟。</p><h3 id="2-2-Mstaers"><a href="#2-2-Mstaers" class="headerlink" title="2.2 Mstaers"></a>2.2 Mstaers</h3><p><img src="/2021/12/11/alluxio-fen-bu-shi-nei-cun-wen-jian-xi-tong/%E5%9B%BE%E7%89%877.png" alt="图片7"></p><p>Alluxio 包含两种不同类型的主进程。<strong>Alluxio Master</strong> 为所有用户请求和日志文件系统元数据更改提供服务。<strong>Alluxio Job Master</strong>是作为文件系统操作的轻量级调度程序。</p><p>为了<strong>容错，Alluxio Master</strong>可以部署为一个主master和多个备用master。当主master节点宕机时，会选举一个备用master节点成为新的主master节点。</p><h4 id="2-2-1-主master"><a href="#2-2-1-主master" class="headerlink" title="2.2.1 主master"></a>2.2.1 主master</h4><p>Alluxio中只有一个master进程为主master。主master用于管理全局的元数据。这里面包含文件系统元数据（文件系统 inode 树）、数据块元数据（数据块位置）、以及worker的容量元数据（空闲或已占用空间）。Alluxio clients与主master通信用来读取或修改元数据。所有的worker都会定期的向主master发送心跳。主master会在一个分布式的持久化系统上记录所有的文件系统事务，这样可以恢复主master的信息。这组日志被称为journal。</p><h4 id="2-2-2-备用master"><a href="#2-2-2-备用master" class="headerlink" title="2.2.2 备用master"></a>2.2.2 备用master</h4><p>备用master读取主master写入的journal日志，以保持与主master的状态同步。它们会对journal日志写入检查点，用于快速恢复。它们不处理来自Alluxio组件的任何请求。</p><h4 id="2-2-3-Secondary-Masters-for-UFS-journal"><a href="#2-2-3-Secondary-Masters-for-UFS-journal" class="headerlink" title="2.2.3 Secondary Masters (for UFS journal)"></a>2.2.3 Secondary Masters (for UFS journal)</h4><p>当使用 UFS 日志在没有 HA 模式的情况下运行单个 Alluxio master 时，可以在与主要 master 相同的服务器上启动辅助 master 来写入日志检查点。请注意，辅助 master 并非旨在提供高可用性，而是从主要 master 卸载工作以实现快速恢复。与备用 Master 不同，从属 Master 永远无法升级为领先的 Master。</p><h4 id="2-2-4-Job-Masters"><a href="#2-2-4-Job-Masters" class="headerlink" title="2.2.4 Job Masters"></a>2.2.4 Job Masters</h4><p>Alluxio Job Master 是一个独立的进程，负责在 Alluxio 中异步调度多个重量级文件系统操作。通过分离领先的 Alluxio Master 在同一进程中执行这些操作，Alluxio Master 使用更少的资源，并能够在更短的时间内为更多的客户端提供服务。此外，它还为将来添加更复杂的操作提供了一个可扩展的框架。</p><h3 id="2-3-Workers"><a href="#2-3-Workers" class="headerlink" title="2.3 Workers"></a>2.3 Workers</h3><p><img src="/2021/12/11/alluxio-fen-bu-shi-nei-cun-wen-jian-xi-tong/%E5%9B%BE%E7%89%878.png" alt="图片8"></p><h4 id="2-3-1-Alluxio-Workers"><a href="#2-3-1-Alluxio-Workers" class="headerlink" title="2.3.1 Alluxio Workers"></a>2.3.1 Alluxio Workers</h4><p>Alluxio Workers 负责管理分配给 Alluxio 的用户可配置的本地资源（例如内存、SSD、HDD）。Alluxio Worker将数据存储为块，并通过在其本地资源中读取或创建新块来响应 client 请求。Workers 只用于管理数据块；从文件到块的实际映射仅由 master 存储。</p><p>Worker 在底层存储上执行数据操作。这带来了两个重要的好处：</p><ul><li>从底层存储读取的数据可以存储在 worker 中，并立即可供其他 client 使用。</li><li>client 可以是轻量级的，并且不依赖于底层存储连接器。</li></ul><p>由于 RAM 通常提供的容量有限，因此当空间已满时，可以逐出 worker 中的块。工作人员采用驱逐策略来决定将哪些数据保留在 Alluxio 空间中。有关此主题的更多信息，请查看<a href="https://docs.alluxio.io/os/user/stable/en/core-services/Caching.html#multiple-tier-storage" target="_blank" rel="noopener">分层存储</a>的文档。</p><h4 id="2-3-2-Alluxio-Job-Workers"><a href="#2-3-2-Alluxio-Job-Workers" class="headerlink" title="2.3.2 Alluxio Job Workers"></a>2.3.2 Alluxio Job Workers</h4><p>Alluxio Job Workers 是 Alluxio 文件系统的客户端。他们负责运行 Alluxio Job Master 交给他们的任务。Job Workers 接收指令以在任何给定的文件系统位置上运行加载、持久化、复制、移动或复制操作。</p><p>Alluxio job workers 不一定要与普通 workers 位于同一位置，但建议两者在同一个物理节点上。</p><h3 id="2-4-Client"><a href="#2-4-Client" class="headerlink" title="2.4 Client"></a>2.4 Client</h3><p>Alluxio Client 为用户提供了一个与 Alluxio 服务器交互的网关。它发起与 leading master 通信以执行元数据操作，并与 worker 通信以读取和写入存储在 Alluxio 中的数据。Alluxio 支持 Java 中的本机文件系统 API 和多种语言（包括 REST、Go 和 Python）。Alluxio 还支持与 HDFS API 和 Amazon S3 API 兼容的 API。</p><p>请注意，Alluxio Client 从不直接访问底层存储系统。数据通过 Alluxio Workers 传输。</p><p><strong>alluxio服务的几个组件功能总结</strong></p><blockquote><table><thead><tr><th>组件名称</th><th>作用</th></tr></thead><tbody><tr><td>Master</td><td>1.管理全局的元数据信息（包括目录树(inode tree)，块信息(block)，worker的容量信息)；2.worker发送心跳；3.client获取元数据</td></tr><tr><td>SecondaryMaster</td><td>1.读取主master写入的journal日志，以保持与主master的状态同步；2.对journal日志写入检查点，用于快速恢复；3.不处理来自Alluxio组件的任何请求</td></tr><tr><td>JobMaster</td><td>1.负责在Alluxio中异步调度许多重量级文件系统操作，提高master吞吐量；2.为后期复杂操作提供扩展性</td></tr><tr><td>Worker</td><td>1.底层数据存储在worker中供客户端使用；2.alluxio客户端不依赖底层存储</td></tr><tr><td>JobWorker</td><td>执行job master分配的任务，建议与worker放在同一节点上</td></tr><tr><td>Client</td><td>集成到其他计算框架中，调用Alluxio leading master以执行元数据操作，与 workers 通信以读取和写入存储在 Alluxio 中的数据</td></tr></tbody></table></blockquote><h3 id="2-5-读数据流"><a href="#2-5-读数据流" class="headerlink" title="2.5 读数据流"></a>2.5 读数据流</h3><p>Alluxio 位于底层存储和计算框架之间，充当数据读取的缓存层。</p><h4 id="2-5-1-本地缓存命中"><a href="#2-5-1-本地缓存命中" class="headerlink" title="2.5.1 本地缓存命中"></a>2.5.1 本地缓存命中</h4><p>本地缓存命中发生在请求数据位于本地Alluxio worker。举例说明，如果一个应用通过Alluxio client请求数据，client向Alluxio master请求数据所在的worker。如果数据在本地可用，Alluxio client使用<code>短路</code>读取来绕过Alluxio worker，并直接通过本地文件系统读取文件。短路读取避免通过TCP套接字传输数据，并提供数据的直接访问。</p><p>还要注意，Alluxio可以管理除了内存之外还可以管理其他存储介质（例如SSD、HDD），因此本地数据访问速度可能会因本地存储介质的不同而有所不同。</p><p><img src="/2021/12/11/alluxio-fen-bu-shi-nei-cun-wen-jian-xi-tong/%E5%9B%BE%E7%89%879.gif" alt="图片9"></p><h4 id="2-5-2-远程缓存命中"><a href="#2-5-2-远程缓存命中" class="headerlink" title="2.5.2 远程缓存命中"></a>2.5.2 远程缓存命中</h4><p>当请求的数据存储在Alluxio中，而不是存储在client的本地worker上时，client将对具有数据的worker进行远程读取。client完成读取后，会要求本地的worker（如果存在）创建一个copy，这样以后读取的时候可以在本地读取相同的数据。远程缓存命中提供了网络级别速度的数据读取。Alluxio优先从远程worker读取数据，而不是从底层存储，因为Alluxio workers之间的速度一般会快过Alluxio workers和底层存储的速度。</p><p><img src="/2021/12/11/alluxio-fen-bu-shi-nei-cun-wen-jian-xi-tong/%E5%9B%BE%E7%89%8710.gif" alt="图片10"></p><h4 id="2-5-3-缓存Miss"><a href="#2-5-3-缓存Miss" class="headerlink" title="2.5.3 缓存Miss"></a>2.5.3 缓存Miss</h4><p>如果数据在 Alluxio 中找不到，则会发生缓存未命中，应用程序将不得不从底层存储中读取数据。Alluxio client 将读取从 UFS 委托给worker（有限本地worker）。该worker从底层存储中读取和缓存数据。缓存未命中通常会导致最大的延迟，因为必须从底层存储中获取数据。首次读取数据时预计会发生缓存未命中。</p><p>当 client 仅读取块的一部分或非顺序读取块时，client 将指示worker异步缓存完整个块。这称为异步缓存。异步缓存不会阻塞client，但如果 Alluxio 和底层存储系统之间的网络带宽成为瓶颈，仍然可能会影响性能。您可以通过<code>alluxio.worker.network.async.cache.manager.threads.max</code>对worker进行设置来调整异步缓存的影响 。默认值为<code>8</code>。</p><p><img src="/2021/12/11/alluxio-fen-bu-shi-nei-cun-wen-jian-xi-tong/%E5%9B%BE%E7%89%8711.gif" alt="图片11"></p><h4 id="2-5-4-缓存跳过"><a href="#2-5-4-缓存跳过" class="headerlink" title="2.5.4 缓存跳过"></a>2.5.4 缓存跳过</h4><p>可以通过将<a href="https://docs.alluxio.io/os/user/stable/en/reference/Properties-List.html#alluxio.user.file.readtype.default" target="_blank" rel="noopener"><code>alluxio.user.file.readtype.default</code></a> client中的属性设置为 <code>NO_CACHE</code> 来关闭 Alluxio 中的缓存。</p><h3 id="2-6-写数据流"><a href="#2-6-写数据流" class="headerlink" title="2.6 写数据流"></a>2.6 写数据流</h3><p>用户可以通过选择不同的写入类型来配置数据的写入方式。写入类型可以通过 Alluxio API 或通过配置属性 <a href="https://docs.alluxio.io/os/user/stable/en/reference/Properties-List.html#alluxio.user.file.writetype.default" target="_blank" rel="noopener"><code>alluxio.user.file.writetype.default</code></a> 来设置写入类型。</p><h4 id="2-6-1-仅写入-Alluxio-MUST-CACHE"><a href="#2-6-1-仅写入-Alluxio-MUST-CACHE" class="headerlink" title="2.6.1 仅写入 Alluxio ( MUST_CACHE)"></a>2.6.1 仅写入 Alluxio ( <code>MUST_CACHE</code>)</h4><p>当写类型设置为MUST_CACHE，Alluxio client将数据写入本地Alluxio worker，而不会写入到底层存储。如果<code>短路</code>写可用，Alluxio client直接写入到本地RAM的文件，绕过Alluxio worker 避免网络传输。由于数据没有持久存储在under storage中，因此如果机器崩溃或需要释放数据以进行更新的写操作，数据可能会丢失。当可以容忍数据丢失时，MUST_CACHE 设置可用于写入临时数据。</p><p><img src="/2021/12/11/alluxio-fen-bu-shi-nei-cun-wen-jian-xi-tong/%E5%9B%BE%E7%89%8712.gif" alt="图片12"></p><h4 id="2-6-2-直写到-UFS-CACHE-THROUGH"><a href="#2-6-2-直写到-UFS-CACHE-THROUGH" class="headerlink" title="2.6.2 直写到 UFS ( CACHE_THROUGH)"></a>2.6.2 直写到 UFS ( <code>CACHE_THROUGH</code>)</h4><p>使用CACHE_THROUGH写类型，数据同步写入Alluxio worker和底层存储系统。Alluxio client将写操作委托给本地worker，而worker同时将对本地内存和底层存储。由于底层存储的写入速度通常比本地存储慢，所以client的写入速度将与底层存储的速度相匹配。当需要数据持久化时，建议使用CACHE_THROUGH写类型。在本地还存了一份副本，以便可以直接从本地内存中读取数据。</p><p><img src="/2021/12/11/alluxio-fen-bu-shi-nei-cun-wen-jian-xi-tong/%E5%9B%BE%E7%89%8713.gif" alt="图片13"></p><h4 id="2-6-3-写回-UFS-ASYNC-THROUGH"><a href="#2-6-3-写回-UFS-ASYNC-THROUGH" class="headerlink" title="2.6.3 写回 UFS ( ASYNC_THROUGH)"></a>2.6.3 写回 UFS ( <code>ASYNC_THROUGH</code>)</h4><p>Alluxio 提供了一种写类型<code>ASYNC_THROUGH</code>. 使用<code>ASYNC_THROUGH</code>，数据首先被同步写入一个 Alluxio worker，并在后台持久化到 under storage。<code>ASYNC_THROUGH</code>可以以接近 <code>MUST_CACHE</code> 的速度提供数据写入，同时仍然能够持久保存数据。从 Alluxio 2.0 开始， <code>ASYNC_THROUGH</code>是默认的写入类型。</p><p><img src="/2021/12/11/alluxio-fen-bu-shi-nei-cun-wen-jian-xi-tong/%E5%9B%BE%E7%89%8714.gif" alt="图片14"></p><p>为了提供容错，使用的一个重要属性<code>ASYNC_THROUGH</code>是 <code>alluxio.user.file.replication.durable</code> 该属性设置了Alluxio在写入完成后数据持久化到under storage之前的新数据的目标复制级别，默认值为1。Alluxio将在后台持久化进程完成之前保持文件的目标复制级别，并且之后回收Alluxio中的空间，因此数据只会写入UFS一次。</p><p>如果您正在写入副本<code>ASYNC_THROUGH</code>并且所有具有副本的worker在您保存数据之前崩溃，那么您将导致数据丢失。</p><h4 id="2-6-4-仅写入-UFS-THROUGH"><a href="#2-6-4-仅写入-UFS-THROUGH" class="headerlink" title="2.6.4 仅写入 UFS ( THROUGH)"></a>2.6.4 仅写入 UFS ( <code>THROUGH</code>)</h4><p>使用<code>THROUGH</code>，数据被同步写入under storage，而不会缓存到Alluxio worker。这种写类型保证了写完成后数据会持久化，但是速度受限于under storage的吞吐量。</p><h4 id="2-6-5-数据一致性"><a href="#2-6-5-数据一致性" class="headerlink" title="2.6.5 数据一致性"></a>2.6.5 数据一致性</h4><p>无论写入类型如何，<strong>Alluxio 空间</strong>中的文件/目录始终是强一致的，因为所有这些写入操作都将首先通过 Alluxio master 并在将成功返回给客户端/应用程序之前修改 Alluxio 文件系统。因此，只要其对应的写操作成功完成，不同的 Alluxio 客户端将始终看到最新的更新。</p><p>但是，对于考虑 UFS 中状态的用户或应用程序，它可能因写入类型而异：</p><ul><li><code>MUST_CACHE</code> 不向 UFS 写入数据，因此 Alluxio 空间永远不会与 UFS 保持一致。</li><li>CACHE_THROUGH 在将成功返回给应用程序之前，将数据同步写入 Alluxio 和 UFS。<ul><li>如果写入UFS也是强一致性（例如HDFS），如果UFS中没有其他带外更新，Alluxio空间将始终与UFS一致；</li><li>如果写入 UFS 最终一致（例如 S3），则文件可能成功写入 Alluxio，但稍后会显示在 UFS 中。在这种情况下，Alluxio 客户端仍然会看到一致的文件系统，因为他们总是会咨询强一致性的 Alluxio master；因此，尽管不同的 Alluxio 客户端仍然在 Alluxio 空间中看到一致的状态，但在数据最终传播到 UFS 之前可能会有一个不一致的窗口。</li></ul></li><li><code>ASYNC_THROUGH</code>将数据写入 Alluxio 并返回到应用程序，让 Alluxio 将数据异步传播到 UFS。从用户的角度来看，该文件可以成功写入Alluxio，但稍后会在UFS中持久化。</li><li><code>THROUGH</code>直接将数据写入 UFS，无需在 Alluxio 中缓存数据，但是，Alluxio 知道文件及其状态。因此元数据仍然是一致的。</li></ul><blockquote><table><thead><tr><th>策略</th><th>注释</th></tr></thead><tbody><tr><td>MUST_CACHE</td><td>只写入缓存</td></tr><tr><td>CACHE_THROUGH</td><td>同步写入缓存和底层存储系统</td></tr><tr><td>ASYNC_THROUGH</td><td>异步写入缓存和底层存储系统，调用jobmaster和jobworker完成</td></tr><tr><td>THROUGH</td><td>只写入底层存储</td></tr></tbody></table></blockquote><h2 id="三、核心功能"><a href="#三、核心功能" class="headerlink" title="三、核心功能"></a>三、核心功能</h2><h3 id="3-1-Alluxio存储概述"><a href="#3-1-Alluxio存储概述" class="headerlink" title="3.1 Alluxio存储概述"></a>3.1 Alluxio存储概述</h3><p>Alluxio在帮助统一跨各种平台用户数据的同时还有助于为用户提升总体I/O吞吐量。 Alluxio是通过把存储分为两个不同的类别来实现这一目标的。</p><ul><li><strong>UFS（底层文件存储，也称为底层存储）</strong>该存储空间代表不受Alluxio管理的空间。 UFS存储可能来自外部文件系统，包括如HDFS或S3。 Alluxio可能连接到一个或多个UFS并在一个命名空间中统一呈现这类底层存储。 -通常，UFS存储旨在相当长一段时间持久存储大量数据。</li><li>Alluxio存储<ul><li>Alluxio做为一个分布式缓存来管理Alluxio workers本地存储，包括内存。这个在用户应用程序与各种底层存储之间的快速数据层带来的是显著提高的I/O性能；</li><li>Alluxio存储主要用于存储热数据，暂态数据，而不是长期持久数据存储；</li><li>每个Alluxio节点要管理的存储量和类型由用户配置决定；</li><li>即使数据当前不在Alluxio存储中，通过Alluxio连接的UFS中的文件仍然对Alluxio客户可见。当客户端尝试读取仅可从UFS获得的文件时数据将被复制到Alluxio存储中。</li></ul></li></ul><p><img src="/2021/12/11/alluxio-fen-bu-shi-nei-cun-wen-jian-xi-tong/%E5%9B%BE%E7%89%8715.png" alt="图片15"></p><p>Alluxio存储通过将数据存储在计算节点内存中来提高性能。 Alluxio存储中的数据可以被复制来形成“热”数据，更易于I/O并行操作和使用。</p><p>Alluxio中的数据副本独立于UFS中可能已存在的副本。 Alluxio存储中的数据副本数是由集群活动动态决定的。 由于Alluxio依赖底层文件存储来存储大部分数据， Alluxio不需要保存未使用的数据副本。</p><p>Alluxio还支持让系统存储软件可感知的分层存储，使类似L1/L2 CPU缓存一样的数据存储优化成为可能。</p><h3 id="3-2-配置Alluxio存储"><a href="#3-2-配置Alluxio存储" class="headerlink" title="3.2 配置Alluxio存储"></a>3.2 配置Alluxio存储</h3><h4 id="3-2-1-单层存储"><a href="#3-2-1-单层存储" class="headerlink" title="3.2.1 单层存储"></a>3.2.1 单层存储</h4><p>配置Alluxio存储的最简单方法是使用默认的单层模式。</p><p>请注意，此部分是讲本地存储，诸如<code>mount</code>之类的术语指在本地存储文件系统上挂载，不要与Alluxio的外部底层存储的<code>mount</code>概念混淆。</p><p>在启动时，Alluxio将在每个worker节点上发放一个ramdisk并占用一定比例的系统的总内存。 此ramdisk将用作分配给每个Alluxio worker的唯一存储介质。</p><p>通过Alluxio配置中的<code>alluxio-site.properties</code>来配置Alluxio存储。 详细信息见<a href="https://docs.alluxio.io/os/user/stable/en/operation/Configuration.html" target="_blank" rel="noopener">configuration settings</a>。</p><p>对默认值的常见修改是明确设置ramdisk的大小。 例如，设置每个worker的ramdisk大小为16GB：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">alluxio.worker.ramdisk.size</span>=<span class="string">16GB</span></span><br></pre></td></tr></table></figure><p>另一个常见更改是指定多个存储介质，例如ramdisk和SSD。 需要 更新<code>alluxio.worker.tieredstore.level0.dirs.path</code>以指定想用的每个存储介质 为一个相应的存储目录。 例如，要使用ramdisk(挂载在<code>/mnt/ramdisk</code>上)和两个SSD(挂载在<code>/mnt/ssd1</code>和<code>/mnt/ssd2</code>):</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">alluxio.worker.tieredstore.level0.dirs.path</span>=<span class="string">/mnt/ramdisk,/mnt/ssd1,/mnt/ssd2</span></span><br><span class="line"><span class="meta">alluxio.worker.tieredstore.level0.dirs.mediumtype</span>=<span class="string">MEM,SSD,SSD</span></span><br></pre></td></tr></table></figure><p>请注意，介质类型的顺序必须与路径的顺序相符。 MEM和SSD是Alluxio中的两种预配置存储类型。 <code>alluxio.master.tieredstore.global.mediumtype</code>是包含所有可用的介质类型的配置参数，默认情况下设置为<code>MEM，SSD，HDD</code>。 如果用户有额外存储介质类型可以通过修改这个配置来增加。</p><p>提供的路径应指向挂载适当存储介质的本地文件系统中的路径。 为了实现短路操作，对于这些路径，应允许客户端用户在这些路径上进行读取，写入和执行。 例如，对于与启动Alluxio服务的用户组同组用户应给予<code>770</code>权限。</p><p>更新存储介质后，需要指出每个存储目录分配了多少存储空间。 例如，如果要在ramdisk上使用16 GB，在每个SSD上使用100 GB：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">alluxio.worker.tieredstore.level0.dirs.quota</span>=<span class="string">16GB,100GB,100GB</span></span><br></pre></td></tr></table></figure><p>注意存储空间配置的顺序一定与存储目录的配置相符。</p><p>Alluxio在通过<code>Mount</code>或<code>SudoMount</code>选项启动时，配置并挂载ramdisk。 这个ramdisk大小是由<code>alluxio.worker.ramdisk.size</code>确定的。 默认情况下，tier 0设置为MEM并且管理整个ramdisk。 此时<code>alluxio.worker.tieredstore.level0.dirs.quota</code>的值同<code>alluxio.worker.ramdisk.size</code>一样。 如果tier0要使用除默认的ramdisk以外的设备，应该显式地设置<code>alluxio.worker.tieredstore.level0.dirs.quota</code>选项。</p><h4 id="3-2-2-多层存储"><a href="#3-2-2-多层存储" class="headerlink" title="3.2.2 多层存储"></a>3.2.2 多层存储</h4><p>通常建议异构存储介质也使用单个存储层。 在特定环境中，工作负载将受益于基于I/O速度存储介质明确排序。 Alluxio假定根据按I/O性能从高到低来对多层存储进行排序。 例如，用户经常指定以下层：</p><ul><li>MEM(内存)</li><li>SSD(固态存储)</li><li>HDD(硬盘存储)</li></ul><h5 id="3-2-2-1-写数据"><a href="#3-2-2-1-写数据" class="headerlink" title="3.2.2.1 写数据"></a>3.2.2.1 写数据</h5><p>用户写新的数据块时，默认情况下会将其写入顶层存储。如果顶层没有足够的可用空间， 则会尝试下一层存储。如果在所有层上均未找到存储空间，因Alluxio的设计是易失性存储，Alluxio会释放空间来存储新写入的数据块。 根据块注释策略，空间释放操作会从work中释放数据块。 <a href="https://docs.alluxio.io/os/user/stable/cn/core-services/Caching.html#block-annotation-policies" target="_blank" rel="noopener">块注释策略</a>。 如果空间释放操作无法释放新空间，则写数据将失败。</p><p><strong>注意：</strong>新的释放空间模型是同步模式并会代表要求为其要写入的数据块释放新空白存储空间的客户端来执行释放空间操作。 在块注释策略的帮助下，同步模式释放空间不会引起性能下降，因为总有已排序的数据块列表可用。 然而，可以将<code>alluxio.worker.tieredstore.free.ahead.bytes</code>(默认值：0)配置为每次释放超过释放空间请求所需字节数来保证有多余的已释放空间满足写数据需求。</p><p>用户还可以通过<a href="https://docs.alluxio.io/os/user/stable/cn/core-services/Caching.html#configuring-tiered-storage" target="_blank" rel="noopener">configuration settings</a>来指定写入数据层。</p><h5 id="3-2-2-2-读取数据"><a href="#3-2-2-2-读取数据" class="headerlink" title="3.2.2.2 读取数据"></a>3.2.2.2 读取数据</h5><p>如果数据已经存在于Alluxio中，则客户端将简单地从已存储的数据块读取数据。 如果将Alluxio配置为多层，则不一定是从顶层读取数据块， 因为数据可能已经透明地挪到更低的存储层。</p><p>用<code>ReadType.CACHE_PROMOTE</code>读取数据将在从worker读取数据前尝试首先将数据块挪到顶层存储。也可以将其用作为一种数据管理策略 明确地将热数据移动到更高层存储读取。</p><h5 id="3-2-2-3-配置分层存储"><a href="#3-2-2-3-配置分层存储" class="headerlink" title="3.2.2.3 配置分层存储"></a>3.2.2.3 配置分层存储</h5><p>可以使用以下方式在Alluxio中启用分层存储 <a href="https://docs.alluxio.io/os/user/stable/en/operation/Configuration.html" target="_blank" rel="noopener">配置参数</a>。 为Alluxio指定额外存储层，使用以下配置参数：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">alluxio.worker.tieredstore.levels</span></span><br><span class="line"><span class="attr">alluxio.worker.tieredstore.level&#123;x&#125;.alias</span></span><br><span class="line"><span class="attr">alluxio.worker.tieredstore.level&#123;x&#125;.dirs.quota</span></span><br><span class="line"><span class="attr">alluxio.worker.tieredstore.level&#123;x&#125;.dirs.path</span></span><br><span class="line"><span class="attr">alluxio.worker.tieredstore.level&#123;x&#125;.dirs.mediumtype</span></span><br></pre></td></tr></table></figure><p>例如，如果计划将Alluxio配置为具有两层存储，内存和硬盘存储， 可以使用类似于以下的配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># configure 2 tiers in Alluxio</span></span><br><span class="line"><span class="meta">alluxio.worker.tieredstore.levels</span>=<span class="string">2</span></span><br><span class="line"><span class="comment"># the first (top) tier to be a memory tier</span></span><br><span class="line"><span class="meta">alluxio.worker.tieredstore.level0.alias</span>=<span class="string">MEM</span></span><br><span class="line"><span class="comment"># defined `/mnt/ramdisk` to be the file path to the first tier</span></span><br><span class="line"><span class="meta">alluxio.worker.tieredstore.level0.dirs.path</span>=<span class="string">/mnt/ramdisk</span></span><br><span class="line"><span class="comment"># defined MEM to be the medium type of the ramdisk directory</span></span><br><span class="line"><span class="meta">alluxio.worker.tieredstore.level0.dirs.mediumtype</span>=<span class="string">MEM</span></span><br><span class="line"><span class="comment"># set the quota for the ramdisk to be `100GB`</span></span><br><span class="line"><span class="meta">alluxio.worker.tieredstore.level0.dirs.quota</span>=<span class="string">100GB</span></span><br><span class="line"><span class="comment"># configure the second tier to be a hard disk tier</span></span><br><span class="line"><span class="meta">alluxio.worker.tieredstore.level1.alias</span>=<span class="string">HDD</span></span><br><span class="line"><span class="comment"># configured 3 separate file paths for the second tier</span></span><br><span class="line"><span class="meta">alluxio.worker.tieredstore.level1.dirs.path</span>=<span class="string">/mnt/hdd1,/mnt/hdd2,/mnt/hdd3</span></span><br><span class="line"><span class="comment"># defined HDD to be the medium type of the second tier</span></span><br><span class="line"><span class="meta">alluxio.worker.tieredstore.level1.dirs.mediumtype</span>=<span class="string">HDD,HDD,HDD</span></span><br><span class="line"><span class="comment"># define the quota for each of the 3 file paths of the second tier</span></span><br><span class="line"><span class="meta">alluxio.worker.tieredstore.level1.dirs.quota</span>=<span class="string">2TB,5TB,500GB</span></span><br></pre></td></tr></table></figure><p>可配置层数没有限制 但是每个层都必须使用唯一的别名进行标识。 典型的配置将具有三层，分别是内存，SSD和HDD。 要在HDD层中使用多个硬盘存储，需要在配置<code>alluxio.worker.tieredstore.level{x}.dirs.path</code>时指定多个路径。</p><h4 id="3-2-3-块注释策略"><a href="#3-2-3-块注释策略" class="headerlink" title="3.2.3 块注释策略"></a>3.2.3 块注释策略</h4><p>Alluxio从v2.3开始使用块注释策略来维护存储中数据块的严格顺序。 注释策略定义了跨层块的顺序，并在以下操作过程中进行用来参考: -释放空间 -<a href="https://docs.alluxio.io/os/user/stable/cn/core-services/Caching.html#block-aligning-dynamic-block-placement" target="_blank" rel="noopener">动态块放置</a>。</p><p>与写操作同步发生的释放空间操作将尝试根据块注释策略强制顺序删除块并释放其空间给写操作。注释顺序的最后一个块是第一个释放空间候选对象，无论它位于哪个层上。</p><p>开箱即用的注释策略实施包括:</p><ul><li><strong>LRUAnnotator：</strong>根据最近最少使用的顺序对块进行注释和释放。 <strong>这是Alluxio的默认注释策略</strong>。</li><li><strong>LRFUAnnotator：</strong>根据配置权重的最近最少使用和最不频繁使用的顺序对块进行注释。<ul><li>如果权重完全偏设为最近最少使用，则行为将 与LRUAnnotator相同。</li><li>适用的配置属性包括<code>alluxio.worker.block.annotator.lrfu.step.factor</code> <code>alluxio.worker.block.annotator.lrfu.attenuation.factor</code>。</li></ul></li></ul><p>workers选择使用的注释策略由Alluxio属性 <a href="https://docs.alluxio.io/os/user/stable/en/reference/Properties-List.html#alluxio.worker.block.annotator.class" target="_blank" rel="noopener">alluxio.worker.block.annotator.class</a>决定。 该属性应在配置中指定完全验证的策略名称。当前可用的选项有:</p><ul><li><code>alluxio.worker.block.annotator.LRUAnnotator</code></li><li><code>alluxio.worker.block.annotator.LRFUAnnotator</code></li></ul><h5 id="3-2-3-1-释放空间模拟"><a href="#3-2-3-1-释放空间模拟" class="headerlink" title="3.2.3.1 释放空间模拟"></a>3.2.3.1 释放空间模拟</h5><p>旧的释放空间策略和Alluxio提供的实施现在已去掉了，并用适当的注释策略替换。 配置旧的Alluxio释放空间策略将导致worker启动失败，并报错<code>java.lang.ClassNotFoundException</code>。 同样，旧的基于水位标记配置已失效。因此，以下配置选项是无效的:</p><ul><li><code>alluxio.worker.tieredstore.levelX.watermark.low.ratio</code></li><li><code>alluxio.worker.tieredstore.levelX.watermark.high.ratio</code></li></ul><p>然而，Alluxio支持基于自定义释放空间实施算法数据块注释的仿真模式。该仿真模式假定已配置的释放空间策略创建一个基于某种顺序释放空间的计划，并通过定期提取这种自定义顺序来支持块注释活动。</p><p>旧的释放空间配置应进行如下更改。 (由于旧的释放空间实施已删除，如未能更改基于旧实施的以下配置就会导致class加载错误。)</p><p>-LRUEvictor-&gt; LRUAnnotator -GreedyEvictor-&gt; LRUAnnotator -PartialLRUEvictor-&gt; LRUAnnotator -LRFUEvictor-&gt; LRFUAnnotator</p><h4 id="3-2-4-分层存储管理"><a href="#3-2-4-分层存储管理" class="headerlink" title="3.2.4 分层存储管理"></a>3.2.4 分层存储管理</h4><p>因为块分配/释放不再强制新的写入必须写到特定存储层，新数据块可能最终被写到任何已配置的存储层中。这样允许写入超过Alluxio存储容量的数据。但是，这就需要Alluxio动态管理块放置。 为了确保层配置为从最快到最慢的假设，Alluxio会基于块注释策略在各层存储之间移动数据块。</p><p>每个单独层管理任务都遵循以下配置:</p><ul><li><code>alluxio.worker.management.task.thread.count</code>:管理任务所用线程数。 (默认值:CPU核数)</li><li><code>alluxio.worker.management.block.transfer.concurrency.limit</code>:可以同时执行多少个块传输。 (默认:<code>CPU核数</code>/2)</li></ul><h5 id="3-2-4-1-块对齐-动态块放置"><a href="#3-2-4-1-块对齐-动态块放置" class="headerlink" title="3.2.4.1 块对齐(动态块放置)"></a>3.2.4.1 块对齐(动态块放置)</h5><p>Alluxio将动态地跨层移动数据块，以使块组成与配置的块注释策略一致。</p><p>为辅助块对齐，Alluxio会监视I/O模式并会跨层重组数据块，以确保 <strong>较高层的最低块比下面层的最高块具有更高的次序</strong>。</p><p>这是通过“对齐”这个管理任务来实现的。此管理任务在检测到层之间 顺序已乱时，会通过在层之间交换块位置来有效地将各层与已配置的注释策略对齐以消除乱序。 有关如何控制这些新的后台任务对用户I/O的影响，参见<a href="https://docs.alluxio.io/os/user/stable/cn/core-services/Caching.html#management-task-back-off" target="_blank" rel="noopener">管理任务推后</a>部分。</p><p>用于控制层对齐:</p><ul><li><code>alluxio.worker.management.tier.align.enabled</code>:是否启用层对齐任务。 (默认: <code>true</code>)</li><li><code>alluxio.worker.management.tier.align.range</code>:单个任务运行中对齐多少个块。 (默认值:<code>100</code>)</li><li><code>alluxio.worker.management.tier.align.reserved.bytes</code>:配置多层时，默认情况下在所有目录上保留的空间大小。 (默认:1GB) 用于内部块移动。</li><li><code>alluxio.worker.management.tier.swap.restore.enabled</code>:控制一个特殊任务，该任务用于在内部保留空间用尽时unblock层对齐。 (默认:true) 由于Alluxio支持可变的块大小，因此保留空间可能会用尽，因此，当块大小不匹配时在块对齐期间在层之间块交换会导致一个目录保留空间的减少。</li></ul><h5 id="3-2-4-2-块升级"><a href="#3-2-4-2-块升级" class="headerlink" title="3.2.4.2 块升级"></a>3.2.4.2 块升级</h5><p>当较高层具有可用空间时，低层的块将向上层移动，以便更好地利用较快的磁盘介质，因为假定较高的层配置了较快的磁盘介质。</p><p>用于控制动态层升级:</p><ul><li><code>alluxio.worker.management.tier.promote.enabled</code>:是否启用层升级任务。 (默认: <code>true</code>)</li><li><code>alluxio.worker.management.tier.promote.range</code>:单个任务运行中升级块数。 (默认值:<code>100</code>)</li><li><code>alluxio.worker.management.tier.promote.quota.percent</code>:每一层可以用于升级最大百分比。 一旦其已用空间超过此值，向此层升级将停止。 (0表示永不升级，100表示总是升级。)</li></ul><h5 id="3-2-4-3-管理任务推后"><a href="#3-2-4-3-管理任务推后" class="headerlink" title="3.2.4.3 管理任务推后"></a>3.2.4.3 管理任务推后</h5><p>层管理任务(对齐/升级)会考虑用户I/O并在worker/disk重载情况下推后运行。 这是为了确保内部管理任务不会对用户I/O性能产生负面影响。</p><p>可以在<code>alluxio.worker.management.backoff.strategy</code>属性中设置两种可用的推后类型，分别是Any和DIRECTORY。</p><ul><li><code>ANY</code>; 当有任何用户I/O时，worker管理任务将推后。 此模式将确保较低管理任务开销，以便提高即时用户I/O性能。 但是，管理任务要取得进展就需要在worker上花更长的时间。</li><li><code>DIRECTORY</code>; 管理任务将从有持续用户I/O的目录中推后。 此模式下管理任务更易取得进展。 但是，由于管理任务活动的增加，可能会降低即时用户I/O吞吐量。</li></ul><p>影响这两种推后策略的另一个属性是<code>alluxio.worker.management.load.detection.cool.down.time</code>，控制多长时间的用户I/O计为在目标directory/worker上的一个负载。</p><h3 id="3-3-Alluxio中数据生命周期管理"><a href="#3-3-Alluxio中数据生命周期管理" class="headerlink" title="3.3 Alluxio中数据生命周期管理"></a>3.3 Alluxio中数据生命周期管理</h3><p>用户需要理解以下概念，以正确利用可用资源:</p><ul><li><strong>free：</strong>释放数据是指从Alluxio缓存中删除数据，而不是从底层UFS中删除数据。 释放操作后，数据仍然可供用户使用，但对Alluxio释放文件后尝试访问该文件 的客户端来讲性能可能会降低。</li><li><strong>load：</strong>加载数据意味着将其从UFS复制到Alluxio缓存中。如果Alluxio使用基于内存的存储，加载后用户可能会看到I/O性能的提高。</li><li><strong>persist：</strong>持久数据是指将Alluxio存储中可能被修改过或未被修改过的数据写回UFS。 通过将数据写回到UFS，可以保证如果Alluxio节点发生故障数据还是可恢复的。</li><li><strong>TTL(Time to Live)：</strong>TTL属性设置文件和目录的生存时间，以在数据超过其生存时间时将它们从Alluxio空间中删除。还可以配置 TTL来删除存储在UFS中的相应数据。</li></ul><h4 id="3-3-1-从Alluxio存储中释放数据"><a href="#3-3-1-从Alluxio存储中释放数据" class="headerlink" title="3.3.1 从Alluxio存储中释放数据"></a>3.3.1 从Alluxio存储中释放数据</h4><p>为了在Alluxio中手动释放数据，可以使用<code>./bin/alluxio</code>文件系统命令 行界面。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./bin/alluxio fs free <span class="variable">$&#123;PATH_TO_UNUSED_DATA&#125;</span></span></span><br></pre></td></tr></table></figure><p>这将从Alluxio存储中删除位于给定路径的数据。如果数据是持久存储到UFS的则仍然可以访问该数据。有关更多信息，参考 <a href="https://docs.alluxio.io/os/user/stable/en/operation/User-CLI.html#free" target="_blank" rel="noopener">命令行界面文档</a></p><p>注意，用户通常不需要手动从Alluxio释放数据，因为配置的<a href="https://docs.alluxio.io/os/user/stable/cn/core-services/Caching.html#block-annotation-policies" target="_blank" rel="noopener">注释策略</a>将负责删除未使用或旧数据。</p><h4 id="3-3-2-将数据加载到Alluxio存储中"><a href="#3-3-2-将数据加载到Alluxio存储中" class="headerlink" title="3.3.2 将数据加载到Alluxio存储中"></a>3.3.2 将数据加载到Alluxio存储中</h4><p>如果数据已经在UFS中，使用 <a href="https://docs.alluxio.io/os/user/stable/en/operation/User-CLI.html#load" target="_blank" rel="noopener"><code>alluxio fs load</code></a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./bin/alluxio fs load <span class="variable">$&#123;PATH_TO_FILE&#125;</span></span></span><br></pre></td></tr></table></figure><p>要从本地文件系统加载数据，使用命令 <a href="https://docs.alluxio.io/os/user/stable/en/operation/User-CLI.html#copyfromlocal" target="_blank" rel="noopener"><code>alluxio fs copyFromLocal</code></a>。 这只会将文件加载到Alluxio存储中，而不会将数据持久保存到UFS中。 将写入类型设置为<code>MUST_CACHE</code>写入类型将不会将数据持久保存到UFS， 而设置为<code>CACHE</code>和<code>CACHE_THROUGH</code>将会持久化保存。不建议手动加载数据，因为，当首次使用文件时Alluxio会自动将数据加载到Alluxio缓存中。</p><h4 id="3-3-3-在Alluxio中持久化保留数据"><a href="#3-3-3-在Alluxio中持久化保留数据" class="headerlink" title="3.3.3 在Alluxio中持久化保留数据"></a>3.3.3 在Alluxio中持久化保留数据</h4><p>命令<a href="https://docs.alluxio.io/os/user/stable/en/operation/User-CLI.html#persist" target="_blank" rel="noopener"><code>alluxio fs persist</code></a> 允许用户将数据从Alluxio缓存推送到UFS。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./bin/alluxio fs persist <span class="variable">$&#123;PATH_TO_FILE&#125;</span></span></span><br></pre></td></tr></table></figure><p>如果您加载到Alluxio的数据不是来自已配置的UFS，则上述命令很有用。 在大多数情况下，用户不必担心手动来持久化保留数据。</p><h4 id="3-3-4-设置生存时间-TTL"><a href="#3-3-4-设置生存时间-TTL" class="headerlink" title="3.3.4 设置生存时间(TTL)"></a>3.3.4 设置生存时间(TTL)</h4><p>Alluxio支持命名空间中每个文件和目录的”生存时间(TTL)”设置。此功能可用于有效地管理Alluxio缓存，尤其是在严格保证数据访问模式的环境中。例如，如果对上一周提取数据进行分析， 则TTL功能可用于明确刷新旧数据，从而为新文件释放缓存空间。</p><p>Alluxio具有与每个文件或目录关联的TTL属性。这些属性将保存为日志的一部分，所以集群重启后也能持久保持。活跃master节点负责当Alluxio提供服务时将元数据保存在内存中。在内部，master运行一个后台线程，该线程定期检查文件是否已达到其TTL到期时间。</p><p><strong>注意：</strong>后台线程按配置的间隔运行，默认设置为一个小时。 在检查后立即达到其TTL期限的数据不会马上删除， 而是等到一个小时后下一个检查间隔才会被删除。</p><p>如将间隔设置为10分钟，在<code>alluxio-site.properties</code>添加以下配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">alluxio.master.ttl.checker.interval</span>=<span class="string">10m</span></span><br></pre></td></tr></table></figure><p>请参考<a href="https://docs.alluxio.io/os/user/stable/cn/operation/Configuration.html" target="_blank" rel="noopener">配置页</a> CN以获取有关设置Alluxio配置的更多详细信息。</p><h5 id="3-3-4-1-API"><a href="#3-3-4-1-API" class="headerlink" title="3.3.4.1 API"></a>3.3.4.1 API</h5><p>有两种设置路径的TTL属性的方法。</p><blockquote><ol><li>通过Alluxio shell命令行</li><li>每个元数据加载或文件创建被动设置</li></ol></blockquote><p>TTL API如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SetTTL(path，duration，action)</span><br><span class="line">`path` Alluxio命名空间中的路径</span><br><span class="line">`duration`TTL动作生效前的毫秒数，这会覆盖任何先前的设置</span><br><span class="line">`action`生存时间过去后要执行的`action`。</span><br><span class="line"> `FREE` 将导致文件从Alluxio存储中删除释放，无论其目前的状态如何。</span><br><span class="line"> `DELETE` 将导致文件从Alluxio命名空间和底层存储中删除。注意:`DELETE`是某些命令的默认设置，它将导致文件被永久删除。</span><br></pre></td></tr></table></figure><h5 id="3-3-4-2-命令行用法"><a href="#3-3-4-2-命令行用法" class="headerlink" title="3.3.4.2 命令行用法"></a>3.3.4.2 命令行用法</h5><p>了解如何使用<code>setTtl</code>命令在Alluxio shell中修改TTL属性参阅详细的 <a href="https://docs.alluxio.io/os/user/stable/cn/operation/User-CLI.html#setttl" target="_blank" rel="noopener">命令行文档</a>。</p><h5 id="3-3-4-3-Alluxio中文件上的被动TTL设置"><a href="#3-3-4-3-Alluxio中文件上的被动TTL设置" class="headerlink" title="3.3.4.3 Alluxio中文件上的被动TTL设置"></a>3.3.4.3 Alluxio中文件上的被动TTL设置</h5><p>Alluxio客户端可以配置为只要在Alluxio命名空间添加新文件时就添加TTL属性。 当预期用户是临时使用文件情况下，被动TTL很有用 ，但它不灵活，因为来自同一客户端的所有请求将继承 相同的TTL属性。</p><p>被动TTL通过以下选项配置:</p><ul><li><code>alluxio.user.file.create.ttl</code>：在Alluxio中文件上设置的TTL持续时间。 默认情况下，未设置TTL持续时间。</li><li><code>alluxio.user.file.create.ttl.action</code>：对文件设置的TTL到期后的操作 在Alluxio中。<strong>注意：默认情况下，此操作为“DELETE”，它将导致文件永久被删除。</strong></li></ul><p>TTL默认情况下处于不使用状态，仅当客户有严格数据访问模式才启用。</p><p>例如，要3分钟后删除由<code>runTests</code>创建的文件:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./bin/alluxio runTests -Dalluxio.user.file.create.ttl=3m \</span></span><br><span class="line">  -Dalluxio.user.file.create.ttl.action=DELETE</span><br></pre></td></tr></table></figure><p>对于这个例子，确保<code>alluxio.master.ttl.checker.interval</code>被设定为短间隔，例如一分钟，以便master能快速识别过期文件。</p><h3 id="3-4-在Alluxio中管理数据复制"><a href="#3-4-在Alluxio中管理数据复制" class="headerlink" title="3.4 在Alluxio中管理数据复制"></a>3.4 在Alluxio中管理数据复制</h3><h4 id="3-4-1-被动复制"><a href="#3-4-1-被动复制" class="headerlink" title="3.4.1 被动复制"></a>3.4.1 被动复制</h4><p>与许多分布式文件系统一样，Alluxio中的每个文件都包含一个或多个分布在集群中存储的存储块。默认情况下，Alluxio可以根据工作负载和存储容量自动调整不同块的复制级别。例如，当更多的客户以类型<code>CACHE</code>或<code>CACHE_PROMOTE</code>请求来读取此块时Alluxio可能会创建此特定块更多副本。当较少使用现有副本时，Alluxio可能会删除一些不常用现有副来为经常访问的数据征回空间(<a href="https://docs.alluxio.io/os/user/stable/cn/core-services/Caching.html#block-annotation-policies" target="_blank" rel="noopener">块注释策略</a>)。 在同一文件中不同的块可能根据访问频率不同而具有不同数量副本。</p><p>默认情况下，此复制或征回决定以及相应的数据传输对访问存储在Alluxio中数据的用户和应用程序完全透明。</p><h4 id="3-4-2-主动复制"><a href="#3-4-2-主动复制" class="headerlink" title="3.4.2 主动复制"></a>3.4.2 主动复制</h4><p>除了动态复制调整之外，Alluxio还提供API和命令行 界面供用户明确设置文件的复制级别目标范围。 尤其是，用户可以在Alluxio中为文件配置以下两个属性:</p><ol><li><code>alluxio.user.file.replication.min</code>是此文件的最小副本数。 默认值为0，即在默认情况下，Alluxio可能会在文件变冷后从Alluxio管理空间完全删除该文件。 通过将此属性设置为正整数，Alluxio 将定期检查此文件中所有块的复制级别。当某些块的复制数不足时，Alluxio不会删除这些块中的任何一个，而是主动创建更多副本以恢复其复制级别。</li><li><code>alluxio.user.file.replication.max</code>是最大副本数。一旦文件该属性设置为正整数，Alluxio将检查复制级别并删除多余的副本。将此属性设置为-1为不设上限(默认情况)，设置为0以防止在Alluxio中存储此文件的任何数据。注意，<code>alluxio.user.file.replication.max</code>的值必须不少于<code>alluxio.user.file.replication.min</code>。</li></ol><p>例如，用户可以最初使用至少两个副本将本地文件<code>/path/to/file</code>复制到Alluxio:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./bin/alluxio fs -Dalluxio.user.file.replication.min=2 \</span></span><br><span class="line">copyFromLocal /path/to/file /file</span><br></pre></td></tr></table></figure><p>接下来，设置<code>/file</code>的复制级别区间为3到5。需要注意的是，在后台进程中完成新的复制级别范围设定后此命令将马上返回，实现复制目标是异步完成的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./bin/alluxio fs setReplication --min 3 --max 5 /file</span></span><br></pre></td></tr></table></figure><p>设置<code>alluxio.user.file.replication.max</code>为无上限。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./bin/alluxio fs setReplication --max -1 /file</span></span><br></pre></td></tr></table></figure><p>重复递归复制目录<code>/dir</code>下所有文件复制级别(包括其子目录）使用<code>-R</code>:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./bin/alluxio fs setReplication --min 3 --max -5 -R /dir</span></span><br></pre></td></tr></table></figure><p>要检查的文件的目标复制水平，运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./bin/alluxio fs <span class="built_in">stat</span> /foo</span></span><br></pre></td></tr></table></figure><p>并在输出中查找<code>replicationMin</code>和<code>replicationMax</code>字段。</p><h3 id="3-5-检查Alluxio缓存容量和使用情况"><a href="#3-5-检查Alluxio缓存容量和使用情况" class="headerlink" title="3.5 检查Alluxio缓存容量和使用情况"></a>3.5 检查Alluxio缓存容量和使用情况</h3><p>Alluxio shell命令<code>fsadmin report</code>提供可用空间的简短摘要以及其他有用的信息。输出示例如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./bin/alluxio fsadmin report</span></span><br><span class="line">Alluxio cluster summary:</span><br><span class="line">    Master Address: hadoop2:19998</span><br><span class="line">    Web Port: 19999</span><br><span class="line">    Rpc Port: 19998</span><br><span class="line">    Started: 12-10-2021 18:34:50:977</span><br><span class="line">    Uptime: 2 day(s), 16 hour(s), 47 minute(s), and 46 second(s)</span><br><span class="line">    Version: 2.6.2</span><br><span class="line">    Safe Mode: false</span><br><span class="line">    Zookeeper Enabled: true</span><br><span class="line">    Zookeeper Addresses:</span><br><span class="line">        hadoop1:2181</span><br><span class="line">        hadoop2:2181</span><br><span class="line">        hadoop3:2181</span><br><span class="line">    Live Workers: 3</span><br><span class="line">    Lost Workers: 0</span><br><span class="line">    Total Capacity: 7.40GB</span><br><span class="line">        Tier: MEM  Size: 7.40GB</span><br><span class="line">    Used Capacity: 1804B</span><br><span class="line">        Tier: MEM  Size: 1804B</span><br><span class="line">    Free Capacity: 7.40GB</span><br></pre></td></tr></table></figure><p><strong>Alluxio shell还允许用户检查Alluxio缓存中多少空间可用和在用。</strong></p><p>获得Alluxio缓存总使用字节数运行:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./bin/alluxio fs getUsedBytes</span></span><br></pre></td></tr></table></figure><p>获得Alluxio缓存以字节为单位的总容量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./bin/alluxio fs getCapacityBytes</span></span><br></pre></td></tr></table></figure><p>Alluxio master web界面为用户提供了集群的可视化总览包括已用多少存储空间。可以在<code>http:/{MASTER_IP}:${alluxio.master.web.port}/</code>中找到。 有关Alluxio Web界面的更多详细信息可以在 <a href="https://docs.alluxio.io/os/user/stable/en/operation/Web-Interface.html" target="_blank" rel="noopener">相关文档</a> 中找到。</p><h2 id="四、Alluxio-高可用集群部署"><a href="#四、Alluxio-高可用集群部署" class="headerlink" title="四、Alluxio 高可用集群部署"></a>四、Alluxio 高可用集群部署</h2><p><strong>服务规划</strong></p><table><thead><tr><th>主机名</th><th>Alluxio 角色</th><th>依赖服务</th></tr></thead><tbody><tr><td>hadoop1</td><td>master、worker</td><td>JDK1.8、zookeeper</td></tr><tr><td>hadoop2</td><td>master、worker</td><td>JDK1.8、zookeeper</td></tr><tr><td>hadoop3</td><td>worker</td><td>JDK1.8、zookeeper</td></tr></tbody></table><p><strong>前置条件</strong></p><blockquote><p>服务器免密登录（确保master可以免密登录到worker节点）<br>zk环境是可用的</p><p>Hadoop HDFS是可用的，保存master检查点信息用于HA快速恢复</p></blockquote><h3 id="4-1-安装-jdk"><a href="#4-1-安装-jdk" class="headerlink" title="4.1 安装 jdk"></a>4.1 安装 jdk</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@hadoop1 ~]$ tar xf downloads/jdk-8u301-linux-x64.tar.gz</span><br><span class="line">[hadoop@hadoop1 ~]$ vim .bash_profile</span><br><span class="line">export JAVA_HOME=/home/hadoop/jdk1.8.0_301</span><br><span class="line">export JRE_HOME=$&#123;JAVA_HOME&#125;/jre</span><br><span class="line">export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib</span><br><span class="line"></span><br><span class="line">[hadoop@hadoop1 ~]$ source .bash_profile</span><br></pre></td></tr></table></figure><h3 id="4-2-配置-Alluxio"><a href="#4-2-配置-Alluxio" class="headerlink" title="4.2 配置 Alluxio"></a>4.2 配置 Alluxio</h3><p><strong>准备Alluxio</strong> ，在各节点分别下载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@hadoop1 ~/downloads]$ wget https://downloads.alluxio.io/downloads/files/2.6.2/alluxio-2.6.2-bin.tar.gz</span><br><span class="line">[hadoop@hadoop1 ~]$ tar xf downloads/alluxio-2.6.2-bin.tar.gz</span><br><span class="line">[hadoop@hadoop1 ~]$ cd alluxio-2.6.2/</span><br></pre></td></tr></table></figure><p><strong>编辑 alluxio-site.properties 配置文件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@hadoop1 ~/alluxio-2.6.2]$ cp conf/alluxio-site.properties.template conf/alluxio-site.properties</span><br><span class="line">[hadoop@hadoop1 ~/alluxio-2.6.2]$ vim conf/alluxio-site.properties</span><br><span class="line"><span class="meta">#</span><span class="bash"> 主节点名称</span></span><br><span class="line">alluxio.master.hostname=hadoop1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 高可用配置</span></span><br><span class="line">alluxio.zookeeper.enabled=true</span><br><span class="line">alluxio.zookeeper.address=hadoop1:2181,hadoop2:2181,hadoop3:2181</span><br><span class="line">alluxio.master.journal.type=UFS</span><br><span class="line">alluxio.master.journal.folder=hdfs://hadoop2:8020/alluxio/journal/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Worker properties <span class="comment">#有几个层级的存储就写几，比如我们要配置的只有level0一层，就写1</span></span></span><br><span class="line">alluxio.worker.ramdisk.size=16GB</span><br><span class="line">alluxio.worker.tieredstore.levels=1</span><br><span class="line">alluxio.worker.tieredstore.level0.alias=MEM</span><br><span class="line">alluxio.worker.tieredstore.level0.dirs.path=/home/hadoop/alluxio-2.6.2/ramdisk</span><br></pre></td></tr></table></figure><p><strong>编辑 masters 配置文件</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@hadoop2 ~/alluxio-2.6.2]<span class="formula">$ vim conf/masters</span></span><br><span class="line"><span class="formula">hadoop1</span></span><br><span class="line"><span class="formula">hadoop2</span></span><br></pre></td></tr></table></figure><p><strong>编辑 masters 配置文件</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@hadoop2 ~/alluxio-2.6.2]<span class="formula">$ vim conf/workers</span></span><br><span class="line"><span class="formula">hadoop1</span></span><br><span class="line"><span class="formula">hadoop2</span></span><br><span class="line"><span class="formula">hadoop3</span></span><br></pre></td></tr></table></figure><p><strong>编辑 alluxio-env.sh 配置文件</strong>，添加java环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@hadoop1 ~/alluxio-2.6.2]$ vim conf/alluxio-env.sh</span><br><span class="line"></span><br><span class="line">JAVA_HOME=/home/hadoop/jdk1.8.0_301</span><br></pre></td></tr></table></figure><p><strong>将配置颁发到其它alluxio节点上</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@hadoop1 ~/alluxio-2.6.2]$ scp conf/* hadoop@hadoop2:~/alluxio-2.6.2/conf/</span><br><span class="line">[hadoop@hadoop1 ~/alluxio-2.6.2]$ scp conf/* hadoop@hadoop3:~/alluxio-2.6.2/conf/</span><br></pre></td></tr></table></figure><blockquote><p>确保master节点的 <code>alluxio.master.hostname</code> 配置为该节点的本机地址（hadoop2节点的 <code>alluxio.master.hostname=hadoop2</code>）</p></blockquote><h3 id="4-3-启动-Alluxio-HA-集群"><a href="#4-3-启动-Alluxio-HA-集群" class="headerlink" title="4.3 启动 Alluxio HA 集群"></a>4.3 启动 Alluxio HA 集群</h3><p><strong>格式 Alluxio</strong>，Alluxio 集群在其中一个主节点中使用以下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@hadoop1 ~/alluxio-2.6.2]$ ./bin/alluxio format</span><br></pre></td></tr></table></figure><p><strong>启动 Alluixo</strong>，在可以进行免密登录的机器上执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@hadoop1 ~/alluxio-2.6.2]$ ./bin/alluxio-start.sh all SudoMount</span><br></pre></td></tr></table></figure><blockquote><p>参数<code>SudoMount</code>表示使用<code>sudo</code>特权将 RamFS 挂载到每个 worker 上（如果尚未挂载）</p></blockquote><p><strong>验证 Alluxio 集群</strong></p><p>要验证 Alluxio 是否正在运行，您可以访问主master 的 web UI。要确定主master可在任意节点使用 <code>alluxio fs masterInfo</code> 查询</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@hadoop3 ~/alluxio-2.6.2]$ ./bin/alluxio fs masterInfo</span><br><span class="line">Current leader master: hadoop1:19998</span><br><span class="line">All masters: [hadoop1:19998, hadoop2:19998]</span><br></pre></td></tr></table></figure><p><strong>访问 web UI</strong>，master和worker都拥有各自的Web UI页面。master Web界面的默认 端口是19999，worker的端口是30000。</p><p><img src="/2021/12/11/alluxio-fen-bu-shi-nei-cun-wen-jian-xi-tong/%E5%9B%BE%E7%89%8716.png" alt="图片16"></p><p><img src="/2021/12/11/alluxio-fen-bu-shi-nei-cun-wen-jian-xi-tong/%E5%9B%BE%E7%89%8717.png" alt="图片17"></p><h3 id="4-4-挂载-HDFS-存储"><a href="#4-4-挂载-HDFS-存储" class="headerlink" title="4.4 挂载 HDFS 存储"></a>4.4 挂载 HDFS 存储</h3><h4 id="4-4-1-配置文件挂载"><a href="#4-4-1-配置文件挂载" class="headerlink" title="4.4.1 配置文件挂载"></a>4.4.1 配置文件挂载</h4><p><strong>编辑Master节点的 alluxio-site.properties 配置文件</strong>，添加以下配置</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@hadoop2 ~/alluxio-2.6.2]<span class="formula">$ vim conf/alluxio-site.properties</span></span><br><span class="line"><span class="formula">alluxio.master.mount.table.root.ufs=hdfs://hadoop2:8020/alluxio</span></span><br></pre></td></tr></table></figure><blockquote><p>Alluxio默认使用本地文件作为文件系统 <code>alluxio.master.mount.table.root.ufs=${alluxio.work.dir}/underFSStorage</code></p></blockquote><p><strong>重启 Master 服务</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@hadoop1 ~/alluxio-2.6.2]$ ./bin/alluxio-stop.sh master</span><br><span class="line">[hadoop@hadoop2 ~/alluxio-2.6.2]$ ./bin/alluxio-stop.sh master</span><br><span class="line"></span><br><span class="line">[hadoop@hadoop1 ~/alluxio-2.6.2]$ ./bin/alluxio-start.sh master</span><br><span class="line">[hadoop@hadoop2 ~/alluxio-2.6.2]$ ./bin/alluxio-start.sh master</span><br></pre></td></tr></table></figure><p><strong>查看挂载的hdfs存储</strong></p><p><img src="/2021/12/11/alluxio-fen-bu-shi-nei-cun-wen-jian-xi-tong/%E5%9B%BE%E7%89%8718.png" alt="图片18"></p><p>现在已经把hdfs的alluxio目录挂载为alluxio的根目录，接下来我们运行alluxio自带的示例程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@hadoop2 ~/alluxio-2.6.2]$ ./bin/alluxio runTests</span><br></pre></td></tr></table></figure><p>创建完示例文件后可以在alluxio和hdfs查看到了</p><p><img src="/2021/12/11/alluxio-fen-bu-shi-nei-cun-wen-jian-xi-tong/%E5%9B%BE%E7%89%8719.png" alt="图片19"></p><p><img src="/2021/12/11/alluxio-fen-bu-shi-nei-cun-wen-jian-xi-tong/%E5%9B%BE%E7%89%8721.png" alt="图片21"></p><h4 id="4-4-2-命令行挂载"><a href="#4-4-2-命令行挂载" class="headerlink" title="4.4.2 命令行挂载"></a>4.4.2 命令行挂载</h4><p>配置文件挂载，只能挂载到<code>/</code>根目录，如果需要挂载多个hdfs目录或多个hdfs集群，只能通过命令行进行挂载了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 挂载多个hdfs目录</span></span><br><span class="line">[hadoop@hadoop2 ~/alluxio-2.6.2]$ ./bin/alluxio fs mount /hdfs2 hdfs://hadoop2:8020/hbase</span><br><span class="line">[hadoop@hadoop2 ~/alluxio-2.6.2]$ ./bin/alluxio fs mount /hive hdfs://hadoop2:8020/hive</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 挂载多个hdfs集群需要指定hdfs-site.xml,core-site.xml配置文件</span></span><br><span class="line">[hadoop@hadoop2 ~/alluxio-2.6.2]$ ./bin/alluxio fs mount /alluxio hdfs://hadoop2:8020/alluxio \</span><br><span class="line">--option alluxio.underfs.hdfs.configuration=/home/hadoop/hadoop-2.7.2/etc/hadoop/core-site.xml:/home/hadoop/hadoop-2.7.2/etc/hadoop/hdfs-site.xml</span><br><span class="line">[hadoop@hadoop2 ~/alluxio-2.6.2]$ ./bin/alluxio fs mount /druid hdfs://mycluster/druid \</span><br><span class="line">--option alluxio.underfs.hdfs.configuration=/home/hadoop/hadoop-2.7.2/etc/hadoop/core-site.xml:/home/hadoop/hadoop-2.7.2/etc/hadoop/hdfs-site.xml</span><br></pre></td></tr></table></figure><p><strong>查看挂载的hdfs存储</strong></p><p><img src="/2021/12/11/alluxio-fen-bu-shi-nei-cun-wen-jian-xi-tong/%E5%9B%BE%E7%89%8722.png" alt="图片22"></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Nov 08 2022 22:51:10 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;一、Alluxio概览&quot;&gt;&lt;a href=&quot;#一、Alluxio概览&quot; class=&quot;headerlink&quot; title=&quot;一、All
      
    
    </summary>
    
    
      <category term="Hadoop" scheme="http://chenzhonzhou.github.io/categories/Hadoop/"/>
    
    
      <category term="Hadoop" scheme="http://chenzhonzhou.github.io/tags/Hadoop/"/>
    
      <category term="Alluxio" scheme="http://chenzhonzhou.github.io/tags/Alluxio/"/>
    
  </entry>
  
  <entry>
    <title>Apache Doris和 ClickHouse深度对比</title>
    <link href="http://chenzhonzhou.github.io/2021/12/07/apache-doris-he-clickhouse-shen-du-dui-bi/"/>
    <id>http://chenzhonzhou.github.io/2021/12/07/apache-doris-he-clickhouse-shen-du-dui-bi/</id>
    <published>2021-12-07T08:03:39.000Z</published>
    <updated>2021-12-07T10:54:39.905Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Nov 08 2022 22:51:10 GMT+0800 (GMT+08:00) --><h2 id="一、背景介绍"><a href="#一、背景介绍" class="headerlink" title="一、背景介绍"></a>一、背景介绍</h2><p>Apache Doris是由百度贡献的开源MPP分析型数据库产品，亚秒级查询响应时间，支持实时数据分析；分布式架构简洁，易于运维，可以支持10PB以上的超大数据集；可以满足多种数据分析需求，例如固定历史报表，实时数据分析，交互式数据分析和探索式数据分析等。</p><p>ClickHouse是俄罗斯的搜索公司Yandex开源的MPP架构的分析引擎，号称比事务数据库快100-1000倍，团队有计算机体系结构的大牛，最大的特色是高性能的向量化执行引擎，而且功能丰富、可靠性高。</p><h2 id="二、差异和选择建议"><a href="#二、差异和选择建议" class="headerlink" title="二、差异和选择建议"></a>二、差异和选择建议</h2><p><strong>Doris 更优的方面</strong></p><ul><li>使用更简单，如建表更简单，SQL标准支持更好， Join性能更好，导数功能更强大；</li><li>运维更简单，如灵活的扩缩容能力，故障节点自动恢复，社区提供的支持更好；</li><li>分布式更强，支持事务和幂等性导数，物化视图自动聚合，查询自动路由，全面元数据管理。</li></ul><p><strong>ClickHouse 更优的方面</strong></p><ul><li>性能更佳，导入性能和单表查询性能更好，同时可靠性更好；</li><li>功能丰富，非常多的表引擎，更多类型和函数支持，更好的聚合函数以及庞大的优化参数选项；</li><li>集群管理工具更多，更好多租户和配额管理，灵活的集群管理，方便的集群间迁移工具。</li></ul><p><strong>那么两者之间如何选择呢？</strong></p><ul><li>业务场景复杂数据规模巨大，希望投入研发力量做定制开发，选ClickHouse</li><li>希望一站式的分析解决方案，少量投入研发资源，选择Doris</li></ul><p>另外， Doris源自在线广告系统，偏交易系统数据分析；ClickHouse起源于网站流量分析服务，偏互联网数据分析，但是这两类场景这两个引擎都可以覆盖。如果说两者不那么强的地方，ClickHouse的问题是使用门槛高、运维成本高和分布式能力太弱，需要较多的定制化和较深的技术实力，Doris的问题是性能差一些可靠性差一些，下面就深入分析两者的差异。</p><h2 id="三、架构分析"><a href="#三、架构分析" class="headerlink" title="三、架构分析"></a>三、架构分析</h2><p>从部署运维、分布式能力、数据导入、查询、存储和使用成本等方面进行对比，这部分会涉及到内核中的设计原理、方案和实现，了解这些原理会有助于理解上文的结论。</p><h3 id="3-1-部署运维"><a href="#3-1-部署运维" class="headerlink" title="3.1 部署运维"></a>3.1 部署运维</h3><p><strong>1）部署和日常运维</strong></p><p>部署指部署集群，安装相关依赖和核心组件，修改配置文件，让集群正常运行起来；运维指日常集群版本更新，配置文件更改、扩缩容等相关事项。集群所需组件如下：</p><p><img src="/2021/12/07/apache-doris-he-clickhouse-shen-du-dui-bi/%E5%9B%BE%E7%89%871.png" alt="图片1"></p><ul><li>左侧是Doris的部署架构图，JDBC指接入协议，DNS是域名和请求分发系统。Managerment Panel是管控面。Frontend指前端模块简称FE，包含了SQL解析、查询计划、计划调度、元数据管理等功能，Backend指后端模块简称BE负责存储层、数据读取和写入，另外还有一个BrokerLoad导数组件最好是单独部署。所以，Doris一般只需要FE和BE两个组件。</li><li>右侧是ClickHouse的部署架构图，ClickHouse本身只有一个模块，就是ClickHouse Server，周边有两个模块，如ClickHouseProxy主要是转发请求、配额限制和容灾等，ZooKeeper这块负责分布式DDL和副本间数据同步，ClickHouseCopier负责集群和数据迁移，ClickHouse一般需要Server、ZooKeeper和CHProxy三个组件。</li><li>日常运维如更新版本、更改配置文件两者都需要依赖Ansible或者SaltStack来进行批量更新。两者都有部分配置文件可以热更新，不用重启节点，而且有Session相关参数可以设置可以覆盖配置文件。Doris有较多的SQL命令协助运维，比如增加节点，Doris中Add Backend即可，ClickHouse中需要更改配置文件并下发到各个节点上。</li></ul><p><strong>2）多租户管理</strong></p><p>ClickHouse的权限和Quota的粒度更细，可以很方便的支持多租户使用共享集群。比如可以设置查询内存、查询线程数量、查询超时等，以便来限制查询的大小；同时结合查询并发和一定时间窗口内的查询数量，以便来控制查询数量。多租户的方案，对发展中的业务非常友好，因为使用共享集群资源，可以快速动态调整配额，如果是独占集群资源利用率不高、扩容相对麻烦。</p><p><img src="/2021/12/07/apache-doris-he-clickhouse-shen-du-dui-bi/%E5%9B%BE%E7%89%872.png" alt="图片2"></p><p><strong>3）集群迁移</strong></p><p>Doris通过内置的backup/restore命令将数据和元数据备份到三方对象存储或者HDFS上，backup可以通过快照的方式完整导出一致性的数据和元数据，并且可以按照分区来实现增量备份，降低备份的成本。在Doris中，有一种变通的迁移集群的方法，把新机器分批加入到已有的集群，然后再把旧机器逐步下线，集群能够自动均衡，这个过程视集群数据量可能会持续数天。</p><p>ClickHouse有几个方法实现数据迁移，数据量大通过自带的Clickhouse-copier工具进行集群间的数据拷贝，实现数据的跨集群迁移，需要手工配置很多信息，我们做了一些完善和改进；数据量小通过SQL命令remote关键字实现跨集群的数据迁移。而官方对实现其他存储介质的备份和恢复的推荐是采用文件系统的snapshot实现，或者可以通过三方工具（<a href="https://github.com/AlexAkulov/clickhouse-backup" target="_blank" rel="noopener">https://github.com/AlexAkulov/clickhouse-backup</a> ）来实现。</p><p><strong>4）扩容/缩容</strong></p><p>Doris支持集群的在线动态扩缩容，通过内置的SQL命令 <code>alter system add/decomission backends</code> 即可进行节点的扩缩容，数据均衡的粒度是tablet，每个tablet大概是数百兆，扩容后表的tablet会自动拷贝到新的BE节点，如果在线扩容，应该小批量去增加BE，避免过于剧烈导致集群不稳定。</p><p><img src="/2021/12/07/apache-doris-he-clickhouse-shen-du-dui-bi/%E5%9B%BE%E7%89%873.png" alt="图片3"></p><p>ClickHouse的扩容缩容复杂且繁琐，目前做不到自动在线操作，需要自研工具支持。扩容时需要部署新的节点，添加新分片和副本到配置文件中，并在新节点上创建元数据，如果是扩副本数据会自动均衡，如果是扩分片，需要手工去做均衡，或自研相关工具，让均衡自动进行。</p><h3 id="3-2-分布式能力"><a href="#3-2-分布式能力" class="headerlink" title="3.2 分布式能力"></a>3.2 分布式能力</h3><p><strong>1）分布式协议和高可用</strong></p><p>Doris在FrontEnd中包含元数据的管理能力，内置了BerkeleyDB JE HA组件，包含选举策略和副本数据同步，提供了FE的高可用方案。FE中管理的元数据也非常丰富，包含节点、集群、库、表和用户信息，以及分区、Tablet等数据信息，也包含事务、后台任务、DDL操作和导数相关任务等信息。</p><p>Doris的 FrontEnd可以部署3个Follwer + n个Observer（n&gt;=0）的方式来实现元数据和访问连接的高可用，Follower参与选主，在有Leader宕机时，会自动的选举出新节点保证读写高可用，Observer是只读的扩展节点，可以水平扩展实现读的扩展。BE通过多副本来实现高可用，一般来说也采取默认的三副本，写入的时候采用Quroum协议保证数据一致性。Doris的元数据和数据多副本存储的，能自动复制具有自动灾备的能力，服务挂了可以自动重启，坏一块盘数据自动均衡，小范围的节点宕机不会影响集群对外的服务，但宕机后数据均衡过程会消耗集群资源，引发短时间的负载过高。架构如下图：</p><p><img src="/2021/12/07/apache-doris-he-clickhouse-shen-du-dui-bi/%E5%9B%BE%E7%89%874.png" alt="图片4"></p><p>ClickHouse目前版本是基于ZooKeeper来存储元数据，包含分布式的DDL、表和数据Part信息，从元数据丰富程度来说稍弱，因为存储了大量细粒度的文件信息，导致ZooKeeper经常出现性能瓶颈，社区也有基于Raft协议的改进计划。ClickHouse依赖Zookeeper来实现数据的高可用，Zookeeper带来额外的运维复杂性的同时也有性能问题。ClickHouse没有集中的元数据管理，每个节点分别管理，高可用一般依赖业务方来实现。ClickHouse中某个副本节点宕机，对查询和分布式表的导入没有影响，本地表导入要在导数程序中做灾备方案比如选择健康的副本，对DDL操作是有影响的，需要及时处理。</p><p><img src="/2021/12/07/apache-doris-he-clickhouse-shen-du-dui-bi/%E5%9B%BE%E7%89%875.png" alt="图片5"></p><p>在分布式能力这块，Doris在内核侧已经实现，使用的代价更低；而ClickHouse需要依赖于外部配套的措施去保障，使用成本较高。</p><p><strong>2）事务支持</strong></p><p>ACID指事务的原子性、一致性、隔离性和持久化，OLAP的事务体现在几个方面，一是导数，需要保证导数的原子性，同时也要保证明细数据和物化视图的数据一致性；二是元数据的变更，需要保证所有节点的元数据统一变更的强一致性；三是在节点间做数据均衡时，需要保证数据的一致性。</p><p>Doris提供了导入的事务支持，可以保证导数的幂等性，比如数据导入的原子性，如果有其他错误会自动回滚，同时相同标签的数据不会重复导入。基于导入事务的功能，Doris还实现了Flink-connector这样的外部组件可以实现数据导入不丢不重。两者均不支持通用TP场景中的BEGIN/END/COMMIT语义的事务，很明显有事务支持的Doris比无事务支持的ClickHouse要节省很多开发成本，因为在ClickHouse中，这一切都需要外部导数程序来保证。</p><p>ClickHouse不支持事务，需要在外部去做各种校验和检查，在导数这块能保证100万以内的原子性，但是不保证一致性，比如要更新某些字段或者更新物化视图，这个操作是后台异步的，需要显示指定关键字FINAL来查询最终数据，而且其他操作没有事务支持。</p><p>DDL操作两者都是异步的，但是Doris能保证各个节点元数据的一致性，但ClickHouse中保证不了，会出现局部节点元数据和其他节点不一致的情况。</p><h3 id="3-3-数据导入"><a href="#3-3-数据导入" class="headerlink" title="3.3 数据导入"></a>3.3 数据导入</h3><p>Doris中有RoutineLoad、BrokerLoad和StreamLoad等丰富内置的导数方式，这些功能非常好用，虽然无法处理复杂的ETL逻辑，但是支持简单过滤和转换函数，也能容忍少量的数据异常，同时支持ACID和导数幂等性。</p><ul><li>Routineload支持消费Kafka的实时数据，按每批条数、导入间隔和并发数等设置导数参数，用于实时数据的导入；</li><li>Brokerload支持从HDFS上导入数据文件，用于离线导数，速度不是很快；</li><li>Streamload是导数的底层接口，更加高级的功能可以外部程序处理后通过Steamload来导入。</li></ul><p><img src="/2021/12/07/apache-doris-he-clickhouse-shen-du-dui-bi/%E5%9B%BE%E7%89%876.png" alt="图片6"></p><p>ClickHouse中并没有后台导数任务这一概念，它更多的是通过各种引擎去连接到各种存储系统中。导数在1048576条以内是原子的，要么都生效，要么都失败，但是没有类似Doris中事务ID的概念，在Doris中相同的事务ID插入数据是无效的，这也避免了重复的导数，在CH中如果导数重复，只能删除重新导入。CH中比较有特色的是既可以写分布式表又可以写本地表。</p><p>导入性能因为ClickHouse可以导入本地表，而且没有事务的限制，所以导入性能差不多是节点磁盘写入的性能，而Doris的导数受限于只能分布式表的导入，导入性能差一些。</p><p>如果数据量少可以使用OLAP中的导数，数据量大逻辑复杂，一般使用Spark/Flink等外部计算引擎来做ETL和导数功能，主要是导数消耗集群资源。</p><p><img src="/2021/12/07/apache-doris-he-clickhouse-shen-du-dui-bi/%E5%9B%BE%E7%89%877.png" alt="图片7"></p><h3 id="3-4-存储架构"><a href="#3-4-存储架构" class="headerlink" title="3.4 存储架构"></a>3.4 存储架构</h3><p><strong>1）MVCC模型</strong></p><p>Doris的存储部分参考GoogleMesa，采用的MVCC模式，MVCC指Multi-version concurrency control多版本控制，通过版本可以实现事务的两段提交，可以通过版本进行小文件合并，也可以在明细表和物化视图之间实现强一致性。</p><p><img src="/2021/12/07/apache-doris-he-clickhouse-shen-du-dui-bi/%E5%9B%BE%E7%89%878.png" alt="图片8"></p><p>ClickHouse中也是类似，有两个操作，一种是Merge合并小的Part文件到一个大的Part，提升查询性能避免扫描多个小文件，合并过程类似上图。另外一种是Mutation就是在已有的Part中实现数据的变更或元数据的变更，如下图的SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> [db.]<span class="keyword">table</span> <span class="keyword">DELETE</span> <span class="keyword">WHERE</span> filter_expr;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> [db.]<span class="keyword">table</span> <span class="keyword">UPDATE</span> column1 = expr1 [, ...] <span class="keyword">WHERE</span> filter_expr;</span><br></pre></td></tr></table></figure><p><img src="/2021/12/07/apache-doris-he-clickhouse-shen-du-dui-bi/%E5%9B%BE%E7%89%879.png" alt="图片9"></p><p><strong>2）存储结构</strong></p><p>两者都是列存，列存的好处就是：</p><ul><li>分析场景中需要读大量行但是少数几个列，只需要读取参与计算的列即可，极大的减低了IO，加速了查询；</li><li>同一列中的数据属于同一类型，压缩效果显著，节省存储空间，降低了存储成本；</li><li>高压缩比，意味着同等大小的内存能够存放更多数据，系统Cache效果更好。</li></ul><p><img src="/2021/12/07/apache-doris-he-clickhouse-shen-du-dui-bi/%E5%9B%BE%E7%89%8710.png" alt="图片10"></p><p>Doris的数据划分方式是Table、Partition、Bucket/Tablet、Segment几个部分，其中Partition代表数据的纵向划分分区一般是日期列，Bucket/Tablet一般指数据的横向切割分桶规则一般为某主键， Segment是具体的存储文件。Segment中包含数据和索引，数据部分包含多个列的数据按列存放，有三种索引：物理索引、稀疏索引和ZoneMap索引。</p><p>ClickHouse中分为DistributeTable、LocalTable、Partition、Shard、Part、Column几个部分，差不多能和Doris对应起来，区别就是CH中每个Column都对应一组数据文件和索引文件，好处就是命中系统Cache性能更高，不好的地方就是IO较高且文件数量较多，另外CH有Count索引，所以Count时命中索引会比较快。</p><p>通过分区分桶的方式可以让用户自定义数据在集群中的数据分布方式，降低数据查询的扫描量，方便集群的管理。分区作为数据管理的手段， Doris支持按照range分区，ClickHouse可以表达式来自定义。Doris可以通过动态分区的配置来按照时间自动创建新的分区，也可以做冷热数据的分级存储。ClickHouse通过distrubute引擎来进行多节点的数据分布，但是因为缺少bucket这一层，会导致集群的迁移扩容比较麻烦， Doris通过分桶的配置可以进一步对数据划分，方便数据的均衡和迁移。</p><p><img src="/2021/12/07/apache-doris-he-clickhouse-shen-du-dui-bi/%E5%9B%BE%E7%89%8711.png" alt="图片11"></p><p><strong>3）表引擎/模型</strong></p><p>两者都有典型的表类型（引擎类型）的支持</p><ul><li>Doris：可重复的Duplicated Key就是明细表，按维度聚合的Aggregate Key，唯一主键Unique Key，UniqueKey这个可以视为AggregateKey的特例，另外在这三种基础上可以建立Rollup（上卷），可以理解为物化视图。</li><li>ClickHouse : 主要是MergeTree表引擎家族，主要是ReplicatedMergeTree带副本的、ReplacingMergeTree可以更新数据的和AggregatingMergeTree可以聚合数据，另外还有内存字典表可以加载数据字典、内存表可以加速查询或获得更好写入性能。CH比较特殊地方是分布式表和每个节点的本地表都要单独创建，物化视图无法自动路由。</li></ul><p>另外，Doris新开发的Primary Key模型，对实时更新场景下的读性能进行了深度优化，在支持update语义的同时，避免了Unique key的sort merge开销。在实时update的压力下，查询性能跟是Unique key的3-15倍。类似的，相比ClickHouse的ReplicatedMergeTree，也避免了select final/optimize final的问题。</p><p><img src="/2021/12/07/apache-doris-he-clickhouse-shen-du-dui-bi/%E5%9B%BE%E7%89%8712.png" alt="图片12"></p><p><strong>4）数据类型</strong></p><p>ClickHouse中存在较多的复杂类型的支持如Array/Nested/Map/Tuple/Enum等，这些类型能够满足一些特性场景，还是比较好用的。</p><p><img src="/2021/12/07/apache-doris-he-clickhouse-shen-du-dui-bi/%E5%9B%BE%E7%89%8713.png" alt="图片13"></p><h3 id="3-5-数据查询"><a href="#3-5-数据查询" class="headerlink" title="3.5 数据查询"></a>3.5 数据查询</h3><p><strong>1）查询架构</strong></p><p><img src="/2021/12/07/apache-doris-he-clickhouse-shen-du-dui-bi/%E5%9B%BE%E7%89%8714.png" alt="图片14"></p><p>分布式查询指查询分布在多台服务器上的数据，就如同使用一张表一样，分布式Join比较繁琐，Doris的分布式Join有Local join，Broadcast join，Shuffle join，Hash join等方式。ClickHouse只有Local和Broadcast两种Join，这种架构比较简单，也限制了Join SQL的自由度，变通的方式是通过子查询和查询嵌套来实现多级的Join。</p><p><img src="/2021/12/07/apache-doris-he-clickhouse-shen-du-dui-bi/%E5%9B%BE%E7%89%8715.png" alt="图片15"></p><p>Doris和ClickHouse都支持向量化执行，向量化简单理解就是一批数据一批数据去执行，可以多行并发执行，同时也提升了CPU Cache命中率。在数据库领域，一直是Codegen和Vectorized并存，如下图是TPC-H的五个测试SQL，纵轴是查询时间，Type是编译执行，TW是向量化执行，可以看出两者在不同场景下，性能表现不一样。</p><p><img src="/2021/12/07/apache-doris-he-clickhouse-shen-du-dui-bi/%E5%9B%BE%E7%89%8716.png" alt="图片16"></p><p><strong>2）并发能力</strong></p><p>OLAP因为MPP架构，每一个SQL所有节点都会参与计算，以此来加速海量计算，因此一个集群的并发能力和单台没有太大的区别，所以，OLAP和数据库类似，并不是能够承担极高并发的系统。但是也并非毫无办法，比如通过增加副本数来达到承载较大并发的能力。比如4个分片1个副本，能承担100QPS，那么如果要承担500的QPS，则只需要把副本数扩展到5个副本即可。另外一点很重要的是查询能否利用到Cache，包括ResultCache，Page Cache和CPU Cache，这样并发还能提升一个很大的台阶。</p><p>Doris有两点比较优势，一是副本数的设置是在表级别的，只需要把并发大的表设置副本数多一些即可，当然副本数不能超过集群的节点数，而ClickHouse的副本数设置是集群级别的。</p><p><strong>3）SQL支持</strong></p><p>Doris与MySQL语法兼容，支持SQL99规范以及部分SQL2003新标准(比如窗口函数，Grouping sets)。</p><p>ClickHouse部分支持SQL-2011 标准（<a href="https://clickhouse.tech/docs/en/sql-reference/ansi/" target="_blank" rel="noopener">https://clickhouse.tech/docs/en/sql-reference/ansi/</a> ），但是由于Planner的一些限制，ClickHouse的多表关联需要对SQL做大量改写工作，比如需要手动下推条件到子查询中，所以复杂查询使用不太方便。</p><p>ClickHouse支持支持ODBC、JDBC、HTTP接口，Doris支持JDBC和ODBC接口。</p><p><strong>4）联邦查询</strong></p><p><img src="/2021/12/07/apache-doris-he-clickhouse-shen-du-dui-bi/%E5%9B%BE%E7%89%8717.png" alt="图片17"></p><p><strong>5）函数支持</strong></p><p><img src="/2021/12/07/apache-doris-he-clickhouse-shen-du-dui-bi/%E5%9B%BE%E7%89%8718.png" alt="图片18"></p><p><img src="/2021/12/07/apache-doris-he-clickhouse-shen-du-dui-bi/%E5%9B%BE%E7%89%8719.png" alt="图片19"></p><h3 id="3-6-使用成本"><a href="#3-6-使用成本" class="headerlink" title="3.6 使用成本"></a>3.6 使用成本</h3><p><strong>1）使用成本</strong></p><p>Doris使用成本低，是一个强一致性元数据的系统，导数功能较为完备，查询SQL的标准兼容好无需额外的工作，弹性伸缩能力要好，而ClickHouse则需要做较多工作：</p><ul><li>ZooKeeper存在性能瓶颈导致集群规模不能特别大</li><li>基本无法做到弹性伸缩，纯手工扩缩容工作量巨大且容易出错</li><li>故障节点的容忍度较低，出现一个节点故障会引发某些操作失败</li><li>导数需要外部保证数据不重不丢，导数失败需要删了重导</li><li>元数据需要自己保证各个节点一致性，偶发性的不一致情况较多</li><li>分布式表和本地表有两套表结构，较多用户难以理解</li><li>多表Join SQL需要改写和优化，方言较多几乎是不兼容其他引擎的SQL</li></ul><p>所以，在大规模实施ClickHouse时，需要研发一个比较好用的运维系统的支持，处理大部分的日常运维工作。</p><p><strong>2）代码框架</strong></p><p>Doris整体架构分为FrontEnd和BackEnd，FE由Java编写，BE是C/C++，通信部分是BRPC。FE中包含了元数据、SQL Parser、Optimizer、Planner和Coodinator几个部分，BE中包含写入、存储、索引和查询执行部分。Doris的代码风格整体质量是比较高的，风格统一，有较为完善的单测用例，如果要在Doris上做二次开发，则需要熟悉Java或C++。</p><p>ClickHouse包含ClickHouse Client/Copier/Server这几个比较主要的模块，其中Client是日常使用的命令行客户端，Copier是数据迁移工具，Server是集群核心服务。Server部分包含Parser、Interpreter、Storage、Database、Function等模块。代码整体上是C++11以上的风格，大量使用Poco库，大量使用较新的语言特性。</p><p>因此ClickHouse对二次开发更加友好，技术栈单一，且测试框架完善，模块间互相依赖关系相对较小。</p><p><img src="/2021/12/07/apache-doris-he-clickhouse-shen-du-dui-bi/%E5%9B%BE%E7%89%8720.png" alt="图片20"></p><h2 id="四、性能测试"><a href="#四、性能测试" class="headerlink" title="四、性能测试"></a>四、性能测试</h2><p>TPC-DS 测试是大数据领域比较常用的一个测试，24张表、99个SQL，可以生成不同容量的数据，京东内部常用来做不同引擎的对比测试。</p><ul><li>这两个引擎都无法全部支持99个SQL，不支持的部分我们根据各个引擎不同特点，进行手工SQL改写让其能正确执行，Doris改动量较小，ClickHouse的多表关联几乎都要改写；</li><li>为了简化测试过程，我们挑选了9个关联查询的SQL，然后自己构造了9个单表查询的SQL，共18个SQL来测试性能；</li></ul><p><strong>举个例子</strong></p><p>如下是一个典型的多表关联例子，在Doris中不需要做改动，但是在ClickHouse中，需要改为多个Global Inner Join来执行， ClickHouse的多表关联查询一般都需要改写。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#--Doris/DorisDB SQL 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> i_item_id, <span class="keyword">avg</span>(cs_quantity) agg1, <span class="keyword">avg</span>(cs_list_price) agg2, <span class="keyword">avg</span>(cs_coupon_amt) agg3, <span class="keyword">avg</span>(cs_sales_price) agg4from catalog_sales, customer_demographics, date_dim, item, promotionwhere cs_sold_date_sk = d_date_sk <span class="keyword">and</span>     cs_item_sk = i_item_sk <span class="keyword">and</span>    cs_bill_cdemo_sk = cd_demo_sk <span class="keyword">and</span>    cs_promo_sk = p_promo_sk <span class="keyword">and</span>    cd_gender = <span class="string">'M'</span> <span class="keyword">and</span>     cd_marital_status = <span class="string">'D'</span> <span class="keyword">and</span>    cd_education_status = <span class="string">'Advanced Degree'</span> <span class="keyword">and</span>    (p_channel_email = <span class="string">'N'</span> <span class="keyword">or</span> p_channel_event = <span class="string">'N'</span>) <span class="keyword">and</span> d_year = <span class="number">1998</span> <span class="keyword">group</span> <span class="keyword">by</span> i_item_id <span class="keyword">order</span> <span class="keyword">by</span> i_item_id <span class="keyword">limit</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#--ClickHouse SQL 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> i_item_id, <span class="keyword">avg</span>(cs_quantity) agg1, <span class="keyword">avg</span>(cs_list_price) agg2, <span class="keyword">avg</span>(cs_coupon_amt) agg3, <span class="keyword">avg</span>(cs_sales_price) agg4 <span class="keyword">from</span> catalog_sales_distglobal <span class="keyword">inner</span> <span class="keyword">join</span> (<span class="keyword">select</span> cd_demo_sk <span class="keyword">from</span> customer_demographics_dist <span class="keyword">where</span> cd_gender = <span class="string">'M'</span> <span class="keyword">and</span> cd_marital_status = <span class="string">'D'</span> <span class="keyword">and</span> cd_education_status = <span class="string">'Advanced Degree'</span> ) <span class="keyword">on</span> cs_bill_cdemo_sk = cd_demo_skglobal <span class="keyword">inner</span> <span class="keyword">join</span> (<span class="keyword">select</span> d_date_sk <span class="keyword">from</span> date_dim_dist <span class="keyword">where</span> d_year = <span class="number">1998</span> ) <span class="keyword">on</span>  cs_sold_date_sk = d_date_skglobal <span class="keyword">inner</span> <span class="keyword">join</span> ( <span class="keyword">select</span> i_item_sk, i_item_id <span class="keyword">from</span> item_dist ) <span class="keyword">on</span> cs_item_sk = i_item_skglobal <span class="keyword">inner</span> <span class="keyword">join</span> ( <span class="keyword">select</span> p_promo_sk <span class="keyword">from</span> promotion_dist <span class="keyword">where</span> p_channel_email = <span class="string">'N'</span> <span class="keyword">or</span> p_channel_event = <span class="string">'N'</span>) <span class="keyword">on</span> cs_promo_sk = p_promo_skgroup <span class="keyword">by</span> i_item_id <span class="keyword">order</span> <span class="keyword">by</span> i_item_id <span class="keyword">limit</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><strong>测试环境</strong></p><ul><li>硬件：3台32核/128G内存/HDD磁盘的服务器</li><li>软件：Doris 0.13.1、ClickHouse 21.3.13.1</li><li>配置：3个分片1副本，都是默认配置</li></ul><p><strong>测试总结</strong></p><ul><li>单表性能ClickHouse更好，无论是查询延时还是并发能力</li><li>多表性能Doris优势更明显，特别是复杂Join和大表Join大表的场景，另外ClickHouse需要改写SQL有一些工作量</li></ul><p><strong>单表延时和并发</strong></p><p>单表的SQL都比较简单，大部分是全表分组group by之后avg/sum/count/count distinct的各种聚合，单表查询时间如下，可以看出整体上ClickHouse要明显好一些，同时，为了压测方便我们找了2个延时低的SQL Single4和Single5测试了一下不同并发下的QPS，发现也是ClickHouse更优一些。</p><p>ClickHouse的单表性能好，得益于向量化执行引擎，在数据密集情况下，利用内存的PageCache和CPU的L2 Cache可以大大加速查询过程。</p><p><img src="/2021/12/07/apache-doris-he-clickhouse-shen-du-dui-bi/%E5%9B%BE%E7%89%8721.png" alt="图片21"></p><p><img src="https://p6.itc.cn/images01/20211124/be013966ab2b438ebb0a03b88baba823.jpeg" alt="img"></p><p><strong>Join的延时和并发</strong></p><p>从多表测试来看，Doris在Join6、Join7、Join8、Join9要好一些，Join3两者差不多，其他情况ClickHouse好一些。同样，我们挑选了2个延时低的SQL Join8和Join9做了一下并发测试，并发的测试结果和延时表现比较匹配，延时低的SQL测试并发时QPS同样高。</p><p>Doris多表关联有四种Join方式，BroadCast Join，Shuffle Join/Bucket Shuffle Join和Colocation Join，ClickHouse只有Global Join（就是BroadCast Join）和Local Join（对应Colocation Join），因此在大表Join大表时，要把右表广播到所有节点，性能可想而知。</p><p>Doris的执行计划对SQL进行了较多的优化，因此多表关联中的大部分情况，能找到最优的执行方式，因此多表关联性能较好一些，但是也并不是所有的关联SQL都要好。</p><p><img src="/2021/12/07/apache-doris-he-clickhouse-shen-du-dui-bi/%E5%9B%BE%E7%89%8722.png" alt="图片22"></p><p><img src="/2021/12/07/apache-doris-he-clickhouse-shen-du-dui-bi/%E5%9B%BE%E7%89%8723.png" alt="图片23"></p><p><strong>ClickHouse小表不同数据量下延时</strong></p><p>通过上面的测试，大家肯定有疑问，不是说ClickHouse的Join性能不行么，为什么表现并不差呢？因此，贴一个去年做的一组ClickHouse大小表的测试供大家参考，就是用一个大表关联查询不同数据规模的小表，看Join性能情况怎么样。横轴是指小表的不同数据量，纵轴是执行时间。可以看出，因为Join机制不一样，ClickHouse的延时随小表数据量加大梯度更大，ClickHouse小表数据量1000万以内尚可，超过1000万性能比就比较差了。</p><p><img src="/2021/12/07/apache-doris-he-clickhouse-shen-du-dui-bi/%E5%9B%BE%E7%89%8724.png" alt="图片24"></p><h2 id="五、对比表格"><a href="#五、对比表格" class="headerlink" title="五、对比表格"></a>五、对比表格</h2><p>上面的对比，是从大的几个方面来进行的，下面是比较详细的对比，绿色指我们觉得比较占优的部分。</p><p><img src="/2021/12/07/apache-doris-he-clickhouse-shen-du-dui-bi/%E5%9B%BE%E7%89%8725.png" alt="图片25"></p><p>原文地址：<a href="https://maimai.cn/article/detail?fid=1671866194&amp;efid=BcCQ6YGVagzGO0V7lbC5nw" target="_blank" rel="noopener">https://maimai.cn/article/detail?fid=1671866194&amp;efid=BcCQ6YGVagzGO0V7lbC5nw</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Nov 08 2022 22:51:10 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;一、背景介绍&quot;&gt;&lt;a href=&quot;#一、背景介绍&quot; class=&quot;headerlink&quot; title=&quot;一、背景介绍&quot;&gt;&lt;/a&gt;一、背
      
    
    </summary>
    
    
      <category term="Hadoop" scheme="http://chenzhonzhou.github.io/categories/Hadoop/"/>
    
    
      <category term="Hadoop" scheme="http://chenzhonzhou.github.io/tags/Hadoop/"/>
    
      <category term="OLAP" scheme="http://chenzhonzhou.github.io/tags/OLAP/"/>
    
  </entry>
  
  <entry>
    <title>Apache Doris 联机分析处理(OLAP)</title>
    <link href="http://chenzhonzhou.github.io/2021/12/07/apache-doris-lian-ji-fen-xi-chu-li-olap/"/>
    <id>http://chenzhonzhou.github.io/2021/12/07/apache-doris-lian-ji-fen-xi-chu-li-olap/</id>
    <published>2021-12-07T02:31:35.000Z</published>
    <updated>2021-12-08T10:58:57.735Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Nov 08 2022 22:51:10 GMT+0800 (GMT+08:00) --><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p><a href="https://doris.apache.org/master/zh-CN/" target="_blank" rel="noopener">Apache Doris</a>（原百度 Palo）是一款<strong>基于大规模并行处理（MPP）技术的联机分析处理查询（OLAP）系统</strong>，由百度在 2017 年开源，2018 年 8 月进入 Apache 孵化。</p><p><strong>MPP ( Massively Parallel Processing，大规模并行处理)</strong>，在数据库非共享集群中，每个节点都有独立的磁盘存储系统和内存系统，业务数据根据数据库模型和应用特点划分到各个节点上，每台数据节点通过专用网络或者商业通用网络互相连接，彼此协同计算，作为整体提供数据库服务。非共享数据库集群有完全的可伸缩性、高可用、高性能、优秀的性价比、资源共享等优势。简单来说，MPP 是将任务并行的分散到多个服务器和节点上，在每个节点上计算完成后，将各自部分的结果汇总在一起得到最终的结果 ( 与 Hadoop 相似 )。</p><p><strong>OLAP（On-line Analytical Processing，联机分析处理）</strong>是在基于数据仓库多维模型的基础上实现的面向分析的各类操作的集合。</p><p>Apache Doris 仅需亚秒级响应时间即可获得查询结果，有效地支持实时数据分析。Apache Doris的分布式架构非常简洁，易于运维，并且可以支持10PB以上的超大数据集。Apache Doris可以满足多种数据分析需求，例如固定<strong>历史报表</strong>，<strong>实时数据分析</strong>，<strong>交互式数据分析</strong>和<strong>探索式数据分析</strong>等。让数据分析工作更加简单高效！</p><p>Doris 主要解决 PB 级别的数据量（如果高于 PB 级别，不推荐使用 Doris 解决，可以考虑用 Hive 等工具），解决结构化数据，查询时间一般在<strong>秒级</strong>或<strong>毫秒级</strong>。</p><p><img src="/2021/12/07/apache-doris-lian-ji-fen-xi-chu-li-olap/%E5%9B%BE%E7%89%874.png" alt="图片4"></p><h2 id="二、Doris-架构"><a href="#二、Doris-架构" class="headerlink" title="二、Doris 架构"></a>二、Doris 架构</h2><h3 id="2-1-整体架构"><a href="#2-1-整体架构" class="headerlink" title="2.1 整体架构"></a>2.1 整体架构</h3><p><img src="/2021/12/07/apache-doris-lian-ji-fen-xi-chu-li-olap/%E5%9B%BE%E7%89%871.png" alt="图片1"></p><p>Doris 的架构很简洁，只设 <strong>FE(Frontend)</strong>、<strong>BE(Backend)</strong>两种角色，不依赖于外部组件，方便部署和运维。</p><blockquote><ul><li>FE：Frontend，即 Doris 的前端节点。主要负责接收和返回客户端请求、元数据以及集群管理、查询计划生成等工作。</li><li>BE：Backend，即 Doris 的后端节点。主要负责数据存储与管理、查询计划执行等工作。</li></ul></blockquote><p>在整个架构中FE，BE都可线性扩展。</p><p>FE 主要有有三个角色，一个是 leader，一个是 follower，还有一个 observer。leader 跟 follower，主要是用来达到元数据的高可用，保证单节点宕机的情况下，元数据能够实时地在线恢复，而不影响整个服务。</p><p>右边 observer 只是用来扩展查询节点，就是说如果在发现集群压力非常大的情况下，需要去扩展整个查询的能力，那么可以加 observer 的节点。observer 不参与任何的写入，只参与读取。</p><p>数据的可靠性由 BE 保证，BE 会对整个数据存储多副本或者是三副本。副本数可根据需求动态调整。</p><h3 id="2-2-元数据"><a href="#2-2-元数据" class="headerlink" title="2.2 元数据"></a>2.2 元数据</h3><p>Doris 采用 Paxos 协议以及 Memory + Checkpoint + Journal 的机制来确保元数据的高性能及高可靠。元数据的每次更新，都首先写入到磁盘的日志文件中，然后再写到内存中，最后定期 checkpoint 到本地磁盘上。相当于是一个纯内存的一个结构，也就是说所有的元数据都会缓存在内存之中，从而保证 FE 在宕机后能够快速恢复元数据，而且不丢失元数据。Leader、follower 和 observer 它们三个构成一个可靠的服务，一般是部署一个 leader 两个 follower，在单机节点故障的时候其实基本上三个就够了，因为 FE 节点毕竟它只存了一份元数据，它的压力不大，所以如果 FE 太多的时候它会去消耗机器资源，所以多数情况下三个就足够了，可以达到一个很高可用的元数据服务。</p><p>在百度内部，一个包含2500张表，100万个分片（300万副本）的集群，元数据在内存中仅占用约 2GB。（当然，查询所使用的中间对象、各种作业信息等内存开销，需要根据实际情况估算。但总体依然维持在一个较低的内存开销范围内。）</p><p>同时，元数据在内存中整体采用树状的层级结构存储，并且通过添加辅助结构，能够快速访问各个层级的元数据信息。</p><p><img src="/2021/12/07/apache-doris-lian-ji-fen-xi-chu-li-olap/%E5%9B%BE%E7%89%872.png" alt="图片2"></p><p>如上图，Doris 的元数据主要存储4类数据：</p><blockquote><ul><li>用户数据信息。包括数据库、表的 Schema、分片信息等。</li><li>各类作业信息。如导入作业，Clone 作业、SchemaChange 作业等。</li><li>用户及权限信息。</li><li>集群及节点信息。</li></ul></blockquote><h3 id="2-3-数据流"><a href="#2-3-数据流" class="headerlink" title="2.3 数据流"></a>2.3 数据流</h3><p><img src="/2021/12/07/apache-doris-lian-ji-fen-xi-chu-li-olap/%E5%9B%BE%E7%89%873.png" alt="图片3"></p><p>元数据的数据流具体过程如下：</p><ol><li>只有 leader FE 可以对元数据进行写操作。写操作在修改 leader 的内存后，会序列化为一条log，按照 key-value 的形式写入 bdbje。其中 key 为连续的整型，作为 log id，value 即为序列化后的操作日志。</li><li>日志写入 bdbje 后，bdbje 会根据策略（写多数/全写），将日志复制到其他 non-leader 的 FE 节点。non-leader FE 节点通过对日志回放，修改自身的元数据内存镜像，完成与 leader 节点的元数据同步。</li><li>leader 节点的日志条数达到阈值后（默认 10w 条），会启动 checkpoint 线程。checkpoint 会读取已有的 image 文件，和其之后的日志，重新在内存中回放出一份新的元数据镜像副本。然后将该副本写入到磁盘，形成一个新的 image。之所以是重新生成一份镜像副本，而不是将已有镜像写成 image，主要是考虑写 image 加读锁期间，会阻塞写操作。所以每次 checkpoint 会占用双倍内存空间。</li><li>image 文件生成后，leader 节点会通知其他 non-leader 节点新的 image 已生成。non-leader 主动通过 http 拉取最新的 image 文件，来更换本地的旧文件。</li><li>bdbje 中的日志，在 image 做完后，会定期删除旧的日志。</li></ol><blockquote><p>bdbje：<a href="http://www.oracle.com/technetwork/database/berkeleydb/overview/index-093405.html" target="_blank" rel="noopener">Oracle Berkeley DB Java Edition (opens new window)</a>。在 Doris 中，使用 bdbje 完成元数据操作日志的持久化、FE 高可用等功能。</p></blockquote><h3 id="2-3-实现细节"><a href="#2-3-实现细节" class="headerlink" title="2.3 实现细节"></a>2.3 实现细节</h3><h4 id="2-3-1-元数据目录"><a href="#2-3-1-元数据目录" class="headerlink" title="2.3.1 元数据目录"></a>2.3.1 元数据目录</h4><ol><li>元数据目录通过 FE 的配置项 <code>meta_dir</code> 指定。</li><li><code>bdb/</code> 目录下为 bdbje 的数据存放目录。</li><li><code>image/</code> 目录下为 image 文件的存放目录。<ul><li><code>image.[logid]</code> 是最新的 image 文件。后缀 <code>logid</code> 表明 image 所包含的最后一条日志的 id。</li><li><code>image.ckpt</code> 是正在写入的 image 文件，如果写入成功，会重命名为 <code>image.[logid]</code>，并替换掉旧的 image 文件。</li><li><code>VERSION</code> 文件中记录着 <code>cluster_id</code>。<code>cluster_id</code> 唯一标识一个 Doris 集群。是在 leader 第一次启动时随机生成的一个 32 位整型。也可以通过 fe 配置项 <code>cluster_id</code> 来指定一个 cluster id。</li><li><code>ROLE</code> 文件中记录的 FE 自身的角色。只有 <code>FOLLOWER</code> 和 <code>OBSERVER</code> 两种。其中 <code>FOLLOWER</code> 表示 FE 为一个可选举的节点。（注意：即使是 leader 节点，其角色也为 <code>FOLLOWER</code>）</li></ul></li></ol><h4 id="2-3-2-启动流程"><a href="#2-3-2-启动流程" class="headerlink" title="2.3.2 启动流程"></a>2.3.2 启动流程</h4><ol><li><p>FE 第一次启动，如果启动脚本不加任何参数，则会尝试以 leader 的身份启动。在 FE 启动日志中会最终看到 <code>transfer from UNKNOWN to MASTER</code>。</p></li><li><p>FE 第一次启动，如果启动脚本中指定了 <code>-helper</code> 参数，并且指向了正确的 leader FE 节点，那么该 FE 首先会通过 http 向 leader 节点询问自身的角色（即 ROLE）和 cluster_id。然后拉取最新的 image 文件。读取 image 文件，生成元数据镜像后，启动 bdbje，开始进行 bdbje 日志同步。同步完成后，开始回放 bdbje 中，image 文件之后的日志，完成最终的元数据镜像生成。</p><blockquote><p>注1：使用 <code>-helper</code> 参数启动时，需要首先通过 mysql 命令，通过 leader 来添加该 FE，否则，启动时会报错。</p></blockquote><blockquote><p>注2：<code>-helper</code> 可以指向任何一个 follower 节点，即使它不是 leader。</p></blockquote><blockquote><p>注2：bdbje 在同步日志过程中，fe 日志会显示 <code>xxx detached</code>, 此时正在进行日志拉取，属于正常现象。</p></blockquote></li><li><p>FE 非第一次启动，如果启动脚本不加任何参数，则会根据本地存储的 ROLE 信息，来确定自己的身份。同时根据本地 bdbje 中存储的集群信息，获取 leader 的信息。然后读取本地的 image 文件，以及 bdbje 中的日志，完成元数据镜像生成。（如果本地 ROLE 中记录的角色和 bdbje 中记录的不一致，则会报错。）</p></li><li><p>FE 非第一次启动，且启动脚本中指定了 <code>-helper</code> 参数。则和第一次启动的流程一样，也会先去询问 leader 角色。但是会和自身存储的 ROLE 进行比较。如果不一致，则会报错。</p></li></ol><p><strong>元数据读写与同步</strong></p><ol><li><p>用户可以使用 mysql 连接任意一个 FE 节点进行元数据的读写访问。如果连接的是 non-leader 节点，则该节点会将写操作转发给 leader 节点。leader 写成功后，会返回一个 leader 当前最新的 log id。之后，non-leader 节点会等待自身回放的 log id 大于回传的 log id 后，才将命令成功的消息返回给客户端。这种方式保证了任意 FE 节点的 Read-Your-Write 语义。</p><blockquote><p>注：一些非写操作，也会转发给 leader 执行。比如 <code>SHOW LOAD</code> 操作。因为这些命令通常需要读取一些作业的中间状态，而这些中间状态是不写 bdbje 的，因此 non-leader 节点的内存中，是没有这些中间状态的。（FE 之间的元数据同步完全依赖 bdbje 的日志回放，如果一个元数据修改操作不写 bdbje 日志，则在其他 non-leader 节点中是看不到该操作修改后的结果的。）</p></blockquote></li><li><p>leader 节点会启动一个 TimePrinter 线程。该线程会定期向 bdbje 中写入一个当前时间的 key-value 条目。其余 non-leader 节点通过回放这条日志，读取日志中记录的时间，和本地时间进行比较，如果发现和本地时间的落后大于指定的阈值（配置项：<code>meta_delay_toleration_second</code>。写入间隔为该配置项的一半），则该节点会处于<strong>不可读</strong>的状态。此机制解决了 non-leader 节点在长时间和 leader 失联后，仍然提供过期的元数据服务的问题。</p></li><li><p>各个 FE 的元数据只保证最终一致性。正常情况下，不一致的窗口期仅为毫秒级。我们保证同一 session 中，元数据访问的单调一致性。但是如果同一 client 连接不同 FE，则可能出现元数据回退的现象。（但对于批量更新系统，该问题影响很小。）</p></li></ol><h3 id="2-4-宕机恢复"><a href="#2-4-宕机恢复" class="headerlink" title="2.4 宕机恢复"></a>2.4 宕机恢复</h3><ol><li>leader 节点宕机后，其余 follower 会立即选举出一个新的 leader 节点提供服务。</li><li>当多数 follower 节点宕机时，元数据不可写入。当元数据处于不可写入状态下，如果这时发生写操作请求，目前的处理流程是 <strong>FE 进程直接退出</strong>。后续会优化这个逻辑，在不可写状态下，依然提供读服务。</li><li>observer 节点宕机，不会影响任何其他节点的状态。也不会影响元数据在其他节点的读写。</li></ol><h3 id="2-5-核心特性"><a href="#2-5-核心特性" class="headerlink" title="2.5 核心特性"></a>2.5 核心特性</h3><p><strong>MySQL协议兼容</strong></p><p>Doris提供兼容MySQL协议的连接接口，使得用户不必再单独部署新的客户端库或者工具，可以直接使用MySQL的相关库或者工具；由于提供了MySQL接口，也容易与上层应用兼容；用户学习曲线降低，方便用户上手使用。</p><p><strong>大查询高吞吐</strong></p><p>利用MPP架构的优势，使得查询能够分布式的在多个节点并行执行，充分利用集群整体计算资源，提高大查询的吞吐能力。</p><p><strong>高并发小查询</strong></p><p>通过使用分区裁剪、预聚合，谓词下推，向量化执行、异步RPC等技术，Doris可以支持高并发点查询场景。100台集群可达10w QPS。</p><p><strong>数据更新</strong></p><p>Doris 支持按主键删除和更新数据。能够方便的从 MySQL 等事务数据库中同步实时更新的数据。</p><p><strong>高可用和高可靠</strong></p><p>Doris中的数据和元数据都默认使用3副本存储（Leader Node节点和Compute Node节点需各自大于等于3）。在少数节点宕机的情况下，依然可以保证数据的可靠性。 Doris会自动检查和修复损坏的数据，并将请求自动路由到健康的节点，7*24 小时保证数据的可用性。</p><p><strong>水平扩展和数据均衡</strong></p><p>Leader Node节点和Compute Node节点都可以进行横向扩展。用户可以根据计算和存储需要，灵活的对节点进行扩展。其中Compute Node节点在扩展后，Doris会自动根据节点间的负载情况，进行数据分片的自动均衡，无需人工干预。</p><p><strong>物化视图和预聚合引擎</strong></p><p>Doris支持通过物化视图或上卷表的形式对数据预聚合计算后的结果进行存储，从而加速部分聚合类场景的查询效率。同时，Doris能够保证物化视图和基础表之间的数据一致性，从而使得物化视图会查询和导入完全透明。Doris内部会自动根据用户的查询语句，选择合适的物化视图进行数据摄取。</p><p><strong>丰富的数据导入功能和导入事务保证</strong></p><p>Doris支持多种导入方式。不仅支持近实时的流式导入，也支持大批量的数据导入。同时还可以直接订阅和消费kafka中的数据。Doris自身提供导入事务支持，配合导入Label机制，可以保证导入数据的不丢不重和原子一致性。</p><p><strong>高效的列式存储引擎</strong></p><p>Doris采用自研的列式存储格式来提升OLAP领域的查询效率。存储采用字典编码、RLE等多种编码方式，配合列式存储的特点，提供了非常高的数据压缩比，帮助用户节省存储空间。同时，存储格式上提供包括Min/Max智能索引、稀疏索引、布隆过滤器、bitmap倒排索引等多种查询加速技术，进一步提升了查询效率。</p><p><strong>在线表结构修改</strong></p><p>支持在已导入数据的情况下修改表结构，包括增加列、删除列、修改列类型和改变列顺序等操作。变更操作不会影响当前数据库的查询和写入操作。</p><p><strong>丰富的生态</strong></p><p>Doris可以方便的导入存储在对象存储、HDFS或Kafka中的数据。用户也可以通过Spark来直接查询Doris中存储的数据。而Doris也可以通过ODBC读取包括MySQL、PostgreSQL、SQLServer、Oracle等外部数据源的数据。同时，Doris也可以读取Elasticsearch中存储的数据，为Elasticsearch提供强大的分布式SQL查询层。</p><h2 id="三、Doris-编译与部署"><a href="#三、Doris-编译与部署" class="headerlink" title="三、Doris 编译与部署"></a>三、Doris 编译与部署</h2><p>不想编译的话可以下载 Baidu Doris 团队基于 Apache Doris 的百度<a href="https://cloud.baidu.com/doc/PALO/s/Wksis5irl" target="_blank" rel="noopener">开源版本</a></p><h3 id="3-1-编译"><a href="#3-1-编译" class="headerlink" title="3.1 编译"></a>3.1 编译</h3><blockquote><p>使用 Docker 开发镜像编译（推荐）</p></blockquote><h4 id="3-1-1-下载-Docker-镜像"><a href="#3-1-1-下载-Docker-镜像" class="headerlink" title="3.1.1 下载 Docker 镜像"></a>3.1.1 下载 Docker 镜像</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker pull apache/incubator-doris:build-env-1.4.2</span></span><br></pre></td></tr></table></figure><p><strong>注：</strong>针对不同的 Doris 版本，需要下载对应的镜像版本</p><table><thead><tr><th>镜像版本</th><th>commit id</th><th>doris 版本</th></tr></thead><tbody><tr><td>apache/incubator-doris:build-env</td><td>before <a href="https://github.com/apache/incubator-doris/commit/ff0dd0d2daa588f18b6db56f947e813a56d8ec81" target="_blank" rel="noopener">ff0dd0d(opens new window)</a></td><td>0.8.x, 0.9.x</td></tr><tr><td>apache/incubator-doris:build-env-1.1</td><td><a href="https://github.com/apache/incubator-doris/commit/ff0dd0d2daa588f18b6db56f947e813a56d8ec81" target="_blank" rel="noopener">ff0dd0d(opens new window)</a></td><td>0.10.x, 0.11.x</td></tr><tr><td>apache/incubator-doris:build-env-1.2</td><td><a href="https://github.com/apache/incubator-doris/commit/4ef5a8c8560351d7fff7ff8fd51c4c7a75e006a8" target="_blank" rel="noopener">4ef5a8c(opens new window)</a></td><td>0.12.x - 0.14.0</td></tr><tr><td>apache/incubator-doris:build-env-1.3.1</td><td><a href="https://github.com/apache/incubator-doris/commit/ad67dd34a04c1ca960cff38e5b335b30fc7d559f" target="_blank" rel="noopener">ad67dd3(opens new window)</a></td><td>0.14.x</td></tr><tr><td>apache/incubator-doris:build-env-1.4.1</td><td><a href="https://github.com/apache/incubator-doris/commit/24d38614a0f21ed606462816a262c2e1d8273ace" target="_blank" rel="noopener">24d3861 (opens new window)</a>or later</td><td>0.15.x(releasing)</td></tr><tr><td>apache/incubator-doris:build-env-1.4.2</td><td><a href="https://github.com/apache/incubator-doris/commit/a81f4da4e461a54782a96433b746d07be89e6b54" target="_blank" rel="noopener">a81f4da (opens new window)</a>or later</td><td>0.15.x(releasing)</td></tr></tbody></table><p><strong>注意</strong>：</p><blockquote><ol><li>编译镜像 <a href="https://github.com/apache/incubator-doris/blob/master/thirdparty/CHANGELOG.md" target="_blank" rel="noopener">ChangeLog (opens new window)</a>。</li></ol></blockquote><blockquote><ol><li>doris 0.14.0 版本仍然使用apache/incubator-doris:build-env-1.2 编译，之后的代码将使用apache/incubator-doris:build-env-1.3.1。</li></ol></blockquote><blockquote><ol><li>在 build-env-1.3.1 的docker镜像中，同时包含了 OpenJDK 8 和 OpenJDK 11，并且默认使用 OpenJDK 11 编译。请确保编译使用的 JDK 版本和运行时使用的 JDK 版本一致，否则会导致非预期的运行错误。你可以使用在进入编译镜像的容器后，使用以下命令切换默认 JDK 版本：</li></ol><p>切换到 JDK 8：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> alternatives --<span class="built_in">set</span> java java-1.8.0-openjdk.x86_64</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> alternatives --<span class="built_in">set</span> javac java-1.8.0-openjdk.x86_64</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> JAVA_HOME=/usr/lib/jvm/java-1.8.0</span></span><br></pre></td></tr></table></figure><p>切换到 JDK 11：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> alternatives --<span class="built_in">set</span> java java-11-openjdk.x86_64</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> alternatives --<span class="built_in">set</span> javac java-11-openjdk.x86_64</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> JAVA_HOME=/usr/lib/jvm/java-11</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="3-1-2-运行镜像"><a href="#3-1-2-运行镜像" class="headerlink" title="3.1.2 运行镜像"></a>3.1.2 运行镜像</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run -it apache/incubator-doris:build-env-1.4.2</span></span><br></pre></td></tr></table></figure><p>建议以挂载本地 Doris 源码目录的方式运行镜像，这样编译的产出二进制文件会存储在宿主机中，不会因为镜像退出而消失。</p><p>同时，建议同时将镜像中 maven 的 <code>.m2</code> 目录挂载到宿主机目录，以防止每次启动镜像编译时，重复下载 maven 的依赖库。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run -it -v /your/<span class="built_in">local</span>/.m2:/root/.m2 -v /your/<span class="built_in">local</span>/incubator-doris-DORIS-x.x.x-release/:/root/incubator-doris-DORIS-x.x.x-release/ apache/incubator-doris:build-env-1.4.2</span></span><br></pre></td></tr></table></figure><h4 id="3-1-3-下载源码"><a href="#3-1-3-下载源码" class="headerlink" title="3.1.3 下载源码"></a>3.1.3 下载源码</h4><p>启动镜像后，你应该已经处于容器内。可以通过以下命令下载 Doris 源码（已挂载本地源码目录则不用）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget https://dist.apache.org/repos/dist/dev/incubator/doris/xxx.tar.gz</span></span><br><span class="line">or</span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/apache/incubator-doris.git</span></span><br></pre></td></tr></table></figure><h4 id="3-1-4-编译-Doris"><a href="#3-1-4-编译-Doris" class="headerlink" title="3.1.4 编译 Doris"></a>3.1.4 编译 Doris</h4><p><strong>编译FE，BE</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sh build.sh</span></span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><blockquote><p>如果你使用的是 <code>build-env-1.4.1</code> 这个环境，第一次编译的时候要使用如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sh build.sh --clean --be --fe --ui</span></span><br></pre></td></tr></table></figure><p>这是因为1.4.1 版本镜像升级了 thrift(0.9 -&gt; 0.13)，需要通过 –clean 命令强制使用新版本的 thrift 生成代码文件，否则会出现不兼容的代码。</p></blockquote><p>编译完成后，产出文件在 <code>output/</code> 目录中。</p><p><strong>编译Broker</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> fs_brokers/apache_hdfs_broker/</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sh build.sh</span></span><br></pre></td></tr></table></figure><p>编译完成后，产出文件在 <code>output/</code> 目录中。</p><h3 id="3-2-群集部署"><a href="#3-2-群集部署" class="headerlink" title="3.2 群集部署"></a>3.2 群集部署</h3><h4 id="3-2-1-官方建议配置"><a href="#3-2-1-官方建议配置" class="headerlink" title="3.2.1 官方建议配置"></a>3.2.1 官方建议配置</h4><p><strong>Linux 操作系统版本需求</strong></p><table><thead><tr><th>Linux 系统</th><th>版本</th></tr></thead><tbody><tr><td>CentOS</td><td>7.1 及以上</td></tr><tr><td>Ubuntu</td><td>16.04 及以上</td></tr></tbody></table><p><strong>软件需求</strong></p><table><thead><tr><th>软件</th><th>版本</th></tr></thead><tbody><tr><td>Java</td><td>1.8 及以上</td></tr><tr><td>GCC</td><td>4.8.2 及以上</td></tr></tbody></table><p><strong>开发测试环境</strong></p><table><thead><tr><th>模块</th><th>CPU</th><th>内存</th><th>磁盘</th><th>网络</th><th>实例数量</th></tr></thead><tbody><tr><td>Frontend</td><td>8核+</td><td>8GB+</td><td>SSD 或 SATA，10GB+ *</td><td>千兆网卡</td><td>1</td></tr><tr><td>Backend</td><td>8核+</td><td>16GB+</td><td>SSD 或 SATA，50GB+ *</td><td>千兆网卡</td><td>1-3 *</td></tr></tbody></table><p><strong>生产环境</strong></p><table><thead><tr><th>模块</th><th>CPU</th><th>内存</th><th>磁盘</th><th>网络</th><th>实例数量（最低要求）</th></tr></thead><tbody><tr><td>Frontend</td><td>16核+</td><td>64GB+</td><td>SSD 或 RAID 卡，100GB+ *</td><td>万兆网卡</td><td>1-5 *</td></tr><tr><td>Backend</td><td>16核+</td><td>64GB+</td><td>SSD 或 SATA，100G+ *</td><td>万兆网卡</td><td>10-100 *</td></tr></tbody></table><p>注1：</p><blockquote><ol><li>FE 的磁盘空间主要用于存储元数据，包括日志和 image。通常从几百 MB 到几个 GB 不等。</li><li>BE 的磁盘空间主要用于存放用户数据，总磁盘空间按用户总数据量 * 3（3副本）计算，然后再预留额外 40% 的空间用作后台 compaction 以及一些中间数据的存放。</li><li>一台机器上可以部署多个 BE 实例，但是<strong>只能部署一个 FE</strong>。如果需要 3 副本数据，那么至少需要 3 台机器各部署一个 BE 实例（而不是1台机器部署3个BE实例）。<strong>多个FE所在服务器的时钟必须保持一致（允许最多5秒的时钟偏差）</strong></li><li>测试环境也可以仅适用一个 BE 进行测试。实际生产环境，BE 实例数量直接决定了整体查询延迟。</li><li>所有部署节点关闭 Swap。</li></ol></blockquote><p>注2：FE 节点的数量</p><blockquote><ol><li>FE 角色分为 Follower 和 Observer，（Leader 为 Follower 组中选举出来的一种角色，以下统称 Follower，具体含义见 <a href="https://doris.apache.org/master/zh-CN/internal/metadata-design" target="_blank" rel="noopener">元数据设计文档</a>）。</li><li>FE 节点数据至少为1（1 个 Follower）。当部署 1 个 Follower 和 1 个 Observer 时，可以实现读高可用。当部署 3 个 Follower 时，可以实现读写高可用（HA）。</li><li>Follower 的数量<strong>必须</strong>为奇数，Observer 数量随意。</li><li>根据以往经验，当集群可用性要求很高时（比如提供在线业务），可以部署 3 个 Follower 和 1-3 个 Observer。如果是离线业务，建议部署 1 个 Follower 和 1-3 个 Observer。</li></ol></blockquote><ul><li><strong>通常我们建议 10 ~ 100 台左右的机器，来充分发挥 Doris 的性能（其中 3 台部署 FE（HA），剩余的部署 BE）</strong></li><li><strong>当然，Doris的性能与节点数量及配置正相关。在最少4台机器（一台 FE，三台 BE，其中一台 BE 混部一个 Observer FE 提供元数据备份），以及较低配置的情况下，依然可以平稳的运行 Doris。</strong></li><li><strong>如果 FE 和 BE 混部，需注意资源竞争问题，并保证元数据目录和数据目录分属不同磁盘。</strong></li></ul><h4 id="3-2-2-网络需求"><a href="#3-2-2-网络需求" class="headerlink" title="3.2.2 网络需求"></a>3.2.2 网络需求</h4><p>Doris 各个实例直接通过网络进行通讯。以下表格展示了所有需要的端口</p><table><thead><tr><th>实例名称</th><th>端口名称</th><th>默认端口</th><th>通讯方向</th><th>说明</th></tr></thead><tbody><tr><td>BE</td><td>be_port</td><td>9060</td><td>FE –&gt; BE</td><td>BE 上 thrift server 的端口，用于接收来自 FE 的请求</td></tr><tr><td>BE</td><td>webserver_port</td><td>8040</td><td>BE &lt;–&gt; BE</td><td>BE 上的 http server 的端口</td></tr><tr><td>BE</td><td>heartbeat_service_port</td><td>9050</td><td>FE –&gt; BE</td><td>BE 上心跳服务端口（thrift），用于接收来自 FE 的心跳</td></tr><tr><td>BE</td><td>brpc_port*</td><td>8060</td><td>FE&lt;–&gt;BE, BE &lt;–&gt; BE</td><td>BE 上的 brpc 端口，用于 BE 之间通讯</td></tr><tr><td>FE</td><td>http_port *</td><td>8030</td><td>FE &lt;–&gt; FE，用户</td><td>FE 上的 http server 端口</td></tr><tr><td>FE</td><td>rpc_port</td><td>9020</td><td>BE –&gt; FE, FE &lt;–&gt; FE</td><td>FE 上的 thrift server 端口，每个fe的配置需要保持一致</td></tr><tr><td>FE</td><td>query_port</td><td>9030</td><td>用户</td><td>FE 上的 mysql server 端口</td></tr><tr><td>FE</td><td>edit_log_port</td><td>9010</td><td>FE &lt;–&gt; FE</td><td>FE 上的 bdbje 之间通信用的端口</td></tr><tr><td>Broker</td><td>broker_ipc_port</td><td>8000</td><td>FE –&gt; Broker, BE –&gt; Broker</td><td>Broker 上的 thrift server，用于接收请求</td></tr></tbody></table><blockquote><p>注：</p><ol><li>当部署多个 FE 实例时，要保证 FE 的 http_port 配置相同。</li><li>部署前请确保各个端口在应有方向上的访问权限。</li></ol></blockquote><h4 id="3-2-3-服务规划"><a href="#3-2-3-服务规划" class="headerlink" title="3.2.3 服务规划"></a>3.2.3 服务规划</h4><p><strong>服务规划</strong></p><table><thead><tr><th>主机名</th><th>doris角色</th><th>依赖服务</th></tr></thead><tbody><tr><td>hadoop1</td><td>FE（Frontend）、BE（Backend）</td><td>JDK1.8、GCC4.8.2 及以上</td></tr><tr><td>hadoop2</td><td>BE（Backend）</td><td>JDK1.8、GCC4.8.2 及以上</td></tr><tr><td>hadoop3</td><td>BE（Backend）</td><td>JDK1.8、GCC4.8.2 及以上</td></tr></tbody></table><p>前置条件</p><blockquote><p>JDK和GCC是可用的</p></blockquote><h4 id="3-2-4-IP-绑定"><a href="#3-2-4-IP-绑定" class="headerlink" title="3.2.4 IP 绑定"></a>3.2.4 IP 绑定</h4><p>因为有多网卡的存在，或因为安装过 docker 等环境导致的虚拟网卡的存在，同一个主机可能存在多个不同的 ip。当前 Doris 并不能自动识别可用 IP。所以当遇到部署主机上有多个 IP 时，必须通过 priority_networks 配置项来强制指定正确的 IP。</p><p>priority_networks 是 FE 和 BE 都有的一个配置，配置项需写在 fe.conf 和 be.conf 中。该配置项用于在 FE 或 BE 启动时，告诉进程应该绑定哪个IP。示例如下：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">priority_networks=10.1.3.0/24</span><br></pre></td></tr></table></figure><p>这是一种 <a href="https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing" target="_blank" rel="noopener">CIDR (opens new window)</a>的表示方法。FE 或 BE 会根据这个配置项来寻找匹配的IP，作为自己的 localIP。</p><p><strong>注意</strong>：当配置完 priority_networks 并启动 FE 或 BE 后，只是保证了 FE 或 BE 自身的 IP 进行了正确的绑定。而在使用 ADD BACKEND 或 ADD FRONTEND 语句中，也需要指定和 priority_networks 配置匹配的 IP，否则集群无法建立。举例：</p><p>BE 的配置为：<code>priority_networks=10.1.3.0/24</code></p><p>但是在 ADD BACKEND 时使用的是：<code>ALTER SYSTEM ADD BACKEND &quot;192.168.0.1:9050&quot;;</code></p><p>则 FE 和 BE 将无法正常通信。</p><p>这时，必须 DROP 掉这个添加错误的 BE，重新使用正确的 IP 执行 ADD BACKEND。</p><p>FE 同理。</p><p>BROKER 当前没有，也不需要 priority_networks 这个选项。Broker 的服务默认绑定在 0.0.0.0 上。只需在 ADD BROKER 时，执行正确可访问的 BROKER IP 即可。</p><h4 id="3-2-5-FE-部署"><a href="#3-2-5-FE-部署" class="headerlink" title="3.2.5 FE 部署"></a>3.2.5 FE 部署</h4><p><strong>拷贝 FE 部署文件到指定节点</strong></p><p>将源码编译生成的 output 下的 fe 文件夹拷贝到 FE 的节点指定部署路径下并进入该目录。</p><p><strong>配置 FE</strong></p><p>配置文件为 <code>conf/fe.conf</code>。其中注意：<code>meta_dir</code>是元数据存放位置。默认值为 <code>${DORIS_HOME}/doris-meta</code>。需<strong>手动创建</strong>该目录。</p><blockquote><p><strong>注意：生产环境强烈建议单独指定目录不要放在Doris安装目录下，最好是单独的磁盘（如果有SSD最好），测试开发环境可以使用默认配置</strong></p></blockquote><p>fe.conf 中 JAVA_OPTS 默认 java 最大堆内存为 4GB，<strong>建议生产环境调整至 8G 以上</strong>。</p><p><strong>启动FE</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@hadoop1 ~/doris]$ sh fe/bin/start_fe.sh --daemon</span><br></pre></td></tr></table></figure><p>FE进程启动进入后台执行。日志默认存放在 log/ 目录下。如启动失败，可以通过查看 log/fe.log 或者 log/fe.out 查看错误信息。</p><p><strong>查看 FE 进程</strong></p><p>如果成功的话，可以通过jps查看到进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@hadoop1 ~/doris]$ jps |grep PaloFe</span><br><span class="line">27404 PaloFe</span><br></pre></td></tr></table></figure><blockquote><p>如需部署多 FE，请参见后面的 <strong>FE 扩容和缩容</strong> 部分</p></blockquote><h4 id="3-2-6-BE-部署"><a href="#3-2-6-BE-部署" class="headerlink" title="3.2.6 BE 部署"></a>3.2.6 BE 部署</h4><p><strong>拷贝 BE 部署文件到所有要部署 BE 的节点</strong></p><p>将源码编译生成的 output 下的 be 文件夹拷贝到 BE 的节点的指定部署路径下。</p><p><strong>修改所有 BE 的配置</strong></p><p>修改 <code>be/conf/be.conf</code>。主要是配置 <code>storage_root_path</code>：数据存放目录。默认在be/storage下，需要<strong>手动创建</strong>该目录。多个路径之间使用英文状态的分号 <code>;</code> 分隔（<strong>最后一个目录后不要加 <code>;</code></strong>）。可以通过路径区别存储目录的介质，HDD或SSD。可以添加容量限制在每个路径的末尾，通过英文状态逗号<code>,</code>隔开。</p><p>示例1如下：</p><blockquote><p><strong>注意：如果是SSD磁盘要在目录后面加上<code>.SSD</code>,HDD磁盘在目录后面加<code>.HDD</code></strong><br><code>storage_root_path=/home/disk1/doris.HDD,50;/home/disk2/doris.SSD,10;/home/disk2/doris</code></p></blockquote><p><strong>说明</strong></p><blockquote><p>/home/disk1/doris.HDD, 50，表示存储限制为50GB, HDD;<br>/home/disk2/doris.SSD 10， 存储限制为10GB，SSD；<br>/home/disk2/doris，存储限制为磁盘最大容量，默认为HDD。</p></blockquote><p>示例2如下：</p><blockquote><p><strong>注意：不论HHD磁盘目录还是SSD磁盘目录，都无需添加后缀，storage_root_path参数里指定medium即可</strong><br><code>storage_root_path=/home/disk1/doris,medium:hdd,capacity:50;/home/disk2/doris,medium:ssd,capacity:50</code></p></blockquote><p><strong>说明</strong></p><blockquote><p>/home/disk1/doris,medium:hdd,capacity:10，表示存储限制为10GB, HHD;<br>/home/disk2/doris,medium:ssd,capacity:50，表示存储限制为50GB, SSD;</p></blockquote><p><strong>BE webserver_port端口配置</strong></p><p>如果 be 部署在 hadoop 集群中，注意调整 be.conf 中的 <code>webserver_port = 8040</code> ,以免造成端口冲突</p><p><strong>在 FE 中添加所有 BE 节点</strong></p><p>BE 节点需要先在 FE 中添加，才可加入集群。可以使用 mysql-client(<a href="https://dev.mysql.com/downloads/mysql/5.7.html" target="_blank" rel="noopener">下载MySQL 5.7 (opens new window)</a>) 连接到 FE：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./mysql-client -h host -P port -uroot</span><br></pre></td></tr></table></figure><p>其中 host 为 FE 所在节点 ip；port 为 fe/conf/fe.conf 中的 query_port；默认使用 root 账户，无密码登录。</p><p>登录后，执行以下命令来添加每一个 BE：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">SYSTEM</span> <span class="keyword">ADD</span> BACKEND <span class="string">"host:port"</span>;</span><br></pre></td></tr></table></figure><blockquote><p>其中 host 为 BE 所在节点 ip；port 为 be/conf/be.conf 中的 heartbeat_service_port。</p></blockquote><p><strong>启动 BE</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@hadoop1 ~/doris]$ sh be/bin/start_be.sh --daemon</span><br></pre></td></tr></table></figure><p>BE 进程将启动并进入后台执行。日志默认存放在 be/log/ 目录下。如启动失败，可以通过查看 be/log/be.log 或者 be/log/be.out 查看错误信息。</p><p><strong>查看BE状态</strong></p><p>使用 mysql-client 连接到 FE，并执行 <code>SHOW PROC &#39;/backends&#39;;</code> 查看 BE 运行情况。如一切正常，<code>Alive</code> 列应为 <code>true</code>。</p><p><img src="/2021/12/07/apache-doris-lian-ji-fen-xi-chu-li-olap/%E5%9B%BE%E7%89%875.png" alt="图片5"></p><p><strong>访问 FE UI 查询页面</strong> <code>fe.conf</code> 配置的 <code>http_port</code>端口</p><p><img src="/2021/12/07/apache-doris-lian-ji-fen-xi-chu-li-olap/%E5%9B%BE%E7%89%876.png" alt="图片6"></p><h4 id="3-2-7-FS-Broker-部署（可选）"><a href="#3-2-7-FS-Broker-部署（可选）" class="headerlink" title="3.2.7 FS_Broker 部署（可选）"></a>3.2.7 FS_Broker 部署（可选）</h4><p>Broker 以插件的形式，独立于 Doris 部署。如果需要从第三方存储系统导入数据，需要部署相应的 Broker，默认提供了读取 HDFS 和百度云 BOS 的 fs_broker。fs_broker 是无状态的，建议每一个 FE 和 BE 节点都部署一个 Broker。</p><blockquote><ul><li><p>拷贝源码 fs_broker 的 output 目录下的相应 Broker 目录到需要部署的所有节点上。建议和 BE 或者 FE 目录保持同级。</p></li><li><p>修改相应 Broker 配置<br>在相应 broker/conf/ 目录下对应的配置文件中，可以修改相应配置。</p></li><li><p>启动 Broker<br><code>sh bin/start_broker.sh --daemon</code> 启动 Broker。</p></li><li><p>添加 Broker<br>要让 Doris 的 FE 和 BE 知道 Broker 在哪些节点上，通过 sql 命令添加 Broker 节点列表。<br>使用 mysql-client 连接启动的 FE，执行以下命令：<br><code>ALTER SYSTEM ADD BROKER broker_name &quot;host1:port1&quot;,&quot;host2:port2&quot;,...;</code><br>其中 host 为 Broker 所在节点 ip；port 为 Broker 配置文件中的 broker_ipc_port。</p></li><li><p>查看 Broker 状态<br>使用 mysql-client 连接任一已启动的 FE，执行以下命令查看 Broker 状态：<code>SHOW PROC &quot;/brokers&quot;;</code></p></li></ul></blockquote><p><strong>注：在生产环境中，所有实例都应使用守护进程启动，以保证进程退出后，会被自动拉起，如 <a href="http://supervisord.org/" target="_blank" rel="noopener">Supervisor</a>。如需使用守护进程启动，在 0.9.0 及之前版本中，需要修改各个 start_xx.sh 脚本，去掉最后的 &amp; 符号</strong>。从 0.10.0 版本开始，直接调用 <code>sh start_xx.sh</code> 启动即可。也可参考 <a href="https://www.cnblogs.com/lenmom/p/9973401.html" target="_blank" rel="noopener">这里</a></p><h2 id="四、扩容缩容"><a href="#四、扩容缩容" class="headerlink" title="四、扩容缩容"></a>四、扩容缩容</h2><p>Doris 可以很方便的扩容和缩容 FE、BE、Broker 实例。</p><h3 id="4-1-FE-扩容和缩容"><a href="#4-1-FE-扩容和缩容" class="headerlink" title="4.1 FE 扩容和缩容"></a>4.1 FE 扩容和缩容</h3><p>可以通过将 FE 扩容至 3 个以上节点来实现 FE 的高可用。</p><p>用户可以通过 mysql 客户端登陆 Master FE。通过:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> PROC <span class="string">'/frontends'</span>;</span><br></pre></td></tr></table></figure><p>来查看当前 FE 的节点情况。</p><p>也可以通过前端页面连接：<code>http://fe_hostname:fe_http_port/frontend</code> 或者 <code>http://fe_hostname:fe_http_port/system?path=//frontends</code> 来查看 FE 节点的情况。</p><p>以上方式，都需要 Doris 的 root 用户权限。</p><p>FE 节点的扩容和缩容过程，不影响当前系统运行。</p><h4 id="4-1-1-增加-FE-节点"><a href="#4-1-1-增加-FE-节点" class="headerlink" title="4.1.1 增加 FE 节点"></a>4.1.1 增加 FE 节点</h4><p>FE 分为 Leader，Follower 和 Observer 三种角色。 默认一个集群，只能有一个 Leader，可以有多个 Follower 和 Observer。其中 Leader 和 Follower 组成一个 Paxos 选择组，如果 Leader 宕机，则剩下的 Follower 会自动选出新的 Leader，保证写入高可用。Observer 同步 Leader 的数据，但是不参加选举。如果只部署一个 FE，则 FE 默认就是 Leader。</p><p>第一个启动的 FE 自动成为 Leader。在此基础上，可以添加若干 Follower 和 Observer。</p><p>添加 Follower 或 Observer。使用 mysql-client 连接到已启动的 FE，并执行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">SYSTEM</span> <span class="keyword">ADD</span> FOLLOWER <span class="string">"host:port"</span>;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">SYSTEM</span> <span class="keyword">ADD</span> OBSERVER <span class="string">"host:port"</span>;</span><br></pre></td></tr></table></figure><p>其中 host 为 Follower 或 Observer 所在节点 ip，port 为其配置文件 fe.conf 中的 edit_log_port。</p><p>配置及启动 Follower 或 Observer。Follower 和 Observer 的配置同 Leader 的配置。第一次启动时，需执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/start_fe.sh --helper host:port --daemon</span><br></pre></td></tr></table></figure><p>其中 host 为 Leader 所在节点 ip, port 为 Leader 的配置文件 fe.conf 中的 edit_log_port。--helper 参数仅在 follower 和 observer 第一次启动时才需要。</p><p>查看 Follower 或 Observer 运行状态。使用 mysql-client 连接到任一已启动的 FE，并执行：<code>SHOW PROC &#39;/frontends&#39;;</code> 可以查看当前已加入集群的 FE 及其对应角色。</p><p><strong>FE 扩容注意事项：</strong></p><blockquote><ol><li>Follower FE（包括 Leader）的数量必须为奇数，建议最多部署 3 个组成高可用（HA）模式即可。</li><li>当 FE 处于高可用部署时（1个 Leader，2个 Follower），我们建议通过增加 Observer FE 来扩展 FE 的读服务能力。当然也可以继续增加 Follower FE，但几乎是不必要的。</li><li>通常一个 FE 节点可以应对 10-20 台 BE 节点。建议总的 FE 节点数量在 10 个以下。而通常 3 个即可满足绝大部分需求。</li><li>helper 不能指向 FE 自身，必须指向一个或多个已存在并且正常运行中的 Master/Follower FE。</li></ol></blockquote><h4 id="4-1-2-删除-FE-节点"><a href="#4-1-2-删除-FE-节点" class="headerlink" title="4.1.2 删除 FE 节点"></a>4.1.2 删除 FE 节点</h4><p>使用以下命令删除对应的 FE 节点：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">SYSTEM</span> <span class="keyword">DROP</span> FOLLOWER[OBSERVER] <span class="string">"fe_host:edit_log_port"</span>;</span><br></pre></td></tr></table></figure><p><strong>FE 缩容注意事项：</strong></p><blockquote><ol><li>删除 Follower FE 时，确保最终剩余的 Follower（包括 Leader）节点为奇数。</li></ol></blockquote><h3 id="4-2-BE-扩容和缩容"><a href="#4-2-BE-扩容和缩容" class="headerlink" title="4.2 BE 扩容和缩容"></a>4.2 BE 扩容和缩容</h3><p>用户可以通过 mysql-client 登陆 Leader FE。通过:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> PROC <span class="string">'/backends'</span>;</span><br></pre></td></tr></table></figure><p>来查看当前 BE 的节点情况。</p><p>也可以通过前端页面连接：<code>http://fe_hostname:fe_http_port/backend</code> 或者 <code>http://fe_hostname:fe_http_port/system?path=//backends</code> 来查看 BE 节点的情况。</p><p>以上方式，都需要 Doris 的 root 用户权限。</p><p>BE 节点的扩容和缩容过程，不影响当前系统运行以及正在执行的任务，并且不会影响当前系统的性能。数据均衡会自动进行。根据集群现有数据量的大小，集群会在几个小时到1天不等的时间内，恢复到负载均衡的状态。集群负载情况，可以参见 <a href="https://doris.apache.org/master/zh-CN/administrator-guide/operation/tablet-repair-and-balance.html" target="_blank" rel="noopener">Tablet 负载均衡文档</a>。</p><h4 id="4-2-1-增加-BE-节点"><a href="#4-2-1-增加-BE-节点" class="headerlink" title="4.2.1 增加 BE 节点"></a>4.2.1 增加 BE 节点</h4><p>BE 节点的增加方式同 <strong>BE 部署</strong> 一节中的方式，通过 <code>ALTER SYSTEM ADD BACKEND &quot;host:port&quot;;</code> 命令增加 BE 后 <code>sh be/bin/start_be.sh --daemon</code> 启动节点。</p><p><strong>BE 扩容注意事项：</strong></p><blockquote><ol><li>BE 扩容后，Doris 会自动根据负载情况，进行数据均衡，期间不影响使用。</li></ol></blockquote><h4 id="4-2-2-删除-BE-节点"><a href="#4-2-2-删除-BE-节点" class="headerlink" title="4.2.2 删除 BE 节点"></a>4.2.2 删除 BE 节点</h4><p>删除 BE 节点有两种方式：DROP 和 DECOMMISSION</p><p><strong>DROP 语句如下：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">SYSTEM</span> <span class="keyword">DROP</span> BACKEND <span class="string">"be_host:be_heartbeat_service_port"</span>;</span><br></pre></td></tr></table></figure><p><strong>注意：DROP BACKEND 会直接删除该 BE，并且其上的数据将不能再恢复！！！所以我们强烈不推荐使用 DROP BACKEND 这种方式删除 BE 节点。当你使用这个语句时，会有对应的防误操作提示。</strong></p><p><strong>DECOMMISSION 语句如下：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">SYSTEM</span> DECOMMISSION BACKEND <span class="string">"be_host:be_heartbeat_service_port"</span>;</span><br></pre></td></tr></table></figure><p>DECOMMISSION 命令说明：</p><blockquote><ol><li>该命令用于安全删除 BE 节点。命令下发后，Doris 会尝试将该 BE 上的数据向其他 BE 节点迁移，当所有数据都迁移完成后，Doris 会自动删除该节点。</li><li>该命令是一个异步操作。执行后，可以通过 <code>SHOW PROC &#39;/backends&#39;;</code> 看到该 BE 节点的 isDecommission 状态为 true。表示该节点正在进行下线。</li><li>该命令<strong>不一定执行成功</strong>。比如剩余 BE 存储空间不足以容纳下线 BE 上的数据，或者剩余机器数量不满足最小副本数时，该命令都无法完成，并且 BE 会一直处于 isDecommission 为 true 的状态。</li><li>DECOMMISSION 的进度，可以通过 <code>SHOW PROC &#39;/backends&#39;;</code> 中的 TabletNum 查看，如果正在进行，TabletNum 将不断减少。</li><li>该操作可以通过:<br><code>CANCEL DECOMMISSION BACKEND &quot;be_host:be_heartbeat_service_port&quot;;</code><br>命令取消。取消后，该 BE 上的数据将维持当前剩余的数据量。后续 Doris 重新进行负载均衡</li></ol></blockquote><p><strong>对于多租户部署环境下，BE 节点的扩容和缩容，请参阅 <a href="https://doris.apache.org/master/zh-CN/administrator-guide/operation/multi-tenant.html" target="_blank" rel="noopener">多租户设计文档</a>。</strong></p><h3 id="4-3-Broker-扩容缩容"><a href="#4-3-Broker-扩容缩容" class="headerlink" title="4.3 Broker 扩容缩容"></a>4.3 Broker 扩容缩容</h3><p>Broker 实例的数量没有硬性要求。通常每台物理机部署一个即可。Broker 的添加和删除可以通过以下命令完成：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">SYSTEM</span> <span class="keyword">ADD</span> BROKER broker_name <span class="string">"broker_host:broker_ipc_port"</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">SYSTEM</span> <span class="keyword">DROP</span> BROKER broker_name <span class="string">"broker_host:broker_ipc_port"</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">SYSTEM</span> <span class="keyword">DROP</span> <span class="keyword">ALL</span> BROKER broker_name;</span><br></pre></td></tr></table></figure><p>Broker 是无状态的进程，可以随意启停。当然，停止后，正在其上运行的作业会失败，重试即可。</p><h2 id="五、最佳实践"><a href="#五、最佳实践" class="headerlink" title="五、最佳实践"></a>五、最佳实践</h2><h3 id="5-1-建表"><a href="#5-1-建表" class="headerlink" title="5.1 建表"></a>5.1 建表</h3><h4 id="5-1-1-数据模型选择"><a href="#5-1-1-数据模型选择" class="headerlink" title="5.1.1 数据模型选择"></a>5.1.1 数据模型选择</h4><p>Doris 数据模型上目前分为三类: AGGREGATE KEY, UNIQUE KEY, DUPLICATE KEY。三种模型中数据都是按KEY进行排序。</p><p><strong>5.1.1.1 AGGREGATE KEY</strong></p><p>AGGREGATE KEY相同时，新旧记录进行聚合，目前支持的聚合函数有SUM, MIN, MAX, REPLACE。<br>AGGREGATE KEY模型可以提前聚合数据, 适合报表和多维分析业务。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> site_visit</span><br><span class="line">(</span><br><span class="line">    siteid      <span class="built_in">INT</span>,</span><br><span class="line">    city        <span class="built_in">SMALLINT</span>,</span><br><span class="line">    username    <span class="built_in">VARCHAR</span>(<span class="number">32</span>),</span><br><span class="line">    pv <span class="built_in">BIGINT</span>   <span class="keyword">SUM</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">AGGREGATE</span> <span class="keyword">KEY</span>(siteid, city, username)</span><br><span class="line"><span class="keyword">DISTRIBUTED</span> <span class="keyword">BY</span> <span class="keyword">HASH</span>(siteid) BUCKETS <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><strong>5.1.1.2 UNIQUE KEY</strong></p><p>UNIQUE KEY 相同时，新记录覆盖旧记录。目前 UNIQUE KEY 实现上和 AGGREGATE KEY 的 REPLACE 聚合方法一样，二者本质上相同。适用于有更新需求的分析业务。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> sales_order</span><br><span class="line">(</span><br><span class="line">    orderid     <span class="built_in">BIGINT</span>,</span><br><span class="line">    <span class="keyword">status</span>      <span class="built_in">TINYINT</span>,</span><br><span class="line">    username    <span class="built_in">VARCHAR</span>(<span class="number">32</span>),</span><br><span class="line">    amount      <span class="built_in">BIGINT</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">UNIQUE</span> <span class="keyword">KEY</span>(orderid)</span><br><span class="line"><span class="keyword">DISTRIBUTED</span> <span class="keyword">BY</span> <span class="keyword">HASH</span>(orderid) BUCKETS <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><strong>5.1.1.3 DUPLICATE KEY</strong></p><p>只指定排序列，相同的行不会合并。适用于数据无需提前聚合的分析业务。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> session_data</span><br><span class="line">(</span><br><span class="line">    visitorid   <span class="built_in">SMALLINT</span>,</span><br><span class="line">    sessionid   <span class="built_in">BIGINT</span>,</span><br><span class="line">    visittime   DATETIME,</span><br><span class="line">    city        <span class="built_in">CHAR</span>(<span class="number">20</span>),</span><br><span class="line">    province    <span class="built_in">CHAR</span>(<span class="number">20</span>),</span><br><span class="line">    ip          <span class="built_in">varchar</span>(<span class="number">32</span>),</span><br><span class="line">    brower      <span class="built_in">CHAR</span>(<span class="number">20</span>),</span><br><span class="line">    <span class="keyword">url</span>         <span class="built_in">VARCHAR</span>(<span class="number">1024</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">DUPLICATE</span> <span class="keyword">KEY</span>(visitorid, sessionid)</span><br><span class="line"><span class="keyword">DISTRIBUTED</span> <span class="keyword">BY</span> <span class="keyword">HASH</span>(sessionid, visitorid) BUCKETS <span class="number">10</span>;</span><br></pre></td></tr></table></figure><h4 id="5-1-2-大宽表与-Star-Schema"><a href="#5-1-2-大宽表与-Star-Schema" class="headerlink" title="5.1.2 大宽表与 Star Schema"></a>5.1.2 大宽表与 Star Schema</h4><p>业务方建表时, 为了和前端业务适配, 往往不对维度信息和指标信息加以区分, 而将 Schema 定义成大宽表。对于 Doris 而言, 这类大宽表往往性能不尽如人意:</p><ul><li>Schema 中字段数比较多, 聚合模型中可能 key 列比较多, 导入过程中需要排序的列会增加。</li><li>维度信息更新会反应到整张表中，而更新的频率直接影响查询的效率。</li></ul><p>使用过程中，建议用户尽量使用 Star Schema 区分维度表和指标表。频繁更新的维度表也可以放在 MySQL 外部表中。而如果只有少量更新, 可以直接放在 Doris 中。在 Doris 中存储维度表时，可对维度表设置更多的副本，提升 Join 的性能。</p><h4 id="5-1-3-分区和分桶"><a href="#5-1-3-分区和分桶" class="headerlink" title="5.1.3 分区和分桶"></a>5.1.3 分区和分桶</h4><p>Doris 支持两级分区存储, 第一层为分区(partition)，目前支持 RANGE 分区和 LIST 分区两种类型, 第二层为 HASH 分桶(bucket)。</p><p><strong>5.1.3.1 分区(partition)</strong></p><p>分区用于将数据划分成不同区间, 逻辑上可以理解为将原始表划分成了多个子表。可以方便的按分区对数据进行管理，例如，删除数据时，更加迅速。</p><p>5.1.3.1.1 RANGE分区</p><p>业务上，多数用户会选择采用按时间进行partition, 让时间进行partition有以下好处：</p><ul><li>可区分冷热数据；</li><li>可用上Doris分级存储(SSD + SATA)的功能。</li></ul><p>5.1.3.1.2 LIST分区</p><p>业务上，用户可以选择城市或者其他枚举值进行partition。</p><p><strong>5.1.3.2 HASH分桶(bucket)</strong></p><p>根据hash值将数据划分成不同的 bucket。</p><ul><li>建议采用区分度大的列做分桶, 避免出现数据倾斜；</li><li>为方便数据恢复, 建议单个 bucket 的 size 不要太大, 保持在 10GB 以内, 所以建表或增加 partition 时请合理考虑 bucket 数目, 其中不同 partition 可指定不同的 buckets 数。</li></ul><h4 id="5-1-4-稀疏索引和-Bloom-Filter"><a href="#5-1-4-稀疏索引和-Bloom-Filter" class="headerlink" title="5.1.4 稀疏索引和 Bloom Filter"></a>5.1.4 稀疏索引和 Bloom Filter</h4><p>Doris对数据进行有序存储, 在数据有序的基础上为其建立稀疏索引,索引粒度为 block(1024行)。</p><p>稀疏索引选取 schema 中固定长度的前缀作为索引内容, 目前 Doris 选取 36 个字节的前缀作为索引。</p><ul><li>建表时建议将查询中常见的过滤字段放在 Schema 的前面, 区分度越大，频次越高的查询字段越往前放。</li><li>这其中有一个特殊的地方,就是 varchar 类型的字段。varchar 类型字段只能作为稀疏索引的最后一个字段。索引会在 varchar 处截断, 因此 varchar 如果出现在前面，可能索引的长度可能不足 36 个字节。具体可以参阅 <a href="https://doris.apache.org/master/zh-CN/getting-started/data-model-rollup.html" target="_blank" rel="noopener">数据模型、ROLLUP 及前缀索引</a>。</li><li>除稀疏索引之外, Doris还提供bloomfilter索引, bloomfilter索引对区分度比较大的列过滤效果明显。 如果考虑到varchar不能放在稀疏索引中, 可以建立bloomfilter索引。</li></ul><h4 id="5-1-5-物化视图-rollup"><a href="#5-1-5-物化视图-rollup" class="headerlink" title="5.1.5 物化视图(rollup)"></a>5.1.5 物化视图(rollup)</h4><p>Rollup 本质上可以理解为原始表(Base Table)的一个物化索引。建立 Rollup 时可只选取 Base Table 中的部分列作为 Schema。Schema 中的字段顺序也可与 Base Table 不同。</p><p>下列情形可以考虑建立 Rollup：</p><p><strong>5.1.5.1 Base Table 中数据聚合度不高</strong></p><p>这一般是因 Base Table 有区分度比较大的字段而导致。此时可以考虑选取部分列，建立 Rollup。</p><p>如对于 <code>site_visit</code> 表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site_visit(siteid, city, username, pv)</span><br></pre></td></tr></table></figure><p>siteid 可能导致数据聚合度不高，如果业务方经常根据城市统计pv需求，可以建立一个只有 city, pv 的 Rollup：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> site_visit <span class="keyword">ADD</span> <span class="keyword">ROLLUP</span> rollup_city(city, pv);</span><br></pre></td></tr></table></figure><p><strong>5.1.5.2 Base Table 中的前缀索引无法命中</strong></p><p>这一般是 Base Table 的建表方式无法覆盖所有的查询模式。此时可以考虑调整列顺序，建立 Rollup。</p><p>如对于 session_data 表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session_data(visitorid, sessionid, visittime, city, province, ip, brower, url)</span><br></pre></td></tr></table></figure><p>如果除了通过 visitorid 分析访问情况外，还有通过 brower, province 分析的情形，可以单独建立 Rollup。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> session_data <span class="keyword">ADD</span> <span class="keyword">ROLLUP</span> rollup_brower(brower,province,ip,<span class="keyword">url</span>) <span class="keyword">DUPLICATE</span> <span class="keyword">KEY</span>(brower,province);</span><br></pre></td></tr></table></figure><h3 id="5-2-Schema-Change"><a href="#5-2-Schema-Change" class="headerlink" title="5.2 Schema Change"></a>5.2 Schema Change</h3><p>Doris中目前进行 Schema Change 的方式有三种：Sorted Schema Change，Direct Schema Change, Linked Schema Change。</p><p>2.1. Sorted Schema Change</p><p>改变了列的排序方式，需对数据进行重新排序。例如删除排序列中的一列, 字段重排序。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> site_visit <span class="keyword">DROP</span> <span class="keyword">COLUMN</span> city;</span><br></pre></td></tr></table></figure><p>2.2. Direct Schema Change: 无需重新排序，但是需要对数据做一次转换。例如修改列的类型，在稀疏索引中加一列等。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> site_visit <span class="keyword">MODIFY</span> <span class="keyword">COLUMN</span> username <span class="built_in">varchar</span>(<span class="number">64</span>);</span><br></pre></td></tr></table></figure><p>2.3. Linked Schema Change: 无需转换数据，直接完成。例如加列操作。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> site_visit <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> click <span class="built_in">bigint</span> <span class="keyword">SUM</span> <span class="keyword">default</span> <span class="string">'0'</span>;</span><br></pre></td></tr></table></figure><p>建表时建议考虑好 Schema，这样在进行 Schema Change 时可以加快速度。</p><h2 id="六、权限管理"><a href="#六、权限管理" class="headerlink" title="六、权限管理"></a>六、权限管理</h2><p>Doris 新的权限管理系统参照了 Mysql 的权限管理机制，做到了表级别细粒度的权限控制，基于角色的权限访问控制，并且支持白名单机制。</p><h3 id="6-1-名词解释"><a href="#6-1-名词解释" class="headerlink" title="6.1 名词解释"></a>6.1 名词解释</h3><ol><li><p>用户标识 user_identity</p><p>在权限系统中，一个用户被识别为一个 User Identity（用户标识）。用户标识由两部分组成：username 和 userhost。其中 username 为用户名，由英文大小写组成。userhost 表示该用户链接来自的 IP。user_identity 以 username@&#39;userhost&#39; 的方式呈现，表示来自 userhost 的 username。<br>user_identity 的另一种表现方式为 username@[&#39;domain&#39;]，其中 domain 为域名，可以通过 DNS 或 BNS（百度名字服务）解析为一组 ip。最终表现为一组 username@&#39;userhost&#39;，所以后面我们统一使用 username@&#39;userhost&#39; 来表示。</p></li><li><p>权限 Privilege</p><p>权限作用的对象是节点、数据库或表。不同的权限代表不同的操作许可。</p></li><li><p>角色 Role</p><p>Doris可以创建自定义命名的角色。角色可以被看做是一组权限的集合。新创建的用户可以被赋予某一角色，则自动被赋予该角色所拥有的权限。后续对角色的权限变更，也会体现在所有属于该角色的用户权限上。</p></li><li><p>用户属性 user_property</p><p>用户属性直接附属于某一用户，而不是用户标识。即 cmy@&#39;192.%&#39; 和 cmy@[&#39;domain&#39;] 都拥有同一组用户属性，该属性属于用户 cmy，而不是 cmy@&#39;192.%&#39; 或 cmy@[&#39;domain&#39;]。</p><p>用户属性包括但不限于： 用户最大连接数、导入集群配置等等。</p></li></ol><h3 id="6-2-支持的操作"><a href="#6-2-支持的操作" class="headerlink" title="6.2 支持的操作"></a>6.2 支持的操作</h3><ol><li>创建用户：CREATE USER</li><li>删除用户：DROP USER</li><li>授权：GRANT</li><li>撤权：REVOKE</li><li>创建角色：CREATE ROLE</li><li>删除角色：DROP ROLE</li><li>查看当前用户权限：SHOW GRANTS</li><li>查看所有用户权限：SHOW ALL GRANTS</li><li>查看已创建的角色：SHOW ROLES</li><li>查看用户属性：SHOW PROPERTY</li></ol><p>关于以上命令的详细帮助，可以通过 mysql 客户端连接 Doris 后，使用 help + command 获取帮助。如 <code>HELP CREATE USER</code>。</p><h3 id="6-3-权限类型"><a href="#6-3-权限类型" class="headerlink" title="6.3 权限类型"></a>6.3 权限类型</h3><p>Doris 目前支持以下几种权限</p><ol><li><p>Node_priv</p><p>节点变更权限。包括 FE、BE、BROKER 节点的添加、删除、下线等操作。目前该权限只能授予 Root 用户。</p></li><li><p>Grant_priv</p><p>权限变更权限。允许执行包括授权、撤权、添加/删除/变更 用户/角色 等操作。</p></li><li><p>Select_priv</p><p>对数据库、表的只读权限。</p></li><li><p>Load_priv</p><p>对数据库、表的写权限。包括 Load、Insert、Delete 等。</p></li><li><p>Alter_priv</p><p>对数据库、表的更改权限。包括重命名 库/表、添加/删除/变更 列、添加/删除 分区等操作。</p></li><li><p>Create_priv</p><p>创建数据库、表、视图的权限。</p></li><li><p>Drop_priv</p><p>删除数据库、表、视图的权限。</p></li><li><p>Usage_priv</p><p>资源的使用权限。</p></li></ol><h3 id="6-4-权限层级"><a href="#6-4-权限层级" class="headerlink" title="6.4 权限层级"></a>6.4 权限层级</h3><p>同时，根据权限适用范围的不同，我们将库表的权限分为以下三个层级：</p><ol><li>GLOBAL LEVEL：全局权限。即通过 GRANT 语句授予的 <code>*.*</code> 上的权限。被授予的权限适用于任意数据库中的任意表。</li><li>DATABASE LEVEL：数据库级权限。即通过 GRANT 语句授予的 <code>db.*</code> 上的权限。被授予的权限适用于指定数据库中的任意表。</li><li>TABLE LEVEL：表级权限。即通过 GRANT 语句授予的 <code>db.tbl</code> 上的权限。被授予的权限适用于指定数据库中的指定表。</li></ol><p>将资源的权限分为以下两个层级：</p><ol><li>GLOBAL LEVEL：全局权限。即通过 GRANT 语句授予的 <code>*</code> 上的权限。被授予的权限适用于资源。</li><li>RESOURCE LEVEL: 资源级权限。即通过 GRANT 语句授予的 <code>resource_name</code> 上的权限。被授予的权限适用于指定资源。</li></ol><h3 id="6-5-ADMIN-GRANT-权限说明"><a href="#6-5-ADMIN-GRANT-权限说明" class="headerlink" title="6.5 ADMIN/GRANT 权限说明"></a>6.5 ADMIN/GRANT 权限说明</h3><p>ADMIN_PRIV 和 GRANT_PRIV 权限同时拥有<strong>授予权限</strong>的权限，较为特殊。这里对和这两个权限相关的操作逐一说明。</p><ol><li>CREATE USER<ul><li>拥有 ADMIN 权限，或任意层级的 GRANT 权限的用户可以创建新用户。</li></ul></li><li>DROP USER<ul><li>只有 ADMIN 权限可以删除用户。</li></ul></li><li>CREATE/DROP ROLE<ul><li>只有 ADMIN 权限可以创建角色。</li></ul></li><li>GRANT/REVOKE<ul><li>拥有 ADMIN 权限，或者 GLOBAL 层级 GRANT 权限的用户，可以授予或撤销任意用户的权限。</li><li>拥有 DATABASE 层级 GRANT 权限的用户，可以授予或撤销任意用户对指定数据库的权限。</li><li>拥有 TABLE 层级 GRANT 权限的用户，可以授予或撤销任意用户对指定数据库中指定表的权限。</li></ul></li><li>SET PASSWORD<ul><li>拥有 ADMIN 权限，或者 GLOBAL 层级 GRANT 权限的用户，可以设置任意用户的密码。</li><li>普通用户可以设置自己对应的 UserIdentity 的密码。自己对应的 UserIdentity 可以通过 <code>SELECT CURRENT_USER();</code> 命令查看。</li><li>拥有非 GLOBAL 层级 GRANT 权限的用户，不可以设置已存在用户的密码，仅能在创建用户时指定密码。</li></ul></li></ol><h3 id="6-6-一些说明"><a href="#6-6-一些说明" class="headerlink" title="6.6 一些说明"></a>6.6 一些说明</h3><ol><li><p>Doris 初始化时，会自动创建如下用户和角色：</p><ol><li>operator 角色：该角色拥有 Node_priv 和 Admin_priv，即对Doris的所有权限。后续某个升级版本中，我们可能会将该角色的权限限制为 Node_priv，即仅授予节点变更权限。以满足某些云上部署需求。</li><li>admin 角色：该角色拥有 Admin_priv，即除节点变更以外的所有权限。</li><li>root@&#39;%&#39;：root 用户，允许从任意节点登陆，角色为 operator。</li><li>admin@&#39;%&#39;：admin 用户，允许从任意节点登陆，角色为 admin。</li></ol></li><li><p>不支持删除或更改默认创建的角色或用户的权限。</p></li><li><p>operator 角色的用户有且只有一个。admin 角色的用户可以创建多个。</p></li><li><p>一些可能产生冲突的操作说明</p><ol><li><p>域名与ip冲突：</p><p>假设创建了如下用户：</p><p>CREATE USER cmy@[&#39;domain&#39;];</p><p>并且授权：</p><p>GRANT SELECT_PRIV ON *.* TO cmy@[&#39;domain&#39;]</p><p>该 domain 被解析为两个 ip：ip1 和 ip2</p><p>假设之后，我们对 cmy@&#39;ip1&#39; 进行一次单独授权：</p><p>GRANT ALTER_PRIV ON <em>.</em> TO cmy@&#39;ip1&#39;;</p><p>则 cmy@&#39;ip1&#39; 的权限会被修改为 SELECT_PRIV, ALTER_PRIV。并且当我们再次变更 cmy@[&#39;domain&#39;] 的权限时，cmy@&#39;ip1&#39; 也不会跟随改变。</p></li><li><p>重复ip冲突：</p><p>假设创建了如下用户：</p><p>CREATE USER cmy@&#39;%&#39; IDENTIFIED BY &quot;12345&quot;;</p><p>CREATE USER cmy@&#39;192.%&#39; IDENTIFIED BY &quot;abcde&quot;;</p><p>在优先级上，&#39;192.%&#39; 优先于 &#39;%&#39;，因此，当用户 cmy 从 192.168.1.1 这台机器尝试使用密码 &#39;12345&#39; 登陆 Doris 会被拒绝。</p></li></ol></li><li><p>忘记密码</p><p>如果忘记了密码无法登陆 Doris，可以在 Doris FE 节点所在机器，使用如下命令无密码登陆 Doris：</p><p><code>mysql-client -h 127.0.0.1 -P query_port -uroot</code></p><p>登陆后，可以通过 SET PASSWORD 命令重置密码。</p></li><li><p>任何用户都不能重置 root 用户的密码，除了 root 用户自己。</p></li><li><p>ADMIN_PRIV 权限只能在 GLOBAL 层级授予或撤销。</p></li><li><p>拥有 GLOBAL 层级 GRANT_PRIV 其实等同于拥有 ADMIN_PRIV，因为该层级的 GRANT_PRIV 有授予任意权限的权限，请谨慎使用。</p></li><li><p><code>current_user()</code> 和 <code>user()</code></p><p>用户可以通过 <code>SELECT current_user();</code> 和 <code>SELECT user();</code> 分别查看 <code>current_user</code> 和 <code>user</code>。其中 <code>current_user</code> 表示当前用户是以哪种身份通过认证系统的，而 <code>user</code> 则是用户当前实际的 <code>user_identity</code>。举例说明：</p><p>假设创建了 <code>user1@&#39;192.%&#39;</code> 这个用户，然后以为来自 192.168.10.1 的用户 user1 登陆了系统，则此时的 <code>current_user</code> 为 <code>user1@&#39;192.%&#39;</code>，而 <code>user</code> 为 <code>user1@&#39;192.168.10.1&#39;</code>。</p><p>所有的权限都是赋予某一个 <code>current_user</code> 的，真实用户拥有对应的 <code>current_user</code> 的所有权限。</p></li></ol><h3 id="6-7-最佳实践"><a href="#6-7-最佳实践" class="headerlink" title="6.7 最佳实践"></a>6.7 最佳实践</h3><p>这里举例一些 Doris 权限系统的使用场景。</p><ol><li><p>场景一</p><p>Doris 集群的使用者分为管理员（Admin）、开发工程师（RD）和用户（Client）。其中管理员拥有整个集群的所有权限，主要负责集群的搭建、节点管理等。开发工程师负责业务建模，包括建库建表、数据的导入和修改等。用户访问不同的数据库和表来获取数据。</p><p>在这种场景下，可以为管理员赋予 ADMIN 权限或 GRANT 权限。对 RD 赋予对任意或指定数据库表的 CREATE、DROP、ALTER、LOAD、SELECT 权限。对 Client 赋予对任意或指定数据库表 SELECT 权限。同时，也可以通过创建不同的角色，来简化对多个用户的授权操作。</p></li><li><p>场景二</p><p>一个集群内有多个业务，每个业务可能使用一个或多个数据。每个业务需要管理自己的用户。在这种场景下。管理员用户可以为每个数据库创建一个拥有 DATABASE 层级 GRANT 权限的用户。该用户仅可以对用户进行指定的数据库的授权。</p></li><li><p>黑名单</p><p>Doris 本身不支持黑名单，只有白名单功能，但我们可以通过某些方式来模拟黑名单。假设先创建了名为 <code>user@&#39;192.%&#39;</code> 的用户，表示允许来自 <code>192.*</code> 的用户登录。此时如果想禁止来自 <code>192.168.10.1</code> 的用户登录。则可以再创建一个用户 <code>cmy@&#39;192.168.10.1&#39;</code> 的用户，并设置一个新的密码。因为 <code>192.168.10.1</code> 的优先级高于 <code>192.%</code>，所以来自 <code>192.168.10.1</code> 将不能再使用旧密码进行登录。</p></li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Nov 08 2022 22:51:10 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h2&gt;
      
    
    </summary>
    
    
      <category term="Hadoop" scheme="http://chenzhonzhou.github.io/categories/Hadoop/"/>
    
    
      <category term="Hadoop" scheme="http://chenzhonzhou.github.io/tags/Hadoop/"/>
    
      <category term="Apache Doris" scheme="http://chenzhonzhou.github.io/tags/Apache-Doris/"/>
    
      <category term="OLAP" scheme="http://chenzhonzhou.github.io/tags/OLAP/"/>
    
  </entry>
  
  <entry>
    <title>Superset 一款轻量级BI工具</title>
    <link href="http://chenzhonzhou.github.io/2021/12/02/superset-yi-kuan-qing-liang-ji-bi-gong-ju/"/>
    <id>http://chenzhonzhou.github.io/2021/12/02/superset-yi-kuan-qing-liang-ji-bi-gong-ju/</id>
    <published>2021-12-02T02:41:26.000Z</published>
    <updated>2021-12-03T08:57:00.543Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Nov 08 2022 22:51:11 GMT+0800 (GMT+08:00) --><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p><a href="https://superset.apache.org/" target="_blank" rel="noopener">Apache Superset</a> 是Airbnb开源的数据挖掘和可视化平台。支持丰富的数据源连接，多种可视化方式，并能够对用户实现细粒度的权限控制。该工具主要特点是可自助分析、自定义仪表盘、分析结果可视化（导出）、用户/角色权限控制，还集成了一个SQL编辑器，可以进行SQL编辑查询等。</p><h2 id="二、支持功能"><a href="#二、支持功能" class="headerlink" title="二、支持功能"></a>二、支持功能</h2><ul><li>丰富的数据可视化集；</li><li>易于使用的界面，用于浏览和可视化数据；</li><li>创建和共享仪表板；</li><li>与主要身份验证提供程序（数据库，OpenID，LDAP，OAuth和REMOTE_USER通过Flask AppBuilder集成）集成的企业就绪身份验证；</li><li>可扩展的高粒度安全性/权限模型，允许有关谁可以访问单个要素和数据集的复杂规则；</li><li>一个简单的语义层，允许用户通过定义哪些字段应显示在哪个下拉列表中以及哪些聚合和功能度量可供用户使用来控制如何在UI中显示数据源；</li><li>通过 SQLAlchemy 连接到任何基于 SQL 的数据源，包括 PB 级的现代云原生数据库和引擎；</li><li>与Druid.io的深度集成。</li></ul><h2 id="三、Superset-部署"><a href="#三、Superset-部署" class="headerlink" title="三、Superset 部署"></a>三、Superset 部署</h2><p>Superset 的部署可以使用本地Python环境、Docker Compose、K8s等方式，这里基于前再者进行示范</p><h3 id="3-1-基于本地-Pthon-部署"><a href="#3-1-基于本地-Pthon-部署" class="headerlink" title="3.1 基于本地 Pthon 部署"></a>3.1 基于本地 Pthon 部署</h3><h4 id="3-1-1-安装依赖包"><a href="#3-1-1-安装依赖包" class="headerlink" title="3.1.1 安装依赖包"></a>3.1.1 安装依赖包</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@hadoop3 ~]$ sudo yum install gcc gcc-c++ libffi-devel python-devel python-pip python-wheel openssl-devel cyrus-sasl-devel openldap-devel bzip2-devel</span><br></pre></td></tr></table></figure><p>编译依赖sqlite3，后面编译python的时候，缺失sqlite3的库，并不会直接报错，直到运行Superset时就会报<code>ModuleNotFoundError: No module named &#39;_sqlite3&#39;</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@hadoop3 ~/downloads]$ wget http://www.sqlite.org/sqlite-3.5.6.tar.gz</span><br><span class="line">[hadoop@hadoop3 ~/downloads]$ tar xf sqlite-3.5.6.tar.gz</span><br><span class="line">[hadoop@hadoop3 ~/downloads]$ cd sqlite-3.5.6/</span><br><span class="line">[hadoop@hadoop3 ~/downloads/sqlite-3.5.6]$ ./configure --disable-tcl</span><br><span class="line">[hadoop@hadoop3 ~/downloads/sqlite-3.5.6]$ make &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure><h4 id="3-1-2-安装-python3-环境"><a href="#3-1-2-安装-python3-环境" class="headerlink" title="3.1.2 安装 python3 环境"></a>3.1.2 安装 python3 环境</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@hadoop3 ~/downloads]$ wget https://www.python.org/ftp/python/3.7.11/Python-3.7.11.tgz</span><br><span class="line">[hadoop@hadoop3 ~/downloads]$ sudo tar zxf Python-3.7.11.tgz -C /usr/src/</span><br><span class="line">[hadoop@hadoop3 ~/downloads]$ <span class="built_in">cd</span> /usr/src/Python-3.7.11/</span><br><span class="line">[hadoop@hadoop3 Python-3.7.11]$ sudo ./configure LDFLAGS=<span class="string">"-L/usr/local/lib"</span> CPPFLAGS=<span class="string">"-I/usr/local/include"</span> --<span class="built_in">enable</span>-optimizations</span><br><span class="line">[hadoop@hadoop3 Python-3.7.11]$ sudo make altinstall</span><br></pre></td></tr></table></figure><h4 id="3-1-3-开启-python-虚拟环境"><a href="#3-1-3-开启-python-虚拟环境" class="headerlink" title="3.1.3 开启 python 虚拟环境"></a>3.1.3 开启 python 虚拟环境</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@hadoop3 ~]$ sudo pip3 install --upgrade setuptools pip</span><br><span class="line">[hadoop@hadoop3 ~]$ pip3 install virtualenv -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line"></span><br><span class="line">[hadoop@hadoop3 ~]$ python3 -m venv venv</span><br><span class="line">[hadoop@hadoop3 ~]$ . venv/bin/activate</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">可以通过deactivate命令退出虚拟环境。</span></span><br></pre></td></tr></table></figure><p>或者使用 pyenv-virtualenv：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Here we name the virtual env <span class="string">'superset'</span></span></span><br><span class="line">pyenv virtualenv superset</span><br><span class="line">pyenv activate superset</span><br></pre></td></tr></table></figure><h4 id="3-1-4-安装和初始化-Superset"><a href="#3-1-4-安装和初始化-Superset" class="headerlink" title="3.1.4 安装和初始化 Superset"></a>3.1.4 安装和初始化 Superset</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">安装 superset</span></span><br><span class="line">(venv) [hadoop@hadoop3 ~]$ pip3 install apache-superset -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">初始化 superset</span></span><br><span class="line">(venv) [hadoop@hadoop3 ~]$ superset db upgrade</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">创建管理员用户，初始化，启动superset</span></span><br><span class="line">(venv) [hadoop@hadoop3 ~]$ superset superset fab create-admin</span><br><span class="line">(venv) [hadoop@hadoop3 ~]$ superset load_examples</span><br><span class="line">(venv) [hadoop@hadoop3 ~]$ superset init</span><br><span class="line">(venv) [hadoop@hadoop3 ~]$ superset run -h 0.0.0.0 -p 8088 --with-threads --reload --debugger</span><br></pre></td></tr></table></figure><p>如果报错 <code>ERROR: flask-appbuilder 3.4.0 has requirement Flask-WTF&lt;0.15.0,&gt;=0.14.2, but you&#39;ll have flask-wtf 1.0.0 which is incompatible.</code> 请安装 <code>pip3 install Flask-WTF==0.14.3</code></p><h3 id="3-2-基于Docker-Compose-部署"><a href="#3-2-基于Docker-Compose-部署" class="headerlink" title="3.2 基于Docker Compose 部署"></a>3.2 基于Docker Compose 部署</h3><h4 id="3-2-1-克隆-Superset"><a href="#3-2-1-克隆-Superset" class="headerlink" title="3.2.1 克隆 Superset"></a>3.2.1 克隆 Superset</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@hadoop3 ~]$ git clone https://github.com/apache/superset.git</span><br></pre></td></tr></table></figure><h4 id="3-2-2-启动-Superset"><a href="#3-2-2-启动-Superset" class="headerlink" title="3.2.2 启动 Superset"></a>3.2.2 启动 Superset</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@hadoop3 ~/superset]$ docker-compose -f docker-compose-non-dev.yml up</span><br></pre></td></tr></table></figure><p>访问 Superset UI 页面，默认账户密码admin</p><p><img src="/2021/12/02/superset-yi-kuan-qing-liang-ji-bi-gong-ju/%E5%9B%BE%E7%89%871.png" alt="图片1"></p><h4 id="3-2-3-Superset-汉化"><a href="#3-2-3-Superset-汉化" class="headerlink" title="3.2.3 Superset 汉化"></a>3.2.3 Superset 汉化</h4><p>在 <code>docker/pythonpath_dev/superset_config.py</code> 文件任意位置中添加以下内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LANGUAGES  = &#123;</span><br><span class="line">     <span class="string">'en'</span> : &#123; <span class="string">'flag'</span> : <span class="string">'us'</span> , <span class="string">'name'</span> : <span class="string">'English'</span> &#125;,</span><br><span class="line">     <span class="string">'zh'</span> : &#123; <span class="string">'flag'</span> : <span class="string">'cn'</span> , <span class="string">'name'</span> : <span class="string">'Chinese'</span> &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启 Superset</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@hadoop3 ~/superset]$ docker-compose -f docker-compose-non-dev.yml down</span><br><span class="line">[hadoop@hadoop3 ~/superset]$ docker-compose -f docker-compose-non-dev.yml up</span><br></pre></td></tr></table></figure><p><img src="/2021/12/02/superset-yi-kuan-qing-liang-ji-bi-gong-ju/%E5%9B%BE%E7%89%872.png" alt="图片2"></p><h4 id="3-3-添加-MySQL-数据库"><a href="#3-3-添加-MySQL-数据库" class="headerlink" title="3.3 添加 MySQL 数据库"></a>3.3 添加 MySQL 数据库</h4><p>在 <strong>Data</strong> –&gt;&gt; <strong>Databases</strong> –&gt;&gt; 选择右上解的 <strong>+数据库</strong> –&gt;&gt; <strong>MySQL</strong></p><p>然后添加数据库相关配置</p><p><img src="/2021/12/02/superset-yi-kuan-qing-liang-ji-bi-gong-ju/%E5%9B%BE%E7%89%873.png" alt="图片3"></p><p>添加完后就可以在 <strong>SQL Lab</strong> –&gt;&gt; <strong>SQL Editor</strong> 进行查询</p><p><img src="/2021/12/02/superset-yi-kuan-qing-liang-ji-bi-gong-ju/%E5%9B%BE%E7%89%874.png" alt="图片4"></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Nov 08 2022 22:51:11 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; title=&quot;一、简介&quot;&gt;&lt;/a&gt;一、简介&lt;/h2&gt;
      
    
    </summary>
    
    
      <category term="Hadoop" scheme="http://chenzhonzhou.github.io/categories/Hadoop/"/>
    
    
      <category term="Hadoop" scheme="http://chenzhonzhou.github.io/tags/Hadoop/"/>
    
      <category term="Superset" scheme="http://chenzhonzhou.github.io/tags/Superset/"/>
    
      <category term="BI" scheme="http://chenzhonzhou.github.io/tags/BI/"/>
    
  </entry>
  
  <entry>
    <title>OLAP 如何选型</title>
    <link href="http://chenzhonzhou.github.io/2021/11/30/olap-ru-he-xuan-xing/"/>
    <id>http://chenzhonzhou.github.io/2021/11/30/olap-ru-he-xuan-xing/</id>
    <published>2021-11-30T07:22:53.000Z</published>
    <updated>2021-12-01T08:05:21.040Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Nov 08 2022 22:51:11 GMT+0800 (GMT+08:00) --><h2 id="一、OLAP-简介"><a href="#一、OLAP-简介" class="headerlink" title="一、OLAP 简介"></a>一、OLAP 简介</h2><p><strong>OLAP</strong>，也叫<strong>联机分析处理（Online Analytical Processing）</strong>系统，有的时候也叫DSS决策支持系统，就是我们说的数据仓库。与此相对的是<strong>OLTP（on-line transaction processing）联机事务处理</strong>系统。</p><p>联机分析处理 (OLAP) 的概念最早是由关系数据库之父<strong>E.F.Codd</strong>于1993年提出的。OLAP的提出引起了很大的反响，OLAP作为一类产品同联机事务处理 (OLTP) 明显区分开来。</p><p>Codd认为联机事务处理（OLTP）已不能满足终端用户对数据库查询分析的要求，SQL对大数据库的简单查询也不能满足用户分析的需求。用户的决策分析需要对关系数据库进行大量计算才能得到结果，而查询的结果并不能满足决策者提出的需求。因此，Codd提出了多维数据库和多维分析的概念，即OLAP。</p><p>OLAP委员会对联机分析处理的定义为：从原始数据中转化出来的、能够真正为用户所理解的、并真实反映企业多维特性的数据称为信息数据，使分析人员、管理人员或执行人员能够从多种角度对信息数据进行快速、一致、交互地存取，从而获得对数据的更深入了解的一类软件技术。OLAP的目标是满足决策支持或多维环境特定的查询和报表需求，它的技术核心是”维”这个概念，因此OLAP也可以说是多维数据分析工具的集合。</p><h2 id="二、OLAP-的准则和特性"><a href="#二、OLAP-的准则和特性" class="headerlink" title="二、OLAP 的准则和特性"></a>二、OLAP 的准则和特性</h2><p><strong>E.F.Codd提出了关于OLAP的12条准则</strong></p><ol><li>准则1 OLAP模型必须提供多维概念视图</li><li>准则2 透明性准则</li><li>准则3 存取能力准则</li><li>准则4 稳定的报表能力</li><li>准则5 客户/服务器体系结构</li><li>准则6 维的等同性准则</li><li>准则7 动态的稀疏矩阵处理准则</li><li>准则8 多用户支持能力准则</li><li>准则9 非受限的跨维操作</li><li>准则10 直观的数据操纵</li><li>准则11 灵活的报表生成</li><li>准则12 不受限的维与聚集层次</li></ol><p><strong>OLAP场景的关键特征</strong></p><ol><li>大多数是读请求</li><li>数据总是以相当大的批(&gt; 1000 rows)进行写入</li><li>不修改已添加的数据</li><li>每次查询都从数据库中读取大量的行，但是同时又仅需要少量的列</li><li>宽表，即每个表包含着大量的列</li><li>较少的查询(通常每台服务器每秒数百个查询或更少)</li><li>对于简单查询，允许延迟大约50毫秒</li><li>列中的数据相对较小：数字和短字符串(例如，每个URL 60个字节)</li><li>处理单个查询时需要高吞吐量（每个服务器每秒高达数十亿行）</li><li>事务不是必须的</li><li>对数据一致性要求低</li><li>每一个查询除了一个大表外都很小</li><li>查询结果明显小于源数据，换句话说，数据被过滤或聚合后能够被盛放在单台服务器的内存中</li></ol><blockquote><p>OLTP系统强调数据库内存效率，强调内存各种指标的命令率，强调绑定变量，强调并发操作，强调事务性；<br>OLAP系统则强调数据分析，强调SQL执行时长，强调磁盘I/O，强调分区。</p></blockquote><h2 id="三、OLAP-开源引擎"><a href="#三、OLAP-开源引擎" class="headerlink" title="三、OLAP 开源引擎"></a>三、OLAP 开源引擎</h2><p>目前市面上主流的开源OLAP引擎包含不限于：Hive、Hawq、Presto、Kylin、Impala、Sparksql、Druid、Clickhouse、Greeplum等，可以说目前没有一个引擎能在数据量，灵活程度和性能上做到完美，用户需要根据自己的需求进行选型。</p><p>开源大数据OLAP组件，可以分为MOLAP和ROLAP两类。ROLAP中又可细分为MPP数据库和SQL引擎两类。对于SQL引擎又可以再细分为基于MPP架构的SQL引擎和基于通用计算框架的SQL引擎。</p><p><img src="/2021/11/30/olap-ru-he-xuan-xing/%E5%9B%BE%E7%89%871.png" alt="图片1"></p><p>MOLAP一般对数据存储有优化，并且进行部分预计算，因此查询性能最高。但通常对查询灵活性有限制。</p><p>MPP数据库是个完整的数据库，通常数据需要导入其中才能完成OLAP功能。MPP数据库在数据入库时对数据分布可以做优化，虽然入库效率有一定下降，但是对后期查询性能的提高有很大帮助。MPP数据库可以提供灵活的即席查询能力，但一般对查询数据量有一定限制，无法支撑特别大的数据量的查询。</p><p>SQL引擎只提供SQL执行的能力，本身一般不负责数据存储，通常可以对接多种数据储存，如HDFS、HBase、MySQL等。有的还支持联邦查询能力，可以对多个异构数据源进行联合分析。SQL引擎中，基于MPP架构的SQL引擎，一般对在线查询场景有特殊优化，所以端到端查询性能一般要高于基于通用计算框架的SQL引擎；但是在容错性和数据量方面又会逊于基于通用计算框架的SQL引擎。</p><h3 id="3-1-Kylin"><a href="#3-1-Kylin" class="headerlink" title="3.1 Kylin"></a>3.1 Kylin</h3><p>Apache <a href="https://kylin.apache.org/cn/" target="_blank" rel="noopener">Kylin</a> 是一个开源的分布式分析引擎，提供 Hadoop/Spark 之上的 SQL 查询接口及多维分析（OLAP）能力以支持超大规模数据，它能在亚秒内查询巨大的 Hive 表。Kylin的核心思想是预计算，理论基础是：以空间换时间。即将多维分析可能用到的度量进行预计算，将计算好的结果保存成Cube并存储到HBase中，供查询时直接访问。把高复杂度的聚合运算，多表连接等操作转换成对预计算结果的查询。</p><p>Kylin的主要特点是预计算，提前计算好各个cube，这样的优点是查询快速，秒级延迟；缺点也非常明显，灵活性不足，无法做一些探索式的，关联性的数据分析。</p><p><img src="/2021/11/30/olap-ru-he-xuan-xing/%E5%9B%BE%E7%89%872.png" alt="图片2"></p><p><strong>Kylin的核心模块</strong>：</p><blockquote><p><strong>REST Server：</strong>提供 Restful 接口，例如创建、构建、刷新、合并等 Cube 相关操作，Kylin 的 Projects、Tables 等元数据管理，用户访问权限控制，SQL 的查询等；<br><strong>Query Engine：</strong>使用开源的 Apache Calcite 框架来实现 SQL 解析，可以理解为 SQL 引擎层；<br><strong>Routing：</strong>负责将解析 SQL 生成的执行计划转换成 Cube 缓存的查询，这部分查询是可以在秒级甚至毫秒级完成；<br><strong>Metadata：</strong>Kylin 中有大量的元数据信息，包括 Cube 的定义、星型模型的定义、Job 和执行 Job 的输出信息、模型的维度信息等等，Kylin 的元数据和 Cube 都存储在 HBase 中，存储的格式是 json 字符串；<br><strong>Cube Build Engine：</strong>所有模块的基础，它主要负责 Kylin 预计算中创建 Cube，创建的过程是首先通过 Hive 读取原始数据，然后通过一些 MapReduce 或 Spark 计算生成 Htable，最后将数据 load 到 HBase 表中。</p></blockquote><p><strong>整个系统分为两部分：</strong></p><ol><li><p>离线构建：</p><blockquote><p>1）数据源在左侧，目前主要是 Hadoop Hive，保存着待分析的用户数据；<br>2）根据元数据的定义，下方构建引擎从数据源抽取数据，并构建 Cube；<br>3）数据以关系表的形式输入，支持星形模型和雪花模型；<br>4）2.5 开始 Spark 是主要的构建技术（以前是MapReduce）；<br>5）构建后的 Cube 保存在右侧的存储引擎中，一般选用 HBase 作为存储。</p></blockquote></li><li><p>在线查询</p><blockquote><p>1）用户可以从上方查询系统（Rest API、JDBC/ODBC）发送 SQL 进行查询分析；<br>2）无论从哪个接口进入，SQL 最终都会来到 Rest 服务层，再转交给查询引擎进行处理；<br>3）查询引擎解析 SQL，生成基于关系表的逻辑执行计划；<br>4）然后将其转译为基于 Cube 的物理执行计划；<br>5）最后查询预计算生成的 Cube 并产生结果。</p></blockquote></li></ol><p><strong>优点</strong>：</p><blockquote><p>1）亚秒级查询响应；<br>2）支持百亿、千亿甚至万亿级别交互式分析；<br>3）无缝与 BI 工具集成；<br>4）支持增量刷新；</p></blockquote><p><strong>缺点</strong>：</p><blockquote><p>1）由于 Kylin 是一个分析引擎，只读，不支持 insert, update, delete 等 SQL 操作，用户修改数据的话需要重新批量导入（构建）；<br>2）需要预先建立模型后加载数据到 Cube 后才可进行查询；<br>3）使用 Kylin 的建模人员需要了解一定的数据仓库知识。</p></blockquote><h3 id="3-2-Druid"><a href="#3-2-Druid" class="headerlink" title="3.2 Druid"></a>3.2 Druid</h3><p><a href="https://druid.apache.org/" target="_blank" rel="noopener">Druid</a> 是一个高效的数据查询系统，主要解决的是对于大量的基于时序的数据进行聚合查询。数据可以实时摄入，进入到Druid后立即可查，同时数据是几乎是不可变。</p><p><img src="/2021/11/30/olap-ru-he-xuan-xing/%E5%9B%BE%E7%89%873.png" alt="图片3"></p><p>Druid是专为海量数据集上的做高性能 OLAP而设计的数据存储和分析系统。</p><p>Druid 采用了shared-nothing架构与lambda架构。</p><p>Druid的核心设计结合了数据仓库，时间序列数据库和搜索系统的思想，以创建一个统一的系统，用于针对各种用例的实时分析。Druid将这三个系统中每个系统的关键特征合并到其接收层，存储格式，查询层和核心体系结构中。</p><p>目前 Druid 的去重都是非精确的，Druid 适合处理星型模型的数据，不支持关联操作。也不支持数据的更新。</p><p>Druid有几种进程类型，简要描述如下：</p><blockquote><p><strong>Coordinators协调器进程：</strong>负责监控数据服务器上的Historicals进程，将Segments分配给特定的服务器，并负责确保Segments在多个Historicals之间保持平衡。<br><strong>Overlords进程：</strong>负责监控数据服务器上的MiddleManager进程，并控制数据获取任务的分配。<br><strong>Broker代理进程：</strong>处理来自外部客户端的查询，将查询转发给数据服务器去执行，并合并来自多个数据服务器的结果，返回给最终用户。<br><strong>Routers进程：</strong>是个可选进程，提供统一的API Gateway，可以将请求路由到Brokers、Overlords和Coordinators。<br><strong>Historicals进程：</strong>负责处理“历史数据”的查询。 它会从Deep Storage下载查询需要的Segments以加速查询。它不负责写入。<br><strong>MiddleManager进程：</strong>负责处理获取到新数据，从外部数据源读取数据并转换成Segments进行存储。</p></blockquote><p>Druid进程可以按照任何方式进行部署，但是为了易于部署，一般建议将它们组织为三种服务器类型：</p><blockquote><p><strong>主服务器：</strong>运行Coordinatos和Overlords进程，负责管理数据获取和数据可用性。<br><strong>查询服务器：</strong>运行Brokers和可选的Routers进程，处理来自外部客户端的查询。<br><strong>数据服务器：</strong>运行Historicals和MiddleManagers进程，负责执行数据获取任务并存储所有可查询的数据。</p></blockquote><p><strong>特点：</strong></p><blockquote><p><strong>面向列的存储：</strong>Druid 单独存储和压缩每一列，只需要读取特定查询所需的列，支持快速扫描、排名和 groupBys。<br><strong>本地搜索索引：</strong>Druid 为字符串值创建倒排索引以进行快速搜索和过滤。<br><strong>流式传输和批量摄取：</strong>适用于 Apache Kafka、HDFS、AWS S3、流处理器等的开箱即用连接器。<br><strong>灵活的模式：</strong>Druid 优雅地处理不断变化的模式和<a href="https://druid.apache.org/docs/latest/ingestion/flatten-json" target="_blank" rel="noopener">嵌套数据</a>。<br><strong>时间优化分区：</strong>Druid根据时间对数据进行智能分区，基于时间的查询速度明显快于传统数据库。<br><strong>SQL 支持：</strong>除了其原生的<a href="https://druid.apache.org/docs/latest/querying/querying" target="_blank" rel="noopener">基于 JSON 的语言外</a>，Druid 还通过 HTTP 或 JDBC 使用<a href="https://druid.apache.org/docs/latest/querying/sql" target="_blank" rel="noopener">SQL</a>。<br><strong>水平扩展性：</strong>Druid 已<a href="https://druid.apache.org/druid-powered" target="_blank" rel="noopener">在生产中</a>用于每秒摄取数百万个事件、保留多年数据并提供亚秒级查询。<br><strong>操作简单：</strong>只需添加或删除服务器即可扩大或缩小规模，Druid 会自动重新平衡。容错架构围绕服务器故障进行路由。</p></blockquote><p><strong>使用场景</strong>：</p><blockquote><p>1）需要实时分析，查询延迟为100毫秒到几秒钟；<br>2）插入率非常高，但更新不常见；<br>3）大多数查询都是聚合和报告查询；<br>4）数据有一个时间组件；<br>5）每个查询只能访问一个大的分布式表；<br>6）有高基数数据列，对它们进行快速计数和排名；<br>7）需要交互式和快速探究大量数据。</p></blockquote><p><strong>缺点：</strong></p><blockquote><p>1）灵活性适中，虽然维度之间随意组合，但不支持adhoc查询，不能自由组合查询，且丢失了明细数据（不采用roll-up情况下可以进行明细查询）；<br>2）易用性较差，不支持join，不支持更新，sql支持很弱(有些插件类似于pinot的PQL语言)，只能JSON格式查询，对于去重操作不能精准去重；<br>3）处理方式复杂，需要流处理引擎将数据join成宽表，维护相对复杂；对内存要求较高。</p></blockquote><h3 id="3-3-Greenplum"><a href="#3-3-Greenplum" class="headerlink" title="3.3 Greenplum"></a>3.3 Greenplum</h3><p><a href="https://greenplum.org/" target="_blank" rel="noopener">Greenplum</a> 是基于PostgreSQL的开源MPP数据库，具有良好的线性扩展能力，具有高效的并行运算和并行存储特性。</p><p><img src="/2021/11/30/olap-ru-he-xuan-xing/%E5%9B%BE%E7%89%874.png" alt="图片4"></p><p>Greenplum的系统架构实际上是多台PostgreSQL数据库服务器组成的矩阵，采用无共享(no shareing)的MPP架构：</p><blockquote><p><strong>Master节点：</strong>作为数据库的入口，负责客服端连接；对客服端的请求生成查询计划，分发给某个或者所有的Segment节点；<br><strong>Standby节点 :</strong> 作为master节点的备库，提供高可用性；<br><strong>Interconnect：</strong>是GreenPlum的网络层；负责每个节点之间的通信；<br><strong>Segment节点：</strong>为数据节点；接收master分发下来的查询计划；执行返回结果给master节点；<br><strong>Mirror Segment节点：</strong> 作为Segment节点的备库，提供高可用性；通常跟对应的segment节点不在同一台机器上。</p></blockquote><p><strong>优点</strong>：</p><blockquote><p>1）支持多态数据存储，允许用户根据应用定义数据分布方式，可提高查询性能；<br>2）具有高效的SQL优化器，针对OLAP查询进行优化。</p></blockquote><p><strong>缺点：</strong></p><blockquote><p>1）存在<strong><code>木桶效应</code></strong>，单机故障会导致性能严重下降，因此集群规模不能太大；<br>2）并发性能不高，通常无法支持超过30个并发。</p></blockquote><h3 id="3-4-ClickHouse"><a href="#3-4-ClickHouse" class="headerlink" title="3.4 ClickHouse"></a>3.4 ClickHouse</h3><p><a href="https://clickhouse.yandex/" target="_blank" rel="noopener">ClickHouse</a> 的全称是<strong>Click Stream，Data WareHouse</strong>，简称ClickHouse，是俄罗斯 Yandex 公司于2016年开源的列式存储数据库（DBMS)，主要用于联机分析处理查询（OLAP），能够使用SQL 查询实时生成分析数据报告。<br>目前ClickHouse公开的资料相对匮乏，比如在架构设计层面就很难找到完整的资料，甚至连一张整体的架构图都没有。</p><p>ClickHouse为什么性能这么好？</p><blockquote><p><strong>着眼硬件：</strong>基于将硬件功效最大化的目的，ClickHouse会在内存中进行GROUP BY；与此同时，他们非常在意CPU L3级别的缓存，因为一次L3的缓存失效会带来70～100ns的延迟，意味着在单核CPU上，它会浪费4000万次/秒的运算。正因为注意了这些细节，所以ClickHouse在基准查询中能做到1.75亿次/秒的数据扫描性能。</p><p><strong>注重算法：</strong>例如，在字符串搜索方面，针对不同的场景，ClickHouse选择了多种算法：对于常量，使用Volnitsky算法；对于非常量，使用CPU的向量化执行SIMD，暴力优化；正则匹配使用re2和hyperscan算法。除了字符串之外，其余的场景也与它类似，ClickHouse会使用最合适、最快的算法。如果世面上出现了号称性能强大的新算法，ClickHouse团队会立即将其纳入并进行验证。</p><p><strong>特定场景，特殊优化：</strong>针对同一个场景的不同状况，选择使用不同的实现方式，尽可能将性能最大化。对于数据结构比较清晰的场景，会通过代码生成技术实现循环展开，以减少循环次数。</p><p><strong>向量化执行：</strong>SIMD被广泛地应用于文本转换、数据过滤、数据解压和JSON转换等场景。相较于单纯地使用CPU，利用寄存器暴力优化也算是一种降维打击了。</p></blockquote><p><strong>优点</strong>：</p><blockquote><p>1）为了高效的使用CPU，数据不仅仅按列存储，同时还按向量进行处理；<br>2）数据压缩空间大，减少IO；处理单查询高吞吐量每台服务器每秒最多数十亿行；<br>3）索引非B树结构，不需要满足最左原则；只要过滤条件在索引列中包含即可；即使在使用的数据不在索引中，由于各种并行处理机制ClickHouse全表扫描的速度也很快；<br>4）写入速度非常快，50-200M/s，对于大量的数据更新非常适用。</p></blockquote><p><strong>缺点：</strong></p><blockquote><p>1）不支持事务，不支持真正的删除/更新；<br>2）不支持高并发，官方建议qps为100，可以通过修改配置文件增加连接数，但是在服务器足够好的情况下；<br>3）SQL满足日常使用80%以上的语法，join写法比较特殊；最新版已支持类似SQL的join，但性能不好；<br>4）尽量做1000条以上批量的写入，避免逐行insert或小批量的insert，update，delete操作，因为ClickHouse底层会不断的做异步的数据合并，会影响查询性能，这个在做实时数据写入的时候要尽量避开；<br>5）Clickhouse快是因为采用了并行处理机制，即使一个查询，也会用服务器一半的CPU去执行，所以ClickHouse不能支持高并发的使用场景，默认单查询使用CPU核数为服务器核数的一半，安装时会自动识别服务器核数，可以通过配置文件修改该参数。</p></blockquote><h3 id="3-5-Impala"><a href="#3-5-Impala" class="headerlink" title="3.5 Impala"></a>3.5 Impala</h3><p><a href="https://impala.apache.org/" target="_blank" rel="noopener">Impala</a> 是Cloudera 公司推出，提供对 HDFS、Hbase 数据的高性能、低延迟的交互式 SQL 查询功能。</p><p>Impala 使用 Hive的元数据, 完全在内存中计算。是CDH 平台首选的 PB 级大数据实时查询分析引擎。</p><p><img src="/2021/11/30/olap-ru-he-xuan-xing/%E5%9B%BE%E7%89%875.png" alt="图片5"></p><p>Impala采用MPP架构，与存储引擎解耦：</p><blockquote><p><strong>Impalad进程：</strong>是核心进程，负责接收查询请求并向多个数据节点分发任务。<br><strong>statestored进程：</strong>负责监控所有Impalad进程，并向集群中的节点报告各个Impalad进程的状态。<br><strong>catalogd进程：</strong>负责广播通知元数据的最新信息。</p></blockquote><p><strong>Impala的特性包括：</strong></p><blockquote><p>1）支持Parquet、Avro、Text、RCFile、SequenceFile等多种文件格式；<br>2）支持存储在HDFS、HBase、Amazon S3上的数据操作；<br>3）支持多种压缩编码方式：Snappy、Gzip、Deflate、Bzip2、LZO；<br>4）支持UDF和UDAF；<br>5）自动以最有效的顺序进行表连接；<br>6）允许定义查询的优先级排队策略；<br>7）支持多用户并发查询；<br>8）支持数据缓存；<br>9）提供计算统计信息（COMPUTE STATS）；<br>10）提供窗口函数（聚合 OVER PARTITION, RANK, LEAD, LAG, NTILE等等）以支持高级分析功能；<br>11）支持使用磁盘进行连接和聚合，当操作使用的内存溢出时转为磁盘操作；<br>12）允许在where子句中使用子查询；<br>13）允许增量统计——只在新数据或改变的数据上执行统计计算；<br>14）支持maps、structs、arrays上的复杂嵌套查询；<br>15）可以使用impala插入或更新HBase。</p></blockquote><p><strong>优点：</strong></p><blockquote><p>1）支持SQL查询，快速查询大数据；<br>2）可以对已有数据进行查询，减少数据的加载，转换；<br>3）多种存储格式可以选择（Parquet, Text, Avro, RCFile, SequeenceFile）；<br>4）可以与Hive配合使用。</p></blockquote><p><strong>缺点：</strong></p><blockquote><p>1）不支持用户定义函数UDF；<br>2）不支持text域的全文搜索；<br>3）不支持Transforms；<br>4）不支持查询期的容错；<br>5）对内存要求高。</p></blockquote><h3 id="3-6-Hawq"><a href="#3-6-Hawq" class="headerlink" title="3.6 Hawq"></a>3.6 Hawq</h3><p><a href="http://hawq.apache.org" target="_blank" rel="noopener">HAWQ</a> 是Pivotal公司开源的一个Hadoop原生大规模并行SQL分析引擎，针对的是分析型应用。Apache HAWQ 采用主从（Master-Slave）的改进MPP架构，通过将MPP与批处理系统有效的结合，克服了MPP的一些关键的限制问题，如短板效应、并发限制、扩展性等。其整体架构与Pivotal另一开源MPP数据库Greenplum比较相似。</p><p>下图提供了典型 HAWQ 部署的高级架构视图<br><img src="/2021/11/30/olap-ru-he-xuan-xing/%E5%9B%BE%E7%89%877.png" alt="图片7"></p><p>下图提供了构成 HAWQ 的软件组件的另一种视图<br><img src="/2021/11/30/olap-ru-he-xuan-xing/%E5%9B%BE%E7%89%876.png" alt="图片6"></p><p>HAWQ Master节点内部有以下几个重要组件：</p><blockquote><p>1）<strong>查询解析器（Parser/Analyzer）</strong>，负责解析查询，并检查语法及语义。最终生成查询树传递给优化器。<br>2）<strong>优化器（Optimizer）</strong>，负责接受查询树，生成查询计划。针对一个查询，可能有数亿个可能的等价的查询计划，但执行性能差异很大。优化器的做用是找出优化的查询计划。<br>3）<strong>资源管理器（Resource Manager）</strong>，资源管理器经过资源代理向全局资源管理器（好比YARN）动态申请资源。并缓存资源。在不须要的时候返回资源。<br>4）<strong>HDFS元数据缓存（HDFS Catalog Cache）</strong>，用于HAWQ确定哪些Segment扫描表的哪些部分。HAWQ是把计算派发到数据所在的地方。因此要匹配计算和数据的局部性。如果每一个查询都访问HDFS NameNode会形成NameNode的瓶颈。因此在HAWQ Master节点上创建了HDFS元数据缓存。<br>5）<strong>容错服务（Fault Tolerance Service）</strong>，负责检测哪些节点可用，哪些节点不可用。不可用的机器会被排除出资源池。<br>6）<strong>查询派遣器（Dispatcher）</strong>，优化器优化完查询之后，查询派遣器派遣计划到各个节点上执行，并协调查询执行的整个过程。查询派遣器是整个并行系统的粘合剂。<br>7）<strong>元数据服务（Catalog Service）</strong>，负责存储HAWQ的各类元数据，包括数据库和表信息，以及访问权限信息等。另外，元数据服务也是实现分布式事务的关键。<br>8）其余节点为Slave节点，每一个Slave节点上部署有HDFS DataNode，YARN NodeManager以及一个HAWQ Segment。HAWQ Segment在执行查询的时候会启动多个QE (Query Executor, 查询执行器)。查询执行器运行在资源容器里面。节点间数据交换经过Interconnect（高速互联网络）进行。</p></blockquote><p><strong>优点：</strong></p><blockquote><p>1）对SQL标准的完善支持：ANSI SQL标准，OLAP扩展，标准JDBC/ODBC支持；<br>2）支持ACID事务特性：这是很多现有基于Hadoop的SQL引擎做不到的，对保证数据一致性很重要；<br>3）动态数据流引擎：基于UDP的高速互联网络；<br>4）多种UDF（用户自定义函数）语言支持：java, python, c/c++, perl, R等；<br>5）动态扩容：动态按需扩容，按照存储大小或者计算需求，秒级添加节点；<br>6）支持MADlib机器学习。</p></blockquote><p><strong>缺点：</strong></p><blockquote><p>1）基于GreenPlum实现，技术实现复杂，包含多个组件。比如对于外部数据源，需要通过PXF单独进行处理；<br>2）C++实现，对内存的控制比较复杂，如果出现segmentfault直接导致当前node挂掉；<br>3）安装配置复杂。</p></blockquote><h3 id="3-7-Presto"><a href="#3-7-Presto" class="headerlink" title="3.7 Presto"></a>3.7 Presto</h3><p><a href="https://prestodb.io/" target="_blank" rel="noopener">Presto</a> 是由 Facebook 推出的一个基于Java开发的开源分布式SQL查询引擎，数据量支持GB到TB字节，presto本身不存数据，但是可以接入很多数据源，它使得用SQL访问任何数据源成为可能，而且支持跨数据源的级联查询。你可以使用Presto通过水平扩展查询处理的方式来查询大型数据集。</p><p>Presto相比ClickHouse优点主要是多表join效果好。相比ClickHouse的支持功能简单，场景支持单一，Presto支持复杂的查询，应用范围更广。</p><p><img src="/2021/11/30/olap-ru-he-xuan-xing/%E5%9B%BE%E7%89%878.png" alt="图片8"></p><p>Presto采用典型的Master-Slave架构：</p><blockquote><p>1）<strong>coordinator</strong>：是presto集群的master节点。负责解析SQL语句，生成执行计划，分发执行任务给Worker节点执行；<br>2）<strong>worker</strong>：是执行任务的节点。负责实际查询任务的计算和读写；<br>3）<strong>discovery service</strong>：是将coordinator和worker结合在一起服务。worker节点启动后向discovery service服务注册，coordinator通过discovery service获取注册的worker节点；<br>4）<strong>connector</strong>：presto以插件形式对数据存储层进行了抽象，即connector。可通过connector连接多种数据源，提取数据。</p></blockquote><p>discovery service 将coordinator和worker结合在一起服务； worker节点启动后向discovery service服务注册 coordinator通过discovery service获取注册的worker节点。</p><p><strong>优点：</strong></p><blockquote><p>1）基于内存运算，减少没必要的硬盘IO；<br>2）都能够处理PB级别的海量数据分析；（虽然能够处理PB级别的海量数据分析，但不是代表Presto把PB级别都放在内存中计算的。而是根据场景，如count，avg等聚合运算，是边读数据边计算，再清内存，再读数据再计算，这种耗的内存并不高。）<br>3）能够连接多个数据源，跨数据源关联查询；<br>4）清晰的架构，是一个能够独立运行的系统，不依赖于任何其他外部系统。部署简单。</p></blockquote><p><strong>缺点：</strong></p><blockquote><p>1）不适合多个大表的join操作，因为presto是基于内存的，太多数据内存放不下的；<br>2）Presto的一个权衡是不关心中间查询容错。如果其中一个Presto工作节点出现故障（例如，关闭），则大多数情况下正在进行的查询将中止并需要重新启动。</p></blockquote><h3 id="3-8-Drill"><a href="#3-8-Drill" class="headerlink" title="3.8 Drill"></a>3.8 Drill</h3><p><a href="https://drill.apache.org/" target="_blank" rel="noopener">Drill</a> 是MapR开源的一个低延迟的大数据集的分布式SQL查询引擎，是谷歌Dremel的开源实现。它支持对本地文件、HDFS、HBASE等数据进行数据查询，也支持对如JSON等schema-free的数据进行查询。</p><p><img src="/2021/11/30/olap-ru-he-xuan-xing/%E5%9B%BE%E7%89%879.png" alt="图片9"></p><p>从架构上看，与同是源自Dremel的Impala比较类似。Drill的核心是DrillBit，它主要负责接收客户端的请求，处理查询，并将结果返回给客户端。 Drill的查询流程包括以下步骤：</p><blockquote><p>1）Drill客户端发起查询，任意DrilBit都可以接受来自客户端的查询；<br>2）收到请求的DrillBit成为<strong>驱动节点（Foreman）</strong>，对查询进行分析优化生成执行计划，之后将执行计划划分成各个<strong>片段（Fragment）</strong>，并确定合适的节点来执行；<br>3）各个节点执行查询片段（Fragment），并将结果返回给驱动节点；<br>4）驱动节点将结果返回给客户端。</p></blockquote><p><strong>优点：</strong></p><blockquote><p>1）几乎可以查询任何类型的NoSQL数据库（包含 Hbase、MongoDB、ElasticSearch、Cassandra、Druid、Kudu、Kafka、OpenTSDB、HDFS、Amazon S3、Azure Blob Storage、Google Cloud Storage、Swift、NAS和本地文件。可以在单次查询中组合多个数据源（联邦查询）。）；<br>2）在处理数据之前，无需加载数据、创建和维护模式或转换数据。相反，只需在 SQL 查询中包含 Hadoop 目录、MongoDB 集合或 S3 存储桶的路径；<br>3）Drill 是唯一支持复杂数据的列式查询引擎。它具有用于复杂数据的内存切碎柱状表示，这使 Drill 能够通过内部 JSON 文档模型的灵活性实现柱状速度；<br>4）可以使用 Tableau、Qlik、MicroStrategy、Spotfire、SAS 和 Excel 等标准 BI/分析工具；<br>5）Drill 的对称架构（所有节点都相同）和简单的安装使得部署和扩展集群变得容易；<br>6）Drill 不是世界上第一个查询引擎，但它是第一个兼具灵活性和速度的查询引擎。为了实现这一点，Drill 具有完全不同的架构，可以在不牺牲 JSON 文档模型提供的灵活性的情况下实现破纪录的性能。</p></blockquote><p><strong>缺点：</strong></p><blockquote><p>1） drill语法和常规sql有区别,一般是如 <code>select * from 插件名.表名</code> 的形式。主要是因为drill查询不同数据源时需要切换不同的插件；<br>2）技术线太长，不容易切合到实际生产线上去；<br>3）国内使用较少，没有大型成功案例，不够大众化，出现问题可能维护起来比较困难。资料比较少。</p></blockquote><h3 id="3-9-Hive"><a href="#3-9-Hive" class="headerlink" title="3.9 Hive"></a>3.9 Hive</h3><p><a href="https://hive.apache.org/" target="_blank" rel="noopener">Hive</a> 是一个构建于Hadoop顶层的数据仓库工具。定义了简单的类似SQL 的查询语言——HiveQL，可以将HiveQL查询转换为MapReduce 的任务在Hadoop集群上执行。</p><p><img src="/2021/11/30/olap-ru-he-xuan-xing/%E5%9B%BE%E7%89%8710.png" alt="图片10"></p><p>hdfs可以将结构化的数据文件映射为一张数据库表，并提供完整的sql查询功能，可以将sql语句转换为MapReduce任务进行运行。其优点是学习成本低，可以通过类SQL语句快速实现简单的MapReduce统计，不必开发专门的MapReduce应用，十分适合数据仓库的统计分析。</p><p>对于Hive主要针对的是OLAP应用，其底层是HDFS分布式文件系统，HDFS一般只用于查询分析统计，而不能是常见的CUD操作，Hive需要从已有的数据库或日志进行同步最终入到HDFS文件系统中，当前要做到增量实时同步都相当困难。</p><p><strong>优点：</strong></p><blockquote><p>1）<strong>高可靠、高容错：</strong>HiveServer采用集群模式，双MetaStor，超时重试机制；<br>2）<strong>类SQL：</strong>类似SQL语法，内置大量函数；<br>3）<strong>可扩展：</strong>自定义存储格式，自定义函数；<br>4）<strong>多接口：</strong>Beeline，JDBC，ODBC，Python，Thrift。</p></blockquote><p><strong>缺点：</strong></p><blockquote><p>1）<strong>延迟较高：</strong>默认MR为执行引擎，MR延迟较高；<br>2）<strong>不支持物化视图：</strong>Hive支持普通视图，不支持物化视图。Hive不能再视图上更新、插入、删除数据；<br>3）<strong>不适用OLTP：</strong>暂不支持列级别的数据添加、更新、删除操作。</p></blockquote><h3 id="3-10-Spark-SQL"><a href="#3-10-Spark-SQL" class="headerlink" title="3.10 Spark SQL"></a>3.10 Spark SQL</h3><p><a href="https://spark.apache.org/sql/" target="_blank" rel="noopener">Spark SQL</a> 的前身是Shark，它将 SQL 查询与 Spark 程序无缝集成，可以将结构化数据作为 Spark 的 RDD 进行查询。Spark SQL作为Spark生态的一员继续发展，而不再受限于Hive，只是兼容Hive。</p><p>Spark SQL提供了sql访问和API访问的接口。支持访问各式各样的数据源，包括Hive, Avro, Parquet, ORC, JSON 和 JDBC。</p><p>Spark SQL与传统 DBMS 的查询优化器 + 执行器的架构较为类似，只不过其执行器是在分布式环境中实现，并采用的 Spark 作为执行引擎：</p><p><img src="/2021/11/30/olap-ru-he-xuan-xing/%E5%9B%BE%E7%89%8711.png" alt="图片11"></p><p>SparkSQL的架构图如下：</p><p><img src="/2021/11/30/olap-ru-he-xuan-xing/%E5%9B%BE%E7%89%8712.png" alt="图片12"></p><p><strong>优点：</strong></p><blockquote><p>1）支持多种数据源；<br>2）易整合，有各种API；<br>3）兼容HiveQL。</p></blockquote><p><strong>缺点：</strong></p><blockquote><p>1）查询性能不高；<br>2）以thrift server方式提供的SparkSQL服务不支持多种数据源，必须使用DataFrame API。</p></blockquote><h2 id="四、各组件性能对比"><a href="#四、各组件性能对比" class="headerlink" title="四、各组件性能对比"></a>四、各组件性能对比</h2><p>测试数据来源于：<a href="http://www.clickhouse.com.cn/topic/5c453371389ad55f127768ea" target="_blank" rel="noopener">开源OLAP引擎测评报告</a>。通过测试以及相关调研编写了各组件各个方面的综合对比分析表，这里采用5分为满分来比较，如下表所示：</p><p><img src="/2021/11/30/olap-ru-he-xuan-xing/%E5%9B%BE%E7%89%8713.png" alt="图片13"></p><ol><li>SparkSQL是Hadoop中另一个著名的SQL引擎，它以Spark作为底层计算框架，Spark使用RDD作为分布式程序的工作集合，它提供一种分布式共享内存的受限形式。在分布式共享内存系统中，应用可以向全局地址空间的任意位置进行读写作，而RDD是只读的，对其只能进行创建、转化和求值等作。这种内存操作大大提高了计算速度。SparkSql的性能相对其他的组件要差一些，多表单表查询性能都不突出。</li><li>Impala官方宣传其计算速度是一大优点，在实际测试中我们也发现它的多表查询性能和presto差不多，但是单表查询方面却不如presto好。而且Impala有很多不支持的地方，例如：不支持update、delete操作，不支持Date数据类型，不支持ORC文件格式等等，所以我们查询时采用parquet格式进行查询，而且Impala在查询时占用的内存很大。</li><li>Presto综合性能比起来要比其余组件好一些，无论是查询性能还是支持的数据源和数据格式方面都要突出一些，在单表查询时性能靠前，多表查询方面性能也很突出。由于Presto是完全基于内存的并行计算，所以presto在查询时占用的内存也不少，但是发现要比Impala少一些，比如多表join需要很大的内存，Impala占用的内存比presto要多。</li><li>HAWQ 吸收了先进的基于成本的 SQL 查询优化器，自动生成执行计划，可优化使用hadoop 集群资源。HAWQ 采用 Dynamic pipelining 技术解决这一关键问题。Dynamic pipelining 是一种并行数据流框架，利用线性可扩展加速Hadoop查询，数据直接存储在HDFS上，并且其SQL查询优化器已经为基于HDFS的文件系统性能特征进行过细致的优化。但是我们发现HAWQ在多表查询时比Presto、Impala差一些；而且不适合单表的复杂聚合操作，单表测试性能方面要比其余四种组件差很多，hawq环境搭建也遇到了诸多问题。</li><li>ClickHouse 作为目前所有开源MPP计算框架中计算速度最快的，它在做多列的表，同时行数很多的表的查询时，性能是很让人兴奋的，但是在做多表的join时，它的性能是不如单宽表查询的。性能测试结果表明ClickHouse在单表查询方面表现出很大的性能优势，但是在多表查询中性能却比较差，不如presto、impala、hawq的效果好。</li><li>GreenPlum作为关系型数据库产品，它的特点主要就是查询速度快，数据装载速度快，批量DML处理快。而且性能可以随着硬件的添加，呈线性增加，拥有非常良好的可扩展性。因此，它主要适用于面向分析的应用。比如构建企业级ODS/EDW，或者数据集市等，GREENPLUM都是不错的选择。</li></ol><p><strong>OLAP大混战对比分析：</strong> 仅供参考</p><table><thead><tr><th>引擎/对比项目</th><th>Kylin</th><th>Presto</th><th>Impala</th><th>Druid</th><th>SpaqkSql</th><th>ElasticSearch</th><th>Kudu</th><th>ClickHouse</th><th>Doris</th><th>TiDB</th><th>Hive</th><th>Greenplum</th><th>SnappyData</th><th>Hawq</th></tr></thead><tbody><tr><td>亚秒级响应</td><td>Y</td><td>N</td><td>Y</td><td>Y</td><td>N</td><td>N</td><td>Y（据说可以到达秒级）</td><td>单表查询Y，多表查询N</td><td>Y（ms-s性能高于Kylin‘）</td><td>N</td><td>N</td><td>Y</td><td>Y</td><td>N</td></tr><tr><td>高并发</td><td>Y</td><td>N</td><td>Y</td><td>Y</td><td>N</td><td>N</td><td>Y</td><td>N</td><td>N</td><td>Y</td><td>Y</td><td>N</td><td>Y</td><td>Y</td></tr><tr><td>百亿数据集</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td></td><td>Y</td><td>Y</td><td>N</td><td>N</td><td>Y</td><td></td></tr><tr><td>SQL支持</td><td>Y</td><td>Y</td><td>Y</td><td>N（开发中）</td><td>Y</td><td>N</td><td>Y（结合Impala可支持SQL查询）</td><td>Y（支持Sql中基本语法对于开窗函数还不支持）</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>离线</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>实时</td><td>N（开发中，目前主要支持Kafka 流构建 Cube）</td><td>N</td><td>N</td><td>Y</td><td>N</td><td>Y</td><td>Y（Spark Streaming）</td><td>Y（实时数据分析领域的黑马）</td><td>Y</td><td>Y</td><td>N</td><td>N</td><td>Y</td><td>N</td></tr><tr><td>精准去重能力</td><td>Y</td><td>Y</td><td>Y</td><td>N</td><td>Y</td><td>N</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>是否支持明细查询</td><td>N</td><td>Y</td><td>N</td><td>N</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>多表join</td><td>Y</td><td>Y</td><td>Y</td><td>N</td><td>Y</td><td>N</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>能否更改模型</td><td>N</td><td>Y</td><td>N</td><td>N</td><td>Y</td><td>N</td><td>Y</td><td>Y（更换表引擎）</td><td>N</td><td>Y</td><td>Y</td><td>N</td><td>Y</td><td>未知</td></tr><tr><td>JDBC/ODBC for BI集成</td><td>Y</td><td>Y</td><td>N</td><td>N</td><td>Y</td><td>N</td><td>Y</td><td>N</td><td>Y</td><td>Y</td><td>Y</td><td>N</td><td>Y</td><td>Y</td></tr><tr><td>WEB GUI</td><td>Y</td><td>Y</td><td>Y</td><td>N</td><td>N</td><td>N</td><td>Y</td><td>Y</td><td>N</td><td>Y</td><td>N</td><td>未知</td><td>未知</td><td>Y</td></tr><tr><td>REST API</td><td>Y</td><td>N</td><td>Y</td><td>N</td><td>N</td><td>Y</td><td>N</td><td>N</td><td>N</td><td>N</td><td>N</td><td>未知</td><td>N</td><td>N</td></tr><tr><td>社区活跃度</td><td>活跃</td><td>活跃</td><td>活跃</td><td>活跃</td><td>活跃</td><td>活跃</td><td>较活跃</td><td>不太活跃</td><td>Doris社区刚刚起步，目前核心用户只有Baidu；</td><td>较活跃</td><td>活跃</td><td>活跃</td><td>较活跃</td><td>较活跃</td></tr><tr><td>存储能力</td><td>shared nothing</td><td>shared nothing</td><td>纯计算</td><td>shared nothing</td><td>无</td><td>计算+存储</td><td>列式存储</td><td>计算+存储</td><td>计算+存储</td><td>计算+存储</td><td>存储到HDFS</td><td>计算+存储</td><td>shared</td><td>noting</td></tr><tr><td>成本</td><td>中</td><td>中</td><td>中（CDH据说要收费收费以后可能会提高）</td><td>中</td><td>低</td><td>中</td><td>中</td><td>高</td><td>中</td><td>中</td><td>低</td><td>未知</td><td>高</td><td>中</td></tr><tr><td>易用性</td><td>安装简单快捷，轻量级，简单，选择维度表和度量即可构建Cube</td><td>安装简单，基于内存，查询代价较大</td><td>部署简单，基于内存，查询代价较大</td><td>部署简单，基于内存</td><td>部署简单</td><td>部署较简单，但是难用目前发展趋向于专人专岗</td><td>部署简单，需要开发门槛较高，基于磁盘</td><td>简单易用</td><td>按装复杂</td><td>安装部署较为复杂</td><td>部署较简单</td><td>未知</td><td>未知</td><td>部署比较复杂</td></tr><tr><td>监控成本</td><td>自带监控组件、运维成本低</td><td>有公共web监控管理</td><td>自带监控组件，运维成本低</td><td>自带监控可配置，有web页面</td><td>自带监控</td><td>可以使用Kibana实现，成本较高</td><td>已经集成到CDH中，便于监控</td><td>自身具有简单的监控组件，可以联合其他的监控工具进行监控</td><td>监控的集中到Prometheus</td><td>使用开源的 metric 分析及可视化系统Grafana 进行监控</td><td>没有自带的监控，但是在阿里云有配合hive的监控，成本高</td><td>未知</td><td>运维成本高</td><td>支持多种工具监控</td></tr></tbody></table><h2 id="五、选型的一些建设"><a href="#五、选型的一些建设" class="headerlink" title="五、选型的一些建设"></a>五、选型的一些建设</h2><p>上面给出了常用的一些OLAP引擎，它们各自有各自的特点，我们将其分组：</p><ul><li>Hive，Hawq，Impala - 基于SQL on Hadoop；</li><li>Presto和Spark SQL类似 - 基于内存解析SQL生成执行计划；</li><li>Kylin 用空间换时间，预计算；</li><li>Druid 一个支持数据的实时摄入；</li><li>ClickHouse OLAP领域的Hbase，单表查询性能优势巨大；</li><li>Greenpulm OLAP领域的Postgresql。</li></ul><p>如果你的场景是基于HDFS的离线计算任务，那么Hive，Hawq和Imapla就是你的调研目标；<br>如果你的场景解决分布式查询问题，有一定的实时性要求，那么Presto和Spark SQL可能更符合你的期望；<br>如果你的汇总维度比较固定，实时性要求较高，可以通过用户配置的维度+指标进行预计算，那么不妨尝试Kylin和Druid；<br>ClickHouse则在单表查询性能上独领风骚，远超过其他的OLAP数据库；<br>Greenpulm作为关系型数据库产品，性能可以随着集群的扩展线性增长，更加适合进行数据分析。</p><p>就像美团在调研Kylin的报告中所说的：</p><p>目前还没有一个OLAP系统能够满足各种场景的查询需求。<br>其本质原因是，没有一个系统能同时在数据量、性能、和灵活性三个方面做到完美，每个系统在设计时都需要在这三者间做出取舍。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Nov 08 2022 22:51:11 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;一、OLAP-简介&quot;&gt;&lt;a href=&quot;#一、OLAP-简介&quot; class=&quot;headerlink&quot; title=&quot;一、OLAP 简介
      
    
    </summary>
    
    
      <category term="Hadoop" scheme="http://chenzhonzhou.github.io/categories/Hadoop/"/>
    
    
      <category term="Hadoop" scheme="http://chenzhonzhou.github.io/tags/Hadoop/"/>
    
      <category term="OLAP" scheme="http://chenzhonzhou.github.io/tags/OLAP/"/>
    
  </entry>
  
</feed>
