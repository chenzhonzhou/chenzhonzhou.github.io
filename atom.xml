<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://chenzhonzhou.github.io/"/>
  <updated>2019-10-24T02:39:25.308Z</updated>
  <id>http://chenzhonzhou.github.io/</id>
  
  <author>
    <name>Zhongzhou Chen</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>hexo使用next主题菜单问题</title>
    <link href="http://chenzhonzhou.github.io/2019/10/23/hexo-shi-yong-next-zhu-ti-cai-dan-tu-biao-wen-ti/"/>
    <id>http://chenzhonzhou.github.io/2019/10/23/hexo-shi-yong-next-zhu-ti-cai-dan-tu-biao-wen-ti/</id>
    <published>2019-10-23T03:05:15.000Z</published>
    <updated>2019-10-24T02:39:25.308Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Oct 24 2019 10:39:36 GMT+0800 (GMT+08:00) --><p>nexo主题的简洁我个人非常喜欢，但在使用过程中当我按文档部署添加菜单后页面显示如下</p><p><img src="E:%5Caaa%5Cgit_frier%5Cchenzhonzhou.github.io%5Cpublic%5Cimages%5Cnexo%5Cimage-20191024103850041.png" alt="image-20191024103850041"></p><p>可以看到菜单显示正常，当我点开某个菜单后显示 <strong>Cannot GET /tags%20/</strong></p><p><img src="E:%5Caaa%5Cgit_frier%5Cchenzhonzhou.github.io%5Cpublic%5Cimages%5Cnexo%5C1571883139114.png" alt="1571883139114"></p><p>在网上找了很多文档都是如下配置，打开 <strong><em>主题配置文件\</em></strong> 找到<code>Menu Settings</code></p><pre class=" language-cpp"><code class="language-cpp">menu<span class="token operator">:</span>  home<span class="token operator">:</span> <span class="token operator">/</span> <span class="token operator">||</span> home                          <span class="token comment" spellcheck="true">//首页</span>  archives<span class="token operator">:</span> <span class="token operator">/</span>archives<span class="token operator">/</span> <span class="token operator">||</span> archive          <span class="token comment" spellcheck="true">//归档</span>  categories<span class="token operator">:</span> <span class="token operator">/</span>categories<span class="token operator">/</span> <span class="token operator">||</span> th           <span class="token comment" spellcheck="true">//分类</span>  tags<span class="token operator">:</span> <span class="token operator">/</span>tags<span class="token operator">/</span> <span class="token operator">||</span> tags                     <span class="token comment" spellcheck="true">//标签</span>  about<span class="token operator">:</span> <span class="token operator">/</span>about<span class="token operator">/</span> <span class="token operator">||</span> user                   <span class="token comment" spellcheck="true">//关于</span>  <span class="token macro property">#schedule: /schedule/ || calendar        </span><span class="token comment" spellcheck="true">//日程表</span>  <span class="token macro property">#sitemap: /sitemap.xml || sitemap        </span><span class="token comment" spellcheck="true">//站点地图</span>  <span class="token macro property">#commonweal: /404/ || heartbeat          </span><span class="token comment" spellcheck="true">//公益404</span></code></pre><p>让我们再回顾一下新建菜单的过程，注意看第三步：</p><p>例如，在<code>[Hexo+Next]</code>主题下新增一个资源分类页面。</p><h4 id="1-新建一个页面，命名为tags。"><a href="#1-新建一个页面，命名为tags。" class="headerlink" title="1.新建一个页面，命名为tags。"></a>1.新建一个页面，命名为tags。</h4><pre class=" language-sh">hexo new page tags</code></pre><blockquote><p>此时会在hexo &gt; source文件夹中会生成一个tag文件夹。</p></blockquote><h4 id="2-编辑tags文件夹下的md页面"><a href="#2-编辑tags文件夹下的md页面" class="headerlink" title="2.编辑tags文件夹下的md页面"></a>2.编辑tags文件夹下的<code>md</code>页面</h4><p>将类型设置为tags，主题将自动为这个页面显示所有分类，<strong>别忘添加layout项</strong>。</p><pre><code class="bash"><code class="language-sh">hexo new page tags</code></pre><blockquote><p>此时会在hexo &gt; source文件夹中会生成一个tag文件夹。</p></blockquote><h4 id="2-编辑tags文件夹下的md页面"><a href="#2-编辑tags文件夹下的md页面" class="headerlink" title="2.编辑tags文件夹下的md页面"></a>2.编辑tags文件夹下的<code>md</code>页面</h4><p>将类型设置为tags，主题将自动为这个页面显示所有分类，<strong>别忘添加layout项</strong>。</p><pre><code class="bash">title: 常用工具date: 2017-12-14 13:05:38type: "tags"layout: tags---</code></pre><p>注意：如果有启用评论，默认页面也会带有评论。需要关闭的话，请添加字段<code>comments</code>并将值设置为<code>false</code>，如：</p><pre class=" language-bash"><code class="language-bash">title: 常用工具date: 2017-12-14 13:05:38type: <span class="token string">"tags"</span>layout: tagscomments: <span class="token boolean">false</span>---</code></pre><h4 id="3-在菜单中添加链接"><a href="#3-在菜单中添加链接" class="headerlink" title="3.在菜单中添加链接"></a>3.在菜单中添加链接</h4><p>编辑主题的<code>_config.yml</code>，在<code>menu</code>中的添加如下:</p><pre class=" language-ruby"><code class="language-ruby">menu<span class="token punctuation">:</span>  home<span class="token punctuation">:</span> <span class="token operator">/</span><span class="token operator">||</span> home                          <span class="token operator">/</span><span class="token operator">/</span>首页  archives<span class="token punctuation">:</span> <span class="token operator">/</span>archives<span class="token operator">/</span><span class="token operator">||</span> archive          <span class="token operator">/</span><span class="token operator">/</span>归档  categories<span class="token punctuation">:</span> <span class="token operator">/</span>categories<span class="token operator">/</span><span class="token operator">||</span> th           <span class="token operator">/</span><span class="token operator">/</span>分类  tags<span class="token punctuation">:</span> <span class="token operator">/</span>tags<span class="token operator">/</span><span class="token operator">||</span> tags                     <span class="token operator">/</span><span class="token operator">/</span>标签  about<span class="token punctuation">:</span> <span class="token operator">/</span>about<span class="token operator">/</span><span class="token operator">||</span> user                   <span class="token operator">/</span><span class="token operator">/</span>关于  <span class="token comment" spellcheck="true">#schedule: /schedule/ || calendar        //日程表</span>  <span class="token comment" spellcheck="true">#sitemap: /sitemap.xml || sitemap        //站点地图</span>  <span class="token comment" spellcheck="true">#commonweal: /404/ || heartbeat          //公益404</span></code></pre><blockquote><p><code>||</code>之前的值是目标链接，之后的是分类页面的图标，图标名称来自于<a href="http://fontawesome.io/icons/" target="_blank" rel="noopener">FontAwesome icon</a>。若没有配置图标，默认会使用问号图标。</p><p>注意：这里的配置在原文中||前面是有空格的，也正是如此我前面点击菜单才会出现<strong>Cannot GET /tags%20/</strong>，当我把||前面的空格去掉后就好了。</p></blockquote><h4 id="4-新添加的菜单需要翻译对应的中文"><a href="#4-新添加的菜单需要翻译对应的中文" class="headerlink" title="4.新添加的菜单需要翻译对应的中文"></a>4.新添加的菜单需要翻译对应的中文</h4><p>打开<code>hexo&gt;theme&gt;next&gt;languages&gt;zh-Hans.yml</code>，在menu下添加：</p><pre class=" language-undefined"><code class="language-undefined">menu:  home: 首页  archives: 归档  categories: 分类  tags: 标签  about: 关于  search: 搜索  schedule: 日程表  sitemap: 站点地图  commonweal: 公益404  resources: 资源</code></pre><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Oct 24 2019 10:39:36 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;nexo主题的简洁我个人非常喜欢，但在使用过程中当我按文档部署添加菜单后页面显示如下&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;E:%5Caaa%5Cgi
      
    
    </summary>
    
    
      <category term="hexo" scheme="http://chenzhonzhou.github.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://chenzhonzhou.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>hexo 创建文章、标签、分类</title>
    <link href="http://chenzhonzhou.github.io/2019/10/22/hexo-chuang-jian-wen-zhang-biao-qian-fen-lei/"/>
    <id>http://chenzhonzhou.github.io/2019/10/22/hexo-chuang-jian-wen-zhang-biao-qian-fen-lei/</id>
    <published>2019-10-22T11:53:15.000Z</published>
    <updated>2019-10-24T02:01:29.491Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Oct 24 2019 10:39:36 GMT+0800 (GMT+08:00) --><h3 id="1、创建文章"><a href="#1、创建文章" class="headerlink" title="1、创建文章"></a>1、创建文章</h3><h5 id="1-1在hexo下创建一个新的文章"><a href="#1-1在hexo下创建一个新的文章" class="headerlink" title="1.1在hexo下创建一个新的文章"></a>1.1在hexo下创建一个新的文章</h5><pre><code> hexo new &quot;文章名称&quot; </code></pre><p>生成后会提示你文件路径，一般在hexo/source/_posts下</p><h5 id="1-2文章基本设置"><a href="#1-2文章基本设置" class="headerlink" title="1.2文章基本设置"></a>1.2文章基本设置</h5><pre><code>---title: yum安装dockerdate: 2019-10-22 19:01:24comments: true #是否可评论toc: true #是否显示文章目录categories: &quot;云服务器&quot; #分类tags:   #标签    - docker    - yum---</code></pre><h3 id="2、创建标签"><a href="#2、创建标签" class="headerlink" title="2、创建标签"></a>2、创建标签</h3><h5 id="2-1创建标签页面"><a href="#2-1创建标签页面" class="headerlink" title="2.1创建标签页面"></a>2.1创建标签页面</h5><pre><code>hexo new page tags</code></pre><h5 id="2-2基本设置"><a href="#2-2基本设置" class="headerlink" title="2.2基本设置"></a>2.2基本设置</h5><p>source/tags目录下index.md文件</p><pre><code>title: tagsdate: 2019-10-22 19:03:11type: &quot;tags&quot;layout: &quot;tags&quot;</code></pre><h3 id="3、创建分类"><a href="#3、创建分类" class="headerlink" title="3、创建分类"></a>3、创建分类</h3><h5 id="3-1创建分类页面"><a href="#3-1创建分类页面" class="headerlink" title="3.1创建分类页面"></a>3.1创建分类页面</h5><pre><code>hexo new page categories</code></pre><h5 id="3-2基本设置"><a href="#3-2基本设置" class="headerlink" title="3.2基本设置"></a>3.2基本设置</h5><p>source/categories目录下index.md文件</p><pre><code>title: categoriesdate: 2019-10-22 19:07:45type: &quot;categories&quot;layout: &quot;categories&quot;</code></pre><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Oct 24 2019 10:39:36 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;1、创建文章&quot;&gt;&lt;a href=&quot;#1、创建文章&quot; class=&quot;headerlink&quot; title=&quot;1、创建文章&quot;&gt;&lt;/a&gt;1、创
      
    
    </summary>
    
    
      <category term="hexo" scheme="http://chenzhonzhou.github.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://chenzhonzhou.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Prometheus部署+邮箱告警+企业微信告警+钉钉告警</title>
    <link href="http://chenzhonzhou.github.io/2019/03/01/prometheus-bu-shu-you-xiang-gao-jing-qi-ye-wei-xin-gao-jing-ding-ding-gao-jing/"/>
    <id>http://chenzhonzhou.github.io/2019/03/01/prometheus-bu-shu-you-xiang-gao-jing-qi-ye-wei-xin-gao-jing-ding-ding-gao-jing/</id>
    <published>2019-03-01T06:05:15.000Z</published>
    <updated>2019-10-23T04:57:38.480Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Oct 24 2019 09:58:29 GMT+0800 (GMT+08:00) --><h1 id="Prometheus部署-邮箱告警-企业微信告警-钉钉告警"><a href="#Prometheus部署-邮箱告警-企业微信告警-钉钉告警" class="headerlink" title="Prometheus部署+邮箱告警+企业微信告警+钉钉告警"></a>Prometheus部署+邮箱告警+企业微信告警+钉钉告警</h1><h5 id="1-部署Prometheus-server"><a href="#1-部署Prometheus-server" class="headerlink" title="1 部署Prometheus server"></a>1 部署Prometheus server</h5><h6 id="1-1-下载二进制包"><a href="#1-1-下载二进制包" class="headerlink" title="1.1 下载二进制包"></a>1.1 下载二进制包</h6><pre class=" language-ruby">$ wget https://github.com/prometheus/prometheus/releases/download/v2.12.0/prometheus-2.12.0.linux-amd64.tar.gz</code></pre><h6 id="1-2-解压并move至-work-admin目录下"><a href="#1-2-解压并move至-work-admin目录下" class="headerlink" title="1.2 解压并move至/work/admin目录下"></a>1.2 解压并move至/work/admin目录下</h6><pre><code class="ruby"><code class="language-ruby">$ wget https://github.com/prometheus/prometheus/releases/download/v2.12.0/prometheus-2.12.0.linux-amd64.tar.gz</code></pre><h6 id="1-2-解压并move至-work-admin目录下"><a href="#1-2-解压并move至-work-admin目录下" class="headerlink" title="1.2 解压并move至/work/admin目录下"></a>1.2 解压并move至/work/admin目录下</h6><pre><code class="ruby">$ tar zcvf prometheus-2.7.1.linux-amd64.tar.gz$ mv prometheus-2.7.1.linux-amd64 /work/admin/prometheus</code></pre><h6 id="1-3-配置并启动"><a href="#1-3-配置并启动" class="headerlink" title="1.3 配置并启动"></a>1.3 配置并启动</h6><pre class=" language-bash"><code class="language-bash">$ <span class="token function">cat</span> prometheus.ymlglobal:  scrape_interval:    15s <span class="token comment" spellcheck="true"># 默认抓取间隔, 15秒向目标抓取一次数据。</span>  evaluation_interval: 15s <span class="token comment" spellcheck="true"># Evaluate rules every 15 seconds. The default is every 1 minute.</span>  <span class="token comment" spellcheck="true"># scrape_timeout is set to the global default (10s).</span><span class="token comment" spellcheck="true"># Alertmanager configuration</span>alerting:  alertmanagers:  - static_configs:    - targets:      - <span class="token string">"localhost:9093"</span>      <span class="token comment" spellcheck="true"># - alertmanager:9093</span><span class="token comment" spellcheck="true"># Load rules once and periodically evaluate them according to the global 'evaluation_interval'.</span>rule_files:  - <span class="token string">"/usr/local/prometheus/rules/mysql*.rules"</span>  <span class="token comment" spellcheck="true"># - "first_rules.yml"</span>  <span class="token comment" spellcheck="true"># - "second_rules.yml"</span><span class="token comment" spellcheck="true"># A scrape configuration containing exactly one endpoint to scrape:</span><span class="token comment" spellcheck="true"># Here it's Prometheus itself.</span>scrape_configs:  <span class="token comment" spellcheck="true"># The job name is added as a label `job=&lt;job_name>` to any timeseries scraped from this config.</span>  - job_name: <span class="token string">'prometheus'</span>    <span class="token comment" spellcheck="true"># metrics_path defaults to '/metrics'</span>    <span class="token comment" spellcheck="true"># scheme defaults to 'http'.</span>    static_configs:    - targets: <span class="token punctuation">[</span><span class="token string">'localhost:9090'</span><span class="token punctuation">]</span>  - job_name: <span class="token string">'linux'</span>    static_configs:    - targets: <span class="token punctuation">[</span><span class="token string">'localhost:9101'</span><span class="token punctuation">]</span>      labels:        instance: node1  - job_name: <span class="token string">'mysql'</span>    static_configs:    - targets: <span class="token punctuation">[</span><span class="token string">'192.168.1.11:9104'</span><span class="token punctuation">]</span>      labels:        instance: db1$ /usr/local/prometheus/prometheus --config.file<span class="token operator">=</span>/usr/local/prometheus/prometheus.yml --storage.tsdb.path<span class="token operator">=</span>/var/lib/prometheus</code></pre><h5 id="2-部署node-exporter"><a href="#2-部署node-exporter" class="headerlink" title="2 部署node_exporter"></a>2 部署node_exporter</h5><h6 id="2-1-下载二进制包"><a href="#2-1-下载二进制包" class="headerlink" title="2.1 下载二进制包"></a>2.1 下载二进制包</h6><pre class=" language-ruby">$ wget https://github.com/prometheus/node_exporter/releases/download/v0.17.0/node_exporter-0.17.0.linux-amd64.tar.gz</code></pre><h6 id="2-2-解压并move至-usr-local-prometheus目录下"><a href="#2-2-解压并move至-usr-local-prometheus目录下" class="headerlink" title="2.2 解压并move至/usr/local/prometheus目录下"></a>2.2 解压并move至/usr/local/prometheus目录下</h6><pre><code class="ruby"><code class="language-ruby">$ wget https://github.com/prometheus/node_exporter/releases/download/v0.17.0/node_exporter-0.17.0.linux-amd64.tar.gz</code></pre><h6 id="2-2-解压并move至-usr-local-prometheus目录下"><a href="#2-2-解压并move至-usr-local-prometheus目录下" class="headerlink" title="2.2 解压并move至/usr/local/prometheus目录下"></a>2.2 解压并move至/usr/local/prometheus目录下</h6><pre><code class="ruby">$ tar zcvf node_exporter-0.17.0.linux-amd64.tar.gz$ mv node_exporter-0.17.0.linux-amd64 /usr/local/prometheus/node_exporter</code></pre><h6 id="2-3-启动"><a href="#2-3-启动" class="headerlink" title="2.3 启动"></a>2.3 启动</h6><pre class=" language-bash">$ /usr/local/prometheus/node_exporter/node_exporter --web.listen-address=:9100</code></pre><h5 id="3-部署mysqld-exporter"><a href="#3-部署mysqld-exporter" class="headerlink" title="3 部署mysqld_exporter"></a>3 部署mysqld_exporter</h5><h6 id="3-1-下载二进制包"><a href="#3-1-下载二进制包" class="headerlink" title="3.1 下载二进制包"></a>3.1 下载二进制包</h6><pre><code class="ruby">$ wget https://github.com/prometheus/mysqld_exporter/releases/download/v0.11.0/mysqld_exporter-0.11.0.linux-amd64.tar.gz</code></pre><h6 id="3-2-解压并move至-usr-local-prometheus目录下"><a href="#3-2-解压并move至-usr-local-prometheus目录下" class="headerlink" title="3.2 解压并move至/usr/local/prometheus目录下"></a>3.2 解压并move至/usr/local/prometheus目录下</h6><pre><code class="ruby"><code class="language-bash">$ /usr/local/prometheus/node_exporter/node_exporter --web.listen-address=:9100</code></pre><h5 id="3-部署mysqld-exporter"><a href="#3-部署mysqld-exporter" class="headerlink" title="3 部署mysqld_exporter"></a>3 部署mysqld_exporter</h5><h6 id="3-1-下载二进制包"><a href="#3-1-下载二进制包" class="headerlink" title="3.1 下载二进制包"></a>3.1 下载二进制包</h6><pre><code class="ruby">$ wget https://github.com/prometheus/mysqld_exporter/releases/download/v0.11.0/mysqld_exporter-0.11.0.linux-amd64.tar.gz</code></pre><h6 id="3-2-解压并move至-usr-local-prometheus目录下"><a href="#3-2-解压并move至-usr-local-prometheus目录下" class="headerlink" title="3.2 解压并move至/usr/local/prometheus目录下"></a>3.2 解压并move至/usr/local/prometheus目录下</h6><pre><code class="ruby">$ tar zcvf mysqld_exporter-0.11.0.linux-amd64.tar.gz$ mv mysqld_exporter-0.11.0.linux-amd64 /usr/local/prometheus/mysqld_exporter</code></pre><h6 id="3-3-为mysqld-exporter配置MySQL用户并授权，启动"><a href="#3-3-为mysqld-exporter配置MySQL用户并授权，启动" class="headerlink" title="3.3 为mysqld_exporter配置MySQL用户并授权，启动"></a>3.3 为mysqld_exporter配置MySQL用户并授权，启动</h6><pre class=" language-ruby"><code class="language-ruby">$ cat <span class="token punctuation">.</span>my<span class="token punctuation">.</span>cnf<span class="token punctuation">[</span>client<span class="token punctuation">]</span>user<span class="token operator">=</span>mysqld_exporterpassword<span class="token operator">=</span><span class="token number">000000</span>$ <span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span>prometheus<span class="token operator">/</span>mysqld_exporter<span class="token operator">/</span>mysqld_exporter <span class="token operator">--</span>config<span class="token punctuation">.</span>my<span class="token operator">-</span>cnf<span class="token operator">=</span><span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span>prometheus<span class="token regex">/mysqld_exporter/</span><span class="token punctuation">.</span>my<span class="token punctuation">.</span>cnf</code></pre><h5 id="4-部署alertmanager"><a href="#4-部署alertmanager" class="headerlink" title="4 部署alertmanager"></a>4 部署alertmanager</h5><h6 id="4-1-下载二进制包"><a href="#4-1-下载二进制包" class="headerlink" title="4.1 下载二进制包"></a>4.1 下载二进制包</h6><pre class=" language-ruby">$ wget https://github.com/prometheus/alertmanager/releases/download/v0.16.1/alertmanager-0.16.1.linux-amd64.tar.gz</code></pre><h6 id="4-2-解压并move至-usr-local-prometheus目录下"><a href="#4-2-解压并move至-usr-local-prometheus目录下" class="headerlink" title="4.2 解压并move至/usr/local/prometheus目录下"></a>4.2 解压并move至/usr/local/prometheus目录下</h6><pre><code class="ruby"><code class="language-ruby">$ wget https://github.com/prometheus/alertmanager/releases/download/v0.16.1/alertmanager-0.16.1.linux-amd64.tar.gz</code></pre><h6 id="4-2-解压并move至-usr-local-prometheus目录下"><a href="#4-2-解压并move至-usr-local-prometheus目录下" class="headerlink" title="4.2 解压并move至/usr/local/prometheus目录下"></a>4.2 解压并move至/usr/local/prometheus目录下</h6><pre><code class="ruby">$ tar zcvf alertmanager-0.16.1.linux-amd64.tar.gz$ mv alertmanager-0.16.1.linux-amd64 /usr/local/prometheus/alertmanager</code></pre><h6 id="4-3-修改配置文件并启动"><a href="#4-3-修改配置文件并启动" class="headerlink" title="4.3 修改配置文件并启动"></a>4.3 修改配置文件并启动</h6><pre class=" language-bash"><code class="language-bash">$ <span class="token function">cat</span> alertmanager.ymlglobal:  resolve_timeout: 5m  smtp_smarthost: <span class="token string">'smtp.163.com:25'</span> <span class="token comment" spellcheck="true"># 邮箱smtp服务器代理</span>  smtp_from: <span class="token string">'XXXXXX@163.com'</span> <span class="token comment" spellcheck="true"># 发送邮箱名称</span>  smtp_auth_username: <span class="token string">'XXXXX@163.com'</span> <span class="token comment" spellcheck="true"># 邮箱名称</span>  smtp_auth_password: <span class="token string">'XXXXXXXX'</span> <span class="token comment" spellcheck="true"># 邮箱密码或授权码</span>templates:  - <span class="token string">'template/*.tmpl'</span>route:  group_by: <span class="token punctuation">[</span><span class="token string">'alertname'</span><span class="token punctuation">]</span>  group_wait: 10s  group_interval: 10s  repeat_interval: 24h  receiver: <span class="token string">'ops_dingding'</span>receivers:  - name: <span class="token string">'email'</span>    email_configs:    - to: <span class="token string">'XXXXX@163.com'</span>  <span class="token comment" spellcheck="true"># 接收警报的email配置</span>      html: <span class="token string">'{{ template "test.html" . }}'</span> <span class="token comment" spellcheck="true"># 设定邮箱的内容模板</span>      headers: <span class="token punctuation">{</span> Subject: <span class="token string">"[WARN] 报警邮件"</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true"># 接收邮件的标题</span>  - name: <span class="token string">'wechat'</span>    wechat_configs:    - corp_id: <span class="token string">'XXXXX'</span>      to_party: <span class="token string">'1'</span>      agent_id: <span class="token string">'1000002'</span>      api_secret: <span class="token string">'XXXXX'</span>  - name: <span class="token string">'ops_dingding'</span>    webhook_configs:    - url: <span class="token string">'http://localhost:8060/dingtalk/ops_dingding/send'</span>inhibit_rules:  - source_match:      severity: <span class="token string">'critical'</span>    target_match:      severity: <span class="token string">'warning'</span>    equal: <span class="token punctuation">[</span><span class="token string">'alertname'</span>, <span class="token string">'dev'</span>, <span class="token string">'instance'</span><span class="token punctuation">]</span>$ /usr/local/prometheus/alertmanager/alertmanager --config.file<span class="token operator">=</span>/usr/local/prometheus/alertmanager/alertmanager.yml</code></pre><h5 id="5-prometheus通过webhook推送告警至钉钉"><a href="#5-prometheus通过webhook推送告警至钉钉" class="headerlink" title="5 prometheus通过webhook推送告警至钉钉"></a>5 prometheus通过webhook推送告警至钉钉</h5><h6 id="5-1-添加钉钉机器人，获取webhook"><a href="#5-1-添加钉钉机器人，获取webhook" class="headerlink" title="5.1 添加钉钉机器人，获取webhook"></a>5.1 添加钉钉机器人，获取webhook</h6><p>参考 <a href="https://open-doc.dingtalk.com/docs/doc.htm?treeId=257&amp;articleId=105735&amp;docType=1" target="_blank" rel="noopener">https://open-doc.dingtalk.com/docs/doc.htm?treeId=257&amp;articleId=105735&amp;docType=1</a></p><h6 id="5-2-下载插件（二进制文件）"><a href="#5-2-下载插件（二进制文件）" class="headerlink" title="5.2 下载插件（二进制文件）"></a>5.2 下载插件（二进制文件）</h6><pre class=" language-ruby">$ wget https://github.com/timonwong/prometheus-webhook-dingtalk/releases/download/v0.3.0/prometheus-webhook-dingtalk-0.3.0.linux-amd64.tar.gz</code></pre><h6 id="5-3-解压并move至-usr-local-prometheus目录下"><a href="#5-3-解压并move至-usr-local-prometheus目录下" class="headerlink" title="5.3 解压并move至/usr/local/prometheus目录下"></a>5.3 解压并move至/usr/local/prometheus目录下</h6><pre><code class="ruby"><code class="language-ruby">$ wget https://github.com/timonwong/prometheus-webhook-dingtalk/releases/download/v0.3.0/prometheus-webhook-dingtalk-0.3.0.linux-amd64.tar.gz</code></pre><h6 id="5-3-解压并move至-usr-local-prometheus目录下"><a href="#5-3-解压并move至-usr-local-prometheus目录下" class="headerlink" title="5.3 解压并move至/usr/local/prometheus目录下"></a>5.3 解压并move至/usr/local/prometheus目录下</h6><pre><code class="ruby">$ tar zxvf prometheus-webhook-dingtalk-0.3.0.linux-amd64.tar.gz$ mv prometheus-webhook-dingtalk-0.3.0.linux-amd64/prometheus-webhook-dingtalk /usr/local/prometheus/alertmanager</code></pre><h6 id="5-4-编辑启动脚本（请替换为自己的webhook-URL-及-ding-profile）"><a href="#5-4-编辑启动脚本（请替换为自己的webhook-URL-及-ding-profile）" class="headerlink" title="5.4 编辑启动脚本（请替换为自己的webhook URL 及 ding.profile）"></a>5.4 编辑启动脚本（请替换为自己的webhook URL 及 ding.profile）</h6><pre class=" language-bash"><code class="language-bash">$ <span class="token function">cat</span> dingding_start.sh<span class="token function">nohup</span> /usr/local/prometheus/alertmanager/prometheus-webhook-dingtalk --ding.profile<span class="token operator">=</span><span class="token string">"ops_dingding=https://oapi.dingtalk.com/robot/send?access_token=XXXXXXX"</span>  2<span class="token operator">></span><span class="token operator">&amp;</span>1 1<span class="token operator">></span>/usr/local/prometheus/alertmanager/dingding.log <span class="token operator">&amp;</span>$ sh dingding_start.sh</code></pre><h6 id="5-5-编辑alertmanager-yml，增加web-hook配置并重启alertmanager"><a href="#5-5-编辑alertmanager-yml，增加web-hook配置并重启alertmanager" class="headerlink" title="5.5 编辑alertmanager.yml，增加web_hook配置并重启alertmanager"></a>5.5 编辑alertmanager.yml，增加web_hook配置并重启alertmanager</h6><pre class=" language-bash"><code class="language-bash">  - name: <span class="token string">'ops_dingding'</span>    webhook_configs:    - url: <span class="token string">'http://localhost:8060/dingtalk/ops_dingding/send'</span></code></pre><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Oct 24 2019 09:58:29 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;Prometheus部署-邮箱告警-企业微信告警-钉钉告警&quot;&gt;&lt;a href=&quot;#Prometheus部署-邮箱告警-企业微信告警-钉
      
    
    </summary>
    
    
      <category term="监控系统" scheme="http://chenzhonzhou.github.io/categories/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="prometheus" scheme="http://chenzhonzhou.github.io/categories/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/prometheus/"/>
    
    
      <category term="prometheus" scheme="http://chenzhonzhou.github.io/tags/prometheus/"/>
    
      <category term="监控系统" scheme="http://chenzhonzhou.github.io/tags/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>docker镜像、容器管理</title>
    <link href="http://chenzhonzhou.github.io/2018/09/05/docker-jing-xiang-rong-qi-guan-li/"/>
    <id>http://chenzhonzhou.github.io/2018/09/05/docker-jing-xiang-rong-qi-guan-li/</id>
    <published>2018-09-05T04:07:11.000Z</published>
    <updated>2019-10-23T02:18:04.501Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Oct 24 2019 09:58:29 GMT+0800 (GMT+08:00) --><h3 id="一、Docker简介"><a href="#一、Docker简介" class="headerlink" title="一、Docker简介"></a>一、Docker简介</h3><h5 id="Docker是什么"><a href="#Docker是什么" class="headerlink" title="Docker是什么?"></a>Docker是什么?</h5><p>Docker的英文本意是“搬运工”，在程序员的世界里，Docker搬运的是集装箱（Container），集装箱里装的是任意类型的App，开发者通过Docker可以将App变成一种标准化的、可移植的、自管理的组件，可以在任何主流系统中开发、调试和运行。</p><p>说白了,docker是一种用了新颖方式实现的轻量级虚拟机,类似于VM,但是在原理和应用上和VM的差别还是很大的.并且docker的专业叫法是应用容器(Application Container)。</p><p>为啥要用容器?<br>应用容器是个啥样子呢,一个做好的应用容器长得就像一个装好了一组特定应用的虚拟机一样,比如我现在想用mysql,那我就找个装好了mysql的容器就可以了,然后运行起来,我就能使用mysql了。</p><p>为啥不能直接安装一个mysql?安装一个SQL Server也可以啊,可是有的时候根据每个人电脑的不同,在安装的时候可能会报出各种各样的错误,万一你的机器中毒了,你的电脑挂了,你所有的服务都需要重新安装.但是有了docker,或者说有了容器就不同了,你就相当于有了一个可以运行起来的虚拟机,只要你能运行容器,mysql的配置就省了.而且如果你想换个电脑,直接把容器”端过来”就可以使用容器里面的服务.</p><p>Docker 基于 Go 语言开发，代码托管在Github上，并遵循Apache 2.0 开源协议。Docker 容器可以封装任何有效负载，几乎可以在任何服务器之间进行一致性运行。换句话说，开发者构建的应用只需一次构建即可多平台运行。运营人员只需配置他们的服务，即可运行所有的应用。</p><p>若是利用容器的话,那么开发直接在容器里开发,测试的时候把整个容器给测试,测好了把测试后容器再上线就好了.通过容器,整个开发,测试和生产环境可以保持高度一致。</p><p>此外容器也VM一样具有一定得隔离性,各个容器之间的数据和内存空间相互隔离,可以保证一定的安全性。</p><p>Hyper-V、KVM和Xen等虚拟机管理程序都“基于虚拟化硬件仿真机制。这意味着，它们对系统要求很高.然而，容器却使用共享的操作系统。这意味着它们在使用系统资源方面比虚拟机管理程序要高效得多。容器不是对硬件进行虚拟化处理，而是驻留在一个Linux实例上。<br>Docker可以解决虚拟机能够解决的问题，同时也能够解决虚拟机由于资源要求过高而无法解决的问题。</p><h5 id="为什么要使用docker？"><a href="#为什么要使用docker？" class="headerlink" title="为什么要使用docker？"></a>为什么要使用docker？</h5><h6 id="1-、快速交付应用程序"><a href="#1-、快速交付应用程序" class="headerlink" title="1 、快速交付应用程序"></a>1 、快速交付应用程序</h6><p>•开发者使用一个标准的 image 来构建开发容器，开发完成之后，系统管理员就可以使用这个容器来部署代码<br>•docker可以快速创建容器，快速迭代应用程序，并让整个过程可见，使团队中的其他成员更容易理解应用程序是如何创建和工作的。<br>•docker容器很轻！很快！容器的启动时间是次秒级的，节约开发、测试、部署的时间</p><h6 id="2-、更容易部署和扩展"><a href="#2-、更容易部署和扩展" class="headerlink" title="2 、更容易部署和扩展"></a>2 、更容易部署和扩展</h6><p>•docker容器可以在几乎所有的环境中运行，物理机、虚拟机、公有云、私有云、个人电脑、服务器等等。<br>•docker容器兼容很多平台，这样就可以把一个应用程序从一个平台迁移到另外一个。</p><h6 id="3-、效率更高"><a href="#3-、效率更高" class="headerlink" title="3 、效率更高"></a>3 、效率更高</h6><p>•docker容器不需要 hypervisor ，他是内核级的虚拟化。</p><h6 id="4-、快速部署也意味着更简单的管理"><a href="#4-、快速部署也意味着更简单的管理" class="headerlink" title="4 、快速部署也意味着更简单的管理"></a>4 、快速部署也意味着更简单的管理</h6><p>•通常只需要小小的改变就可以替代以往巨型和大量的更新工作。</p><ul><li>Docker 的常用案例包括：<br> 自动打包和部署应用<br> 创建轻量、私有的 PaaS 环境<br> 自动化测试和持续集成/部署<br> 部署并扩展 Web 应用、数据库和后端服务器</li></ul><h5 id="那么为啥不用VM"><a href="#那么为啥不用VM" class="headerlink" title="那么为啥不用VM?"></a>那么为啥不用VM?</h5><p>那么既然容器和VM这么类似为啥不用VM?docker容器相对于VM还是有很多优点的:<br>1.启动速度快,容器通常在一秒内可以启动.而VM要很久.<br>2.资源利用率高,一台普通服务器可以跑上千个容器，而跑VM就。。。。。。<br>3.性能开销小,VM需要额外的CPU和内存来完成OS的功能,这一部分占据了额外的资源.</p><p>为啥相似的功能在性能上会有如此巨大的差距呢?看一下他们的设计图,先看VM的:</p><p>下面的图片比较了 Docker 和传统虚拟化方式的不同之处，<br><img src="https://img2018.cnblogs.com/blog/1829796/201910/1829796-20191022105823671-1553838987.png" alt=""></p><p>可见容器是在操作系统层面上实现虚拟化，直接复用本地主机的操作系统，而传统方式则是在硬件层面实现。</p><p>Docker优势和劣势<br>作为一种新兴的虚拟化方式，Docker 跟传统的虚拟化方式相比具有众多的优势。<br>首先，Docker 容器的启动可以在秒级实现，这相比传统的虚拟机方式要快得多。<br>其次，Docker 对系统资源的利用率很高，一台主机上可以同时运行数千个 Docker 容器。<br>容器除了运行其中应用外，基本不消耗额外的系统资源，使得应用的性能很高，同时系统的开销尽量小。传统虚拟机方式运行 10 个不同的应用就要起 10 个虚拟机，而 Docker 只需要启动 10 个隔离的应用即可。</p><p>具体说来，Docker 在如下几个方面具有较大的优势。<br>更快速的交付和部署<br>对开发和运维（devop）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。开发者可以使用一个标准的镜像来构建一套开发容器，开发完成之后，运维人员可以直接使用这个容器来部署代码。 Docker 可以快速创建容器，快速迭代应用程序，并让整个过程全程可见，使团队中的其他成员更容易理解应用程序是如何创建和工作的。 Docker 容器很轻很快！容器的启动时间是秒级的，大量地节约开发、测试、部署的时间。<br>更高效的虚拟化<br>Docker 容器的运行不需要额外的 hypervisor 支持，它是内核级的虚拟化，因此可以实现更高的性能和效率。<br>更轻松的迁移和扩展<br>Docker 容器几乎可以在任意的平台上运行，包括物理机、虚拟机、公有云、私有云、个人电脑、服务器等。这种兼容性可以让用户把一个应用程序从一个平台直接迁移到另外一个。<br>更简单的管理<br>使用 Docker，只需要小小的修改，就可以替代以往大量的更新工作。所有的修改都以增量的方式被分发和更新，从而实现自动化并且高效的管理。</p><p>对比传统虚拟机总结<br>| 特性 | 容器 | 虚拟机 |<br>| ———- | —————— | ————– |<br>| 启动 | 秒级 | 分钟级 |<br>| 硬盘使用 | 一般为MB | 一般为GB |<br>| 性能 | 接近原生 | 弱于 |<br>| 系统支持量 | 单机支持上千个容器 | 单机最多几十个 |</p><h3 id="二、Docker-的体系结构"><a href="#二、Docker-的体系结构" class="headerlink" title="二、Docker 的体系结构"></a>二、Docker 的体系结构</h3><p>docker使用C/S 架构，docker daemon 作为 server 端接受 client 的请求，并处理（创建、运行、分发容器），他们可以运行在一个机器上，也通过 socket或者 RESTful API 通信<br><img src="https://img2018.cnblogs.com/blog/1829796/201910/1829796-20191022110500682-916327167.png" alt=""></p><p>Docker daemon 一般在宿主主机后台运行。<br>Docker client以系统命令的形式存在，用户用docker命令来跟docker daemon 交互。</p><p>Docker 守护进程（Docker daemon）<br>如上图所示，Docker 守护进程运行在一台主机上。用户并不直接和守护进程进行交互，而是通过 Docker 客户端间接和其通信。<br>Docker 客户端（Docker client）<br>Docker 客户端，实际上是docker的二进制程序，是用户与 Docker 交互方式。它接收用户指令并且与背后的 Docker 守护进程通信。<br><img src="https://img2018.cnblogs.com/blog/1829796/201910/1829796-20191022110512127-968965811.png" alt=""></p><h5 id="Docker-内部："><a href="#Docker-内部：" class="headerlink" title="Docker 内部："></a>Docker 内部：</h5><p>要理解 Docker 内部构建，需要理解以下三种部件：<br>1)Docker 镜像 - Docker images<br>2)Docker 仓库 - Docker registeries<br>3)Docker 容器 - Docker containers</p><h5 id="1、Docker-镜像-："><a href="#1、Docker-镜像-：" class="headerlink" title="1、Docker 镜像 ："></a>1、Docker 镜像 ：</h5><p>Docker 镜像是 Docker 容器运行时的只读模板，镜像可以用来创建 Docker 容器。每一个镜像由一系列的层 (layers) 组成。Docker 使用UnionFS（联合文件系统）来将这些层联合到单独的镜像中。UnionFS允许独立文件系统中的文件和文件夹(称之为分支)被透明覆盖，形成一个单独连贯的文件系统。正因为有了这些层的存在，Docker 是如此的轻量。当你改变了一个 Docker 镜像，比如升级到某个程序到新的版本，一个新的层会被创建。因此，不用替换整个原先的镜像或者重新建立(在使用虚拟机的时候你可能会这么做)，只是一个新的层被添加或升级了。现在你不用重新发布整个镜像，只需要升级，层使得分发 Docker 镜像变得简单和快速。<br>每个docker都有很多层次构成，docker使用 union file systems 将这些不同的层结合到一个image 中去。<br>例如：centos镜像中安装nginx，就成了nginx镜像”，其实在此时Docker镜像的层级概念就体现出来了。底层一个centos操作系统镜像，上面叠加一个ngnx层，就完成了一个nginx镜像的构建。层级概念就不难理解，此时我们一般centos操作系统镜像称为nginx镜像层的父镜像。<br><img src="https://img2018.cnblogs.com/blog/1829796/201910/1829796-20191022110524969-1070377586.png" alt=""></p><h5 id="2、Docker-仓库-："><a href="#2、Docker-仓库-：" class="headerlink" title="2、Docker 仓库 ："></a>2、Docker 仓库 ：</h5><p>Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。同样的，Docker 仓库也有公有和私有的概念。公有的 Docker 仓库名字是 Docker Hub。Docker Hub 提供了庞大的镜像集合供使用。这些镜像可以是自己创建，或者在别人的镜像基础上创建。<br>仓库是集中存放镜像文件的场所。有时候会把仓库和仓库注册服务器（Registry）混为一谈，并不严格区分。实际上，仓库注册服务器上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签（tag）。</p><p>仓库分为公开仓库（Public）和私有仓库（Private）两种形式，最大的公开仓库是 Docker Hub，存放了数量庞大的镜像供用户下载。国内的公开仓库包括 Docker Pool等，可以提供大陆用户更稳定快速的访问。</p><p>当然，用户也可以在本地网络内创建一个私有仓库。当用户创建了自己的镜像之后就可以使用push命令将它上传到公有或者私有仓库，这样下次在另外一台机器上使用这个镜像时候，只需要从仓库上pull下来就可以了。<br>*注：Docker 仓库的概念跟Git类似，注册服务器可以理解为 GitHub 这样的托管服务。</p><h5 id="3、Docker-容器-："><a href="#3、Docker-容器-：" class="headerlink" title="3、Docker 容器 ："></a>3、Docker 容器 ：</h5><p>Docker 容器用来运行应用，一个Docker容器包含了所有的某个应用运行所需要的环境。每一个 Docker 容器都是从 Docker 镜像创建的。Docker 容器可以运行、开始、停止、移动和删除。每一个 Docker 容器都是独立和安全的应用平台。<br>容器是从镜像创建的运行实例。它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。<br>可以把容器看做是一个简易版的 Linux 环境（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。<br>*注：镜像是只读的，容器在启动的时候创建一层可写层作为最上层。<br><img src="https://img2018.cnblogs.com/blog/1829796/201910/1829796-20191022110535409-1799935510.png" alt=""></p><p>与虚拟机相比，容器有一个很大的差异，它们被设计用来运行”单进程”，无法很好地模拟一个完整的环境。Docker设计者极力推崇“一个容器一个进程的方式”，如果你要选择在一个容器中运行多个进程，那唯一情况是：出于调试目的。<br>容器是设计来运行一个应用的，而非一台机器。你可能会把容器当虚拟机用，但你将失去很多的灵活性，因为Docker提供了用于分离应用与数据的工具，使得你可以快捷地更新运行中的代码/系统，而不影响数据。<br>Docker 从 0.9 版本开始使用 libcontainer 替代 lxc，libcontainer 和 Linux 系统的交互图如下：<br><img src="https://img2018.cnblogs.com/blog/1829796/201910/1829796-20191022110543385-1355070567.png" alt=""></p><p>Docker 底层技术<br>docker底层的 2 个核心技术分别是 Namespaces 和 Control groups<br>Namespaces用来隔离各个容器</p><h6 id="1-pid-namespace"><a href="#1-pid-namespace" class="headerlink" title="1)pid namespace"></a>1)pid namespace</h6><p>不同用户的进程就是通过pid namespace 隔离开的，且不同 namespace 中可以有相同pid。所有的LXC进程在docker中的父进程为docker进程，每个lxc进程具有不同的 namespace 。</p><h6 id="2-net-namespace"><a href="#2-net-namespace" class="headerlink" title="2) net namespace"></a>2) net namespace</h6><p>有了pid namespace, 每个 namespace 中的pid能够相互隔离，但是网络端口还是共享 host 的端口。网络隔离是通过 net namespace 实现的，每个 net namespace 有独立的 network devices, IP addresses, IP routing tables, /proc/net 目录。这样每个 container 的网络就能隔离开来。docker默认采用veth的方式将 container 中的虚拟网卡同 host 上的一个docker bridge: docker0 连接在一起。</p><h6 id="3-ipc-namespace"><a href="#3-ipc-namespace" class="headerlink" title="3) ipc namespace"></a>3) ipc namespace</h6><p>container 中进程交互还是采用linux常见的进程间交互方法 (interprocess communication - IPC),包括常见的信号量、消息队列和共享内存。container 的进程间交互实际上还是host 上具有相同pid namespace 中的进程间交互。</p><h6 id="4-mnt-namespace"><a href="#4-mnt-namespace" class="headerlink" title="4) mnt namespace"></a>4) mnt namespace</h6><p>类似chroot，将一个进程放到一个特定的目录执行。mnt namespace 允许不同 namespace 的进程看到的文件结构不同，这样每个 namespace 中的进程所看到的文件目录就被隔离开了。在container里头，看到的文件系统，就是一个完整的linux系统，有/etc、/lib 等，通过chroot实现。</p><h6 id="5-uts-namespace"><a href="#5-uts-namespace" class="headerlink" title="5) uts namespace"></a>5) uts namespace</h6><p>UTS(“UNIX Time-sharing System”) namespace 允许每个 container 拥有独立的 hostname 和 domain name, 使其在网络上可以被视作一个独立的节点而非 Host 上的一个进程。</p><h6 id="6-user-namespace"><a href="#6-user-namespace" class="headerlink" title="6) user namespace"></a>6) user namespace</h6><p>每个 container 可以有不同的 user 和 group id, 也就是说可以在 container 内部用 container 内部的用户执行程序而非 Host 上的用户。</p><p>有了以上 6 种 namespace 从进程、网络、IPC、文件系统、UTS和用户角度的隔离，一个 container 就可以对外展现出一个独立计算机的能力，并且不同 container 从 OS 层面实现了隔离。然而不同 namespace 之间资源还是相互竞争的，仍然需要类似ulimit来管理每个 container 所能使用的资源 - -cgroup。</p><p>资源配额「cgroups」<br>cgroups 实现了对资源的配额和度量。 cgroups 的使用非常简单，提供类似文件的接口，在 /cgroup 目录下新建一个文件夹即可新建一个 group，在此文件夹中新建 task 文件，并将 pid 写入该文件，即可实现对该进程的资源控制。具体的资源配置选项可以在该文件夹中新建子 subsystem ，{子系统前缀}.{资源项} 是典型的配置方法， 如 memory.usageinbytes 就定义了该 group 在 subsystem memory 中的一个内存限制选项。 另外，cgroups 中的 subsystem 可以随意组合，一个 subsystem 可以在不同的 group 中，也可以一个 group 包含多个 subsystem - 也就是说一个 subsystem。<br>memory<br>内存相关的限制<br>cpu<br>在 cgroup 中，并不能像硬件虚拟化方案一样能够定义 CPU 能力，但是能够定义 CPU 轮转的优先级，因此具有较高 CPU 优先级的进程会更可能得到 CPU 运算。 通过将参数写入 cpu.shares ,即可定义改 cgroup 的 CPU 优先级 - 这里是一个相对权重，而非绝对值<br>blkio<br>block IO 相关的统计和限制，byte/operation 统计和限制 (IOPS 等)，读写速度限制等，但是这里主要统计的都是同步 IO<br>devices<br>设备权限限制</p><h3 id="三、Docker-安装"><a href="#三、Docker-安装" class="headerlink" title="三、Docker 安装"></a>三、Docker 安装</h3><p>docker官网：<a href="https://docs.docker.com" target="_blank" rel="noopener">https://docs.docker.com</a><br>Docker值得关注的特性：<br>o文件系统隔离：每个进程容器运行在一个完全独立的根文件系统里。<br>o资源隔离：系统资源，像CPU和内存等可以分配到不同的容器中，使用cgroup。<br>o网络隔离：每个进程容器运行在自己的网络空间，虚拟接口和IP地址。<br>o日志记录：Docker将会收集和记录每个进程容器的标准流（stdout/stderr/stdin），用于实时检索或批量检索。<br>o变更管理：容器文件系统的变更可以提交到新的映像中，并可重复使用以创建更多的容器。无需使用模板或手动配置。<br>o交互式shell：Docker可以分配一个虚拟终端并关联到任何容器的标准输入上，</p><p>CentOS 系列安装 Docker，Docker 支持 CentOS6 及以后的版本。<br>CentOS6：<br>在RedHat/CentOS环境下安装Docker。官方文档要求Linux kernel至少3.8以上，且docker只能运行在64位的系统中。由于RHEL6和CentOS6的内核版本为2.6，因此必须要先升级内核。</p><p>升级内核（记住一定要升级，要不然会出现很多莫名奇怪的问题，建议用yum安装）</p><h5 id="1、Centos6系统安装docker"><a href="#1、Centos6系统安装docker" class="headerlink" title="1、Centos6系统安装docker:"></a>1、Centos6系统安装docker:</h5><p>1-1)yum安装带aufs模块的3.10内核</p><pre><code>[root@server4 ~]# cd /etc/yum.repos.d/[root@server4 yum.repos.d]# wget http://www.hop5.in/yum/el6/hop5.repo[root@server4 yum.repos.d]# lshop5.repo[root@server4 yum.repos.d]# yum -y install kernel-ml-aufs kernel-ml-aufs-devel</code></pre><p>1-2)修改grub的主配置文件/etc/grub.conf，设置default=0，表示第一个title下的内容为默认启动的kernel（一般新安装的内核在第一个位置），</p><p>1-3)重启系统，这时候你的内核就成功升级了。</p><pre><code>[root@server4 ~]# uname -r3.10.0-327.el7.x86_64</code></pre><p>1-4)可以使用EPEL库安装 Docker，命令如下：</p><pre><code>#yum install http://mirrors.yun-idc.com/epel/6/i386/epel-release-6-8.noarch.rpm#yum install docker-io</code></pre><p>1-5)启动docker服务</p><pre><code>#service docker start</code></pre><h5 id="2、CentOS7安装docker："><a href="#2、CentOS7安装docker：" class="headerlink" title="2、CentOS7安装docker："></a>2、CentOS7安装docker：</h5><p>2-1）Prerequisites（先决条件）<br>Docker requires a 64-bit installation regardless of your CentOS version. Also, your kernel must be 3.10 at minimum, which CentOS 7 runs.<br>To check your current kernel version, open a terminal and use uname -r to display your kernel version:<br>[root@server4 yum.repos.d]# uname -r<br>3.10.0-327.el7.x86_64</p><p>2-2）Docker 软件包已经包括在默认的 CentOS-Extras 软件源里。因此想要安装docker，只需要运行下面的 yum 命令：<br>[root@server4 yum.repos.d]# yum -y install docker<br>注：如出现以下报错<br>[root@server4 yum.repos.d]# yum -y install docker<br>Loaded plugins: plugins: fastestmirror, langpacks<br>Existing lock /var/run/yum.pid: another copy is running as pid 13120.<br>Another app is currently holding the yum lock; waiting for it to exit…<br>The other application is: PackageKit<br>Memory : 26 M RSS (429 MB VSZ)<br>Started: Fri Nov 11 10:27:44 2016 - 00:12 ago<br>State : Sleeping, pid: 13120<br>解决方法：<br>[root@server4 yum.repos.d]# rm -rf /var/run/yum.pid</p><p>2-3）启动 Docker 服务：<br>安装完成后，使用下面的命令来启动docker服务，并将其设置为开机启动：</p><pre><code>[root@server4 ~]# systemctl enable docker [root@server4 ~]# systemctl start docker</code></pre><p>2-4)查看docker版本</p><pre><code>[root@server4 ~]# docker versionClient: Version:         1.10.3 API version:     1.22 Package version: docker-common-1.10.3-46.el7.centos.14.x86_64 Go version:      go1.6.3 Git commit:      cb079f6-unsupported Built:           Fri Sep 16 13:24:25 2016 OS/Arch:         linux/amd64Server: Version:         1.10.3 API version:     1.22 Package version: docker-common-1.10.3-46.el7.centos.14.x86_64 Go version:      go1.6.3 Git commit:      cb079f6-unsupported Built:           Fri Sep 16 13:24:25 2016 OS/Arch:         linux/amd64</code></pre><p>2-5)查看docker版本：docker info</p><pre><code>[root@server4 ~]# docker infoContainers: 0 Running: 0 Paused: 0 Stopped: 0Images: 0Server Version: 1.10.3Storage Driver: devicemapper Pool Name: docker-253:0-1785801-pool Pool Blocksize: 65.54 kB Base Device Size: 10.74 GB Backing Filesystem: xfs Data file: /dev/loop0 Metadata file: /dev/loop1 Data Space Used: 11.8 MB Data Space Total: 107.4 GB Data Space Available: 40.74 GB Metadata Space Used: 581.6 kB Metadata Space Total: 2.147 GB Metadata Space Available: 2.147 GB Udev Sync Supported: true Deferred Removal Enabled: false Deferred Deletion Enabled: false Deferred Deleted Device Count: 0 Data loop file: /var/lib/docker/devicemapper/devicemapper/data</code></pre><p>以上是使用centos7软件源提供的docker安装程序<br>附：也可以按照官方文档安装<br>1.Log into your machine as a user with sudo or root privileges.<br>2.Make sure your existing yum packages are up-to-date.<br>3．Add the yum repo<br>$ sudo tee /etc/yum.repos.d/docker.repo&lt;&lt;-‘EOF’<br>[dockerrepo]<br>name=DockerRepositorybaseurl=<a href="https://yum.dockerproject.org/repo/main/centos/7/" target="_blank" rel="noopener">https://yum.dockerproject.org/repo/main/centos/7/</a><br>enabled=1<br>gpgcheck=1<br>gpgkey=<a href="https://yum.dockerproject.org/gpg" target="_blank" rel="noopener">https://yum.dockerproject.org/gpg</a><br>EOF<br>注：如果我们既想把输出保存到文件中，又想在屏幕上看到输出内容，就可以使用tee命令了。tee命令读取标准输入，把这些内容同时输出到标准输出和（多个）文件中<br>4．Install the Docker package<br>$ sudo yum install docker-engine<br>5．Start the Docker daemon.<br>$ sudo service dockerstart<br>6．Verify docker is installed correctly by running a test image in a container.<br>验证docker安装正确</p><p>以上是使用centos7软件源提供的docker安装程序<br>附：也可以按照官方文档安装<br>1.Log into your machine as a user with sudo or root privileges.<br>2.Make sure your existing yum packages are up-to-date.<br>3．Add the yum repo<br>$ sudo tee /etc/yum.repos.d/docker.repo&lt;&lt;-‘EOF’<br>[dockerrepo]<br>name=DockerRepositorybaseurl=<a href="https://yum.dockerproject.org/repo/main/centos/7/" target="_blank" rel="noopener">https://yum.dockerproject.org/repo/main/centos/7/</a><br>enabled=1<br>gpgcheck=1<br>gpgkey=<a href="https://yum.dockerproject.org/gpg" target="_blank" rel="noopener">https://yum.dockerproject.org/gpg</a><br>EOF<br>注：如果我们既想把输出保存到文件中，又想在屏幕上看到输出内容，就可以使用tee命令了。tee命令读取标准输入，把这些内容同时输出到标准输出和（多个）文件中<br>4．Install the Docker package<br>$ sudo yum install docker-engine<br>5．Start the Docker daemon.<br>$ sudo service dockerstart<br>6．Verify docker is installed correctly by running a test image in a container.<br>验证docker安装正确</p><p>$ sudo docker run hello-world</p><p>7.docker默认使用的是unix socket</p><pre><code>[root@server4 ~]# ss -ax | grep dockeru_str  LISTEN     0      128    /var/lib/docker/network/files/8269c2bdc34721cabf2d2fa89b52bafd7fd1cd3f7d0c7456518c74b5cb704bdf.sock 53403                 * 0                    u_str  LISTEN     0      128    /var/run/docker.sock 53301                 * 0                    u_str  ESTAB      0      0      /var/run/docker.sock 55511                 * 48920         </code></pre><p>​<br>附：直接输入docker命令来查看所有的Options和Commands，查看某一个command的详细使用方法：dockerCOMMAND–help</p><h3 id="四、Docker-image详细介绍"><a href="#四、Docker-image详细介绍" class="headerlink" title="四、Docker image详细介绍"></a>四、Docker image详细介绍</h3><p>在之前的介绍中，我们知道docker images 是docker的三大组件之一。<br>docker把下载的 images 存储到docker主机上，如果一个 image 不在主机上，docker会从一个镜像仓库下载，默认的仓库是 DOCKER HUB 公共仓库。<br>接下来将介绍更多关于docker images 的内容，包括：<br>•使用和管理本地主机上的 images<br>•创建一个基础的 images<br>•上传 images 到docker hub （公共 images 仓库）<br>•列出本地主机上已经存在的 images</p><h5 id="1）使用docker-images-显示本机上的-images"><a href="#1）使用docker-images-显示本机上的-images" class="headerlink" title="1）使用docker images  显示本机上的 images"></a>1）使用docker images 显示本机上的 images</h5><pre><code>[root@localhost ~]# docker images REPOSITORY     TAG          IMAGE ID         CREATED         SIZEdocker.io/centos  latest        50dae1ee8677     3 months ago     196.7 MB</code></pre><p>在列出信息中，<br>•REPOSITORY:来自于哪个仓库，比如 docker.io/centos<br>•TAG的标记，比如 latest<br>•IMAGE ID:镜像它的 ID 号<br>•CREATED:创建时间<br>•SIZE:镜像的 SIZE<br>一个仓库可能有一个 images 的都个发行版，比如ubuntu，他们有 10.04 12.04 12.10 13.04 14.04,每个发行版的标记都不同，可以使用 tag 命令来指定 images<br>注：如果你不指定具体的发行版，比如仅使用ubuntu，那么docker会使用最新的发行版ubuntu:latest<br>提示：建议最好指定发行版，只有这样你才可以保证你真正使用的 image 是那个</p><h5 id="2）获取-images-网络"><a href="#2）获取-images-网络" class="headerlink" title="2）获取 images (网络)"></a>2）获取 images (网络)</h5><p>我们如何获取新的 images 呢？当我们启动容器使用的 image 不再本地主机上时，docker会自动下载他们。这很耗时，我们可以使用docker pull 命令来预先下载我们需要的 image 。下面的例子下载一个centos 镜像。</p><pre><code>[root@localhost ~]# docker pull docker.io/centosUsing default tag: latestTrying to pull repository docker.io/library/centos ... latest: Pulling from docker.io/library/centos08d48e6f1cff: Downloading [&gt;                                   ] 1.081 MB/70.48 MB</code></pre><p>这样当我们使用这个 image 来启动容器的时候，它就可以马上启动了。</p><p>这样当我们使用这个 image 来启动容器的时候，它就可以马上启动了。</p><h5 id="3）查找-images-网络"><a href="#3）查找-images-网络" class="headerlink" title="3）查找 images (网络)"></a>3）查找 images (网络)</h5><p>docker的一个特点是很多人因为各种不同的用途创建了各种不同的 images 。它们都被上传到了docker hub 共有仓库上，我们可以在docker hub 的网站上来查找它们。使用docker search 命令。比如，当我们需要 ruby 和sinatra作为 web 应用程序的开发时，我们使用docker search 来搜索合适的image ，使用关键字sinatra</p><pre><code>[root@localhost ~]# docker search sinatra</code></pre><p>我们看到返回了很多包含sinatra的 images 。其中包括 image 名字、描述、星级（表示该 image 的受欢迎程度）、是否官方创建、是否自动创建。官方的 images 是stackbrew项目组创建和维护的，automated 资源允许你验证 image 的来源和内容。</p><p>到目前为止，我们看到了 2种 images 资源。比如ubuntu，被称为基础或则根镜像。这些基础镜像是docker公司创建、验证、支持、提供。他们往往使用一个单词作为他们的名字。还有一种类型，比如我们选择的 training/sinatra镜像。它是由docker的用户创建并维护的，你可以通过指定 image 名字的前缀来指定他们，比如 training 。</p><h5 id="4）下载-images"><a href="#4）下载-images" class="headerlink" title="4）下载 images"></a>4）下载 images</h5><p>现在我们指定了一个 image ， training/sinatra，我们可以使用docker pull 命令来下载它</p><pre><code>[root@localhost ~]# docker pull  docker.io/jdeathe/centos-ssh</code></pre><p>下载过程中，会输出获取镜像的每一层信息。<br>该命令实际上相当于#docker pull registry.hub.docker.com/ubuntu:12.04 命令，即从注册服<br>务器 registry.hub.docker.com 中的ubuntu仓库来下载标记为 12.04 的镜像。<br>有时候官方仓库注册服务器下载较慢，可以从其他仓库下载。从其它仓库下载时需要指定完整的仓库注册服务器地址。例如</p><pre><code>#docker pull dl.dockerpool.com:5000/ubuntu:12.04</code></pre><h5 id="5-查看镜像文件docker-images"><a href="#5-查看镜像文件docker-images" class="headerlink" title="5) 查看镜像文件docker images"></a>5) 查看镜像文件docker images</h5><pre><code>[root@localhost ~]# docker images REPOSITORY      TAG             IMAGE ID          CREATED          SIZEdocker.io/centos   latest           50dae1ee8677      3 months ago      196.7 MBdocker.io/centos   centos6         cf2c3ece5e41       4 months ago      194.6 MB</code></pre><h5 id="6-查看完整信息"><a href="#6-查看完整信息" class="headerlink" title="6) 查看完整信息"></a>6) 查看完整信息</h5><p>当镜像下载成功后，你可以看到 12 位的 hash 值像 05188b417f30，这是下载完整的镜像的精简 ID，这些短的镜像 ID 是完整镜像 ID 的前 12 个字符–可以使用docker inspect 或者docker images –no-trunc来获得完整的镜像 ID</p><pre><code>[root@localhost ~]# docker inspect docker.io/centos</code></pre><p>或: –no-trunc来获得完整的镜像 ID</p><pre><code>[root@localhost ~]# docker images --no-trunc</code></pre><h5 id="7）创建我们自己的-images"><a href="#7）创建我们自己的-images" class="headerlink" title="7）创建我们自己的 images"></a>7）创建我们自己的 images</h5><p>别人的镜像虽然好，但不一定适合我们。我们可以对他们做一些改变，有 2 个方法：<br>1.第一个方法：使用docker commit 来扩展一个 image<br>1-1先使用 image 启动容器，更新后提交结果到新的 image 。</p><pre><code>[root@localhost ~]# docker run -it docker.io/centos /bin/bash[root@cfd9c030875b /]#</code></pre><p>注意：记住容器的 ID ，稍后我们还会用到</p><p>注意：记住容器的 ID ，稍后我们还会用到</p><p>1-2在容器中添加mariadb-server应用。</p><pre><code>[root@cfd9c030875b /]# yum -y install httpd[root@cfd9c030875b /]# exit</code></pre><p>exit<br>当结束后，我们使用 exit 来退出，现在我们的容器已经被我们改变了</p><p>exit<br>当结束后，我们使用 exit 来退出，现在我们的容器已经被我们改变了</p><p>1-3使用docker commint命令来提交相应的副本。</p><pre><code>[root@localhost ~]# docker commit -m &quot;added httpd app&quot; -a &quot;docker chen&quot; cfd9c030875b centos:httpdsha256:05653ceb4e74275edfbc16edaa1976410e0fd6a35b910d4d04d83f8e92353669</code></pre><p>其中:<br>-m 来指定提交的说明信息，跟我们使用的版本控制工具一样；<br>-a 可以指定更新的用户信息；之后是用来创建镜像的容器的 ID；<br>最后指定目标镜像的仓库名和 tag 信息。创建成功后会返回这个镜像的 ID信息。</p><p>其中:<br>-m 来指定提交的说明信息，跟我们使用的版本控制工具一样；<br>-a 可以指定更新的用户信息；之后是用来创建镜像的容器的 ID；<br>最后指定目标镜像的仓库名和 tag 信息。创建成功后会返回这个镜像的 ID信息。</p><p>1-4)使用docker images 来查看新创建的镜像。</p><pre><code>[root@localhost ~]# docker images REPOSITORY       TAG             IMAGE ID         CREATED            SIZEcentos           httpd            05653ceb4e74     About a minute ago   295.3 MBdocker.io/centos   latest            50dae1ee8677     3 months ago        196.7 MBdocker.io/centos  centos6          cf2c3ece5e41       4 months ago         194.6 MB</code></pre><p>之后，可以使用新的镜像来启动容器</p><p>之后，可以使用新的镜像来启动容器</p><pre><code>[root@localhost ~]# docker run  -it centos:httpd /bin/bash[root@392e3fa371b7 /]# uname -r3.10.0-327.el7.x86_64</code></pre><p>2.第二个办法：从dockerfile来创建 image<br>使用docker commit 来扩展一个 image 比较简单，但它不容易在一个团队中分享它。我们使用docker build 来创建一个新的 image 。为此，我们需要创建一个dockerfile，包含一些如何创建我们的image 的指令。<br>2-1）创建一个目录和一个dockerfile</p><pre><code>[root@localhost ~]# mkdir -p /docker/httpd[root@localhost ~]# cd /docker/httpd[root@localhost httpd]# vim dockerfile#This is a commentFROM docker.io/centosMAINTAINER chen &lt;chen@mail.com&gt;RUN yum -y -q install httpd</code></pre><p>Dockerfile基本的语法是<br>使用#来注释<br>FROM指令告诉 Docker 使用哪个镜像作为基础（docker使用哪个 image 源）<br>MAINTAINER是维护者的信息<br>RUN开头的指令会在创建中运行，比如安装一个软件包，在这里使用 yum来安装了一些软件</p><p>Dockerfile基本的语法是<br>使用#来注释<br>FROM指令告诉 Docker 使用哪个镜像作为基础（docker使用哪个 image 源）<br>MAINTAINER是维护者的信息<br>RUN开头的指令会在创建中运行，比如安装一个软件包，在这里使用 yum来安装了一些软件</p><p>2-2）编写完成Dockerfile后可以使用docker build 来生成镜像。</p><pre><code>[root@localhost httpd]# docker build -t=&quot;centos:httpd-1&quot; .</code></pre><p>其中:<br>-t 标记来添加 tag，指定新的镜像的用户信息。<br>“.”是Dockerfile所在的路径（当前目录），也可以替换为一个具体的Dockerfile的路径。<br>可以看到 build 进程在执行操作。它要做的第一件事情就是上传这个Dockerfile内容，因为所有的操作都要依据Dockerfile来进行。然后，Dockfile中的指令被一条一条的执行。每一步都创建了一个新的容器，在容器中执行指令并提交修改（就跟之前介绍过的docker commit 一样）。当所有的指令都执行完毕之后，返回了最终的镜像 id。所有的中间步骤所产生的容器都被删除和清理了。<br>*注意一个镜像不能超过 127 层</p><p>2-3）查看生成的镜像</p><pre><code>[root@localhost httpd]# docker images REPOSITORY        TAG              IMAGE ID          CREATED           SIZEcentos            httpd-1           a7e5b7ebdc89      8 minutes ago      338.5 MBcentos            httpd            f8cadf4f19b7       13 minutes ago      338.5 MBdocker.io/centos    latest            50dae1ee8677      3 months ago       196.7 MBdocker.io/centos   centos6           cf2c3ece5e41       4 months ago       194.6 MB</code></pre><p>2-4）从我们新建的 images 开启容器</p><pre><code>[root@localhost httpd]# docker run -it centos:httod-1 /bin/bash[root@dafdc2b34c56 /]#</code></pre><p>2-5）还可以用docker tag 命令来修改镜像的标签。</p><pre><code>[root@localhost httpd]# docker tag centos:httpd-1 centos:httod-1[root@localhost httpd]# docker images REPOSITORY        TAG             IMAGE ID         CREATED            SIZEcentos            httod-1           a7e5b7ebdc89      12 minutes ago     338.5 MBcentos            httpd-1           a7e5b7ebdc89      12 minutes ago     338.5 MBcentos            httpd            f8cadf4f19b7       17 minutes ago      338.5 MBdocker.io/centos   latest             50dae1ee8677      3 months ago       196.7 MBdocker.io/centos   centos6           cf2c3ece5e41       4 months ago       194.6 MB</code></pre><p>3.从本地文件系统导入<br>要从本地文件系统导入一个镜像，可以使用openvz（容器虚拟化的先锋技术）的模板来创建：openvz的模板下载地址为<a href="http://openvz.org/Download/template/precreated。" target="_blank" rel="noopener">http://openvz.org/Download/template/precreated。</a><br>先下载了一个centos-6-x86_64.tar.gz的镜像，之后使用以下命令导入：<br><img src="https://img2018.cnblogs.com/blog/1829796/201910/1829796-20191022110637478-664814624.png" alt=""></p><h5 id="8）上传镜像"><a href="#8）上传镜像" class="headerlink" title="8）上传镜像"></a>8）上传镜像</h5><p>用户可以通过docker push 命令，把自己创建的镜像上传到仓库中来共享。例如，用户在 Docker Hub 上，完成注册后，可以推送自己的镜像到仓库中。<br>这里有两种访问可以创建和注册一个 Docker Hub 账户：<br>1.通过网站，（<a href="https://hub.docker.com）" target="_blank" rel="noopener">https://hub.docker.com）</a><br>2.通过命令行<br>你可以通过使用命令行输入 docker login 命令来创建一个 Docker Hub 账号</p><pre><code>#docker login</code></pre><p>邮箱确认<br>一旦你填写完毕表格，请查看你的电子邮件，通过点击欢迎信息中的链接来激活您的账户。</p><p>邮箱确认<br>一旦你填写完毕表格，请查看你的电子邮件，通过点击欢迎信息中的链接来激活您的账户。</p><p>基本思路：<br>首先注册docker的账户，然后使用docker login登录。<br>使用docker push可以将自己的镜像上传上去了<br><img src="https://img2018.cnblogs.com/blog/1829796/201910/1829796-20191022110650983-1343036792.png" alt=""></p><p>如果有其他的仓库,例如:</p><pre><code>docker push docker.sina.com.cn:5000/commit</code></pre><h5 id="9）用dcokerrmi移除本地-images"><a href="#9）用dcokerrmi移除本地-images" class="headerlink" title="9）用dcokerrmi移除本地 images"></a>9）用dcokerrmi移除本地 images</h5><p>dockerrmi镜像名或镜像id</p><pre><code>[root@localhost httpd]# docker rmi centos:httod-1</code></pre><p>注意：在删除 images 之前要先用dockerrm删掉依赖于这个 images 的容器</p><p>注意：在删除 images 之前要先用dockerrm删掉依赖于这个 images 的容器</p><h5 id="10）存出和载入镜像"><a href="#10）存出和载入镜像" class="headerlink" title="10）存出和载入镜像"></a>10）存出和载入镜像</h5><p>当需要把一台机器上的镜像迁移到另一台机器的时候，需要存出镜像与载入镜像。<br>10-1）存出镜像<br>如果要导出镜像到本地文件，可以使用docker save 命令。</p><pre><code>[root@localhost ~]# docker save -o centos-6-httpd.tar centos:httpd-1[root@localhost ~]# ls centos-6-httpd.tar centos-6-httpd.tar</code></pre><p>10-2）载入镜像<br>可以使用docker load 从导出的本地文件中再导入到本地镜像库，例如</p><p>这将导入镜像以及其相关的元数据信息（包括标签等）</p><h3 id="五、Docker-容器"><a href="#五、Docker-容器" class="headerlink" title="五、Docker 容器"></a>五、Docker 容器</h3><p>容器是 Docker 又一核心概念,简单的说，容器是独立运行的一个或一组应用，以及它们的运行态环境。对应的，虚拟机可以理解为模拟运行的一整套操作系统（提供了运行态环境和其他系统环境）和跑在上面的应用。<br>本章将具体介绍如何来管理一个容器，包括创建、启动和停止等。<br>启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（stopped）的容器重新启动。</p><h5 id="1、新建并启动"><a href="#1、新建并启动" class="headerlink" title="1、新建并启动"></a>1、新建并启动</h5><p>所需要的命令主要为docker run<br>下面的命令则启动一个 bash 终端，允许用户进行交互。</p><pre><code>[root@localhost ~]# docker run -it docker.io/centos:centos6[root@c88f4fefd1ff /]#</code></pre><p>-t 选项让 Docker 分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上，<br>-i则让容器的标准输入保持打开(即交互式)，可以使用—name给容器起个形象的名称。<br>在交互模式下，用户可以通过所创建的终端来输入命令，例如</p><p>-t 选项让 Docker 分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上，<br>-i则让容器的标准输入保持打开(即交互式)，可以使用—name给容器起个形象的名称。<br>在交互模式下，用户可以通过所创建的终端来输入命令，例如</p><pre><code>[root@c88f4fefd1ff /]# pwd/[root@c88f4fefd1ff /]# ps -efUID        PID  PPID  C STIME TTY          TIME CMDroot         1     0  0 08:18 ?        00:00:00 /bin/bashroot        12     1  0 08:20 ?        00:00:00 ps -ef</code></pre><p>容器的核心为所执行的应用程序，所需要的资源都是应用程序运行所必需的。除此之外，并没有其它的资源。可以在伪终端中利用ps或 top 来查看进程信息。</p><p>容器的核心为所执行的应用程序，所需要的资源都是应用程序运行所必需的。除此之外，并没有其它的资源。可以在伪终端中利用ps或 top 来查看进程信息。</p><pre><code>[root@c88f4fefd1ff /]# ps  PID TTY          TIME CMD    1 ?        00:00:00 bash   13 ?        00:00:00 ps</code></pre><p>可见，容器中仅运行了指定的 bash 应用。这种特点使得 Docker 对资源的利用率极高，是货真价实的轻量级虚拟化。</p><p>可见，容器中仅运行了指定的 bash 应用。这种特点使得 Docker 对资源的利用率极高，是货真价实的轻量级虚拟化。</p><p>如果这个时候我们正常退出，logout 或者 exit 或者Ctrl+d或者Ctrl+c，dockerps–a 查看容器处于 Exit 状态如果需要正常退出可以使用 CTRL –p + CTRL -q —-就像先按 CTRL -p 然后 CTRL –q 退出伪终端<br>下面的命令输出一个“Hello World”，之后终止容器。</p><pre><code>[root@localhost ~]# docker run docker.io/centos:latest /bin/echo &#39;hello world&#39;htool world</code></pre><p>这跟在本地直接执行 /bin/echo ‘hello world’ 几乎感觉不出任何区别。</p><p>这跟在本地直接执行 /bin/echo ‘hello world’ 几乎感觉不出任何区别。</p><p>当利用docker run 来创建容器时，Docker 在后台运行的标准操作包括：<br>1.检查本地是否存在指定的镜像，不存在就从公有仓库下载<br>2.利用镜像创建并启动一个容器<br>3.分配一个文件系统，并在只读的镜像层外面挂载一层可读写层<br>4.从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去<br>5.从地址池配置一个ip地址给容器<br>6.执行用户指定的应用程序<br>7.执行完毕后容器被终止</p><h5 id="2、查看容器dockerps"><a href="#2、查看容器dockerps" class="headerlink" title="2、查看容器dockerps"></a>2、查看容器dockerps</h5><pre><code>[root@localhost ~]# docker ps -a![](https://img2018.cnblogs.com/blog/1829796/201910/1829796-20191022110725324-901966730.png)</code></pre><p>附：养成查看帮助的习惯</p><pre><code>[root@localhost ~]# docker ps -hUsage:    docker ps [OPTIONS]List containers  -a, --all          Show all containers (default shows just running)  -f, --filter=[]    Filter output based on conditions provided  --format           Pretty-print containers using a Go template  --help             Print usage  -l, --latest       Show the latest created container (includes all states)  -n=-1              Show n last created containers (includes all states)  --no-trunc         Don&#39;t truncate output  -q, --quiet        Only display numeric IDs  -s, --size         Display total file sizes</code></pre><h5 id="3、可以利用docker-start-命令，直接将一个已经终止的容器启动运行。"><a href="#3、可以利用docker-start-命令，直接将一个已经终止的容器启动运行。" class="headerlink" title="3、可以利用docker start  命令，直接将一个已经终止的容器启动运行。"></a>3、可以利用docker start 命令，直接将一个已经终止的容器启动运行。</h5><pre><code>docker start [contraiID]</code></pre><p>容器处于 Exited 状态，可以直接启动<br><img src="https://img2018.cnblogs.com/blog/1829796/201910/1829796-20191022110738858-1203258864.png" alt=""></p><h5 id="4、终止容器"><a href="#4、终止容器" class="headerlink" title="4、终止容器"></a>4、终止容器</h5><pre><code>docker stop [容器 ID]docker kill [容器 ID]</code></pre><p>可以使用docker stop 来终止一个运行中的容器。此外，当Docker容器中指定的应用终结时，容器也自动终止。例如对于前面所讲中启动了一个终端的容器，用户通过 exit 命令或Ctrl+d来退出终端时，所创建的容器立刻终止<br>终止状态的容器可以用docker ps -a 命令看到。例如<br><img src="https://img2018.cnblogs.com/blog/1829796/201910/1829796-20191022110749689-485534913.png" alt=""></p><p>状态由 Up -&gt; Exit<br>处于终止状态的容器，可以通过docker start 命令来重新启动。</p><h5 id="5、重启容器"><a href="#5、重启容器" class="headerlink" title="5、重启容器"></a>5、重启容器</h5><pre><code>docker restart  命令会将一个运行态的容器终止，然后再重新启动它。docker restart [容器 ID]</code></pre><p><img src="https://img2018.cnblogs.com/blog/1829796/201910/1829796-20191022110800024-2009126343.png" alt=""></p><h5 id="6、守护状态运行"><a href="#6、守护状态运行" class="headerlink" title="6、守护状态运行"></a>6、守护状态运行</h5><p>更多的时候，需要让 Docker 容器在后台以守护状态（Daemonized）形式运行。此时，可以通过添加 -d 参数来实现。例如下面的命令会在后台运行容器。</p><pre><code>[root@localhost ~]# docker run -d docker.io/centos /bin/bash -c &quot;while true ; do echo hello world ; sleep 1 ; done&quot;![](https://img2018.cnblogs.com/blog/1829796/201910/1829796-20191022110819599-2000970667.png)</code></pre><p>或</p><pre><code>[root@localhost ~]# docker run -dt docker.io/centos /bin/bash56c3adf740ba870818af856ab76fe43fa7f44d7a0f2fc26fc4b4558788585e3a[root@localhost ~]#</code></pre><p>容器启动后会返回一个唯一的 id，也可以通过docker ps命令来查看容器信息。<br>1．docker run -d 运行提个新的容器，我们通过-d 命令让他作为一个后台运行<br>2．centos:centos6 是一个我们想要在内部运行命令的镜像<br>3．/bin/sh -c 是我们想要在容器内部运行的命令<br>4．while true; do echo hello weibo; sleep 1; done 这是一个简单的脚本，我们仅仅只是每秒打印一次 hello word 一直到我们结束它</p><p>容器启动后会返回一个唯一的 id，也可以通过docker ps命令来查看容器信息。<br>1．docker run -d 运行提个新的容器，我们通过-d 命令让他作为一个后台运行<br>2．centos:centos6 是一个我们想要在内部运行命令的镜像<br>3．/bin/sh -c 是我们想要在容器内部运行的命令<br>4．while true; do echo hello weibo; sleep 1; done 这是一个简单的脚本，我们仅仅只是每秒打印一次 hello word 一直到我们结束它</p><h5 id="7、用docker-inspect查看容器的信息"><a href="#7、用docker-inspect查看容器的信息" class="headerlink" title="7、用docker  inspect查看容器的信息"></a>7、用docker inspect查看容器的信息</h5><p>命令格式：docker inspect 容器ID或容器名</p><pre><code>[root@localhost ~]# docker inspect 56c3adf740ba [    {        &quot;Id&quot;: &quot;56c3adf740ba870818af856ab76fe43fa7f44d7a0f2fc26fc4b4558788585e3a&quot;,        &quot;Created&quot;: &quot;2016-11-15T10:50:58.658378757Z&quot;,        &quot;Path&quot;: &quot;/bin/bash&quot;,        &quot;Args&quot;: [],        &quot;State&quot;: {            &quot;Status&quot;: &quot;running&quot;,            &quot;Running&quot;: true,            &quot;Paused&quot;: false,            &quot;Restarting&quot;: false,            &quot;OOMKilled&quot;: false,            &quot;Dead&quot;: false,            &quot;Pid&quot;: 42710,            &quot;ExitCode&quot;: 0,            &quot;Error&quot;: &quot;&quot;,            &quot;StartedAt&quot;: &quot;2016-11-15T10:50:59.092432423Z&quot;,            &quot;FinishedAt&quot;: &quot;0001-01-01T00:00:00Z&quot;        },</code></pre><p>用docker inspect查看容器的ip地址</p><p>用docker inspect查看容器的ip地址</p><pre><code>[root@localhost ~]# docker inspect -f &#39;{{.NetworkSettings.IPAddress}}&#39; 56c3adf740ba172.17.0.4</code></pre><p>用docker inspect查看容器执行的程序</p><p>用docker inspect查看容器执行的程序</p><pre><code>[root@localhost ~]# docker inspect  -f &#39;{{.Config.Cmd}}&#39; 56c3adf740ba {[/bin/bash]}</code></pre><h5 id="8、进入容器"><a href="#8、进入容器" class="headerlink" title="8、进入容器"></a>8、进入容器</h5><p>在使用 -d 参数时，容器启动后会进入后台。某些时候需要进入容器进行操作，有很多种方法，包括使用docker attach 命令或nsenter命令。<br>使用docker attach进入容器<br>docker attach 是Docker自带的命令。下面示例如何使用该命令。</p><pre><code>[root@localhost ~]# docker attach 56c3adf740ba [root@56c3adf740ba /]#</code></pre><p>或：</p><p>或：</p><pre><code>[root@localhost ~]# docker attach --sig-proxy=false 56c3adf740ba [root@56c3adf740ba /]#</code></pre><p>1．docker attach 允许我们进入后台进程.<br>2．–sig-proxy=false 不使用容器转发信号，允许我们使用 ctrl -c 来退出，执行dockerps查看在后台运行<br>但是使用 attach命令有时候并不方便。当多个窗口同时 attach 到同一个容器的时候，所有窗口都会同步显示。当某个窗口因命令阻塞时,其他窗口也无法执行操作了。</p><p>1．docker attach 允许我们进入后台进程.<br>2．–sig-proxy=false 不使用容器转发信号，允许我们使用 ctrl -c 来退出，执行dockerps查看在后台运行<br>但是使用 attach命令有时候并不方便。当多个窗口同时 attach 到同一个容器的时候，所有窗口都会同步显示。当某个窗口因命令阻塞时,其他窗口也无法执行操作了。</p><p>也可以执行docker exec进入运行的容器</p><pre><code>docker  exec  -it  容器ID/名称 /bin/bash</code></pre><p>以上命令返回一个命令界面，exec代表直接在容器中运行命令</p><p>以上命令返回一个命令界面，exec代表直接在容器中运行命令</p><pre><code>[root@localhost ~]# docker exec -it 56c3adf740ba[root@56c3adf740ba /]#</code></pre><h5 id="9、使用nsenter进入容器"><a href="#9、使用nsenter进入容器" class="headerlink" title="9、使用nsenter进入容器"></a>9、使用nsenter进入容器</h5><p>安装<br>nsenter工具在util-linux包2.23版本后包含。如果系统中util-linux包没有该命令，可以按照下面的方法从源码安装</p><pre><code>#wgethttps://www.kernel.org/pub/linux/utils/util-linux/v2.24/util-linux-2.24.tar.gz#tar util-linux-2.24.tar.gz#cd util-linux-2.24./configure --without-ncurses&amp;&amp; make nsenter#cpnsenter /usr/local/bin</code></pre><p>nsenter可以访问另一个进程的名字空间。nsenter要正常工作需要有 root 权限<br>庆幸的是centos7使用的是util-linux-2.23，所以就直接使用系统提供的util-linux包了。</p><p>nsenter可以访问另一个进程的名字空间。nsenter要正常工作需要有 root 权限<br>庆幸的是centos7使用的是util-linux-2.23，所以就直接使用系统提供的util-linux包了。</p><pre><code>[root@localhost ~]# rpm -q util-linuxutil-linux-2.23.2-26.el7.x86_64</code></pre><p>为了连接到容器，你还需要找到容器的第一个进程的PID，可以通过下面的命令获取。</p><p>为了连接到容器，你还需要找到容器的第一个进程的PID，可以通过下面的命令获取。</p><pre><code>PID=$(docker inspect --format &quot;{{ .State.Pid }}&quot; &lt;container&gt;)</code></pre><p>通过这个PID，就可以连接到这个容器：</p><pre><code>nsenter --target $PID --mount --uts --ipc --net --pid</code></pre><p>下面给出一个完整的例子。<br><img src="https://img2018.cnblogs.com/blog/1829796/201910/1829796-20191022110908741-1979087383.png" alt=""></p><p>下面给出一个完整的例子。</p><p>通过这个PID，就可以连接到这个容器：</p><pre><code>nsenter --target $PID --mount --uts --ipc --net --pid</code></pre><p>下面给出一个完整的例子。</p><p>下面给出一个完整的例子。</p><p>附：更简单的，建议大家下载 .bashrc_docker，并将内容放到 .bashrc中。</p><pre><code>#wget  ~ https://github.com/yeasy/docker_practice/raw/master/_local/.bashrc_docker#echo &quot;[ -f ~/.bashrc_docker ] &amp;&amp;. ~/.bashrc_docker&quot; &gt;&gt; ~/.bashrc#source ~/.bashrc</code></pre><p>这个文件中定义了很多方便使用 Docker 的命令，例如docker-pid可以获取某个容器的PID；而docker-enter 可以进入容器或直接在容器内执行命令。</p><p>这个文件中定义了很多方便使用 Docker 的命令，例如docker-pid可以获取某个容器的PID；而docker-enter 可以进入容器或直接在容器内执行命令。</p><pre><code>echo $(docker-pid&lt;container&gt;)docker-enter &lt;container&gt; ls</code></pre><p>容器导入和导出<br>导出容器：<br>docker export [容器 id] &gt; [导出文件]<br>如果要导出本地某个容器，可以使用docker export 命令。</p><pre><code>[root@localhost ~]# docker export 56c3adf740ba &gt; centos_web.tar[root@localhost ~]# lsanaconda-ks.cfgcentos6.tarcentos7.tarcentos_web.tar</code></pre><p>这样将导出容器快照到本地文件</p><p>这样将导出容器快照到本地文件</p><p>导入容器：<br>可以使用docker import 从容器快照文件中再导入为镜像</p><pre><code>cat centos6.tar | docker import – centos6:test</code></pre><p>docker images</p><pre><code>[root@localhost ~]# cat centos_web.tar | docker import - centos:websha256:4429751684b5529cb70ddd080ada1462b3dfe2f48651c02a42c8ebd794a11c7d[root@localhost ~]# docker images REPOSITORY       TAG               IMAGE ID          CREATED           SIZEcentos            web              4429751684b5      4 seconds ago     196.7 MB</code></pre><p>此外，也可以通过指定 URL 或者某个目录来导入，例如<br>docker import <a href="http://example.com/exampleimage.tgzexample/imagerepo" target="_blank" rel="noopener">http://example.com/exampleimage.tgzexample/imagerepo</a><br>*注：用户既可以使用docker load 来导入镜像存储文件到本地镜像库，也可以使用docker import 来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</p><p>此外，也可以通过指定 URL 或者某个目录来导入，例如<br>docker import <a href="http://example.com/exampleimage.tgzexample/imagerepo" target="_blank" rel="noopener">http://example.com/exampleimage.tgzexample/imagerepo</a><br>*注：用户既可以使用docker load 来导入镜像存储文件到本地镜像库，也可以使用docker import 来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</p><p>删除容器<br>可以使用dockerrm来删除一个处于终止状态的容器。<br>如果要删除一个运行中的容器，可以添加 -f 参数。Docker 会发送SIGKILL信号给容器。</p><p>docker rm [容器 id/容器 name]</p><pre><code>[root@localhost ~]# docker rm -f 3db07fa904c93db07fa904c9</code></pre><p>批量删除多个容器<br>docker rm $(docker ps –a –q)</p><pre><code>[root@localhost ~]# docker rm -f $(docker ps -a)56c3adf740bae674da52f432acb16411ba25eea3221f0dac</code></pre><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Oct 24 2019 09:58:29 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;一、Docker简介&quot;&gt;&lt;a href=&quot;#一、Docker简介&quot; class=&quot;headerlink&quot; title=&quot;一、Docke
      
    
    </summary>
    
    
      <category term="docker" scheme="http://chenzhonzhou.github.io/categories/docker/"/>
    
    
      <category term="docker" scheme="http://chenzhonzhou.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>yum 安装docker</title>
    <link href="http://chenzhonzhou.github.io/2018/09/01/yum-an-zhuang-docker/"/>
    <id>http://chenzhonzhou.github.io/2018/09/01/yum-an-zhuang-docker/</id>
    <published>2018-09-01T03:05:15.000Z</published>
    <updated>2019-10-23T06:40:36.606Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Oct 24 2019 09:58:29 GMT+0800 (GMT+08:00) --><h4 id="1-安装docker-1-13-0"><a href="#1-安装docker-1-13-0" class="headerlink" title="1. 安装docker 1.13.0"></a>1. 安装docker 1.13.0</h4><h5 id="1-1-安装yum源"><a href="#1-1-安装yum源" class="headerlink" title="1.1 安装yum源"></a>1.1 安装yum源</h5><pre><code>curl -f sSL https://get.docker.com/ | sh -s -- --mirror AzureChinaCloud</code></pre><p>或：</p><pre><code>wget https://docs.docker.com/v1.13/engine/installation/linux/repo_files/centos/docker.repo</code></pre><h5 id="1-2-安装最新版的docker"><a href="#1-2-安装最新版的docker" class="headerlink" title="1.2 安装最新版的docker"></a>1.2 安装最新版的docker</h5><pre><code>yum makecache fastyum -y install docker-engine</code></pre><p>或者安装其他版本docker</p><pre><code>yum list docker-engine.x86_64  --showduplicates |sort -ryum -y install docker-engine-&lt;VERSION_STRING&gt;</code></pre><h5 id="1-3-把当前用户加入docker用户组"><a href="#1-3-把当前用户加入docker用户组" class="headerlink" title="1.3 把当前用户加入docker用户组"></a>1.3 把当前用户加入docker用户组</h5><pre><code>sudo groupadd dockersudo usermod -aG docker $USER</code></pre><h4 id="2-yum-安装docker-1-26"><a href="#2-yum-安装docker-1-26" class="headerlink" title="2. yum 安装docker 1.26"></a>2. yum 安装docker 1.26</h4><h5 id="2-1-配置docker-yum-源"><a href="#2-1-配置docker-yum-源" class="headerlink" title="2.1 配置docker yum 源"></a>2.1 配置docker yum 源</h5><pre><code>cat &gt; /etc/yum.repos.d/docker.repo &lt;&lt;-EOF[dockerrepo]name=Docker Repositorybaseurl=https://yum.dockerproject.org/repo/experimental/centos/7/enabled=1gpgcheck=1gpgkey=https://yum.dockerproject.org/gpgEOF</code></pre><h5 id="2-2-安装组件"><a href="#2-2-安装组件" class="headerlink" title="2.2 安装组件"></a>2.2 安装组件</h5><pre><code>yum -y install docker-enginecurl -fsSL https://get.docker.com/ | sh 或者 wget -qO- https://get.docker.com/ |sh</code></pre><h5 id="2-3-启动"><a href="#2-3-启动" class="headerlink" title="2.3 启动"></a>2.3 启动</h5><p>systemctl start docker 启动 docker<br>systemctl enable docker 设置开机启动</p><h5 id="2-4-docker-compose环境安装"><a href="#2-4-docker-compose环境安装" class="headerlink" title="2.4 docker-compose环境安装"></a>2.4 docker-compose环境安装</h5><pre><code>yum install python-pip -ypip install docker-composedocker-compose -version</code></pre><p>下载二进制可执行文件的方式安装Docker-compose(推荐)</p><pre><code>curl -L https://github.com/docker/compose/releases/download/1.14.0/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-composechmod +x /usr/local/bin/docker-compose</code></pre><h5 id="2-5-docker加速（链接为阿里云docker镜像仓库，登录即可领取属于你的加速地址）"><a href="#2-5-docker加速（链接为阿里云docker镜像仓库，登录即可领取属于你的加速地址）" class="headerlink" title="2.5 docker加速（链接为阿里云docker镜像仓库，登录即可领取属于你的加速地址）"></a>2.5 docker加速（链接为阿里云docker镜像仓库，登录即可领取属于你的加速地址）</h5><p><a href="https://account.aliyun.com/login/login.htm?oauth_callback=https%3A%2F%2Fcr.console.aliyun.com%2F&amp;lang=zh#/accelerator" target="_blank" rel="noopener">https://account.aliyun.com/login/login.htm?oauth_callback=https%3A%2F%2Fcr.console.aliyun.com%2F&amp;lang=zh#/accelerator</a></p><pre><code>vim /etc/docker/daemon.json{  &quot;registry-mirrors&quot;: [&quot;https://av7k0o0o.mirror.aliyuncs.com&quot;]}</code></pre><h5 id="2-6-harbor-删除镜像及资源回收"><a href="#2-6-harbor-删除镜像及资源回收" class="headerlink" title="2.6 harbor 删除镜像及资源回收"></a>2.6 harbor 删除镜像及资源回收</h5><pre><code>$ docker-compose stop$ docker run -it --name gc --rm --volumes-from deploy_registry_1 registry:2.5.0 garbage-collect --dry-run /etc/registry/config.yml$ docker-compose start</code></pre><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Oct 24 2019 09:58:29 GMT+0800 (GMT+08:00) --&gt;&lt;h4 id=&quot;1-安装docker-1-13-0&quot;&gt;&lt;a href=&quot;#1-安装docker-1-13-0&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
      <category term="docker" scheme="http://chenzhonzhou.github.io/categories/docker/"/>
    
    
      <category term="docker" scheme="http://chenzhonzhou.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>mm_wiki部署企业文档平台</title>
    <link href="http://chenzhonzhou.github.io/2018/08/10/mm-wiki-bu-shu-qi-ye-wen-dang-ping-tai/"/>
    <id>http://chenzhonzhou.github.io/2018/08/10/mm-wiki-bu-shu-qi-ye-wen-dang-ping-tai/</id>
    <published>2018-08-10T07:13:45.000Z</published>
    <updated>2019-10-22T12:21:59.499Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Oct 24 2019 09:58:29 GMT+0800 (GMT+08:00) --><p><strong>github地址：</strong></p><p><a href="https://github.com/phachon/mm-wiki" target="_blank" rel="noopener">https://github.com/phachon/mm-wiki</a></p><p>github项目上安装非常简单，不做介绍</p><p>修改分享文档最下方显示公司版权，修改 ./views/page/display.html 文件。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Oct 24 2019 09:58:29 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;strong&gt;github地址：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/phachon/mm-
      
    
    </summary>
    
    
      <category term="wiki" scheme="http://chenzhonzhou.github.io/categories/wiki/"/>
    
    
      <category term="wiki" scheme="http://chenzhonzhou.github.io/tags/wiki/"/>
    
  </entry>
  
</feed>
