<!-- build time:Tue Dec 21 2021 14:39:49 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html class="theme-next gemini use-motion" lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script><link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet"><script></script><meta name="theme-color" content="#222"><style>.pace .pace-progress{background:#1E92FB;height:3px}.pace .pace-progress-inner{box-shadow:0 0 10px #1E92FB,0 0 5px #1E92FB}.pace .pace-activity{border-top-color:#1E92FB;border-left-color:#1E92FB}</style><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="google-site-verification" content="HGM141IpbHrSmnAmR6W_zE4bo9Z3f-yXLeHYT3bg1fk"><meta name="baidu-site-verification" content="code-5Ai1DA8e6T"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4"><link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222"><meta name="keywords" content="Hadoop,OLAP,Druid,"><link rel="alternate" href="/atom.xml" title="凡间的精灵" type="application/atom+xml"><meta name="description" content="一、简介Apache Druid 是一个实时分析数据库，专为大型数据集进行快速的查询分析（OLAP 查询）而设计。Druid最常被当做数据库来用以支持实时摄取、高性能查询和高稳定运行的应用场景。Druid也通常被用来助力分析型应用的图形化界面，或者当做需要快速聚合的高并发后端API，Druid最适合应用于面向事件类型的数据。1.1 Druid 常见应用领域Druid的常见应用领域包括：点击流分析（"><meta name="keywords" content="Hadoop,OLAP,Druid"><meta property="og:type" content="article"><meta property="og:title" content="Apache Druid 联机分析处理(OLAP)"><meta property="og:url" content="http:&#x2F;&#x2F;chenzhonzhou.github.io&#x2F;2021&#x2F;11&#x2F;24&#x2F;apache-druid-lian-ji-fen-xi-chu-li-olap&#x2F;index.html"><meta property="og:site_name" content="凡间的精灵"><meta property="og:description" content="一、简介Apache Druid 是一个实时分析数据库，专为大型数据集进行快速的查询分析（OLAP 查询）而设计。Druid最常被当做数据库来用以支持实时摄取、高性能查询和高稳定运行的应用场景。Druid也通常被用来助力分析型应用的图形化界面，或者当做需要快速聚合的高并发后端API，Druid最适合应用于面向事件类型的数据。1.1 Druid 常见应用领域Druid的常见应用领域包括：点击流分析（"><meta property="og:locale" content="zh-Hans"><meta property="og:image" content="http:&#x2F;&#x2F;chenzhonzhou.github.io&#x2F;2021&#x2F;11&#x2F;24&#x2F;apache-druid-lian-ji-fen-xi-chu-li-olap&#x2F;%E5%9B%BE%E7%89%873.png"><meta property="og:image" content="http:&#x2F;&#x2F;chenzhonzhou.github.io&#x2F;2021&#x2F;11&#x2F;24&#x2F;apache-druid-lian-ji-fen-xi-chu-li-olap&#x2F;%E5%9B%BE%E7%89%874.png"><meta property="og:image" content="http:&#x2F;&#x2F;chenzhonzhou.github.io&#x2F;2021&#x2F;11&#x2F;24&#x2F;apache-druid-lian-ji-fen-xi-chu-li-olap&#x2F;%E5%9B%BE%E7%89%875.png"><meta property="og:image" content="http:&#x2F;&#x2F;chenzhonzhou.github.io&#x2F;2021&#x2F;11&#x2F;24&#x2F;apache-druid-lian-ji-fen-xi-chu-li-olap&#x2F;%E5%9B%BE%E7%89%871.png"><meta property="og:image" content="http:&#x2F;&#x2F;chenzhonzhou.github.io&#x2F;2021&#x2F;11&#x2F;24&#x2F;apache-druid-lian-ji-fen-xi-chu-li-olap&#x2F;%E5%9B%BE%E7%89%872.png"><meta property="og:image" content="http:&#x2F;&#x2F;chenzhonzhou.github.io&#x2F;2021&#x2F;11&#x2F;24&#x2F;apache-druid-lian-ji-fen-xi-chu-li-olap&#x2F;%E5%9B%BE%E7%89%873.png"><meta property="og:image" content="http:&#x2F;&#x2F;chenzhonzhou.github.io&#x2F;2021&#x2F;11&#x2F;24&#x2F;apache-druid-lian-ji-fen-xi-chu-li-olap&#x2F;%E5%9B%BE%E7%89%871.png"><meta property="og:image" content="http:&#x2F;&#x2F;chenzhonzhou.github.io&#x2F;2021&#x2F;11&#x2F;24&#x2F;apache-druid-lian-ji-fen-xi-chu-li-olap&#x2F;%E5%9B%BE%E7%89%876.png"><meta property="og:image" content="http:&#x2F;&#x2F;chenzhonzhou.github.io&#x2F;2021&#x2F;11&#x2F;24&#x2F;apache-druid-lian-ji-fen-xi-chu-li-olap&#x2F;%E5%9B%BE%E7%89%877.png"><meta property="og:image" content="http:&#x2F;&#x2F;chenzhonzhou.github.io&#x2F;2021&#x2F;11&#x2F;24&#x2F;apache-druid-lian-ji-fen-xi-chu-li-olap&#x2F;%E5%9B%BE%E7%89%878.png"><meta property="og:image" content="http:&#x2F;&#x2F;chenzhonzhou.github.io&#x2F;2021&#x2F;11&#x2F;24&#x2F;apache-druid-lian-ji-fen-xi-chu-li-olap&#x2F;%E5%9B%BE%E7%89%879.png"><meta property="og:image" content="http:&#x2F;&#x2F;chenzhonzhou.github.io&#x2F;2021&#x2F;11&#x2F;24&#x2F;apache-druid-lian-ji-fen-xi-chu-li-olap&#x2F;%E5%9B%BE%E7%89%8710.png"><meta property="og:image" content="http:&#x2F;&#x2F;chenzhonzhou.github.io&#x2F;2021&#x2F;11&#x2F;24&#x2F;apache-druid-lian-ji-fen-xi-chu-li-olap&#x2F;%E5%9B%BE%E7%89%8711.png"><meta property="og:image" content="http:&#x2F;&#x2F;chenzhonzhou.github.io&#x2F;2021&#x2F;11&#x2F;24&#x2F;apache-druid-lian-ji-fen-xi-chu-li-olap&#x2F;%E5%9B%BE%E7%89%8712.png"><meta property="og:updated_time" content="2021-12-09T06:41:11.802Z"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http:&#x2F;&#x2F;chenzhonzhou.github.io&#x2F;2021&#x2F;11&#x2F;24&#x2F;apache-druid-lian-ji-fen-xi-chu-li-olap&#x2F;%E5%9B%BE%E7%89%873.png"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Gemini",version:"5.1.4",sidebar:{position:"left",display:"always",offset:12,b2t:!0,scrollpercent:!0,onmobile:!0},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://chenzhonzhou.github.io/2021/11/24/apache-druid-lian-ji-fen-xi-chu-li-olap/"><title>Apache Druid 联机分析处理(OLAP) | 凡间的精灵</title><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">凡间的精灵</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">凡尘落素一精灵</p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-categories"><a href="/categories" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="menu-item-icon fa fa-fw fa-sitemap"></i><br>站点地图</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i> </span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://chenzhonzhou.github.io/2021/11/24/apache-druid-lian-ji-fen-xi-chu-li-olap/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Zhongzhou Chen"><meta itemprop="description" content=""><meta itemprop="image" content="/images/chen.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="凡间的精灵"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Apache Druid 联机分析处理(OLAP)</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-11-24T16:25:33+08:00">2021-11-24 </time></span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Hadoop/" itemprop="url" rel="index"><span itemprop="name">Hadoop</span></a></span></span><div class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">14.2k </span><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">54</span></div></div></header><div class="post-body" itemprop="articleBody"><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p><a href="https://druid.apache.org/" target="_blank" rel="noopener">Apache Druid</a> 是一个实时分析数据库，专为大型数据集进行快速的查询分析（OLAP 查询）而设计。Druid最常被当做数据库来用以支持实时摄取、高性能查询和高稳定运行的应用场景。Druid也通常被用来助力分析型应用的图形化界面，或者当做需要快速聚合的高并发后端API，Druid最适合应用于面向事件类型的数据。</p><h3 id="1-1-Druid-常见应用领域"><a href="#1-1-Druid-常见应用领域" class="headerlink" title="1.1 Druid 常见应用领域"></a>1.1 Druid 常见应用领域</h3><p>Druid的常见应用领域包括：</p><ul><li>点击流分析（网络和移动分析）</li><li>网络遥测分析（网络性能监控）</li><li>服务器指标存储</li><li>供应链分析（制造指标）</li><li>应用程序性能指标</li><li>数字营销/广告分析</li><li>商业智能/OLAP</li></ul><h3 id="1-2-Druid-的三个设计原则"><a href="#1-2-Druid-的三个设计原则" class="headerlink" title="1.2 Druid 的三个设计原则"></a>1.2 Druid 的三个设计原则</h3><h4 id="1-2-1-快速查询"><a href="#1-2-1-快速查询" class="headerlink" title="1.2.1 快速查询"></a>1.2.1 快速查询</h4><p>对于数据分析场景，大部分情况下，我们只关心一定粒度聚合的数据，而非每一行原始数据的细节情况。因此，数据聚合粒度可以是1分钟、5分钟、1小时或1天等。部分数据聚合（Partial Aggregate）给Druid争取了很大的性能优化空间。<br>数据内存化也是提高查询速度的杀手锏。内存和硬盘的访问速度相差近百倍，但内存的大小是非常有限的，因此在内存使用方面要精细设计，比如Druid里面使用了Bitmap和各种压缩技术。<br>另外，为了支持Drill-Down某些维度，Druid维护了一些倒排索引。这种方式可以加快AND和OR等计算操作。</p><h4 id="1-2-2-水平扩展能力"><a href="#1-2-2-水平扩展能力" class="headerlink" title="1.2.2 水平扩展能力"></a>1.2.2 水平扩展能力</h4><p>Druid 查询性能在很大程度上依赖于内存的优化使用。数据可以分布在多个节点的内存中，因此当数据增长的时候，可以通过简单增加机器的方式进行扩容。为了保持平衡，Druid按照时间范围把聚合数据进行分区处理。对于高基数的维度，只按照时间切分有时候是不够的（Druid的每个Segment不超过2000万行），故Druid还支持对Segment进一步分区。<br>历史Segment数据可以保存在深度存储系统中，存储系统可以是本地磁盘、HDFS或远程的云服务。如果某些节点出现故障，则可借助Zookeeper协调其他节点重新构造数据。Druid内置了容易并行化的集合操作，在直方图方面和去重查询方面采用近似算法保证性能，如HyperLoglog，DataSketches等。</p><h4 id="1-2-3-实时分析"><a href="#1-2-3-实时分析" class="headerlink" title="1.2.3 实时分析"></a>1.2.3 实时分析</h4><p>Druid提供了包含基于时间维度数据的存储服务，并且任何一行数据都是历史真实发生的事件，因此在设计之初就约定事件一但进入系统，就不能再改变。<br>对于历史数据Druid以Segment数据文件的方式组织，并且将它们存储到深度存储系统中，例如文件系统或亚马逊的S3等。当需要查询这些数据的时候，Druid再从深度存储系统中将它们装载到内存供查询使用。</p><h3 id="1-3-特点"><a href="#1-3-特点" class="headerlink" title="1.3 特点"></a>1.3 特点</h3><p>Druid的核心架构吸收和结合了<strong>数据仓库</strong>、<strong>时序数据库</strong>以及<strong>检索系统</strong>的优势，其主要特征如下：</p><ul><li><strong>面向列的存储：</strong>Druid 单独存储和压缩每一列，只需要读取特定查询所需的列，支持快速扫描、排名和 groupBys。</li><li><strong>本地搜索索引：</strong>Druid 为字符串值创建倒排索引以进行快速搜索和过滤。</li><li><strong>流式传输和批量摄取：</strong>适用于 Apache Kafka、HDFS、AWS S3、流处理器等的开箱即用连接器。</li><li><strong>灵活的模式：</strong>Druid 优雅地处理不断变化的模式和<a href="https://druid.apache.org/docs/latest/ingestion/flatten-json" target="_blank" rel="noopener">嵌套数据</a>。</li><li><strong>时间优化分区：</strong>Druid根据时间对数据进行智能分区，基于时间的查询速度明显快于传统数据库。</li><li><strong>SQL 支持：</strong>除了其原生的<a href="https://druid.apache.org/docs/latest/querying/querying" target="_blank" rel="noopener">基于 JSON 的语言外</a>，Druid 还通过 HTTP 或 JDBC 使用<a href="https://druid.apache.org/docs/latest/querying/sql" target="_blank" rel="noopener">SQL</a>。</li><li><strong>水平扩展性：</strong>Druid 已<a href="https://druid.apache.org/druid-powered" target="_blank" rel="noopener">在生产中</a>用于每秒摄取数百万个事件、保留多年数据并提供亚秒级查询。</li><li><strong>操作简单：</strong>只需添加或删除服务器即可扩大或缩小规模，Druid 会自动重新平衡。容错架构围绕服务器故障进行路由。</li></ul><h3 id="1-4-数据格式"><a href="#1-4-数据格式" class="headerlink" title="1.4 数据格式"></a>1.4 数据格式</h3><ul><li><p>数据源（类似数据库中表的概念，存放一类数据）</p><ul><li>时间列：每个数据源都需要有的事件时间，是预聚合的主要依据；</li><li>维度列：用于标识事件和属性，用于聚合；</li><li>指标列：用于聚合计算的列，通常是关键量化指标；</li></ul><p><img src="/2021/11/24/apache-druid-lian-ji-fen-xi-chu-li-olap/%E5%9B%BE%E7%89%873.png" alt="图片3"></p></li><li><p>数据摄入</p><ul><li>实时摄入：Kafka；</li><li>批量摄入：HDFS、CSV等；</li></ul><p><img src="/2021/11/24/apache-druid-lian-ji-fen-xi-chu-li-olap/%E5%9B%BE%E7%89%874.png" alt="图片4"></p></li><li><p>数据查询</p><ul><li>原生Json查询，Http接口；</li><li><a href="https://druid.apache.org/docs/latest/querying/sql" target="_blank" rel="noopener">SQL</a>查询，除了标准 SQL 运算符之外，Druid 还支持独特的运算符，这些运算符利用其近似算法套件来提供快速计数、排名和分位数。</li></ul><p><img src="/2021/11/24/apache-druid-lian-ji-fen-xi-chu-li-olap/%E5%9B%BE%E7%89%875.png" alt="图片5"></p></li></ul><h3 id="1-5-数据保障"><a href="#1-5-数据保障" class="headerlink" title="1.5 数据保障"></a>1.5 数据保障</h3><p>Druid 旨在为需要每周 7 天、每天 24 小时不间断运行的应用程序提供支持。因此，德鲁伊拥有多项功能，可确保正常运行且不会丢失数据。</p><p><strong>数据复制</strong></p><blockquote><p>Druid 中的所有数据都复制了可配置的次数，因此单个服务器故障不会对查询产生影响。</p></blockquote><p><strong>独立服务</strong></p><blockquote><p>Druid 明确命名其所有主要服务，每个服务都可以根据用例进行微调。服务可以独立失败而不影响其他服务。例如，如果摄取服务失败，系统中不会加载新数据，但现有数据仍可查询。</p></blockquote><p><strong>自动数据备份</strong></p><blockquote><p>Druid 自动将所有索引数据备份到 HDFS 等文件系统。您可能会丢失整个 Druid 集群并从这些备份数据中快速恢复它。</p></blockquote><p><strong>滚动更新</strong></p><blockquote><p>您可以通过滚动更新在不停机的情况下更新 Druid 集群，也不会对最终用户产生影响。所有德鲁伊版本都向后兼容以前的版本。</p></blockquote><h3 id="1-6-优缺点"><a href="#1-6-优缺点" class="headerlink" title="1.6 优缺点"></a>1.6 优缺点</h3><p>优点：<br>1、支持的数据规模大(本地存储+DeepStorage–HDFS)；<br>2、性能高，列存压缩，预聚合加上倒排索引以及位图索引，秒级查询；<br>3、实时性高，可以通过kafka实时导入数据。</p><p>缺点：<br>1、灵活性适中，虽然维度之间随意组合，但不支持adhoc查询，不能自由组合查询，且丢失了明细数据（不采用roll-up情况下可以进行明细查询）；<br>2、易用性较差，不支持join，不支持更新，sql支持很弱(有些插件类似于pinot的PQL语言)，只能JSON格式查询，对于去重操作不能精准去重；<br>3、处理方式复杂，需要流处理引擎将数据join成宽表，维护相对复杂；对内存要求较高。</p><h3 id="1-7-适合的业务"><a href="#1-7-适合的业务" class="headerlink" title="1.7 适合的业务"></a>1.7 适合的业务</h3><ul><li>时序化数据：Druid 可以理解为时序数据库，所有的数据必须有时间字段；</li><li>实时数据接入可容忍丢数据(tranquility)：目前 tranquility 有丢数据的风险，所以建议实时和离线一起用，实时接当天数据，离线第二天把今天的数据全部覆盖，保证数据完备性；</li><li>OLAP 查询而不是 OLTP 查询：Druid 查询并发有限，不适合 OLTP 查询；</li><li>非精确的去重计算：目前 Druid 的去重都是非精确的；</li><li>无 Join 操作：Druid 适合处理星型模型的数据，不支持关联操作；</li><li>数据没有 update 更新操作，只对 segment 粒度进行覆盖：由于时序化数据的特点，Druid 不支持数据的更新。</li></ul><h3 id="1-8-高可用性"><a href="#1-8-高可用性" class="headerlink" title="1.8 高可用性"></a>1.8 高可用性</h3><ul><li><strong>MetaStore挂掉：</strong>无法感知新的Segment生成，不影响老数据；</li><li><strong>Indexing Service挂掉：</strong>无法执行新的任务，新数据无法摄入，不影响查询；</li><li><strong>Broker挂掉：</strong>本Broker节点不能查询，其他节点Broker继续服务，不影响数据摄入；</li><li><strong>Historical挂掉：</strong>Coordinator Node重分配该节点上segment到其它节点；</li><li><strong>Coordinator挂掉：</strong>Segment不会被加载和删除，选举新leader；</li><li><strong>Zookeeper挂掉：</strong>无法执行新的任务，新数据进不来；Broker有缓存。</li></ul><h2 id="二、基本架构"><a href="#二、基本架构" class="headerlink" title="二、基本架构"></a>二、基本架构</h2><p><img src="/2021/11/24/apache-druid-lian-ji-fen-xi-chu-li-olap/%E5%9B%BE%E7%89%871.png" alt="图片1"></p><h3 id="2-1-内部进程"><a href="#2-1-内部进程" class="headerlink" title="2.1 内部进程"></a>2.1 内部进程</h3><h4 id="2-1-1-Coordinator"><a href="#2-1-1-Coordinator" class="headerlink" title="2.1.1 Coordinator"></a>2.1.1 Coordinator</h4><p><strong>协调节点（Coordinator）</strong>主要负责历史节点的数据负载均衡，以及通过规则（Rule） 管理数据的生命周期。协调节点告诉历史节点加载新数据、卸载过期数据、复制数据、 和为了负载均衡移动数据。</p><p>Coordinator 是周期性运行的（由 druid.coordinator.period 配置指定，默认执行间隔为 60s）。因为需要评估集群的当前状态，才能决定应用哪种策略，所以，Coordinator 需要维护和 ZooKeeper 的连接，以获取集群的信息。而关于 Segment 和 Rule 的信息保存在了元数据库中，所以也需要维护与元数据库的连接。</p><h4 id="2-1-2-Overlord"><a href="#2-1-2-Overlord" class="headerlink" title="2.1.2 Overlord"></a>2.1.2 Overlord</h4><p><strong>统治者(Overlord）</strong>进程监视 MiddleManager 进程，并且是数据摄入 Druid 的控制器。他们负责将提取任务分配给 MiddleManagers 并协调 Segement 发布，包括接受、拆解、分配 Task，以及创建 Task 相关的锁，并返回 Task 的状态。</p><h4 id="2-1-3-Broker"><a href="#2-1-3-Broker" class="headerlink" title="2.1.3 Broker"></a>2.1.3 Broker</h4><p><strong>查询节点（Broker）</strong>接收客户端查询请求，并将这些查询转发给 Historicals 和 MiddleManagers。当 Brokers 从这些子查询中收到结果时，它们会合并这些结果并将它们返回给调用者。</p><h4 id="2-1-4-Router"><a href="#2-1-4-Router" class="headerlink" title="2.1.4 Router"></a>2.1.4 Router</h4><p>Router 将请求路由到Broker, Coordinators和Overlords，进程可以在 Brokers、Overlords 和 Coordinators 进程之上，提供一层统一的 API网关。Router 进程是<strong>可选</strong>进程，不过如果集群的数据规模已经达到了 TB级别，还是需要考虑启用的（<code>druid.router.managementProxy.enabled=true</code>）。因为一旦集群规模达到一定的数量级，那么发生故障的概率就会变得不容忽视，而 Router 支持将请求只发送给健康的节点，避免请求失败。同时，查询的响应时间和资源消耗，也会随着数据量的增长而变高，而 Router 支持设置查询的优先级和负载均衡策略，避免了大查询造成的队列堆积或查询热点等问题。</p><p>另外，Router 节点还可用于将查询路由到不同的 Broker 节点，便于实现冷热分层，以更好地应对超大规模数据集。默认情况下，Router 会根据设置的 Rule 规则，来路由查询请求。例如，如果将最近一个月的数据加载到热集群中，则最近一个月内的查询可以路由到一组专用 Broker，超出该时间范围的查询将被路由到另一组 Broker，如此便实现了查询的冷热隔离。</p><h4 id="2-1-5-Historical"><a href="#2-1-5-Historical" class="headerlink" title="2.1.5 Historical"></a>2.1.5 Historical</h4><p><strong>历史节点（Historical）</strong>加载已生成好的数据文件，以供数据查询。historical 节点是整个集群查询性能的核心所在，因为 historical 会承担绝大部分的 segment 查询。<br>Historical 进程从 Deep Storage 中下载 Segment，并响应有关这些 Segment 的查询请求（这些请求来自Broker 进程）。另外，Historical 进程不处理写入请求 。<br>Historical 进程采用了无共享架构设计，它知道如何去加载和删除 Segment，以及如何基于 Segment 来响应查询。因此，即便底层的 Deep Storage无法正常工作，Historical 进程还是能针对其已同步的 Segments，正常提供查询服务。</p><h4 id="2-1-6-MiddleManager"><a href="#2-1-6-MiddleManager" class="headerlink" title="2.1.6 MiddleManager"></a>2.1.6 MiddleManager</h4><p><strong>中间管理节点（MiddleManager）</strong>及时摄入实时数据，已生成 Segment 数据文件。<br>MiddleManager 进程是执行提交的任务的工作节点。Middle Managers 将任务转发给在不同 JVM 中运行的 Peon进程（如此，可以做到资源和日志的隔离）。MiddleManager、Peon、Task 的对应关系是，每个 Peon 进程一次只能运行一个Task 任务，但一个 MiddleManager 却可以管理多个 Peon 进程。</p><p>Druid进程可以按照您喜欢的任何方式进行部署，但是为了便于部署，我们建议将其组织为三种服务器类型：</p><ul><li><strong>Master</strong>: <code>Coordinator</code>, <code>Overload</code> 运行协调器和领主进程，管理数据可用性和接收；</li><li><strong>Query</strong>: <code>Broker</code> and <code>Router</code>，行代理和可选的路由器进程，处理来自外部客户端的查询；</li><li><strong>Data</strong>: <code>Historical</code> and <code>MiddleManager</code>，运行Historical和MiddleManager进程，执行提取工作负载并存储所有可查询的数据。</li></ul><h3 id="2-2-外部依赖"><a href="#2-2-外部依赖" class="headerlink" title="2.2 外部依赖"></a>2.2 外部依赖</h3><h4 id="2-2-1-深度储存"><a href="#2-2-1-深度储存" class="headerlink" title="2.2.1 深度储存"></a>2.2.1 深度储存</h4><p><strong>深度储存（Deep Storage）</strong>：存放生成的 Segment 数据文件，并供历史服务器下载， 对于单节点集群可以是本地磁盘，而对于分布式集群一般是 HDFS。</p><h4 id="2-2-2-元数据库"><a href="#2-2-2-元数据库" class="headerlink" title="2.2.2 元数据库"></a>2.2.2 元数据库</h4><p><strong>元数据库（Metadata Storage）</strong>，存储 Druid 集群的元数据信息，比如 Segment 的相关信息，一 般用 MySQL 或 PostgreSQL。</p><h4 id="2-2-3-Zookeeper"><a href="#2-2-3-Zookeeper" class="headerlink" title="2.2.3 Zookeeper"></a>2.2.3 Zookeeper</h4><p><strong>Zookeeper</strong>：为 Druid 集群提供以执行协调服务。如内部服务的监控，协调和领导者选举。</p><p>涵盖了以下的几个主要特性：</p><blockquote><p>Coordinator 节点的 Leader 选举；<br>Historical 节点发布 Segment 的协议；<br>Coordinator 和 Historical 之间 load/drop Segment 的协议；<br>Overlord 节点的 Leader 选举；<br>Overlord 和 MiddleManager 之间的 Task 管理。</p></blockquote><h3 id="2-3-Druid-主要功能特性"><a href="#2-3-Druid-主要功能特性" class="headerlink" title="2.3 Druid 主要功能特性"></a>2.3 Druid 主要功能特性</h3><p>Druid的核心体系结构结合了<strong>数据仓库</strong>，<strong>时间序列数据库</strong>和<strong>日志搜索系统</strong>的思想。Druid的一些主要功能是：</p><ol><li>列式存储格式。<br>Druid使用面向列的存储，这意味着它仅需要加载特定查询所需的确切列。这极大地提高了仅命中几列的查询的速度。此外，每列都针对其特定数据类型进行了优化存储，从而支持快速扫描和聚合。</li><li>可扩展的分布式系统。<br>Druid通常部署在数十到数百台服务器的群集中，并且可以提供每秒数百万条记录的接收速率，数万亿条记录的保留以及亚秒级到几秒的查询延迟。</li><li>大规模并行处理。<br>Druid可以在整个集群中并行处理查询。</li><li>实时或批量摄取。<br>Druid可以实时（批量获取被查询的数据）或批量提取数据。</li><li>自我修复，自我平衡，易于操作。<br>作为操作员，要扩展或扩展集群，只需添加或删除服务器，集群就会在后台自动重新平衡自身，而不会造成任何停机。如果任何Druid服务器出现故障，系统将自动绕过损坏，直到可以更换这些服务器为止。Druid设计为24*7全天候运行，而无需出于任何原因而导致计划内停机，包括配置更改和软件更新。</li><li>云原生的容错架构，不会丢失数据。<br>一旦Druid摄取了数据，副本就安全地存储在深度存储（通常是云存储，HDFS或共享文件系统）中。即使每台Druid服务器发生故障，也可以从深度存储中恢复数据。对于仅影响少数Druid服务器的有限故障，复制可确保在系统恢复时仍可进行查询。</li><li>用于快速过滤的索引。<br>Druid使用CONCISE或 Roaring压缩的位图索引来创建索引，以支持快速过滤和跨多列搜索。</li><li>基于时间的分区。<br>Druid首先按时间对数据进行分区，然后可以根据其他字段进行分区。这意味着基于时间的查询将仅访问与查询时间范围匹配的分区。这将大大提高基于时间的数据的性能。</li><li>近似算法。<br>Druid包括用于近似计数区别，近似排名以及近似直方图和分位数计算的算法。这些算法提供有限的内存使用量，通常比精确计算要快得多。对于精度比速度更重要的情况，Druid还提供了精确的计数区别和精确的排名。</li><li>摄取时自动汇总。<br>Druid可选地在摄取时支持数据汇总。这种汇总会部分地预先聚合您的数据，并可以节省大量成本并提高性能。</li></ol><h2 id="三、架构设计"><a href="#三、架构设计" class="headerlink" title="三、架构设计"></a>三、架构设计</h2><h3 id="3-1-存储设计"><a href="#3-1-存储设计" class="headerlink" title="3.1 存储设计"></a>3.1 存储设计</h3><h4 id="3-1-1-数据源和段"><a href="#3-1-1-数据源和段" class="headerlink" title="3.1.1 数据源和段"></a>3.1.1 数据源和段</h4><p>Datasources and segments</p><p>Druid 数据存储在 <strong>datasources</strong> 中，类似于传统RDBMS中的表。每个数据源都按时间分区，并且可以选择按其他属性进一步分区。每个时间范围都称为 <code>块</code>chunk（例如，如果您的数据源按天划分，则为一天）。在一个chunk内，数据被划分为一个或多个 <code>段</code>segments。每个段都是单个文件，通常包含多达几百万行的数据。由于细分是按时间块组织的，因此有时将段视为存在于如下时间线上是有帮助的：</p><p><img src="/2021/11/24/apache-druid-lian-ji-fen-xi-chu-li-olap/%E5%9B%BE%E7%89%872.png" alt="图片2"></p><p>数据源可能具有从几个段到数十万甚至数百万个段的任何位置。每个段都是从在MiddleManager上创建开始的，并且时段是可变的且未提交的。段构建过程包括以下步骤，旨在生成紧凑且支持快速查询的数据文件：</p><ul><li>转换为列格式</li><li>使用位图索引编制索引</li><li>使用各种算法进行压缩<ul><li>字符串列的ID存储最小化的字典编码</li><li>位图索引的位图压缩</li><li>所有列的类型感知压缩</li></ul></li></ul><p>分段会定期提交和发布。此时，它们被写入深度存储 <a href="https://druid.apache.org/docs/latest/design/architecture.html#deep-storage" target="_blank" rel="noopener">deep storage</a>，变得不可变，并从MiddleManagers迁移到Historical进程。有关该段的条目也将写入到元数据存储 <a href="https://druid.apache.org/docs/latest/design/architecture.html#metadata-storage" target="_blank" rel="noopener">metadata store</a>中。该条目是有关该段的元数据的自描述位，包括诸如段的模式，其大小以及其在深度存储上的位置之类的信息。这些条目是协调器用来了解集群上应该有哪些数据的内容。</p><p>有关段文件格式的详细信息，请参阅<a href="https://druid.apache.org/docs/latest/design/segments.html" target="_blank" rel="noopener">段文件</a>。<br>有关在Druid中对数据建模的详细信息，请参见<a href="https://druid.apache.org/docs/latest/ingestion/schema-design.html" target="_blank" rel="noopener">模式设计</a>。</p><h4 id="3-1-2-索引和切换"><a href="#3-1-2-索引和切换" class="headerlink" title="3.1.2 索引和切换"></a>3.1.2 索引和切换</h4><p>Indexing and handoff</p><p><strong>索引</strong> 是创建新段的机制，<strong>切换</strong> 是它们被发布并开始由历史进程提供服务的机制。该机制在索引端的工作方式如下：</p><p>1）索引任务开始运行并生成新段。必须先在索引任务构建段之前确定段的标识符，对于一个追加数据类型的任务（例如Kafka任务或者其他追加模式的索引任务），这将通过调用Overlord的<code>allocate</code> API来在现有的段集合中添加一个新的分区。对于一个重写类型的任务（例如Hadoop任务，或者一个非追加模式的索引任务）这是通过锁定间隔并创建新的版本号和新的段集来完成的。<br>2）如果一个索引任务是实时任务（像kafka任务），那么段在此刻可以被立即查询，它是可用的，但是未发布。<br>3）索引任务完成对段的数据读取后，会将其推入深度存储，然后通过将记录写入元数据存储来发布。<br>4）如果索引任务是实时任务，则此时它等待<code>Historical</code>进程加载段。如果索引任务不是实时任务，它将立即退出。</p><p>在<code>Coordinator</code>和<code>Historical</code>方面：</p><p>1）Coordinator定期（默认情况下，每1分钟）摘取元数据存储以查找新发布的段。<br>2）当Coordinator发现一个段是发布且可以被使用的、但是不可用的状态时，它会选个一个Historical进程来加载这个段；<br>3）Historical加载这个段并开始为其服务；<br>4）此时，如果索引任务正在等待切换，它将退出。</p><h4 id="3-1-3-段标识符"><a href="#3-1-3-段标识符" class="headerlink" title="3.1.3 段标识符"></a>3.1.3 段标识符</h4><p>Segment identifiers</p><p><strong>段</strong> 包含一个由四部分组成的标识符，包含以下组件：</p><ul><li>数据源名称；</li><li>时间间隔（包含该段的时间块，这与摄取时指定的 <code>segmentGranularity</code> 有关）；</li><li>版本号（通常是与段集首次启动时间相对应的 ISO8601 时间戳）；</li><li>分区号（一个整数，在<code>数据源+间隔+版本</code>中唯一；可能不一定是连续的）。</li></ul><p>例如这个一个段标识符，数据源为 <code>clarity-cloud0</code>, 时间块为 <code>2018-05-21T16:00:00.000Z/2018-05-21T17:00:00.000Z</code>, 版本为 <code>2018-05-21T15:56:09.909Z</code> 以及分区编号为 <code>1</code>:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clarity-cloud0_2018-05-21T16:00:00.000Z_2018-05-21T17:00:00.000Z_2018-05-21T15:56:09.909Z_1</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure><p>分区号为0的段（块中的第一个分区）忽略分区号，如下例所示，该段与上一个时间块位于同一时间块中，但分区号为0而不是1：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clarity-cloud0_2018-05-21T16:00:00.000Z_2018-05-21T17:00:00.000Z_2018-05-21T15:56:09.909</span><br></pre></td></tr></table></figure><h4 id="3-1-4-段版本"><a href="#3-1-4-段版本" class="headerlink" title="3.1.4 段版本"></a>3.1.4 段版本</h4><p>Segment versioning</p><p>您可能想知道上一节中描述的<strong>版本号</strong>是用来做什么的。或者，你可能不想知道，在这种情况下对你有好处，你可以跳过这一节！</p><p>它支持批处理模式覆盖。在Druid中，如果您所做的只是附加数据，那么每个时间块只有一个版本。但是当您覆盖数据时，幕后发生的事情是，使用相同的数据源、相同的时间间隔、但更高的版本号创建一组新的段。这向Druid系统的其他部分发出了一个信号：旧版本应该从集群中删除，新版本应该替换它。</p><p>这个切换对用户来说似乎是瞬间发生的，因为Druid通过首先加载新数据（但不允许查询它）来处理这个问题，然后在新数据全部加载后，将所有新查询切换为使用这些新段。然后它会在几分钟后丢弃旧的段。</p><h4 id="3-1-5-段生命周期"><a href="#3-1-5-段生命周期" class="headerlink" title="3.1.5 段生命周期"></a>3.1.5 段生命周期</h4><p>Segment lifecycle</p><p>每个段都有一个生命周期，涉及以下三个主要领域：</p><p>1）<strong>元数据存储</strong>：段的元数据（一个小的JSON，通常不超过几个KB）在段构建完成后存储在元数据存储中，将段的记录插入到元数据存储中称为<strong>发布(Publishing)</strong>。这些元数据记录中有一个 <code>used</code> 的布尔标识，控制着段是否可查询。被实时任务创建的段在发布之前是可用的，因为它们仅在完成之时发布，并且不再接受额外的数据行。</p><p>2）<strong>深度存储</strong>：一旦构建了一个段，在将元数据发布到元数据存储之前就立刻将段数据文件推送到深度存储。</p><p>3）<strong>可查询性</strong>：在某些Druid数据服务器上段是可以进行查询的，如实时任务或Historical进程。</p><p>可以使用Druid SQL查询 <code>sys.segments</code> 表检查当前活动段的状态，它包括以下标志：</p><ul><li><code>is_published</code>: 如果段元数据已发布到元数据存储且 <code>used</code> 是true的话，则为true；</li><li><code>is_available</code>: 如果段当前可用于查询（实时任务或Historical进程），则为true；</li><li><code>is_realtime</code>: 如果段仅在实时任务上可用，则为true。对于使用实时摄取的数据源，这通常从true开始，然后在发布和切换段时变为false；</li><li><code>is_overshadowed</code>: 如果段已发布（ <code>used</code> 设置为true），并且被某些其他已发布段完全覆盖，则为true。一般来说，这是一个过渡状态，处于该状态的段很快将其 <code>used</code> 标志自动设置为false；</li></ul><h4 id="3-2-6-查询处理"><a href="#3-2-6-查询处理" class="headerlink" title="3.2.6 查询处理"></a>3.2.6 查询处理</h4><p>查询分布在 Druid 集群中，并由 Broker 管理。查询首先进入<a href="http://www.apache-druid.cn/Design/Broker.html" target="_blank" rel="noopener">Broker</a>，Broker首先鉴别哪些段可能与本次查询有关。 段的列表总是按照时间进行筛选和修剪的，当然也可能由其他属性，具体取决于数据源的分区方式。然后，Broker将确定哪些<a href="http://www.apache-druid.cn/Design/Historical.html" target="_blank" rel="noopener">Historical</a>和<a href="http://www.apache-druid.cn/Design/MiddleManager.html" target="_blank" rel="noopener">MiddleManager</a>为这些段提供服务、并向每个进程发送一个子查询。 Historical和MiddleManager进程接收查询、处理查询并返回结果，Broker将接收到的结果合并到一起形成最后的结果集返回给调用者。</p><p>时间和属性精简是Druid限制每个查询扫描数据量的一个重要方法，但不是唯一的方法。对于比Broker更细粒度级别的精简筛选器，每个段中的索引结构允许Druid在查看任何数据行之前，找出哪些行（如果有的话）与筛选器集匹配。一旦Druid知道哪些行与特定查询匹配，它就只访问该查询所需的特定列。在这些列中，Druid可以从一行跳到另一行，避免读取与查询过滤器不匹配的数据。</p><p>因此，Druid使用三种不同的技术来最大化查询性能：</p><ul><li>精简每个查询访问的段；</li><li>在每个段中，使用索引标识必须访问哪些行；</li><li>在每个段中，只读取与特定查询相关的特定行和列。</li></ul><p>有关 Druid 如何执行查询的更多详细信息，请参阅<a href="https://druid.apache.org/docs/latest/querying/query-execution.html" target="_blank" rel="noopener">查询执行</a>文档。</p><h3 id="3-2-段设计"><a href="#3-2-段设计" class="headerlink" title="3.2 段设计"></a>3.2 段设计</h3><p>Apache Druid 将其索引存储在按时间分区的<strong>段文件中</strong>。在基本设置中，通常为每个时间间隔创建一个段文件，其中时间间隔可在 <code>granularitySpec</code> 的<code>segmentGranularity</code> 参数中配置。为了让 Druid 在繁重的查询负载下运行良好，段文件大小在 300MB-700MB 的推荐范围内很重要。如果你的段文件大于该范围，请考虑更改时间间隔的粒度，或者对数据进行分区，并在 <code>partitionsSpec</code>中调整 <code>targetPartitionSize</code>（此参数的建议起点是500万行）。有关更多信息，请参阅下面的<strong>分片部分</strong>和<a href="https://druid.apache.org/docs/latest/ingestion/hadoop.html#partitionsspec" target="_blank" rel="noopener">批处理摄取</a>文档的<strong>分区规范</strong>部分。</p><h4 id="3-2-1-段文件的核心数据结构"><a href="#3-2-1-段文件的核心数据结构" class="headerlink" title="3.2.1 段文件的核心数据结构"></a>3.2.1 段文件的核心数据结构</h4><p>在这里，我们描述段文件的内部结构，它本质上是<strong>列式</strong>的：每列的数据在单独的数据结构中。通过分别存储每一列，Druid可以通过只扫描查询实际需要的列来减少查询延迟。有三种基本列类型：<strong>时间戳列</strong>、<strong>维度列</strong>和<strong>指标列</strong>，如下图所示：</p><p><img src="/2021/11/24/apache-druid-lian-ji-fen-xi-chu-li-olap/%E5%9B%BE%E7%89%873.png" alt="图片3"></p><p>timestamp和metric列很简单：在底层，每个列都是用LZ4压缩的整数或浮点值数组。一旦查询知道需要选择哪些行，它只需解压缩这些行，提取相关行，然后使用所需的聚合运算符进行计算。与所有列一样，如果不查询一个列，则跳过该列的数据。</p><p>dimension列是不同的，因为它们支持过滤和聚合操作，所以每一个维度都需要以下三种数据结构：</p><p>1）一个将值（通常被当做字符串）映射到整数id的字典；<br>2）一个使用第1步的字典进行编码的列值的列表；<br>3）对于列中每一个不同的值，标识哪些行包含该值的位图。</p><p>为什么需要这三种数据结构？字典简单地将字符串值映射到整数id，以便于在（2）和（3）中可以紧凑的表示。（3）中的位图（也称<strong>倒排索引</strong>）可以进行快速过滤操作（特别是，位图便于快速进行AND和OR操作）。 最后，<code>GroupBy</code> 和 <code>TopN</code> 查询需要（2）中的值列表。换句话说，仅基于过滤器的聚合指标是不需要（2）中存储的维度值列表的。</p><p>要具体了解这些数据结构，请考虑上面示例数据中的<code>page</code>列,表示此维度的三个数据结构如下图所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1: Dictionary that encodes column values</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;Justin Bieber&quot;: 0,</span><br><span class="line">    &quot;Ke$ha&quot;:         1</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">2: Column data</span><br><span class="line">  [0,</span><br><span class="line">   0,</span><br><span class="line">   1,</span><br><span class="line">   1]</span><br><span class="line"></span><br><span class="line">3: Bitmaps - one for each unique value of the column</span><br><span class="line">  value=&quot;Justin Bieber&quot;: [1,1,0,0]</span><br><span class="line">  value=&quot;Ke$ha&quot;:         [0,0,1,1]</span><br></pre></td></tr></table></figure><p><strong>多值列</strong></p><p>如果数据源使用多值列，那么段文件中的数据结构看起来有点不同。让我们假设在上面的例子中，第二行同时标记了<code>Ke$ha</code>和<code>Justin Bieber</code>主题。在这种情况下，这三种数据结构现在看起来如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1: Dictionary that encodes column values</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;Justin Bieber&quot;: 0,</span><br><span class="line">    &quot;Ke$ha&quot;:         1</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">2: Column data</span><br><span class="line">  [0,</span><br><span class="line">   [0,1],  &lt;--Row value of multi-value column can have array of values</span><br><span class="line">   1,</span><br><span class="line">   1]</span><br><span class="line"></span><br><span class="line">3: Bitmaps - one for each unique value</span><br><span class="line">  value=&quot;Justin Bieber&quot;: [1,1,0,0]</span><br><span class="line">  value=&quot;Ke$ha&quot;:         [0,1,1,1]</span><br><span class="line">                            ^</span><br><span class="line">                            |</span><br><span class="line">                            |</span><br><span class="line">    Multi-value column has multiple non-zero entries</span><br></pre></td></tr></table></figure><p>请注意列数据和<code>Ke$ha</code>位图中第二行的更改。如果一行中的某一列有多个值，则其在<strong>列数据</strong>中的条目是一个数组。此外，在<strong>列数据</strong>中有n个值的行在位图中将有n个非零值项。</p><h4 id="3-2-2-SQL-兼容的空值处理"><a href="#3-2-2-SQL-兼容的空值处理" class="headerlink" title="3.2.2 SQL 兼容的空值处理"></a>3.2.2 SQL 兼容的空值处理</h4><p>默认情况下，Druid字符串维度列可以使用 <code>&quot;&quot;</code> 或者 <code>null</code> ，数值列和指标列则不能表示为 <code>null</code>，而是将 <code>null</code> 强制为 <code>0</code>。但是，Druid还提供了一个与SQL兼容的空值处理模式，必须在系统级别通过 <code>Druid.generic.useDefaultValueForNull</code> 启用，当设置为 <code>false</code> 时，此设置将允许Druid在接收数据时创建的段中：字符串列区分 <code>&quot;&quot;</code> 和 <code>null</code> ，数值列区分 <code>null</code> 和 <code>0</code>。</p><p>在这种模式下，字符串维度列不包含额外的列结构，只是为 <code>null</code> 保留额外的字典条目。但是，数值列将与一个附加位图一起存储在段中，该位图标识哪些行是 <code>null</code> 值。除了略微增加段大小之外，由于需要检查 <code>null</code> 的位图，SQL兼容的空值处理在查询时也会导致性能损失，此性能开销仅对实际包含<code>null</code>列的场景中存在。</p><h4 id="3-2-3-命名规则"><a href="#3-2-3-命名规则" class="headerlink" title="3.2.3 命名规则"></a>3.2.3 命名规则</h4><p>段标识符通常使用数据源、时间区间的开始时间（ISO 8601格式）、时间区间的结束时间（ISO 8601格式）和版本来构造。如果数据被额外的分片后超出了时间范围，则段标识符还将包含分区号。</p><p>一个示例段标识符可以是： <code>数据源名称_开始时间_结束时间_版本号_分区号</code></p><h4 id="3-2-4-段的组成"><a href="#3-2-4-段的组成" class="headerlink" title="3.2.4 段的组成"></a>3.2.4 段的组成</h4><p>在底层，一个段由以下几个文件组成：</p><ul><li><p><code>version.bin</code></p><p>4个字节，以整数表示当前段版本。 例如，对于v9段，版本为0x0、0x0、0x0、0x9</p></li><li><p><code>meta.smoosh</code></p><p>一个包含其他 <code>smoosh</code> 文件内容的元数据（文件名以及偏移量）文件</p></li><li><p><code>XXXXX.smoosh</code></p><p>这些文件中有一些是串联的二进制数据</p><p><code>smoosh</code> 文件代表 <strong>smooshed</strong> 在一起的多个文件，以减少必须打开用来容纳数据的文件描述符的数量，它们是最大为2GB的文件（以匹配Java中内存映射的ByteBuffer的限制）。<code>smoosh</code> 文件为数据中的每个列提供单独的文件，并在 <code>index.drd</code> 文件提供有关该段的额外元数据。</p><p>还有一个称为 <code>__time</code> 的特殊列，它表示该段的时间列。</p></li></ul><p>在代码库中，段具有内部格式版本。当前的句段格式版本为 <code>v9</code>。</p><h4 id="3-2-5-列的格式"><a href="#3-2-5-列的格式" class="headerlink" title="3.2.5 列的格式"></a>3.2.5 列的格式</h4><p>每列存储为两部分：</p><ul><li>Jackson序列化的列描述符（ColumnDescriptor）；</li><li>列二进制文件的其余部分。</li></ul><p><strong>列描述符</strong>本质上是一个对象，它允许我们使用Jackson的多态反序列化来添加新的有趣的序列化方法，并且对代码的影响最小。它由关于列的一些元数据（它是什么类型的，它是多值的，等等）和一列序列化/反序列化逻辑组成，这些逻辑可以反序列化二进制文件的其余部分。</p><h4 id="3-2-6-压缩"><a href="#3-2-6-压缩" class="headerlink" title="3.2.6 压缩"></a>3.2.6 压缩</h4><p>Druid 压缩字符串、long、float 和 double 列的值块，默认使用<a href="https://github.com/lz4/lz4-java" target="_blank" rel="noopener">LZ4</a>，字符串列和数字空值的位图使用<a href="https://github.com/RoaringBitmap/RoaringBitmap" target="_blank" rel="noopener">Roaring</a>压缩. 我们建议坚持使用这些默认值，除非使用您自己的数据和查询模式进行实验验证表明非默认选项在您的特定情况下会表现得更好。例如，对于字符串列中的位图，使用 Roaring 和 CONCISE 之间的差异对于高基数列最为明显。在这种情况下，Roaring 在匹配大量值的过滤器上要快得多，但在某些情况下，由于 Roaring 格式的开销，CONCISE 的占用空间较小（但在匹配大量值时仍然较慢）。目前，压缩配置在段级别而不是单个列，有关更多详细信息，请参阅<a href="https://druid.apache.org/docs/latest/ingestion/ingestion-spec.html#indexspec" target="_blank" rel="noopener">IndexSpec</a>。</p><h4 id="3-2-7-切分数据以创建段"><a href="#3-2-7-切分数据以创建段" class="headerlink" title="3.2.7 切分数据以创建段"></a>3.2.7 切分数据以创建段</h4><p><strong>数据分片</strong></p><p>对于同一数据源，同一时间间隔内可能存在多个段。这些段在一段时间内形成一个 <code>块</code> 。根据用于切分数据的 <code>shardSpec</code> 的类型，只有当一个 <code>块</code> 完成时，Druid查询才能完成。也就是说，如果一个块由3个段组成，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sampleData_2011-01-01T02:00:00:00Z_2011-01-01T03:00:00:00Z_v1_0</span><br><span class="line">sampleData_2011-01-01T02:00:00:00Z_2011-01-01T03:00:00:00Z_v1_1</span><br><span class="line">sampleData_2011-01-01T02:00:00:00Z_2011-01-01T03:00:00:00Z_v1_2</span><br></pre></td></tr></table></figure><p>在完成对间隔 <code>2011-01-01T02:00:00:00Z_2011-01-01T03:00:00:00Z</code> 的查询之前，必须加载所有3个段。</p><p>此规则的例外是使用<strong>线性切片规范</strong>。线性切片规范不会强制<strong>完整性</strong>，即使系统中没有加载切片，查询也可以完成。例如，如果您的实时摄取任务创建了3个使用线性切片规范进行分段的段，并且系统中只加载了其中的两个段，那么查询将只返回这两个段的结果。</p><h4 id="3-2-8-Schema更改"><a href="#3-2-8-Schema更改" class="headerlink" title="3.2.8 Schema更改"></a>3.2.8 Schema更改</h4><p><strong>替换段</strong></p><p>Druid使用数据源、间隔、版本和分区号唯一地标识段。只有在为某个时间粒度创建多个段时，分区号才在段id中可见。例如，如果有小时段，但一小时内的数据量超过单个段的容量，则可以为同一小时创建多个段。这些段将共享相同的数据源、间隔和版本，但具有线性增加的分区号。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo_2015-01-01/2015-01-02_v1_0</span><br><span class="line">foo_2015-01-01/2015-01-02_v1_1</span><br><span class="line">foo_2015-01-01/2015-01-02_v1_2</span><br></pre></td></tr></table></figure><p>在上述段的实例中，<code>dataSource = foo</code>, <code>interval = 2015-01-01/2015-01-02</code>, <code>version = v1</code>, and <code>partitionNum = 0</code>。 如果在以后的某个时间点，使用新的schema重新索引数据，则新创建的段将具有更高的版本id。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo_2015-01-01/2015-01-02_v2_0</span><br><span class="line">foo_2015-01-01/2015-01-02_v2_1</span><br><span class="line">foo_2015-01-01/2015-01-02_v2_2</span><br></pre></td></tr></table></figure><p>Druid批量索引任务（基于Hadoop或基于IndexTask）保证了间隔内的的原子更新。在我们的例子中，在 <code>2015-01-01/2015-01-02</code> 的所有 <code>v2</code> 段加载到Druid集群之前，查询只使用 <code>v1</code> 段。加载完所有 <code>v2</code> 段并可查询后，所有查询都将忽略 <code>v1</code> 段并切换到 <code>v2</code> 段。不久之后，<code>v1</code>段将从集群中卸载。</p><p>请注意，跨越多个段间隔的更新在每个间隔内都是原子的，但是在整个更新过程中它们不是原子的。例如，您有如下段：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo_2015-01-01/2015-01-02_v1_0</span><br><span class="line">foo_2015-01-02/2015-01-03_v1_1</span><br><span class="line">foo_2015-01-03/2015-01-04_v1_2</span><br></pre></td></tr></table></figure><p><code>v2</code> 段将在构建后立即加载到集群中，并在段重叠的时间段内替换 <code>v1</code> 段。在完全加载 <code>v2</code>段之前，集群可能混合了 <code>v1</code> 和 <code>v2</code> 段。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo_2015-01-01/2015-01-02_v1_0</span><br><span class="line">foo_2015-01-02/2015-01-03_v2_1</span><br><span class="line">foo_2015-01-03/2015-01-04_v1_2</span><br></pre></td></tr></table></figure><p>在这种情况下，查询可能会命中 <code>v1</code> 和 <code>v2</code> 段的混合.</p><h4 id="3-2-9-段之间的不同Schema"><a href="#3-2-9-段之间的不同Schema" class="headerlink" title="3.2.9 段之间的不同Schema"></a>3.2.9 段之间的不同Schema</h4><p>同一数据源的Druid段可能有不同的schema。如果一个字符串列（维度列）存在于一个段中而不是另一个段中，则涉及这两个段的查询仍然有效。对缺少维度的段的查询将表现为该维度只有空值。类似地，如果一个段有一个数值列（指标列），而另一个没有，那么查询缺少指标列的段通常会<strong>做正确的事情</strong>，在缺失的指标上做聚合操作也就是缺失的。</p><h3 id="3-3-进程和服务"><a href="#3-3-进程和服务" class="headerlink" title="3.3 进程和服务"></a>3.3 进程和服务</h3><h4 id="3-3-1-进程类型"><a href="#3-3-1-进程类型" class="headerlink" title="3.3.1 进程类型"></a>3.3.1 进程类型</h4><p>Druid有以下几种进程类型：</p><ul><li><a href="http://www.apache-druid.cn/Design/Coordinator.html" target="_blank" rel="noopener">Coordinator</a></li><li><a href="http://www.apache-druid.cn/Design/Overlord.html" target="_blank" rel="noopener">Overlord</a></li><li><a href="http://www.apache-druid.cn/Design/Broker.html" target="_blank" rel="noopener">Broker</a></li><li><a href="http://www.apache-druid.cn/Design/Historical.html" target="_blank" rel="noopener">Historical</a></li><li><a href="http://www.apache-druid.cn/Design/MiddleManager.html" target="_blank" rel="noopener">MiddleManager</a> 和 <a href="http://www.apache-druid.cn/Design/Peons.html" target="_blank" rel="noopener">Peons</a></li><li><a href="http://www.apache-druid.cn/Design/Indexer.html" target="_blank" rel="noopener">Indexer(可选)</a></li><li><a href="http://www.apache-druid.cn/Design/Router.html" target="_blank" rel="noopener">Router(可选)</a></li></ul><h4 id="3-3-2-服务类型"><a href="#3-3-2-服务类型" class="headerlink" title="3.3.2 服务类型"></a>3.3.2 服务类型</h4><p>Druid进程可以按照您喜欢的任何方式部署，但是为了便于部署，我们建议将它们组织成三种服务器类型：</p><ul><li><strong>Master</strong></li><li><strong>Query</strong></li><li><strong>Data</strong></li></ul><p><img src="/2021/11/24/apache-druid-lian-ji-fen-xi-chu-li-olap/%E5%9B%BE%E7%89%871.png" alt="图片1"></p><h5 id="3-3-2-1-Master服务"><a href="#3-3-2-1-Master服务" class="headerlink" title="3.3.2.1 Master服务"></a>3.3.2.1 Master服务</h5><p>Master服务管理数据的摄取和可用性：它负责启动新的摄取作业并协调下面描述的”Data服务”上数据的可用性。</p><p>在Master服务中，功能分为两个进程：Coordinator和Overlord。</p><p><strong>Coordinator进程</strong></p><p><a href="http://www.apache-druid.cn/Design/Coordinator.html" target="_blank" rel="noopener">Coordinator</a> 监视Data服务中的Historical进程，它们负责将数据段分配给特定的服务器，并确保数据段在各个Historical之间保持良好的平衡。</p><p><strong>Overlord进程</strong></p><p><a href="http://www.apache-druid.cn/Design/Overlord.html" target="_blank" rel="noopener">Overlord</a> 监视Data服务中的MiddleManager进程，并且是Druid数据接收的控制器。它们负责将接收任务分配给MiddleManager，并协调数据段的发布。</p><h5 id="3-3-2-2-Query服务"><a href="#3-3-2-2-Query服务" class="headerlink" title="3.3.2.2 Query服务"></a>3.3.2.2 Query服务</h5><p>Query服务提供用户和客户端应用程序交互，将查询路由到Data服务或其他Query服务（以及可选的代理Master服务请求）。</p><p>在Query服务中，功能上分为两个进程：Broker和Router。</p><p><strong>Broker进程</strong></p><p><a href="http://www.apache-druid.cn/Design/Broker.html" target="_blank" rel="noopener">Broker</a>从外部客户端接收查询并将这些查询转发到Data服务器, 当Broker接收到子查询的结果时，它们会合并这些结果并将其返回给调用者。用户通常查询Broker，而不是直接查询Data服务中的Historical或MiddleManager进程。</p><p><strong>Router进程（可选）</strong></p><p>Router进程是<em>可选</em>的进程，相当于是为Druid Broker、Overlord和Coordinator提供一个统一的API网关。Router是可选的，因为也可以直接与Druid的Broker、Overlord和Coordinator。</p><p>Router还运行着<a href="http://www.apache-druid.cn/Operations/manageui.md" target="_blank" rel="noopener">Druid控制台</a>，一个用于数据源、段、任务、数据进程（Historical和MiddleManager）和Coordinator动态配置的管理UI。用户还可以在控制台中运行SQL和本地Druid查询。</p><h5 id="3-3-2-3-Data服务"><a href="#3-3-2-3-Data服务" class="headerlink" title="3.3.2.3 Data服务"></a>3.3.2.3 Data服务</h5><p>Data服务执行摄取作业并存储可查询数据。</p><p>在Data服务中，根据功能被分为两个进程：Historical和MiddleManager。</p><h5 id="3-3-2-4-Historical进程"><a href="#3-3-2-4-Historical进程" class="headerlink" title="3.3.2.4 Historical进程"></a>3.3.2.4 Historical进程</h5><p><a href="http://www.apache-druid.cn/Design/Historical.html" target="_blank" rel="noopener">Historical</a> 进程是处理存储和查询”Historical”数据（包括系统中已提交足够长时间的任何流数据）的工作程序。Historical进程从深层存储下载段并响应有关这些段的查询，他们不接受写操作。</p><h5 id="3-3-2-5-MiddleManager进程"><a href="#3-3-2-5-MiddleManager进程" class="headerlink" title="3.3.2.5 MiddleManager进程"></a>3.3.2.5 MiddleManager进程</h5><p><a href="http://www.apache-druid.cn/Design/MiddleManager.html" target="_blank" rel="noopener">MiddleManager</a> 进程处理将新数据摄取到集群中的操作, 他们负责读取外部数据源并发布新的Druid段。</p><p><strong>Peon进程</strong></p><p><a href="http://www.apache-druid.cn/Design/Peons.html" target="_blank" rel="noopener">Peon</a> 进程是由MiddleManagers生成的任务执行引擎。每个Peon运行一个单独的JVM，负责执行一个任务。Peon总是和运行它们的MiddleManager在同一个主机上运行。</p><h5 id="3-3-2-6-Indexer进程（可选）"><a href="#3-3-2-6-Indexer进程（可选）" class="headerlink" title="3.3.2.6 Indexer进程（可选）"></a>3.3.2.6 Indexer进程（可选）</h5><p><a href="http://www.apache-druid.cn/Design/Indexer.html" target="_blank" rel="noopener">Indexer</a> 进程是MiddleManager和Peon的替代方法。Indexer在单个JVM进程中作为单个线程运行任务，而不是为每个任务派生单独的JVM进程。</p><p>与MiddleManager + Peon系统相比，Indexer的设计更易于配置和部署，并且能够更好地实现跨任务的资源共享。Indexer是一种较新的功能，由于其内存管理系统仍在开发中，因此目前被指定为<a href="http://www.apache-druid.cn/Development/experimental.md" target="_blank" rel="noopener">实验性的特性</a>。它将在Druid的未来版本中继续成熟。</p><p>通常，您可以部署MiddleManagers或indexer，但不能同时部署两者。</p><h4 id="3-3-3-服务混合部署的利弊"><a href="#3-3-3-服务混合部署的利弊" class="headerlink" title="3.3.3 服务混合部署的利弊"></a>3.3.3 服务混合部署的利弊</h4><p>Druid进程可以基于上面描述的Master/Data/Query服务组织进行混合部署，这种部署方式通常会使大多数集群更好地利用硬件资源。</p><p>但是，对于非常大规模的集群，可以分割Druid进程，使它们在单独的服务器上运行，以避免资源争用。</p><p>本节介绍与进程混合部署相关的指南和配置参数。</p><h5 id="3-3-3-1-Coordinator和Overlord"><a href="#3-3-3-1-Coordinator和Overlord" class="headerlink" title="3.3.3.1 Coordinator和Overlord"></a>3.3.3.1 Coordinator和Overlord</h5><p>Coordinator进程的工作负载往往随着集群中段的数量而增加。Overlord的工作量也会根据集群中的分段数而增加，但程度要比Coordinator小。</p><p>在具有非常大量的段的集群中，可以将Coordinator进程和Overlord进程分开，以便为Coordinator进程的分段平衡工作负载提供更多资源。</p><p><strong>统一进程</strong></p><p>通过设置 <code>druid.Coordinator.asOverlord.enabled</code> 属性，Coordinator进程和Overlord进程可以作为单个组合进程运行。</p><p>有关详细信息，请参阅<a href="http://www.apache-druid.cn/Configuration/configuration.html#Coordinator" target="_blank" rel="noopener">Coordinator配置</a>。</p><h5 id="3-3-3-2-Historical和MiddleManager"><a href="#3-3-3-2-Historical和MiddleManager" class="headerlink" title="3.3.3.2 Historical和MiddleManager"></a>3.3.3.2 Historical和MiddleManager</h5><p>对于更高级别的数据摄取或查询负载，将Historical进程和MiddleManager进程部署在不同的主机上以避免CPU和内存争用。</p><p>Historical还受益于为<strong>内存映射段</strong>提供可用内存，这也是分别部署Historical和MiddleManager进程的另一个原因。</p><h3 id="3-4-深度存储"><a href="#3-4-深度存储" class="headerlink" title="3.4 深度存储"></a>3.4 深度存储</h3><p>Apache Druid不提供的存储机制，深度存储是存储段的地方。深度存储基础结构定义了数据的持久性级别，只要Druid进程能够看到这个存储基础结构并获得存储在上面的段，那么无论丢失多少Druid节点，都不会丢失数据。如果段在深度存储层消失了，则这些段中存储的任何数据都将丢失。</p><h4 id="3-4-1-本地挂载"><a href="#3-4-1-本地挂载" class="headerlink" title="3.4.1 本地挂载"></a>3.4.1 本地挂载</h4><p>本地装载也可用于存储段。这使得您可以使用本地文件系统或任何可以在本地挂载的东西，如NFS、Ceph等来存储段。这是默认的深度存储实现。</p><p>为了使用本地装载进行深层存储，需要在公共配置中设置以下配置：</p><table><thead><tr><th>属性</th><th>可能的取值</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td><code>druid.storage.type</code></td><td>local</td><td></td><td>必须设置</td></tr><tr><td><code>druid.storage.storageDirectory</code></td><td></td><td>存储段的目录</td><td>必须设置</td></tr></tbody></table><p>注意，通常应该将 <code>druid.storage.storageDirectory</code> 设置为与 <code>druid.segmentCache.locations</code> 和 <code>druid.segmentCache.infoDir</code> 不同的目录。</p><p>如果在本地模式下使用Hadoop Indexer，那么只需给它一个本地目录作为输出目录，它就可以工作了。</p><h4 id="3-4-2-S3适配"><a href="#3-4-2-S3适配" class="headerlink" title="3.4.2 S3适配"></a>3.4.2 S3适配</h4><p>请看<a href="http://www.apache-druid.cn/Configuration/core-ext/s3.md" target="_blank" rel="noopener">druid-s3-extensions</a>扩展文档</p><h4 id="3-4-3-HDFS"><a href="#3-4-3-HDFS" class="headerlink" title="3.4.3 HDFS"></a>3.4.3 HDFS</h4><p>请看<a href="http://www.apache-druid.cn/Configuration/core-ext/hdfs.md" target="_blank" rel="noopener">druid-hdfs-extensions</a>扩展文档</p><h4 id="3-4-4-其他深度存储"><a href="#3-4-4-其他深度存储" class="headerlink" title="3.4.4 其他深度存储"></a>3.4.4 其他深度存储</h4><p>对于另外的深度存储等，可以参见<a href="http://www.apache-druid.cn/Configuration/extensions.md" target="_blank" rel="noopener">扩展列表</a></p><h3 id="3-5-元数据存储"><a href="#3-5-元数据存储" class="headerlink" title="3.5 元数据存储"></a>3.5 元数据存储</h3><p>元数据存储是Apache Druid的一个外部依赖。Druid使用它来存储系统的各种元数据，但不存储实际的数据。下面有许多用于各种目的的表。</p><p>Derby是Druid的默认元数据存储，但是它不适合生产环境。<a href="http://www.apache-druid.cn/Configuration/core-ext/mysql.md" target="_blank" rel="noopener">MySQL</a>和<a href="http://www.apache-druid.cn/Configuration/core-ext/postgresql.md" target="_blank" rel="noopener">PostgreSQL</a>是更适合生产的元数据存储。</p><blockquote><p>元数据存储存储了Druid集群工作所必需的整个元数据。对于生产集群，考虑使用MySQL或PostgreSQL而不是Derby。此外，强烈建议设置数据库的高可用，因为如果丢失任何元数据，将无法恢复。</p></blockquote><h4 id="3-5-1-使用Derby"><a href="#3-5-1-使用Derby" class="headerlink" title="3.5.1 使用Derby"></a>3.5.1 使用Derby</h4><p>将以下内容添加到您的Druid配置中：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">druid.metadata.storage.type=derby</span><br><span class="line">druid.metadata.storage.connector.connectURI=jdbc:derby://localhost:1527//opt/var/druid_state/derby;create=true</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure><h4 id="3-5-2-MySQL"><a href="#3-5-2-MySQL" class="headerlink" title="3.5.2 MySQL"></a>3.5.2 MySQL</h4><p>参见<a href="http://www.apache-druid.cn/Configuration/core-ext/mysql.md" target="_blank" rel="noopener">mysql-metadata-storage</a>扩展文档</p><h4 id="5-3-3-PostgreSQL"><a href="#5-3-3-PostgreSQL" class="headerlink" title="5.3.3 PostgreSQL"></a>5.3.3 PostgreSQL</h4><p>参见<a href="http://www.apache-druid.cn/Configuration/core-ext/postgresql.md" target="_blank" rel="noopener">postgresql-metadata-storage</a>扩展文档</p><h4 id="5-3-4-添加自定义的数据库连接池属性"><a href="#5-3-4-添加自定义的数据库连接池属性" class="headerlink" title="5.3.4 添加自定义的数据库连接池属性"></a>5.3.4 添加自定义的数据库连接池属性</h4><p>注意：<code>username</code>、<code>password</code>、<code>connectURI</code>、<code>validationQuery</code>、<code>testOnBorrow</code> 这些属性不能通过 <code>druid.metadata.storage.connector.dbcp</code> 属性设置，这些必须通过 <code>druid.metadata.storage.connector</code> 属性设置。</p><p>支持的属性示例：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">druid.metadata.storage.connector.dbcp.maxConnLifetimeMillis=1200000</span><br><span class="line">druid.metadata.storage.connector.dbcp.defaultQueryTimeout=30000</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure><p>全部列表请查看 <a href="https://commons.apache.org/proper/commons-dbcp/configuration.html" target="_blank" rel="noopener">基本数据源配置</a></p><h4 id="5-3-5-元数据存储表"><a href="#5-3-5-元数据存储表" class="headerlink" title="5.3.5 元数据存储表"></a>5.3.5 元数据存储表</h4><h5 id="5-3-5-1-段表"><a href="#5-3-5-1-段表" class="headerlink" title="5.3.5.1 段表"></a>5.3.5.1 段表</h5><p>这是由 <code>druid.metadata.storage.tables.segments</code> 属性决定的。</p><p>此表存储了系统中可用段的元数据。<a href="http://www.apache-druid.cn/Design/Coordinator.html" target="_blank" rel="noopener">Coordinator</a> 对表进行轮询，以确定可用于在系统中查询的段集。该表有两个主功能列，其他列用于索引。</p><p><code>used</code> 列是布尔型标识。1表示集群应”使用”该段(即，应加载该段并可用于请求), 0表示不应将段主动加载到集群中。我们这样做是为了从集群中删除段，而不实际删除它们的元数据（这允许在出现问题时更简单地回滚）。</p><p><code>payload</code> 列存储一个JSON blob，该blob包含该段的所有元数据（存储在该payload中的某些数据与表中的某些列是冗余的，这是有意的）, 信息如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> <span class="attr">"dataSource"</span>:<span class="string">"wikipedia"</span>,</span><br><span class="line"> <span class="attr">"interval"</span>:<span class="string">"2012-05-23T00:00:00.000Z/2012-05-24T00:00:00.000Z"</span>,</span><br><span class="line"> <span class="attr">"version"</span>:<span class="string">"2012-05-24T00:10:00.046Z"</span>,</span><br><span class="line"> <span class="attr">"loadSpec"</span>:&#123;</span><br><span class="line">    <span class="attr">"type"</span>:<span class="string">"s3_zip"</span>,</span><br><span class="line">    <span class="attr">"bucket"</span>:<span class="string">"bucket_for_segment"</span>,</span><br><span class="line">    <span class="attr">"key"</span>:<span class="string">"path/to/segment/on/s3"</span></span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="attr">"dimensions"</span>:<span class="string">"comma-delimited-list-of-dimension-names"</span>,</span><br><span class="line"> <span class="attr">"metrics"</span>:<span class="string">"comma-delimited-list-of-metric-names"</span>,</span><br><span class="line"> <span class="attr">"shardSpec"</span>:&#123;<span class="attr">"type"</span>:<span class="string">"none"</span>&#125;,</span><br><span class="line"> <span class="attr">"binaryVersion"</span>:<span class="number">9</span>,</span><br><span class="line"> <span class="attr">"size"</span>:size_of_segment,</span><br><span class="line"> <span class="attr">"identifier"</span>:<span class="string">"wikipedia_2012-05-23T00:00:00.000Z_2012-05-24T00:00:00.000Z_2012-05-23T00:10:00.046Z"</span></span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure><p>请注意，此blob的格式可以而且将不时地更改。</p><h5 id="5-3-5-2-规则表"><a href="#5-3-5-2-规则表" class="headerlink" title="5.3.5.2 规则表"></a>5.3.5.2 规则表</h5><p>规则表用于存储有关段应在何处着陆的各种规则。<a href="http://www.apache-druid.cn/Design/Coordinator.html" target="_blank" rel="noopener">Coordinator</a> 在对集群进行段（重）分配决策时使用这些规则。</p><h5 id="5-3-5-3-配置表"><a href="#5-3-5-3-配置表" class="headerlink" title="5.3.5.3 配置表"></a>5.3.5.3 配置表</h5><p>配置表用于存储运行时的配置对象。我们还没有很多这样的机制，我们也不确定是否会继续使用这种机制，但这是一种在运行时跨集群更改一些配置参数的方法的开始。</p><h5 id="5-3-5-4-任务相关的表"><a href="#5-3-5-4-任务相关的表" class="headerlink" title="5.3.5.4 任务相关的表"></a>5.3.5.4 任务相关的表</h5><p>在管理任务时，<a href="http://www.apache-druid.cn/Design/Overlord.html" target="_blank" rel="noopener">Overlord</a> 和 <a href="http://www.apache-druid.cn/Design/MiddleManager.html" target="_blank" rel="noopener">MiddleManager</a> 还创建和使用了许多表。</p><h5 id="5-3-5-5-审计表"><a href="#5-3-5-5-审计表" class="headerlink" title="5.3.5.5 审计表"></a>5.3.5.5 审计表</h5><p>审核表用于存储配置更改的历史记录，例如<a href="http://www.apache-druid.cn/Design/Coordinator.html" target="_blank" rel="noopener">Coordinator</a> 所做的规则更改和其他配置更改。</p><p>只有以下角色才能访问元数据存储：</p><ul><li>索引服务进程（如果有）</li><li>实时进程（如果有）</li><li>协调程序</li></ul><p>因此，您只需要为这些计算机授予访问元数据存储的权限（例如，在AWS安全组中）。</p><h3 id="3-6-ZooKeeper"><a href="#3-6-ZooKeeper" class="headerlink" title="3.6 ZooKeeper"></a>3.6 ZooKeeper</h3><p>Apache Druid使用<a href="http://zookeeper.apache.org/" target="_blank" rel="noopener">Apache ZooKeeper</a> 来管理整个集群状态。通过ZK来进行的操作有：</p><ul><li><a href="http://www.apache-druid.cn/Design/Coordinator.html" target="_blank" rel="noopener">Coordinator</a> Leader选举</li><li><a href="http://www.apache-druid.cn/Design/Historical.html" target="_blank" rel="noopener">Historical</a> 段发布协议</li><li><a href="http://www.apache-druid.cn/Design/Coordinator.html" target="_blank" rel="noopener">Coordinator</a> 和 <a href="http://www.apache-druid.cn/Design/Historical.html" target="_blank" rel="noopener">Historical</a> 之间的段加载/删除</li><li><a href="http://www.apache-druid.cn/Design/Overlord.html" target="_blank" rel="noopener">Overlord</a> Leader选举</li><li><a href="http://www.apache-druid.cn/Design/Overlord.html" target="_blank" rel="noopener">Overlord</a>和<a href="http://www.apache-druid.cn/Design/MiddleManager.html" target="_blank" rel="noopener">MiddleManager</a>任务管理</li></ul><h4 id="3-6-1-Coordinator-Leader选举"><a href="#3-6-1-Coordinator-Leader选举" class="headerlink" title="3.6.1 Coordinator Leader选举"></a>3.6.1 Coordinator Leader选举</h4><p>我们使用 <strong>Curator LeadershipLatch</strong> 进行Leader选举：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;druid.zk.paths.coordinatorPath&#125;/_COORDINATOR</span><br></pre></td></tr></table></figure><h4 id="3-6-2-Historical和Realtime之间的段发布"><a href="#3-6-2-Historical和Realtime之间的段发布" class="headerlink" title="3.6.2 Historical和Realtime之间的段发布"></a>3.6.2 Historical和Realtime之间的段发布</h4><p><code>announcementsPath</code> 和 <code>servedSegmentsPath</code> 这两个参数用于这个功能。</p><p>所有的 <a href="http://www.apache-druid.cn/Design/Historical.html" target="_blank" rel="noopener">Historical</a> 进程都将它们自身发布到 <code>announcementsPath</code>, 具体来说它们将在以下路径创建一个临时的ZNODE：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;druid.zk.paths.announcementsPath&#125;/$&#123;druid.host&#125;</span><br></pre></td></tr></table></figure><p>这意味着Historical节点可用。它们也将随后创建一个ZNODE:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;druid.zk.paths.servedSegmentsPath&#125;/$&#123;druid.host&#125;</span><br></pre></td></tr></table></figure><p>当它们加载段时，它们将在以下路径附着一个临时的ZNODE：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;druid.zk.paths.servedSegmentsPath&#125;/$&#123;druid.host&#125;/_segment_identifier_</span><br></pre></td></tr></table></figure><p>然后，<a href="http://www.apache-druid.cn/Design/Coordinator.html" target="_blank" rel="noopener">Coordinator</a> 和 <a href="http://www.apache-druid.cn/Design/Broker.html" target="_blank" rel="noopener">Broker</a> 之类的进程可以监视这些路径，以查看哪些进程当前正在为哪些段提供服务。</p><h4 id="3-6-3-Coordinator和Historical之间的段加载-删除"><a href="#3-6-3-Coordinator和Historical之间的段加载-删除" class="headerlink" title="3.6.3 Coordinator和Historical之间的段加载/删除"></a>3.6.3 Coordinator和Historical之间的段加载/删除</h4><p><code>loadQueuePath</code> 参数用于这个功能。</p><p>当 <a href="http://www.apache-druid.cn/Design/Coordinator.html" target="_blank" rel="noopener">Coordiantor</a> 决定一个 <a href="http://www.apache-druid.cn/Design/Historical.html" target="_blank" rel="noopener">Historical</a> 进程应该加载或删除一个段时，它会将一个临时znode写到:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">&#123;druid.zk.paths.loadQueuePath&#125;/_host_of_historical_process/_segment_identifier</span></span><br></pre></td></tr></table></figure><p>这个znode将包含一个payload，它向Historical进程指示它应该如何处理给定的段。当Historical进程完成任务时，它将删除znode，以便向Coordinator表示它已经完成处理。</p><h2 id="四、Druid-部署"><a href="#四、Druid-部署" class="headerlink" title="四、Druid 部署"></a>四、Druid 部署</h2><h3 id="4-1-单机模式部署"><a href="#4-1-单机模式部署" class="headerlink" title="4.1 单机模式部署"></a>4.1 单机模式部署</h3><p>Druid 包含一组用于单机部署的参考配置和启动脚本，位于<code>conf/druid/single-server/</code>目录下</p><ul><li><code>nano-quickstart</code></li><li><code>micro-quickstart</code></li><li><code>small</code></li><li><code>medium</code></li><li><code>large</code></li><li><code>xlarge</code></li></ul><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Nano-Quickstart：1个CPU，4GB RAM</span><br><span class="line">    启动命令： bin/start-nano-quickstart</span><br><span class="line">    配置目录： conf/druid/single-server/nano-quickstart/*</span><br><span class="line">微型快速入门：4个CPU，16GB RAM</span><br><span class="line">    启动命令： bin/start-micro-quickstart</span><br><span class="line">    配置目录： conf/druid/single-server/micro-quickstart/*</span><br><span class="line">小型：8 CPU，64GB RAM（〜i3.2xlarge）</span><br><span class="line">    启动命令： bin/start-small</span><br><span class="line">    配置目录： conf/druid/single-server/small/*</span><br><span class="line">中：16 CPU，128GB RAM（〜i3.4xlarge）</span><br><span class="line">    启动命令： bin/start-medium</span><br><span class="line">    配置目录： conf/druid/single-server/medium/*</span><br><span class="line">大型：32 CPU，256GB RAM（〜i3.8xlarge）</span><br><span class="line">    启动命令： bin/start-large</span><br><span class="line">    配置目录： conf/druid/single-server/large/*</span><br><span class="line">超大型：64 CPU，512GB RAM（〜i3.16xlarge）</span><br><span class="line">    启动命令： bin/start-xlarge</span><br><span class="line">    配置目录： conf/druid/single-server/xlarge/*</span><br></pre></td></tr></table></figure></blockquote><h4 id="4-1-1-安装-jdk"><a href="#4-1-1-安装-jdk" class="headerlink" title="4.1.1 安装 jdk"></a>4.1.1 安装 jdk</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@hadoop3 ~]$ tar xf downloads/jdk-8u301-linux-x64.tar.gz</span><br><span class="line">[hadoop@hadoop3 ~]$ vim .bash_profile</span><br><span class="line">export JAVA_HOME=/home/hadoop/jdk1.8.0_301</span><br><span class="line">export JRE_HOME=$&#123;JAVA_HOME&#125;/jre</span><br><span class="line">export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib</span><br><span class="line"></span><br><span class="line">[hadoop@hadoop1 ~]$ source .bash_profile</span><br></pre></td></tr></table></figure><h4 id="4-1-2-准备-druid"><a href="#4-1-2-准备-druid" class="headerlink" title="4.1.2 准备 druid"></a>4.1.2 准备 druid</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@hadoop3 ~/downloads]$ wget https://dlcdn.apache.org/druid/0.21.1/apache-druid-0.21.1-bin.tar.gz</span><br><span class="line">https://dlcdn.apache.org/druid/0.21.1/apache-druid-0.21.1-bin.tar.gz</span><br><span class="line">https://downloads.apache.org/druid/0.21.1/apache-druid-0.21.1-bin.tar.gz</span><br><span class="line">[hadoop@hadoop3 ~]$ tar xf apache-druid-0.21.1-bin.tar.gz</span><br><span class="line">[hadoop@hadoop3 ~]$ cd apache-druid-0.21.1/</span><br></pre></td></tr></table></figure><h4 id="4-1-3-启动-druid"><a href="#4-1-3-启动-druid" class="headerlink" title="4.1.3 启动 druid"></a>4.1.3 启动 druid</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@hadoop3 ~/apache-druid-0.21.1]$ ./bin/start-nano-quickstart start</span><br></pre></td></tr></table></figure><p>如果端口冲突，可通过以下配置修改各服务端口信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">cd conf/druid/single-server</span><br><span class="line"></span><br><span class="line">./nano-quickstart/</span><br><span class="line">├── _common</span><br><span class="line">│   ├── common.runtime.properties</span><br><span class="line">│   └── log4j2.xml</span><br><span class="line">├── broker</span><br><span class="line">│   └── runtime.properties      druid.plaintextPort=端口号</span><br><span class="line">├── coordinator-overlord</span><br><span class="line">│   └── runtime.properties      druid.plaintextPort=端口号</span><br><span class="line">├── historical</span><br><span class="line">│   └── runtime.properties      druid.plaintextPort=端口号</span><br><span class="line">├── middleManager</span><br><span class="line">│   └── runtime.properties      druid.plaintextPort=端口号</span><br><span class="line">└── router</span><br><span class="line">    └── runtime.properties      druid.plaintextPort=端口号</span><br></pre></td></tr></table></figure><p><strong>访问 WEB UI</strong></p><p><img src="/2021/11/24/apache-druid-lian-ji-fen-xi-chu-li-olap/%E5%9B%BE%E7%89%876.png" alt="图片6"></p><h3 id="4-2-集群模式部署"><a href="#4-2-集群模式部署" class="headerlink" title="4.2 集群模式部署"></a>4.2 集群模式部署</h3><p>Apache Druid 旨在部署为可扩展、容错的集群。</p><p>在这里，我们将设置一个简单的集群，这个简单的集群将具有：</p><ul><li>一个Master用于托管 Coordinator 和 Overlord 进程的主服务器；</li><li>两个Data运行Historical和 MiddleManager 进程的服务器；</li><li>一个Query服务器，托管 Broker 和 Router 进程。</li></ul><p><strong>服务规划</strong></p><table><thead><tr><th>主机名</th><th>druid角色</th><th>依赖服务</th></tr></thead><tbody><tr><td>hadoop1</td><td>Master（Coordinator、Overlord）</td><td>JDK1.8、zookeeper、Mysql、HDFS</td></tr><tr><td>hadoop2</td><td>Data（Historical、MiddleManager）</td><td>JDK1.8、zookeeper</td></tr><tr><td>hadoop3</td><td>Query（Broker、Router）、Data</td><td>JDK1.8、zookeeper</td></tr></tbody></table><p>在生产环境，推荐署多个Master和多个Query服务来满足容错。但现在可以快速的使用一个Master、一个Query服务器的方式先完成集群部署，后续添加Master、Query服务器。</p><p><strong>前置条件</strong></p><blockquote><p>HDFS、zookeeper和Mysql是可用的</p></blockquote><h4 id="4-2-1-安装-jdk"><a href="#4-2-1-安装-jdk" class="headerlink" title="4.2.1 安装 jdk"></a>4.2.1 安装 jdk</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@hadoop1 ~]$ tar xf downloads/jdk-8u301-linux-x64.tar.gz</span><br><span class="line">[hadoop@hadoop1 ~]$ vim .bash_profile</span><br><span class="line">export JAVA_HOME=/home/hadoop/jdk1.8.0_301</span><br><span class="line">export JRE_HOME=$&#123;JAVA_HOME&#125;/jre</span><br><span class="line">export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib</span><br><span class="line"></span><br><span class="line">[hadoop@hadoop1 ~]$ source .bash_profile</span><br></pre></td></tr></table></figure><h4 id="4-2-2-准备-druid"><a href="#4-2-2-准备-druid" class="headerlink" title="4.2.2 准备 druid"></a>4.2.2 准备 druid</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@hadoop1 ~/downloads]$ wget https://dlcdn.apache.org/druid/0.21.1/apache-druid-0.21.1-bin.tar.gz</span><br><span class="line">[hadoop@hadoop1 ~]$ tar xf apache-druid-0.21.1-bin.tar.gz</span><br><span class="line">[hadoop@hadoop1 ~]$ cd apache-druid-0.21.1/</span><br></pre></td></tr></table></figure><h4 id="4-2-3-准备-mysql-账户"><a href="#4-2-3-准备-mysql-账户" class="headerlink" title="4.2.3 准备 mysql 账户"></a>4.2.3 准备 mysql 账户</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#创建druid数据库和账户</span><br><span class="line">mysql&gt; CREATE DATABASE druid DEFAULT CHARACTER SET utf8mb4;</span><br><span class="line">mysql&gt; CREATE USER &apos;druid&apos;@&apos;%&apos; IDENTIFIED BY &apos;druid&apos;;</span><br><span class="line">mysql&gt; GRANT ALL PRIVILEGES ON druid.* TO &apos;druid&apos;@&apos;%&apos;;</span><br></pre></td></tr></table></figure><h4 id="4-2-3-druid-配置"><a href="#4-2-3-druid-配置" class="headerlink" title="4.2.3 druid 配置"></a>4.2.3 druid 配置</h4><h5 id="4-2-3-1-元数据存储配置"><a href="#4-2-3-1-元数据存储配置" class="headerlink" title="4.2.3.1 元数据存储配置"></a>4.2.3.1 元数据存储配置</h5><p>修改 <code>conf/druid/cluster/_common/common.runtime.properties</code> 配置文件，添加mysql相关信息，记得关闭默认的derby配置</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">druid.extensions.loadList</span>=<span class="string">["mysql-metadata-storage"]</span></span><br><span class="line"><span class="meta">druid.metadata.storage.type</span>=<span class="string">mysql</span></span><br><span class="line"><span class="meta">druid.metadata.storage.connector.connectURI</span>=<span class="string">jdbc:mysql://&lt;host&gt;/druid</span></span><br><span class="line"><span class="meta">druid.metadata.storage.connector.user</span>=<span class="string">druid</span></span><br><span class="line"><span class="meta">druid.metadata.storage.connector.password</span>=<span class="string">diurd</span></span><br></pre></td></tr></table></figure><p>下载mysql驱动，存储到 <code>extensions/mysql-metadata-storage</code> 目录下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@hadoop1 ~/apache-druid-0.21.1/extensions/mysql-metadata-storage]$ wget https://repo1.maven.org/maven2/mysql/mysql-connector-java/5.1.48/mysql-connector-java-5.1.48.jar</span><br></pre></td></tr></table></figure><h5 id="4-2-3-2-深度存储配置"><a href="#4-2-3-2-深度存储配置" class="headerlink" title="4.2.3.2 深度存储配置"></a>4.2.3.2 深度存储配置</h5><p>Druid 依赖分布式文件系统或大对象 (blob) 存储来存储数据。最常用的深度存储实现是 S3 和 HDFS 。这里配置为HDFS，同样修改 <code>conf/druid/cluster/_common/common.runtime.properties</code> 配置文件</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">druid.extensions.loadList</span>=<span class="string">["mysql-metadata-storage", "druid-hdfs-storage"]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">druid.host</span>=<span class="string">hadoop3</span></span><br><span class="line"><span class="comment">#druid.storage.type=local</span></span><br><span class="line"><span class="comment">#druid.storage.storageDirectory=var/druid/segments</span></span><br><span class="line"></span><br><span class="line"><span class="meta">druid.storage.type</span>=<span class="string">hdfs</span></span><br><span class="line"><span class="meta">druid.storage.storageDirectory</span>=<span class="string">/druid/segments</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#druid.indexer.logs.type=file</span></span><br><span class="line"><span class="comment">#druid.indexer.logs.directory=var/druid/indexing-logs</span></span><br><span class="line"></span><br><span class="line"><span class="meta">druid.indexer.logs.type</span>=<span class="string">hdfs</span></span><br><span class="line"><span class="meta">druid.indexer.logs.directory</span>=<span class="string">/druid/indexing-logs</span></span><br></pre></td></tr></table></figure><h5 id="4-2-3-3-配置-Zookeeper-连接"><a href="#4-2-3-3-配置-Zookeeper-连接" class="headerlink" title="4.2.3.3 配置 Zookeeper 连接"></a>4.2.3.3 配置 Zookeeper 连接</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">druid.zk.service.host</span>=<span class="string">hadoop1:2181,hadoop2:2181,hadoop3:2181</span></span><br><span class="line"><span class="meta">druid.zk.paths.base</span>=<span class="string">/druid</span></span><br></pre></td></tr></table></figure><h5 id="4-2-3-4-配置连接Hadoop"><a href="#4-2-3-4-配置连接Hadoop" class="headerlink" title="4.2.3.4 配置连接Hadoop"></a>4.2.3.4 配置连接Hadoop</h5><p>因为前面深度存储配置为了HDFS，那么此时应该配置 Druid 以了解您的Hadoop集群：</p><ul><li>将 Hadoop 配置 XML（core-site.xml、hdfs-site.xml、yarn-site.xml、mapred-site.xml）放在 Druid 进程的类路径上。您可以通过将它们复制到<code>conf/druid/cluster/_common/</code> 目录下来做到这一点。</li></ul><blockquote><p>请注意，若不需要使用 HDFS 深度存储来从 Hadoop 加载数据。例如，如果您的集群在 Amazon Web Services 上运行，我们建议使用 S3 进行深度存储，即使您使用 Hadoop 或 Elastic MapReduce 加载数据。</p></blockquote><h4 id="4-2-4-分发配置"><a href="#4-2-4-分发配置" class="headerlink" title="4.2.4 分发配置"></a>4.2.4 分发配置</h4><p>将修改好的druid配置分发到各节点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@hadoop1 ~]$ rsync -av apache-druid-0.21.1 hadoop@hadoop2:~/</span><br><span class="line">[hadoop@hadoop1 ~]$ rsync -av apache-druid-0.21.1 hadoop@hadoop3:~/</span><br></pre></td></tr></table></figure><blockquote><p>注意各节点的 <code>druid.host</code> 主机名，配置为可以通过该主机名访问的节点名称</p></blockquote><h4 id="4-2-5-启动各节点服务"><a href="#4-2-5-启动各节点服务" class="headerlink" title="4.2.5 启动各节点服务"></a>4.2.5 启动各节点服务</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">启动Master</span></span><br><span class="line">[hadoop@hadoop1 ~/apache-druid-0.21.1]$ ./bin/start-cluster-master-no-zk-server</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">启动Data</span></span><br><span class="line">[hadoop@hadoop2 ~/apache-druid-0.21.1]$ ./bin/start-cluster-data-server</span><br><span class="line">[hadoop@hadoop3 ~/apache-druid-0.21.1]$ ./bin/start-cluster-data-server</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">启动Query</span></span><br><span class="line">[hadoop@hadoop3 ~/apache-druid-0.21.1]$ ./bin/start-cluster-query-server</span><br></pre></td></tr></table></figure><p><strong>访问 WEB UI</strong>，Query节点8888端口</p><p><img src="/2021/11/24/apache-druid-lian-ji-fen-xi-chu-li-olap/%E5%9B%BE%E7%89%877.png" alt="图片7"></p><h4 id="4-2-6-druid-各服务默认资源占用"><a href="#4-2-6-druid-各服务默认资源占用" class="headerlink" title="4.2.6 druid 各服务默认资源占用"></a>4.2.6 druid 各服务默认资源占用</h4><table><thead><tr><th>角色</th><th>默认资源占用</th></tr></thead><tbody><tr><td>Coordinator</td><td>-Xms15g -Xmx15g</td></tr><tr><td>Overlord</td><td>Xms15g -Xmx15g</td></tr><tr><td>middleManager</td><td>Xms128m -Xmx128m</td></tr><tr><td>historical</td><td>-Xms8g -Xmx8g -XX:MaxDirectMemorySize=13g</td></tr><tr><td>broker</td><td>-Xms12g -Xmx12g -XX:MaxDirectMemorySize=6g</td></tr><tr><td>routers</td><td>-Xms1g -Xmx1g -XX:MaxDirectMemorySize=128m</td></tr></tbody></table><h4 id="4-2-7-druid-各服务默认端口"><a href="#4-2-7-druid-各服务默认端口" class="headerlink" title="4.2.7  druid 各服务默认端口"></a>4.2.7 druid 各服务默认端口</h4><p><strong>Master Server</strong></p><ul><li>1527 (Derby 元数据存储；如果您使用单独的元数据存储，如 MySQL 或 PostgreSQL，则不需要)</li><li>2181 (ZooKeeper，如果您使用单独的 ZooKeeper 集群，则不需要)</li><li>8081 (Coordinator)</li><li>8090 (Overlord)</li></ul><p><strong>Data Server</strong></p><ul><li>8083 (Historical)</li><li>8091, 8100–8199 (Druid Middle Manager)</li></ul><p><strong>Query Server</strong></p><ul><li>8082 (Broker)</li><li>8088 (Router, 如果使用)</li></ul><h3 id="4-3-加载示例数据"><a href="#4-3-加载示例数据" class="headerlink" title="4.3 加载示例数据"></a>4.3 加载示例数据</h3><p>这里演示一下从本地加载官方的示例数据，大概有以下几种方式</p><h4 id="4-3-1-通过控制台"><a href="#4-3-1-通过控制台" class="headerlink" title="4.3.1 通过控制台"></a>4.3.1 通过控制台</h4><p>Druid 包包含以下示例本机批处理摄取任务规范<code>quickstart/tutorial/wikipedia-index.json</code>，为方便起见，此处显示，已配置为读取<code>quickstart/tutorial/wikiticker-2015-09-12-sampled.json.gz</code>输入文件：</p><p><img src="/2021/11/24/apache-druid-lian-ji-fen-xi-chu-li-olap/%E5%9B%BE%E7%89%878.png" alt="图片8"></p><p>或者，在<code>Ingestion</code>视图中，单击<code>Tasks</code>旁边的省略号并选择<code>Submit JSON task</code>，粘贴以下内容。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"type"</span> : <span class="string">"index_parallel"</span>,</span><br><span class="line">  <span class="attr">"spec"</span> : &#123;</span><br><span class="line">    <span class="attr">"dataSchema"</span> : &#123;</span><br><span class="line">      <span class="attr">"dataSource"</span> : <span class="string">"wikipedia"</span>,</span><br><span class="line">      <span class="attr">"dimensionsSpec"</span> : &#123;</span><br><span class="line">        <span class="attr">"dimensions"</span> : [</span><br><span class="line">          <span class="string">"channel"</span>,</span><br><span class="line">          <span class="string">"cityName"</span>,</span><br><span class="line">          <span class="string">"comment"</span>,</span><br><span class="line">          <span class="string">"countryIsoCode"</span>,</span><br><span class="line">          <span class="string">"countryName"</span>,</span><br><span class="line">          <span class="string">"isAnonymous"</span>,</span><br><span class="line">          <span class="string">"isMinor"</span>,</span><br><span class="line">          <span class="string">"isNew"</span>,</span><br><span class="line">          <span class="string">"isRobot"</span>,</span><br><span class="line">          <span class="string">"isUnpatrolled"</span>,</span><br><span class="line">          <span class="string">"metroCode"</span>,</span><br><span class="line">          <span class="string">"namespace"</span>,</span><br><span class="line">          <span class="string">"page"</span>,</span><br><span class="line">          <span class="string">"regionIsoCode"</span>,</span><br><span class="line">          <span class="string">"regionName"</span>,</span><br><span class="line">          <span class="string">"user"</span>,</span><br><span class="line">          &#123; <span class="attr">"name"</span>: <span class="string">"added"</span>, <span class="attr">"type"</span>: <span class="string">"long"</span> &#125;,</span><br><span class="line">          &#123; <span class="attr">"name"</span>: <span class="string">"deleted"</span>, <span class="attr">"type"</span>: <span class="string">"long"</span> &#125;,</span><br><span class="line">          &#123; <span class="attr">"name"</span>: <span class="string">"delta"</span>, <span class="attr">"type"</span>: <span class="string">"long"</span> &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"timestampSpec"</span>: &#123;</span><br><span class="line">        <span class="attr">"column"</span>: <span class="string">"time"</span>,</span><br><span class="line">        <span class="attr">"format"</span>: <span class="string">"iso"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"metricsSpec"</span> : [],</span><br><span class="line">      <span class="attr">"granularitySpec"</span> : &#123;</span><br><span class="line">        <span class="attr">"type"</span> : <span class="string">"uniform"</span>,</span><br><span class="line">        <span class="attr">"segmentGranularity"</span> : <span class="string">"day"</span>,</span><br><span class="line">        <span class="attr">"queryGranularity"</span> : <span class="string">"none"</span>,</span><br><span class="line">        <span class="attr">"intervals"</span> : [<span class="string">"2015-09-12/2015-09-13"</span>],</span><br><span class="line">        <span class="attr">"rollup"</span> : <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"ioConfig"</span> : &#123;</span><br><span class="line">      <span class="attr">"type"</span> : <span class="string">"index_parallel"</span>,</span><br><span class="line">      <span class="attr">"inputSource"</span> : &#123;</span><br><span class="line">        <span class="attr">"type"</span> : <span class="string">"local"</span>,</span><br><span class="line">        <span class="attr">"baseDir"</span> : <span class="string">"quickstart/tutorial/"</span>,</span><br><span class="line">        <span class="attr">"filter"</span> : <span class="string">"wikiticker-2015-09-12-sampled.json.gz"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"inputFormat"</span> :  &#123;</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"json"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"appendToExisting"</span> : <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"tuningConfig"</span> : &#123;</span><br><span class="line">      <span class="attr">"type"</span> : <span class="string">"index_parallel"</span>,</span><br><span class="line">      <span class="attr">"maxRowsPerSegment"</span> : <span class="number">5000000</span>,</span><br><span class="line">      <span class="attr">"maxRowsInMemory"</span> : <span class="number">25000</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该规范创建了一个名为<code>wikipedia</code>的数据源。</p><h4 id="4-3-2-通过命令行"><a href="#4-3-2-通过命令行" class="headerlink" title="4.3.2 通过命令行"></a>4.3.2 通过命令行</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> bin/post-index-task --file quickstart/tutorial/wikipedia-index.json --url http://localhost:8081</span></span><br></pre></td></tr></table></figure><h4 id="4-3-3-HTTP-客户端"><a href="#4-3-3-HTTP-客户端" class="headerlink" title="4.3.3 HTTP 客户端"></a>4.3.3 HTTP 客户端</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -X <span class="string">'POST'</span> -H <span class="string">'Content-Type:application/json'</span> -d @quickstart/tutorial/wikipedia-index.json http://localhost:8081/druid/indexer/v1/task</span></span><br></pre></td></tr></table></figure><h3 id="4-4-数据查询方式"><a href="#4-4-数据查询方式" class="headerlink" title="4.4 数据查询方式"></a>4.4 数据查询方式</h3><h4 id="4-4-1-控制台查询"><a href="#4-4-1-控制台查询" class="headerlink" title="4.4.1 控制台查询"></a>4.4.1 控制台查询</h4><p>Druid 控制台包含一个视图，可以更轻松地构建和测试查询以及查看其结果。</p><p>控制台进入<code>Query</code>查询视图，在左则选择需要查询的数据源</p><p><img src="/2021/11/24/apache-druid-lian-ji-fen-xi-chu-li-olap/%E5%9B%BE%E7%89%879.png" alt="图片9"></p><p>展开左窗格中的<code>wikipedia</code>数据源树。我们将为页面维度创建一个查询。</p><p>单击<code>page</code>，然后从菜单中单击<strong>Show:page</strong>：</p><p><img src="/2021/11/24/apache-druid-lian-ji-fen-xi-chu-li-olap/%E5%9B%BE%E7%89%8710.png" alt="图片10"></p><p>SELECT 查询出现在查询编辑窗格中并立即运行。但是，在这种情况下，查询不返回任何数据，因为默认情况下查询会过滤最后一天的数据，而我们的数据远比这更旧。让我们移除过滤器。</p><p>在数据源树中，单击<code>__time</code>并<strong>删除过滤器</strong>。</p><p><img src="/2021/11/24/apache-druid-lian-ji-fen-xi-chu-li-olap/%E5%9B%BE%E7%89%8711.png" alt="图片11"></p><p>单击<strong>运行</strong>以运行查询。</p><p><img src="/2021/11/24/apache-druid-lian-ji-fen-xi-chu-li-olap/%E5%9B%BE%E7%89%8712.png" alt="图片12"></p><p>默认情况下，由于<strong>智能查询限制</strong> 功能，控制台中的结果被限制在大约一百个左右。这有助于用户避免无意中运行返回过多数据的查询，这可能会使他们的系统不堪重负。</p><h4 id="4-4-2-dsql-查询-SQL"><a href="#4-4-2-dsql-查询-SQL" class="headerlink" title="4.4.2 dsql 查询 SQL"></a>4.4.2 dsql 查询 SQL</h4><p>Druid 包包含一个 SQL 命令行客户端，位于<code>bin/dsql</code>Druid 包根目录。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@hadoop3 ~/apache-druid-0.21.1]$ ./bin/dsql</span><br><span class="line">Welcome to dsql, the command-line client for Druid SQL.</span><br><span class="line">Connected to [http://localhost:8082/].</span><br><span class="line"></span><br><span class="line">Type "\h" for help.</span><br><span class="line">dsql&gt; <span class="keyword">SELECT</span> page, <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> Edits <span class="keyword">FROM</span> wikipedia <span class="keyword">WHERE</span> <span class="string">"__time"</span> <span class="keyword">BETWEEN</span> <span class="built_in">TIMESTAMP</span> <span class="string">'2015-09-12 00:00:00'</span> <span class="keyword">AND</span> <span class="built_in">TIMESTAMP</span> <span class="string">'2015-09-13 00:00:00'</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> page <span class="keyword">ORDER</span> <span class="keyword">BY</span> Edits <span class="keyword">DESC</span> <span class="keyword">LIMIT</span> <span class="number">10</span>;</span><br><span class="line">┌──────────────────────────────────────────────────────────┬───────┐</span><br><span class="line">│ page                                                     │ Edits │</span><br><span class="line">├──────────────────────────────────────────────────────────┼───────┤</span><br><span class="line">│ Wikipedia:Vandalismusmeldung                             │    33 │</span><br><span class="line">│ User:Cyde/List of candidates for speedy deletion/Subpage │    28 │</span><br><span class="line">│ Jeremy Corbyn                                            │    27 │</span><br><span class="line">│ Wikipedia:Administrators' noticeboard/Incidents          │    21 │</span><br><span class="line">│ Flavia Pennetta                                          │    20 │</span><br><span class="line">│ Total Drama Presents: The Ridonculous Race               │    18 │</span><br><span class="line">│ User talk:Dudeperson176123                               │    18 │</span><br><span class="line">│ Wikipédia:Le Bistro/12 septembre 2015                    │    18 │</span><br><span class="line">│ Wikipedia:In the news/Candidates                         │    17 │</span><br><span class="line">│ Wikipedia:Requests for page protection                   │    17 │</span><br><span class="line">└──────────────────────────────────────────────────────────┴───────┘</span><br><span class="line">Retrieved 10 rows in 0.09s.</span><br><span class="line"></span><br><span class="line">dsql&gt;</span><br></pre></td></tr></table></figure><h4 id="4-4-3-HTTP-查询-SQL"><a href="#4-4-3-HTTP-查询-SQL" class="headerlink" title="4.4.3 HTTP 查询 SQL"></a>4.4.3 HTTP 查询 SQL</h4><p>可以通过 HTTP 直接向 Druid Broker 提交查询。</p><p>Druid 包包括一个示例文件，其中包含上面显示的 SQL 查询<code>quickstart/tutorial/wikipedia-top-pages-sql.json</code>。让我们将该查询提交给 Druid Broker：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -X <span class="string">'POST'</span> -H <span class="string">'Content-Type:application/json'</span> -d @quickstart/tutorial/wikipedia-top-pages-sql.json http://localhost:8888/druid/v2/sql | jq .</span></span><br></pre></td></tr></table></figure><p>应该返回以下结果</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"page"</span>: <span class="string">"Wikipedia:Vandalismusmeldung"</span>,</span><br><span class="line">    <span class="attr">"Edits"</span>: <span class="number">33</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"page"</span>: <span class="string">"User:Cyde/List of candidates for speedy deletion/Subpage"</span>,</span><br><span class="line">    <span class="attr">"Edits"</span>: <span class="number">28</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"page"</span>: <span class="string">"Jeremy Corbyn"</span>,</span><br><span class="line">    <span class="attr">"Edits"</span>: <span class="number">27</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"page"</span>: <span class="string">"Wikipedia:Administrators' noticeboard/Incidents"</span>,</span><br><span class="line">    <span class="attr">"Edits"</span>: <span class="number">21</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"page"</span>: <span class="string">"Flavia Pennetta"</span>,</span><br><span class="line">    <span class="attr">"Edits"</span>: <span class="number">20</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"page"</span>: <span class="string">"Total Drama Presents: The Ridonculous Race"</span>,</span><br><span class="line">    <span class="attr">"Edits"</span>: <span class="number">18</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"page"</span>: <span class="string">"User talk:Dudeperson176123"</span>,</span><br><span class="line">    <span class="attr">"Edits"</span>: <span class="number">18</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"page"</span>: <span class="string">"Wikipédia:Le Bistro/12 septembre 2015"</span>,</span><br><span class="line">    <span class="attr">"Edits"</span>: <span class="number">18</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"page"</span>: <span class="string">"Wikipedia:In the news/Candidates"</span>,</span><br><span class="line">    <span class="attr">"Edits"</span>: <span class="number">17</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"page"</span>: <span class="string">"Wikipedia:Requests for page protection"</span>,</span><br><span class="line">    <span class="attr">"Edits"</span>: <span class="number">17</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></div><div><div><div style="text-align:center;color:#ccc;font-size:14px">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div></div></div><div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/Hadoop/" rel="tag"><i class="fa fa-tag"></i> Hadoop</a> <a href="/tags/OLAP/" rel="tag"><i class="fa fa-tag"></i> OLAP</a> <a href="/tags/Druid/" rel="tag"><i class="fa fa-tag"></i> Druid</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2021/11/19/clickhouse-lian-ji-fen-xi-chu-li-olap/" rel="next" title="ClickHouse 联机分析处理(OLAP)"><i class="fa fa-chevron-left"></i> ClickHouse 联机分析处理(OLAP)</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2021/11/30/olap-ru-he-xuan-xing/" rel="prev" title="OLAP 如何选型">OLAP 如何选型 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"><div class="jiathis_style"><span class="jiathis_txt">分享到：</span> <a class="jiathis_button_fav">收藏夹</a> <a class="jiathis_button_copy">复制网址</a> <a class="jiathis_button_email">邮件</a> <a class="jiathis_button_weixin">微信</a> <a class="jiathis_button_qzone">QQ空间</a> <a class="jiathis_button_tqq">腾讯微博</a> <a class="jiathis_button_douban">豆瓣</a> <a class="jiathis_button_share">一键分享</a> <a href="http://www.jiathis.com/share?uid=2140465" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank">更多</a> <a class="jiathis_counter_style"></a></div><script type="text/javascript">var jiathis_config={data_track_clickback:!0,summary:"",shortUrl:!1,hideMore:!1}</script><script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=" charset="utf-8"></script></div></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div id="sidebar-dimmer"></div><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/images/chen.png" alt="Zhongzhou Chen"><p class="site-author-name" itemprop="name">Zhongzhou Chen</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/%7C%7C%20archive"><span class="site-state-item-count">312</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">84</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">180</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#一、简介"><span class="nav-text">一、简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-Druid-常见应用领域"><span class="nav-text">1.1 Druid 常见应用领域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-Druid-的三个设计原则"><span class="nav-text">1.2 Druid 的三个设计原则</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-1-快速查询"><span class="nav-text">1.2.1 快速查询</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-2-水平扩展能力"><span class="nav-text">1.2.2 水平扩展能力</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-3-实时分析"><span class="nav-text">1.2.3 实时分析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-特点"><span class="nav-text">1.3 特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-数据格式"><span class="nav-text">1.4 数据格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-数据保障"><span class="nav-text">1.5 数据保障</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-优缺点"><span class="nav-text">1.6 优缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-7-适合的业务"><span class="nav-text">1.7 适合的业务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-8-高可用性"><span class="nav-text">1.8 高可用性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二、基本架构"><span class="nav-text">二、基本架构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-内部进程"><span class="nav-text">2.1 内部进程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-1-Coordinator"><span class="nav-text">2.1.1 Coordinator</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-2-Overlord"><span class="nav-text">2.1.2 Overlord</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-3-Broker"><span class="nav-text">2.1.3 Broker</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-4-Router"><span class="nav-text">2.1.4 Router</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-5-Historical"><span class="nav-text">2.1.5 Historical</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-6-MiddleManager"><span class="nav-text">2.1.6 MiddleManager</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-外部依赖"><span class="nav-text">2.2 外部依赖</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-1-深度储存"><span class="nav-text">2.2.1 深度储存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-2-元数据库"><span class="nav-text">2.2.2 元数据库</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-3-Zookeeper"><span class="nav-text">2.2.3 Zookeeper</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-Druid-主要功能特性"><span class="nav-text">2.3 Druid 主要功能特性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三、架构设计"><span class="nav-text">三、架构设计</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-存储设计"><span class="nav-text">3.1 存储设计</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-1-数据源和段"><span class="nav-text">3.1.1 数据源和段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-2-索引和切换"><span class="nav-text">3.1.2 索引和切换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-3-段标识符"><span class="nav-text">3.1.3 段标识符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-4-段版本"><span class="nav-text">3.1.4 段版本</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-5-段生命周期"><span class="nav-text">3.1.5 段生命周期</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-6-查询处理"><span class="nav-text">3.2.6 查询处理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-段设计"><span class="nav-text">3.2 段设计</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-1-段文件的核心数据结构"><span class="nav-text">3.2.1 段文件的核心数据结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-2-SQL-兼容的空值处理"><span class="nav-text">3.2.2 SQL 兼容的空值处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-3-命名规则"><span class="nav-text">3.2.3 命名规则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-4-段的组成"><span class="nav-text">3.2.4 段的组成</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-5-列的格式"><span class="nav-text">3.2.5 列的格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-6-压缩"><span class="nav-text">3.2.6 压缩</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-7-切分数据以创建段"><span class="nav-text">3.2.7 切分数据以创建段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-8-Schema更改"><span class="nav-text">3.2.8 Schema更改</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-9-段之间的不同Schema"><span class="nav-text">3.2.9 段之间的不同Schema</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-进程和服务"><span class="nav-text">3.3 进程和服务</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-1-进程类型"><span class="nav-text">3.3.1 进程类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-2-服务类型"><span class="nav-text">3.3.2 服务类型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-2-1-Master服务"><span class="nav-text">3.3.2.1 Master服务</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-2-2-Query服务"><span class="nav-text">3.3.2.2 Query服务</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-2-3-Data服务"><span class="nav-text">3.3.2.3 Data服务</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-2-4-Historical进程"><span class="nav-text">3.3.2.4 Historical进程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-2-5-MiddleManager进程"><span class="nav-text">3.3.2.5 MiddleManager进程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-2-6-Indexer进程（可选）"><span class="nav-text">3.3.2.6 Indexer进程（可选）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-3-服务混合部署的利弊"><span class="nav-text">3.3.3 服务混合部署的利弊</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-3-1-Coordinator和Overlord"><span class="nav-text">3.3.3.1 Coordinator和Overlord</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-3-2-Historical和MiddleManager"><span class="nav-text">3.3.3.2 Historical和MiddleManager</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-深度存储"><span class="nav-text">3.4 深度存储</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-1-本地挂载"><span class="nav-text">3.4.1 本地挂载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-2-S3适配"><span class="nav-text">3.4.2 S3适配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-3-HDFS"><span class="nav-text">3.4.3 HDFS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-4-其他深度存储"><span class="nav-text">3.4.4 其他深度存储</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-元数据存储"><span class="nav-text">3.5 元数据存储</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-1-使用Derby"><span class="nav-text">3.5.1 使用Derby</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-2-MySQL"><span class="nav-text">3.5.2 MySQL</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-3-PostgreSQL"><span class="nav-text">5.3.3 PostgreSQL</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-4-添加自定义的数据库连接池属性"><span class="nav-text">5.3.4 添加自定义的数据库连接池属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-5-元数据存储表"><span class="nav-text">5.3.5 元数据存储表</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#5-3-5-1-段表"><span class="nav-text">5.3.5.1 段表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-3-5-2-规则表"><span class="nav-text">5.3.5.2 规则表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-3-5-3-配置表"><span class="nav-text">5.3.5.3 配置表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-3-5-4-任务相关的表"><span class="nav-text">5.3.5.4 任务相关的表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-3-5-5-审计表"><span class="nav-text">5.3.5.5 审计表</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-ZooKeeper"><span class="nav-text">3.6 ZooKeeper</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-1-Coordinator-Leader选举"><span class="nav-text">3.6.1 Coordinator Leader选举</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-2-Historical和Realtime之间的段发布"><span class="nav-text">3.6.2 Historical和Realtime之间的段发布</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-3-Coordinator和Historical之间的段加载-删除"><span class="nav-text">3.6.3 Coordinator和Historical之间的段加载/删除</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四、Druid-部署"><span class="nav-text">四、Druid 部署</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-单机模式部署"><span class="nav-text">4.1 单机模式部署</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-1-安装-jdk"><span class="nav-text">4.1.1 安装 jdk</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-2-准备-druid"><span class="nav-text">4.1.2 准备 druid</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-3-启动-druid"><span class="nav-text">4.1.3 启动 druid</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-集群模式部署"><span class="nav-text">4.2 集群模式部署</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-1-安装-jdk"><span class="nav-text">4.2.1 安装 jdk</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-2-准备-druid"><span class="nav-text">4.2.2 准备 druid</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-3-准备-mysql-账户"><span class="nav-text">4.2.3 准备 mysql 账户</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-3-druid-配置"><span class="nav-text">4.2.3 druid 配置</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#4-2-3-1-元数据存储配置"><span class="nav-text">4.2.3.1 元数据存储配置</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-2-3-2-深度存储配置"><span class="nav-text">4.2.3.2 深度存储配置</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-2-3-3-配置-Zookeeper-连接"><span class="nav-text">4.2.3.3 配置 Zookeeper 连接</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-2-3-4-配置连接Hadoop"><span class="nav-text">4.2.3.4 配置连接Hadoop</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-4-分发配置"><span class="nav-text">4.2.4 分发配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-5-启动各节点服务"><span class="nav-text">4.2.5 启动各节点服务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-6-druid-各服务默认资源占用"><span class="nav-text">4.2.6 druid 各服务默认资源占用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-7-druid-各服务默认端口"><span class="nav-text">4.2.7 druid 各服务默认端口</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-加载示例数据"><span class="nav-text">4.3 加载示例数据</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-1-通过控制台"><span class="nav-text">4.3.1 通过控制台</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-2-通过命令行"><span class="nav-text">4.3.2 通过命令行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-3-HTTP-客户端"><span class="nav-text">4.3.3 HTTP 客户端</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-数据查询方式"><span class="nav-text">4.4 数据查询方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-1-控制台查询"><span class="nav-text">4.4.1 控制台查询</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-2-dsql-查询-SQL"><span class="nav-text">4.4.2 dsql 查询 SQL</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-3-HTTP-查询-SQL"><span class="nav-text">4.4.3 HTTP 查询 SQL</span></a></li></ol></li></ol></li></ol></div></div></section><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span id="scrollpercent"><span>0</span>%</span></div></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="copyright">&copy; <span itemprop="copyrightYear">2021</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">Zhongzhou Chen</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-area-chart"></i> </span><span class="post-meta-item-text">Site words total count&#58;</span> <span title="Site words total count">738.6k</span></div><span class="post-meta-divider"></span></div></footer></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><style>.copy-btn{display:inline-block;padding:6px 12px;font-size:13px;font-weight:700;line-height:20px;color:#333;white-space:nowrap;vertical-align:middle;cursor:pointer;background-color:#eee;background-image:linear-gradient(#fcfcfc,#eee);border:1px solid #d5d5d5;border-radius:3px;user-select:none;outline:0}.highlight-wrap .copy-btn{transition:opacity .3s ease-in-out;opacity:0;padding:2px 6px;position:absolute;right:4px;top:8px}.highlight-wrap .copy-btn:focus,.highlight-wrap:hover .copy-btn{opacity:1}.highlight-wrap{position:relative}</style><script>$(".highlight").each(function(t,e){var n=$("<div>").addClass("highlight-wrap");$(e).after(n),n.append($("<button>").addClass("copy-btn").append("复制").on("click",function(t){var e=$(this).parent().find(".code").find(".line").map(function(t,e){return $(e).text()}).toArray().join("\n"),n=document.createElement("textarea");document.body.appendChild(n),n.style.position="absolute",n.style.top="0px",n.style.left="0px",n.value=e,n.select(),n.focus();var o=document.execCommand("copy");document.body.removeChild(n),o?$(this).text("复制成功"):$(this).text("复制失败"),$(this).blur()})).on("mouseleave",function(t){var e=$(this).find(".copy-btn");setTimeout(function(){e.text("复制")},300)}).append(e)})</script><script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script><script type="text/javascript">function proceedsearch(){$("body").append('<div class="search-popup-overlay local-search-pop-overlay"></div>').css("overflow","hidden"),$(".search-popup-overlay").click(onPopupClose),$(".popup").toggle();var t=$("#local-search-input");t.attr("autocapitalize","none"),t.attr("autocorrect","off"),t.focus()}var isfetched=!1,isXml=!0,search_path="search.xml";0===search_path.length?search_path="search.xml":/json$/i.test(search_path)&&(isXml=!1);var path="/"+search_path,onPopupClose=function(t){$(".popup").hide(),$("#local-search-input").val(""),$(".search-result-list").remove(),$("#no-result").remove(),$(".local-search-pop-overlay").remove(),$("body").css("overflow","")},searchFunc=function(t,e,o){"use strict";$("body").append('<div class="search-popup-overlay local-search-pop-overlay"><div id="search-loading-icon"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div>').css("overflow","hidden"),$("#search-loading-icon").css("margin","20% auto 0 auto").css("text-align","center"),$.ajax({url:t,dataType:isXml?"xml":"json",async:!0,success:function(t){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var n=isXml?$("entry",t).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get():t,r=document.getElementById(e),s=document.getElementById(o),a=function(){var t=r.value.trim().toLowerCase(),e=t.split(/[\s\-]+/);e.length>1&&e.push(t);var o=[];if(t.length>0&&n.forEach(function(n){function r(e,o,n,r){for(var s=r[r.length-1],a=s.position,i=s.word,l=[],h=0;a+i.length<=n&&0!=r.length;){i===t&&h++,l.push({position:a,length:i.length});var p=a+i.length;for(r.pop();0!=r.length&&(s=r[r.length-1],a=s.position,i=s.word,p>a);)r.pop()}return c+=h,{hits:l,start:o,end:n,searchTextCount:h}}function s(t,e){var o="",n=e.start;return e.hits.forEach(function(e){o+=t.substring(n,e.position);var r=e.position+e.length;o+='<b class="search-keyword">'+t.substring(e.position,r)+"</b>",n=r}),o+=t.substring(n,e.end)}var a=!1,i=0,c=0,l=n.title.trim(),h=l.toLowerCase(),p=n.content.trim().replace(/<[^>]+>/g,""),u=p.toLowerCase(),f=decodeURIComponent(n.url),d=[],g=[];if(""!=l&&(e.forEach(function(t){function e(t,e,o){var n=t.length;if(0===n)return[];var r=0,s=[],a=[];for(o||(e=e.toLowerCase(),t=t.toLowerCase());(s=e.indexOf(t,r))>-1;)a.push({position:s,word:t}),r=s+n;return a}d=d.concat(e(t,h,!1)),g=g.concat(e(t,u,!1))}),(d.length>0||g.length>0)&&(a=!0,i=d.length+g.length)),a){[d,g].forEach(function(t){t.sort(function(t,e){return e.position!==t.position?e.position-t.position:t.word.length-e.word.length})});var v=[];0!=d.length&&v.push(r(l,0,l.length,d));for(var $=[];0!=g.length;){var C=g[g.length-1],m=C.position,x=C.word,w=m-20,y=m+80;0>w&&(w=0),y<m+x.length&&(y=m+x.length),y>p.length&&(y=p.length),$.push(r(p,w,y,g))}$.sort(function(t,e){return t.searchTextCount!==e.searchTextCount?e.searchTextCount-t.searchTextCount:t.hits.length!==e.hits.length?e.hits.length-t.hits.length:t.start-e.start});var T=parseInt("1");T>=0&&($=$.slice(0,T));var b="";b+=0!=v.length?"<li><a href='"+f+"' class='search-result-title'>"+s(l,v[0])+"</a>":"<li><a href='"+f+"' class='search-result-title'>"+l+"</a>",$.forEach(function(t){b+="<a href='"+f+'\'><p class="search-result">'+s(p,t)+"...</p></a>"}),b+="</li>",o.push({item:b,searchTextCount:c,hitCount:i,id:o.length})}}),1===e.length&&""===e[0])s.innerHTML='<div id="no-result"><i class="fa fa-search fa-5x" /></div>';else if(0===o.length)s.innerHTML='<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>';else{o.sort(function(t,e){return t.searchTextCount!==e.searchTextCount?e.searchTextCount-t.searchTextCount:t.hitCount!==e.hitCount?e.hitCount-t.hitCount:e.id-t.id});var a='<ul class="search-result-list">';o.forEach(function(t){a+=t.item}),a+="</ul>",s.innerHTML=a}};r.addEventListener("input",a),$(".local-search-pop-overlay").remove(),$("body").css("overflow",""),proceedsearch()}})};$(".popup-trigger").click(function(t){t.stopPropagation(),isfetched===!1?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(onPopupClose),$(".popup").click(function(t){t.stopPropagation()}),$(document).on("keyup",function(t){var e=27===t.which&&$(".search-popup").is(":visible");e&&onPopupClose()})</script><script type="text/javascript" src="/js/src/love.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,log:!1,model:{jsonPath:"/live2dw/assets/shizuku.model.json"},display:{position:"right"},mobile:{show:!0,scale:.5},react:{opacityDefault:.7,opacityOnHover:.2}})</script></body></html><!-- rebuild by neat -->